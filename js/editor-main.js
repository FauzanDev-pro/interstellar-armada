/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides various simple, general usage utility methods.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, setTimeout, NaN */

define('utils/utils',[],function () {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // enums
            /**
             * Indicates a method to be used when scaling a clip-space (or otherwise relative) coordinate to a viewport.
             * @enum {String}
             * @type Object
             */
            ScaleMode = {
                /**
                 * Scale the coordinate using the width of the viewport.
                 */
                WIDTH: "width",
                /**
                 * Scale the coordinate using the height of the viewport.
                 */
                HEIGHT: "height",
                /**
                 * Scale X coordinates using the width and Y coordinates using the height of the viewport.
                 */
                ASPECT: "aspect",
                /**
                 * Scale the coordinate using either the width or the height of the viewport, whichever is smaller.
                 */
                MINIMUM: "minimum",
                /**
                 * Scale the coordinate using either the width or the height of the viewport, whichever is larger.
                 */
                MAXIMUM: "maximum"
            },
            /**
             * A convenience enum storing the numeric mouse button identifiers as they appear in the "which" property of MouseEvent events
             * by meaningful names
             * @enum {Number}
             * @type Object
             */
            MouseButton = {
                LEFT: 1,
                MIDDLE: 2,
                RIGHT: 3
            },
            // ------------------------------------------------------------------------------
            // constants
            EMPTY_STRING = "",
            UNDERSCORE = "_",
            SPACE = " ",
            DASH = "-",
            EMPTY_ARRAY = [],
            EMPTY_OBJECT = {},
            NUMBER_THOUSANDS_DELIMITER = " ",
            DEG = 180 / Math.PI,
            RAD = Math.PI / 180,
            HALF_PI = 0.5 * Math.PI,
            DOUBLE_PI = 2 * Math.PI,
            // ------------------------------------------------------------------------------
            // private variables
            _keyCodeTable = {
                "backspace": 8,
                "tab": 9,
                "enter": 13,
                "shift": 16,
                "ctrl": 17,
                "alt": 18,
                "pause": 19,
                "caps lock": 20,
                "escape": 27,
                "space": 32,
                "page up": 33,
                "page down": 34,
                "end": 35,
                "home": 36,
                "left": 37,
                "up": 38,
                "right": 39,
                "down": 40,
                "insert": 45,
                "delete": 46,
                "0": 48, "1": 49, "2": 50, "3": 51, "4": 52, "5": 53, "6": 54, "7": 55, "8": 56, "9": 57,
                "A": 65, "B": 66, "C": 67, "D": 68, "E": 69, "F": 70, "G": 71, "H": 72, "I": 73, "J": 74,
                "K": 75, "L": 76, "M": 77, "N": 78, "O": 79, "P": 80, "Q": 81, "R": 82, "S": 83, "T": 84,
                "U": 85, "V": 86, "W": 87, "X": 88, "Y": 89, "Z": 90,
                "left window": 91, "right window": 92, "select": 93,
                "numpad 0": 96, "numpad 1": 97, "numpad 2": 98, "numpad 3": 99, "numpad 4": 100,
                "numpad 5": 101, "numpad 6": 102, "numpad 7": 103, "numpad 8": 104, "numpad 9": 105,
                "numpad *": 106, "numpad +": 107, "numpad -": 109, "numpad /": 111,
                "F1": 112, "F2": 113, "F3": 114, "F4": 115, "F5": 116, "F6": 117, "F7": 118, "F8": 119, "F9": 120,
                "F10": 121, "F11": 122, "F12": 123,
                ";": 186, "=": 187, ",": 188, "-": 189, ".": 190, "/": 191, "`": 192, "[": 219, "\\": 220, "]": 221, "'": 222
                // Firefox: "-": 173, "=": 61, ";": 59
            },
            // ------------------------------------------------------------------------------
            // interface
            exports = {};
    // ------------------------------------------------------------------------------
    // public constants
    exports.EMPTY_ARRAY = EMPTY_ARRAY;
    exports.EMPTY_STRING = EMPTY_STRING;
    exports.EMPTY_OBJECT = EMPTY_OBJECT;
    exports.DEG = DEG;
    exports.RAD = RAD;
    exports.HALF_PI = HALF_PI;
    exports.DOUBLE_PI = DOUBLE_PI;
    // ------------------------------------------------------------------------------
    // public enums
    exports.ScaleMode = ScaleMode;
    exports.MouseButton = MouseButton;
    // ------------------------------------------------------------------------------
    // public functions
    /**
     * Returns whether generic coordinates or sizes (in cases where there is no separate X and Y and thus no aspect scaling possible, such
     * as for font sizes) should scale with the width of the viewport according to the passed scaling mode, if the viewport has the passed
     * size.
     * @param {ScaleMode} scaleMode
     * @param {Number} width
     * @param {Number} height
     * @returns {Boolean}
     */
    exports.scalesWithWidth = function (scaleMode, width, height) {
        return ((scaleMode === ScaleMode.WIDTH) || ((scaleMode === ScaleMode.MINIMUM) && (width < height)) || ((scaleMode === ScaleMode.MAXIMUM) && (width >= height)));
    };
    /**
     * Returns whether X coordinates or widths should scale with the width of the viewport according to the passed scaling mode, if the 
     * viewport has the passed size.
     * @param {ScaleMode} scaleMode
     * @param {Number} width
     * @param {Number} height
     * @returns {Boolean}
     */
    exports.xScalesWithWidth = function (scaleMode, width, height) {
        return ((scaleMode === ScaleMode.ASPECT) || (scaleMode === ScaleMode.WIDTH) || ((scaleMode === ScaleMode.MINIMUM) && (width < height)) || ((scaleMode === ScaleMode.MAXIMUM) && (width >= height)));
    };
    /**
     * Returns whether Y coordinates or heights should scale with the height of the viewport according to the passed scaling mode, if the 
     * viewport has the passed size.
     * @param {ScaleMode} scaleMode
     * @param {Number} width
     * @param {Number} height
     * @returns {Boolean}
     */
    exports.yScalesWithHeight = function (scaleMode, width, height) {
        return ((scaleMode === ScaleMode.ASPECT) || (scaleMode === ScaleMode.HEIGHT) || ((scaleMode === ScaleMode.MINIMUM) && (height < width)) || ((scaleMode === ScaleMode.MAXIMUM) && (height >= width)));
    };
    /**
     * Returns the key code of the key passed in human readable string form.
     * @see KeyboardInputInterpreter#getKeyCodeTable
     * @param {String} key
     * @returns {Number}
     */
    exports.getKeyCodeOf = function (key) {
        return key ?
                (key[0] === "#" ?
                        parseInt(key.slice(1), 10) :
                        _keyCodeTable[key]) :
                -1;
    };
    /**
     * Returns the key in human readable string form corresponding to the key code
     * passed as parameter.
     * @see KeyboardInputInterpreter#getKeyCodeTable
     * @param {Number} keyCode
     * @returns {String}
     */
    exports.getKeyOfCode = function (keyCode) {
        var key;
        for (key in _keyCodeTable) {
            if (_keyCodeTable[key] === keyCode) {
                return key;
            }
        }
        return "#" + keyCode;
    };
    /**
     * Compares whether two arrays contain the same values in the same order. Checks for nested arrays as well.
     * @param {Array} array1
     * @param {Array} array2
     * @returns {Boolean}
     */
    exports.arraysEqual = function (array1, array2) {
        var i, l;
        if (!array2) {
            return false;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        for (i = 0, l = array1.length; i < l; i++) {
            // Check if we have nested arrays
            if (array1[i] instanceof Array && array2[i] instanceof Array) {
                if (!array1[i].equals(array2[i])) {
                    return false;
                }
            } else if (array1[i] !== array2[i]) {
                return false;
            }
        }
        return true;
    };
    /**
     * Compares whether two objects have the same own enumerable properties with the same values.
     * Values of properties are checked strictly! Properties that point to equivalent, but different objects or arrays are considered 
     * different.
     * @param {Object} object1
     * @param {Object} object2
     * @returns {Boolean}
     */
    exports.objectsEqual = function (object1, object2) {
        var keys1, keys2, i;
        if ((object1 === null) && (object2 === null)) {
            return true;
        }
        if (object1) {
            keys1 = Object.keys(object1).sort();
        } else {
            return false;
        }
        if (object2) {
            keys2 = Object.keys(object2).sort();
        } else {
            return false;
        }
        if (keys1.length !== keys2.length) {
            return false;
        }
        for (i = 0; i < keys1.length; i++) {
            if ((keys1[i] !== keys2[i]) || (object1[keys1[i]] !== object2[keys2[i]])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Checks whether the passed two variables are equivalent. That is, they have the same value or they refer to objects / arrays that
     * have equivalent properties / elements (even if the reference itself is different) 
     * The types of the two values must be the same.
     * @param {} a
     * @param {} b
     * @returns {Boolean}
     */
    exports.equivalent = function (a, b) {
        var i, l, ka, kb;
        // objects and arrays are (recursively) compared based on the equivalency of their properties / elements
        if (((typeof a) === "object") && ((typeof b) === "object")) {
            if ((a === null) || (b === null)) {
                return (a === b);
            }
            if ((a instanceof Array) && (b instanceof  Array)) {
                if (a.length !== b.length) {
                    return false;
                }
                for (i = 0, l = a.length; i < l; i++) {
                    if (!exports.equivalent(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            }
            ka = Object.keys(a).sort();
            kb = Object.keys(b).sort();
            if (ka.length !== kb.length) {
                return false;
            }
            for (i = 0, l = ka.length; i < l; i++) {
                if ((ka[i] !== kb[i]) || !exports.equivalent(a[ka[i]], b[kb[i]])) {
                    return false;
                }
            }
            return true;
        }
        // primitives are strictly checked (types must be the same, "1" is not equivalent to 1)
        return a === b;
    };
    /**
     * Returns a shallow copy of the passed data
     * @param {} data Any type of data
     * @returns {}
     */
    exports.shallowCopy = function (data) {
        var result, i, propertyNames;
        if (typeof data === "object") {
            if (data instanceof Array) {
                return data.slice();
            }
            result = {};
            propertyNames = Object.keys(data);
            for (i = 0; i < propertyNames.length; i++) {
                result[propertyNames[i]] = data[propertyNames[i]];
            }
            return result;
        }
        return data;
    };
    /**
     * Returns a deep copy (recursive copy by values) of the passed data
     * @param {} data Any type of data
     * @returns {}
     */
    exports.deepCopy = function (data) {
        var result, i, propertyNames;
        if (typeof data === "object") {
            if (data instanceof Array) {
                result = [];
                for (i = 0; i < data.length; i++) {
                    result.push(exports.deepCopy(data[i]));
                }
                return result;
            }
            result = {};
            propertyNames = Object.keys(data);
            for (i = 0; i < propertyNames.length; i++) {
                result[propertyNames[i]] = exports.deepCopy(data[propertyNames[i]]);
            }
            return result;
        }
        return data;
    };
    /**
     * Removes the passed element from the passed array, if it is a part of it
     * @param {Array} array
     * @param {} element
     * @returns {Boolean} Whether the element was found and removed
     */
    exports.removeFromArray = function (array, element) {
        var index = array.indexOf(element);
        if (index >= 0) {
            array.splice(index, 1);
            return true;
        }
        return false;
    };
    /**
     * Returns a value that is guaranteed to be among the possible values of an enumeration object.
     * @param {Object} enumObject
     * @param {any} value
     * @param {any} [defaultValue]
     * @returns {}
     */
    exports.getSafeEnumValue = function (enumObject, value, defaultValue) {
        var p;
        defaultValue = defaultValue ? exports.getSafeEnumValue(enumObject, defaultValue) : null;
        for (p in enumObject) {
            if (enumObject.hasOwnProperty(p)) {
                if (value === enumObject[p]) {
                    return value;
                }
            }
        }
        return defaultValue || null;
    };
    /**
     * Returns a value that is guaranteed to be among the possible values of an enumeration object.
     * @param {Object} enumObject
     * @param {String} key The key for the value - this will be converted to a constant name!
     * @param {any} [defaultValue]
     * @returns {any}
     */
    exports.getSafeEnumValueForKey = function (enumObject, key, defaultValue) {
        defaultValue = (defaultValue !== undefined) ? exports.getSafeEnumValue(enumObject, defaultValue) : null;
        if (key) {
            key = exports.constantName(key);
            if (enumObject.hasOwnProperty(key)) {
                return enumObject[key];
            }
        }
        return (defaultValue !== undefined) ? defaultValue : null;
    };
    /**
     * Returns an array of the possible values of an object serving as an enum.
     * @param {Object} enumObject
     * @returns {Array}
     */
    exports.getEnumValues = function (enumObject) {
        var result = [], p;
        for (p in enumObject) {
            if (enumObject.hasOwnProperty(p)) {
                result.push(enumObject[p]);
            }
        }
        return result;
    };
    /**
     * Returns an array with the possible keys of an enum definition object,
     * converted to camelCase.
     * E.g. {VALUE: 1, OTHER_VALUE: 2} -> ["value", "otherValue"]
     * @param {Object} enumObject
     * @returns {Array}
     */
    exports.getEnumKeys = function (enumObject) {
        var result = Object.keys(enumObject), i;
        for (i = 0; i < result.length; i++) {
            result[i] = exports.camelCase(result[i]);
        }
        return result;
    };
    /**
     * Returns an object that can be used as an enum definition object with the
     * valid enum values being the strings in the passed array.
     * @param {String[]} enumValues
     * @returns {Object}
     */
    exports.getEnumObject = function (enumValues) {
        var result = {}, i;
        for (i = 0; i < enumValues.length; i++) {
            result[enumValues[i]] = enumValues[i];
        }
        return result;
    };
    /**
     * Returns the key of a property of the given object that has the given value, if any.
     * @param {Object} obj
     * @param {} value
     * @returns {String}
     */
    exports.getKeyOfValue = function (obj, value) {
        var key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (obj[key] === value) {
                    return key;
                }
            }
        }
        return null;
    };
    /**
     * Returns a string converted from the given number, padded by "0"s at the beginning, if it has fewer digits than specified
     * @param {Number} num The number to convert to string
     * @param {Number} digits The minimum amount of digits the resulting string should contain
     * @param {Number} [radix=10] The base of the numeric system to use (e.g. 16 for hex)
     * @returns {String}
     */
    exports.getPaddedStringForNumber = function (num, digits, radix) {
        var i, result = num.toString(radix || 10);
        for (i = result.length; i < digits; i++) {
            result = "0" + result;
        }
        return result;
    };
    /**
     * Returns a string converted from the given number, with NUMBER_THOUSANDS_DELIMITER inserted after every 3 digits left of the decimal
     * mark
     * @param {Number} num
     * @returns {String}
     */
    exports.getDelimitedStringForNumber = function (num) {
        if (num >= 1000) {
            return exports.getDelimitedStringForNumber(Math.floor(num / 1000)) + NUMBER_THOUSANDS_DELIMITER + exports.getPaddedStringForNumber(num % 1000, 3);
        }
        return num.toString();
    };
    /**
     * Returns a string describing a length (distance) in human-readable form based on its value in meters.
     * @param {Number} lengthInMeters
     * @returns {String}
     */
    exports.getLengthString = function (lengthInMeters) {
        return (lengthInMeters < 2000) ?
                ((lengthInMeters < 100) ?
                        lengthInMeters.toPrecision(3) + " m" :
                        Math.round(lengthInMeters) + " m") :
                ((lengthInMeters < 100000) ?
                        (lengthInMeters / 1000).toPrecision(3) + " km" :
                        exports.getDelimitedStringForNumber(Math.round(lengthInMeters / 1000)) + " km");
    };
    /**
     * Returns a string describing a mass (weight) in human-readable form based on its value in kilograms.
     * @param {Number} massInKilograms
     * @returns {String}
     */
    exports.getMassString = function (massInKilograms) {
        return (massInKilograms < 2000) ?
                ((massInKilograms < 100) ?
                        massInKilograms.toPrecision(3) + " kg" :
                        Math.round(massInKilograms) + " kg") :
                ((massInKilograms < 100000) ?
                        (massInKilograms / 1000).toPrecision(3) + " t" :
                        exports.getDelimitedStringForNumber(Math.round(massInKilograms / 1000)) + " t");
    };
    /**
     * Returns a string describing a time (duration) in human-readable form based on its value in milliseconds.
     * @param {Number} timeInMs
     * @returns {String}
     */
    exports.getTimeString = function (timeInMs) {
        return (timeInMs < 1000) ?
                timeInMs + " ms" :
                ((timeInMs < 60000) ?
                        (Math.round(timeInMs / 10) / 100) + " s" :
                        exports.formatTimeToMinutes(timeInMs));
    };
    /**
     * Converts the string to all uppercase and replaces spaces and dashes with underscores as well as inserts underscores before uppercase letters
     * @param {String} string
     * @returns {String}
     */
    exports.constantName = function (string) {
        var result = "", i;
        for (i = 0; i < string.length; i++) {
            if (string[i].match(/[A-Z]/)) {
                result += UNDERSCORE;
            }
            result += ((string[i] === SPACE) || (string[i] === DASH)) ? UNDERSCORE : string[i].toUpperCase();
        }
        return result;
    };
    /**
     * Converts the passed string from CONSTANT_NAME_FORMAT to camelCaseFormat
     * @param {String} string
     * @returns {String}
     */
    exports.camelCase = function (string) {
        var result = "", i, capital = false;
        for (i = 0; i < string.length; i++) {
            if (string[i] === UNDERSCORE) {
                capital = true;
            } else {
                result += capital ? string[i] : string[i].toLowerCase();
                capital = false;
            }
        }
        return result;
    };
    /**
     * Replaces parts of a string marked by curly braces with the properties of the passed object
     * that have the same name as indicated between the curly braces and returns the resulting
     * string. (e.g. Called with "Hello, {name}!", {name: "Peter"} parameters, will return "Hello, Peter!")
     * @param {String} string
     * @param {Object} replacements
     * @returns {String}
     */
    exports.formatString = function (string, replacements) {
        var replacementName, str = string.toString();
        for (replacementName in replacements) {
            if (replacements.hasOwnProperty(replacementName)) {
                str = str.replace(new RegExp("\\{" + replacementName + "\\}", "gi"), replacements[replacementName]);
            }
        }
        return str;
    };
    /**
     * Returns a MM:SS format string representing the time duration / interval of the passed amount of milliseconds
     * (if longer than 60 minutes, the full amount will be in minutes, e.g. 120:00 would be 2 hours)
     * @param {Number} milliseconds
     * @returns {String}
     */
    exports.formatTimeToMinutes = function (milliseconds) {
        var min, sec;
        min = Math.floor(milliseconds / 60000);
        sec = Math.floor(milliseconds / 1000) % 60;
        return exports.getPaddedStringForNumber(min, 2) + ":" + exports.getPaddedStringForNumber(sec, 2);
    };
    /**
     * Returns a SS.mm format string representing the time duration / interval of the passed amount of milliseconds
     * (if longer than 60 seconds, the extra time will be ignored)
     * @param {Number} milliseconds
     * @returns {String}
     */
    exports.formatTimeToSeconds = function (milliseconds) {
        var sec, ms;
        sec = Math.floor(milliseconds / 1000) % 60;
        ms = Math.floor((milliseconds % 1000) / 10);
        return exports.getPaddedStringForNumber(sec, 2) + "." + exports.getPaddedStringForNumber(ms, 2);
    };
    /**
     * Adds the passed function to the event queue without any delay.
     * @param {Function} functionToExecute
     */
    exports.executeAsync = function (functionToExecute) {
        setTimeout(functionToExecute, 0);
    };
    /**
     * Returns whether a given 2D point is within a given 2D rectangle.
     * @param {Number} x The X coordinate of the point to check.
     * @param {Number} y The Y coordinate of the point to check.
     * @param {Number} left The X coordinate of the left side of the rectangle.
     * @param {Number} bottom The Y coordinate of the bottom side of the rectangle. (the smaller Y coordinate)
     * @param {Number} right The X coordinate of the right side of the rectangle.
     * @param {Number} top The Y coordinate of the bottom side of the rectangle. (the larger Y coordinate)
     * @returns {Boolean}
     */
    exports.pointInRect = function (x, y, left, bottom, right, top) {
        return (x >= left) && (x <= right) && (y >= bottom) && (y <= top);
    };
    /**
     * Extracts the part after folders and before the extension from the passed file path and returns it.
     * @param {String} path
     * @returns {String}
     */
    exports.getFilenameWithoutExtension = function (path) {
        var dotIndex = path.lastIndexOf("."), slashIndex = path.lastIndexOf("/");
        path = (dotIndex > 0) ? path.substr(0, dotIndex) : path;
        path = (slashIndex > 0) ? path.substr(slashIndex + 1) : path;
        return path;
    };
    /**
     * 
     * @param {Number} value1
     * @param {Number} value2
     * @param {Number} value2Ratio
     * @returns {Number}
     */
    exports.getLinearMix = function (value1, value2, value2Ratio) {
        return value1 * (1 - value2Ratio) + value2 * value2Ratio;
    };
    /**
     * Returns an RGBA color that is the result of mixing the two passed RGBA colors with the second color
     * having the given ratio. (using a simple linear combination of the components of the colors)
     * @param {Number[4]} color1
     * @param {Number[4]} color2
     * @param {Number} color2Ratio A number between 0.0 and 1.0 indicating the relative amount of the second
     * color in the result.
     * @returns {Number[4]}
     */
    exports.getMixedColor = function (color1, color2, color2Ratio) {
        var color1Ratio = 1 - color2Ratio;
        return [
            color1[0] * color1Ratio + color2[0] * color2Ratio,
            color1[1] * color1Ratio + color2[1] * color2Ratio,
            color1[2] * color1Ratio + color2[2] * color2Ratio,
            color1[3] * color1Ratio + color2[3] * color2Ratio
        ];
    };
    /**
     * Returns the luminance value of the passed RGB color
     * @param {Number[3]} color
     * @returns {Number}
     */
    exports.getLuminance = function (color) {
        return 0.299 * color[0] + 0.587 * color[1] + 0.114 * color[2];
    };
    /**
     * Multiplies the given RGBA color with the given RGBA filter and also returns it.
     * @param {Number[4]} color
     * @param {Number[4]} filter
     * @returns {Number[4]} The modified color
     */
    exports.filterColor = function (color, filter) {
        color[0] *= filter[0];
        color[1] *= filter[1];
        color[2] *= filter[2];
        color[3] *= filter[3];
        return color;
    };
    /**
     * Applies the given gamma correction to the given color, and returns the modified color.
     * @param {Number[3]} color
     * @param {Number} gamma
     * @returns {Number[3]}
     */
    exports.gammaCorrect = function (color, gamma) {
        color[0] = Math.pow(color[0], 1.0 / gamma);
        color[1] = Math.pow(color[1], 1.0 / gamma);
        color[2] = Math.pow(color[2], 1.0 / gamma);
        return color;
    };
    /**
     * Converts the passed RGBA color from a 4 component float vector format to a string that can be used to set that color in CSS.
     * @param {Number[4]} color
     * @returns {String}
     */
    exports.getCSSColor = function (color) {
        return "rgba(" +
                Math.round(color[0] * 255) + "," +
                Math.round(color[1] * 255) + "," +
                Math.round(color[2] * 255) + "," +
                color[3] + ")";
    };
    /**
     * Converts the given, 3 component float color to a hex string (such as "#ff0000")
     * @param {Number[3]} color
     * @returns {String}
     */
    exports.getHexColor = function (color) {
        return "#" +
                exports.getPaddedStringForNumber(Math.round(color[0] * 255), 2, 16) +
                exports.getPaddedStringForNumber(Math.round(color[1] * 255), 2, 16) +
                exports.getPaddedStringForNumber(Math.round(color[2] * 255), 2, 16);
    };
    /**
     * Convert the given hex color string (such as "#ff0000") to a 3 component float color
     * @param {String} hexColor
     * @returns {Number[3]}
     */
    exports.getColor3FromHex = function (hexColor) {
        var result = [0, 0, 0];
        result[0] = parseInt(hexColor.substr(1, 2), 16) / 255;
        result[1] = parseInt(hexColor.substr(3, 2), 16) / 255;
        result[2] = parseInt(hexColor.substr(5, 2), 16) / 255;
        return result;
    };
    /**
     * Solves the quadratic equation a * x^2 + b * x + c = 0 for x, and returns the greater of the two solutions. Returns NaN if there is
     * no solution.
     * @param {Number} a
     * @param {Number} b
     * @param {Number} c
     * @returns {Number}
     */
    exports.getGreaterSolutionOfQuadraticEquation = function (a, b, c) {
        var d = b * b - 4 * a * c;
        return (d >= 0) ? ((Math.sqrt(d) - b) / (2 * a)) : NaN;
    };
    /**
     * Solves the 4th degree equation a * x^4 + c * x^2 + d * x + e = 0 for x, and returns the smallest positive,
     * non-complex solution (or NaN, if such a solution doesn't exist)
     * @param {Number} a
     * @param {Number} c
     * @param {Number} d
     * @param {Number} e
     * @returns {Number}
     */
    exports.getSmallestPositiveSolutionOf4thDegreeEquationWithoutDegree3 = function (a, c, d, e) {
        var 
            A = c / a,
            B = d / a,
            C = e / a,
            P = -(A * A / 48) - (C / 4),
            Q = -(A * A * A / 864) - (B * B / 64) + (A * C / 24),
            delta = (Q * Q / 4) + (P * P * P / 27),
            sqrtDelta, u, v, w, aux, x1, x2, Y1, Y2, Y3, x3, x4;
        if (delta >= 0) {
            if ((B === 0) && (A > 0) && (C === (A * A / 4))) {
                return NaN;
            } else {
                sqrtDelta = Math.sqrt(delta);
                u = Math.cbrt(-Q / 2 + sqrtDelta);
                v = Math.cbrt(-Q / 2 - sqrtDelta);
                aux = (A / 6) + 2 * (u + v);
                w = Math.sqrt(-(A / 3) - (u + v) + Math.sqrt(aux * aux - C));
                aux = ((B > 0) ? -1 : 1) * Math.sqrt(-(A / 6) + u + v);
                x1 = aux + w;
                x2 = aux - w;
                if (x1 < 0) {
                    return x2;
                } else if (x2 < 0) {
                    return x1;
                } else {
                    return Math.min(x1, x2);
                }
            }
        } else {
            aux = 2 * Math.sqrt(-P / 3);
            w = 1 / 3 * Math.acos(-Q / 2 / Math.sqrt(-Math.pow(P / 3, 3)));
            Y1 = -(A / 6) + aux * Math.cos(w);
            Y2 = -(A / 6) + aux * Math.cos(2 * Math.PI / 3 + w);
            Y3 = -(A / 6) + aux * Math.cos(4 * Math.PI / 3 + w);
            if ((C > (A * A / 4)) || (A > 0)) {
                return NaN;
            } else {
                aux = ((B > 0) ? -1 : 1) * Math.sqrt(Y1);
                Y2 = Math.sqrt(Y2);
                Y3 = Math.sqrt(Y3);
                w = Y2 + Y3;
                x1 = aux + w;
                x2 = aux - w;
                w = Y2 - Y3;
                x3 = -aux + w;
                x4 = -aux - w;
                if (x1 < 0) {
                    if (x2 < 0) {
                        if (x3 < 0) {
                            if (x4 < 0) {
                                return NaN;
                            } else {
                                return x4;
                            }
                        } else {
                            if (x4 < 0) {
                                return x3;
                            } else {
                                return Math.min(x3, x4);
                            }
                        }
                    } else {
                        if (x3 < 0) {
                            if (x4 < 0) {
                                return x2;
                            } else {
                                return Math.min(x2, x4);
                            }
                        } else {
                            if (x4 < 0) {
                                return Math.min(x2, x3);
                            } else {
                                return Math.min(x2, x3, x4);
                            }
                        }
                    }
                } else {
                    if (x2 < 0) {
                        if (x3 < 0) {
                            if (x4 < 0) {
                                return x1;
                            } else {
                                return Math.min(x1, x4);
                            }
                        } else {
                            if (x4 < 0) {
                                return Math.min(x1, x3);
                            } else {
                                return Math.min(x1, x3, x4);
                            }
                        }
                    } else {
                        if (x3 < 0) {
                            if (x4 < 0) {
                                return Math.min(x1, x2);
                            } else {
                                return Math.min(x1, x2, x4);
                            }
                        } else {
                            if (x4 < 0) {
                                return Math.min(x1, x2, x3);
                            } else {
                                return Math.min(x1, x2, x3, x4);
                            }
                        }
                    }
                }
            }
        }
    };
    /**
     * Returns whether the current environment supports touch events
     * @returns {Boolean}
     */
    exports.areTouchEventsSupported = function () {
        return "ontouchstart" in window;
    };
    return exports;
});
/**
 * Copyright 2014-2017, 2020 Krisztián Nagy
 * @file A low level module with no dependencies that offers general functionality useful for managing basic application functions such
 * as accessing files from a directory structure using AJAX.
 * Usage:
 * - augment the module with your own application's functionality in your own main module
 * - (optional) set application version
 * - set the application folders using setFolders()
 * - (optional) set if you want to bypass file caching with setFileCacheBypassEnabled()
 * - use requestTextFile(), requestFile() or requestCSSFile() to easily manage the loading of files from the set folders
 * - use setLogVerbosity() and log() to log with a settable level of verbosity
 * - use showError() to display verbose error messages
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, requirejs, alert, console, XMLHttpRequest, DOMParser, document, performance */

/**
 * @module modules/application
 */
define('modules/application',[],function () {
    "use strict";
    var
            // -------------------------------------------------------------------------
            // Enums
            /**
             * @enum {String}
             * The possible levels for the severity of displayed errors.
             */
            ErrorSeverity = {
                /**
                 * The application is not functional after such an error.
                 * @type String
                 */
                CRITICAL: "critical",
                /**
                 * The application is expected to produce serious bugs after such an error.
                 * @type String
                 */
                SEVERE: "severe",
                /**
                 * The application should run fine after this kind of error, but with possible changes in settings / performace / features.
                 * @type String
                 */
                MINOR: "minor"
            },
            // -------------------------------------------------------------------------
            // Private variables
            DEFAULT_TEXT_MIME_TYPE = "text/plain; charset=utf-8",
            /**
             * The associative array storing the names of the folders of the application, 
             * indexed by the types of files they contain.
             * @type Object.<String,String>
             */
            _folders = null,
            /**
             * A flag to indicate that file caching should be bypassed (disabled) when
             * grabbing resource files for the program. This property is used for
             * development as setting it to true makes sure that all changes in any of the
             * files always take effect when refreshing the game page. It causes all
             * files to be grabbed every time even if no changes occured, so it is 
             * important to set it to false for releases.
             * @type Boolean
             */
            _fileCacheBypassEnabled = true,
            /**
             * The level of verbosity the program should consider while logging. Only
             * messages with this is lower verbosity level will be displayed, and
             * therefore level 0 is the lowest (logging off) verbosity level. This
             * property is used for debugging, and should be set to 0 for releases.
             * @type Number
             */
            _logVerbosity = 0,
            /**
             * The string identifying the version of the program. Might be any arbitraty
             * string with no restrictions, no specific convention is enforced.
             * @type String
             */
            _version = "",
            /**
             * Whether the current version should be considered a development / debug (and not release / production / distribution)
             * version of the application.
             * @type Boolean
             */
            _isDebugVersion = true,
            /**
             * Whether the application is packaged using Electron (https://electron.atom.io/).
             * @type Boolean
             */
            _usesElectron = false,
            /**
             * The string identifying the version of the program that was run the last time.
             * @type String
             */
            _previouslyRunVersion,
            /**
             * Whether the application is run for the first time.
             * @type Boolean
             */
            _firstRun,
            /**
             * A list of version to be considered releases of the application. Can be used to query the list
             * of releases since the previously run version.
             * @type String
             */
            _releases;
    /**
     * Logs the passed message. (currently on console)
     * @param {String} message The message to log.
     * @param {Number} verbosity The verbosity level of the message. It will only
     * be logged, if the currently set verbosity level is greater or equal than this.
     */
    function log(message, verbosity) {
        if (!verbosity || (verbosity <= _logVerbosity)) {
            console.log(message); //eslint-disable-line no-console
        }
    }
    return {
        // -------------------------------------------------------------------------
        // Public enums
        ErrorSeverity: ErrorSeverity,
        // -------------------------------------------------------------------------
        // Public methods
        /**
         * Returns the path of the folder where the files of the passed type are stored,
         * relative to the site root.
         * @param {String} fileType If the last character is a slash '/', the method
         * will assume the folder name was specified directly, and will simply return it.
         * @returns {String}
         */
        getFolder: function (fileType) {
            if ((fileType.length > 0) && (fileType[fileType.length - 1] === "/")) {
                return fileType;
            }
            if (!_folders) {
                this.log("Looking for the folder assigned to file type '" + fileType + "', but there are no folders specified in the application configuration. Will use the folder with the same name as the file type.");
                return fileType + "/";
            }
            if (_folders[fileType] !== undefined) {
                return _folders[fileType];
            }
            this.showError("Asked for folder for file type '" + fileType + "', and folder for such files is not registered!", ErrorSeverity.SEVERE);
            return null;
        },
        /**
         * Sets the associative array containing the folder paths for different file types. The passed object has to contain the folder URLs 
         * by file types, and the URLs can also contain references to another folder URL, specifying the corresponding file type between {{ 
         * and }} signs. Folder names need to end with a /.
         * @param {Object.<String, String>} folders
         */
        setFolders: function (folders) {
            var fileType = "", resolveFolder = function (folder, fType, referringFolderFileTypes) {
                var start = -1, end = -1, substitutedFolder = "", substitutedFolderFileType = "";
                referringFolderFileTypes = referringFolderFileTypes || [];
                while (folder.indexOf("{{") >= 0) {
                    if (folder.indexOf("}}") >= 0) {
                        start = folder.indexOf("{{");
                        end = folder.indexOf("}}");
                        substitutedFolderFileType = folder.substring(start + 2, end);
                        substitutedFolder = folders[substitutedFolderFileType];
                        if (substitutedFolder) {
                            if (referringFolderFileTypes.indexOf(substitutedFolderFileType) < 0) {
                                folder = folder.replace(folder.substring(start, Math.min(end + 3, folder.length)), resolveFolder(substitutedFolder, substitutedFolderFileType, referringFolderFileTypes.concat(fType)));
                            } else {
                                this.showError("Circular reference detected among the following folders: " + referringFolderFileTypes.concat(fType).join(", "), ErrorSeverity.SEVERE);
                                return null;
                            }
                        } else {
                            this.showError("Invalid folder name specified! Cannot find referenced folder '" + folder.substring(start + 2, end) + "' in " + folder + "!", ErrorSeverity.SEVERE);
                            return null;
                        }
                    } else {
                        this.showError("Invalid folder name specified! Cannot resolve: '" + folder + "'", ErrorSeverity.SEVERE, "References to other folders must be surrounded by {{ and }}.");
                        return null;
                    }
                }
                return folder;
            }.bind(this);
            _folders = {};
            for (fileType in folders) {
                if (folders.hasOwnProperty(fileType)) {
                    _folders[fileType] = resolveFolder(folders[fileType], fileType);
                }
            }
        },
        /**
         * When set to true, a query parameter with the current time is appended to the URL of file requests,
         * so that local file cache is not used.
         * This is useful for development as prevents the application to use the old version of a source file
         * after it has been updated.
         * @param {Boolean} value The new file cache bypass state.
         */
        setFileCacheBypassEnabled: function (value) {
            _fileCacheBypassEnabled = value;
        },
        /**
         * Sets a new logging verbosity level.
         * @param {type} value
         */
        setLogVerbosity: function (value) {
            _logVerbosity = value;
        },
        /**
         * Returns the version string.
         * @returns {String}
         */
        getVersion: function () {
            return _version;
        },
        /**
         * Return an argument that can be appended to URLs, marking them with the current application version.
         * @returns {String}
         */
        getVersionURLArg: function () {
            return "v=" + this.getVersion().split(" ")[0];
        },
        /**
         * Sets a new version string. Any string can be used, the only purpose is to let all the
         * modules of an application that depend on this module access a global version ID.
         * @param {String} value
         */
        setVersion: function (value) {
            _version = value;
            requirejs.config({
                urlArgs: this.getVersionURLArg()
            });
        },
        /**
         * Sets the string identifying the version of the program that was run the previous time the application was run.
         * @param {String} value
         */
        setPreviouslyRunVersion: function (value) {
            _previouslyRunVersion = value;
            _firstRun = (_previouslyRunVersion === undefined);
        },
        /**
         * Returns whether this is (knowingly) the first run of the application (only possible to know if the previously run and the current
         * versions are set)
         * @returns {Boolean}
         */
        isFirstRun: function () {
            return _firstRun;
        },
        /**
         * Returns whether the program version has changed compared to the one that was run the previous time (only possible if both are set)
         * @returns {Boolean}
         */
        hasVersionChanged: function () {
            if (_firstRun === undefined) {
                this.showError("Cannot determine whether the game version has changed, because the previously ran version is not set!");
            } else {
                return (_previouslyRunVersion !== _version);
            }
        },
        /**
         * Returns whether the current version should be considered a development / debug (and not release / production / distribution)
         * version of the application.
         * @returns {Boolean}
         */
        isDebugVersion: function () {
            return _isDebugVersion;
        },
        /**
         * Sets whether the current version should be considered a development / debug (and not release / production / distribution)
         * version of the application.
         * @param {Boolean} value
         */
        setDebugVersion: function (value) {
            _isDebugVersion = value;
        },
        /**
         * Sets the list of versions to be considered releases of the application.
         * @param {String[]} value
         */
        setReleases: function (value) {
            _releases = value;
        },
        /**
         * Returns the list of set releases which are newer than the previously run version of the application.
         * @returns {String[]}
         */
        getNewReleases: function () {
            var i, result = [];
            for (i = 0; i < _releases.length; i++) {
                if (_releases[i] > _previouslyRunVersion.substr(0, 5)) {
                    result.push(_releases[i]);
                }
            }
            return result;
        },
        /**
         * Returns whether the application is packaged using Electron (https://electron.atom.io/).
         * @returns {Boolean}
         */
        usesElectron: function () {
            return _usesElectron;
        },
        /**
         * Sets whether the application is packaged using Electron (https://electron.atom.io/).
         * @param {Boolean} value
         */
        useElectron: function (value) {
            _usesElectron = value;
        },
        /**
         * Returns the relative URL of a resource file of the given type and name.
         * If caching bypass is turned on, modified the URL appropriately.
         * @param {String} filetype The type of the file (e.g. model, texture,
         * config) for looking up the appropriate folder.
         * @param {String} filename The name of the file.
         * @returns {String}
         */
        getFileURL: function (filetype, filename) {
            return this.getFolder(filetype) + (filename + ((_fileCacheBypassEnabled || !this.getVersion()) ? ("?t=" + performance.now()) : ("?" + this.getVersionURLArg())));
        },
        /**
         * Notifies the user of an error that happened while running the game.
         * @param {String} message A brief error message to show.
         * @param {String} [severity] (enum ErrorSeverity) The severity level of the error.
         * @param {String} [details] Additional details to show about the error,
         * with possible explanations or tips how to correct this error.
         */
        showError: function (message, severity, details) {
            var errorString = "Error: " + message + (details ? "\n\n" + details + "\n\n" : "\n\n");
            switch (severity) {
                case ErrorSeverity.CRITICAL:
                    errorString += "Unfortunately this is a critical error.\n" +
                            "The application is not functional until this error is resolved.";
                    break;
                case ErrorSeverity.SEVERE:
                    errorString += "This is a severe error.\n" +
                            "The application might produce unexpected behaviour from this point on. " +
                            "It is recommended that you restart the application by refreshing the page in your browser.";
                    break;
                case ErrorSeverity.MINOR:
                    errorString += "This is a minor error.\n" +
                            "The application might be fully functional, but you might need to readjust some settings or take " +
                            "some other actions depending on the explanation of the error.";
                    break;
                default:
                    errorString += "The severity of this error cannot be determined.\n" +
                            "The application might produce unexpected behaviour from this point on. " +
                            "It is recommended that you restart the application by refreshing the page in your browser.";
                    break;
            }
            alert(errorString);
        },
        // for generic logging both for dev and prod
        log: log,
        // removed from prod source when building
        log_DEBUG: log,
        /**
         * Issues an asynchronous request to get a file and executes a callback function when the file has been grabbed. Uses HTTP request, 
         * thus only works through servers, cannot be used to access files on the local filesystem!
         * @param {String} filetype The type of the file to be accessed, such as model, texture or config. This will be used to choose the 
         * appropriate folder where to look for the file.
         * @param {String} filename The name of the file (not the full URL!)
         * @param {Function} onfinish The function to execute when the file has been loaded. It gets the XMLHTTPRequest object as parameter 
         * which holds the file contents in its response. If the loading fails, this function is still called, but without a parameter.
         * @param {String} [customMimeType] If this is specified, the MIME type will be overriden by the string given here. The standard 
         * type is XML, this needs to be specified if other files are to be loaded.
         * @param {XMLHTTPRequestResponseType} [responseType] If given, the responseType property of the request will be set to this value
         */
        requestFile: function (filetype, filename, onfinish, customMimeType, responseType) {
            this.log("Requesting file: '" + filename + "' from " + (this.getFolder(filetype) !== "" ?
                    "folder: '" + this.getFolder(filetype) :
                    "root folder") +
                    "'...", 2);
            var request = new XMLHttpRequest();
            request.onload = function () {
                this.log("File: '" + filename + "' successfully loaded.", 2);
                onfinish(request);
            }.bind(this);
            request.onerror = function () {
                this.showError("An error occured while trying to load file: '" + filename + "'.", ErrorSeverity.SEVERE, "The status of the request was: '" + request.statusText + "' when the error happened.");
                onfinish();
            }.bind(this);
            request.ontimeout = function () {
                this.showError("Request to load the file: '" + filename + "' timed out.", ErrorSeverity.SEVERE);
                onfinish();
            }.bind(this);
            if (customMimeType) {
                request.overrideMimeType(customMimeType);
            }
            if (responseType) {
                request.responseType = responseType;
            }
            request.open("GET", this.getFileURL(filetype, filename), true);
            request.send(null);
        },
        /**
         * Issues an asynchronous request to get a text file and executes a callback function when the file has been grabbed. Uses HTTP 
         * request, thus only works through servers, cannot be used to access files on the local filesystem!
         * @param {String} filetype The type of the file to be accessed, such as model, texture or config. This will be used to choose the 
         * appropriate folder where to look for the file.
         * @param {String} filename The name of the file (not the full URL!)
         * @param {Function} onfinish See requestFile()
         * @param {String} [mimeType=DEFAULT_TEXT_MIME_TYPE] A string containing the MIME type of the file and the optionally the charset to 
         * use
         */
        requestTextFile: function (filetype, filename, onfinish, mimeType) {
            this.requestFile(filetype, filename, function (request) {
                onfinish(request ? request.responseText : null);
            }, mimeType || DEFAULT_TEXT_MIME_TYPE);
        },
        /**
         * Issues an asynchronous request to get a CSS file and apply it to the current
         * document and executes a callback once it has been loaded.
         * @param {String} filetype The ID of the folder where the CSS files resides.
         * @param {String} filename The name of the file (relative to the referenced folder)
         * @param {Function} [onload] The function to execute when the css has been successfully loaded
         */
        requestCSSFile: function (filetype, filename, onload) {
            var cssLink;
            // Add a <link> tag pointing to the CSS file. Also check if the CSS file has already been 
            // linked, and only add it if not.
            if ((document.head.querySelectorAll("link[href='" + this.getFileURL(filetype, filename) + "']").length === 0)) {
                cssLink = document.createElement("link");
                cssLink.setAttribute("rel", "stylesheet");
                cssLink.setAttribute("type", "text/css");
                cssLink.onload = onload;
                cssLink.href = this.getFileURL(filetype, filename);
                document.head.appendChild(cssLink);
            } else {
                if (onload) {
                    onload();
                }
            }
        }
    };
});
/**
 * Copyright 2016-2017, 2020 Krisztián Nagy
 * @file Provides type checking functionality for simple types (booleans, number, strings) as well as enums (with values defined in an object),
 * arrays and typed arrays, and custom objects through the usage of an object definition (i.e. schema) format. Types can be combined this
 * way and constraints can be set on types (such as a range for a number of an array's length, presence of certain properties, or passing
 * a custom check function).
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, localStorage */

/**
 * @param utils Used for enum functionality
 * @param application Used for displaying error messages
 */
define('utils/types',[
    "utils/utils",
    "modules/application"
], function (utils, application) {
    "use strict";
    var
            /**
             * Stores the various types of errors that can occur the type verification of a variable.
             * @type Object
             */
            Errors = {
                /**
                 * The value provided failed to pass the provided check function.
                 */
                CHECK_FAIL_ERROR: "checkFailError",
                /**
                 * The value provided does not have the required type.
                 */
                TYPE_ERROR: "typeError",
                /**
                 * The value provided is not one of the valid values defined in the passed enum object.
                 */
                ENUM_VALUE_ERROR: "enumValueError",
                /**
                 * The enum object parameter provided is invalid (not object or has no properties)
                 */
                INVALID_ENUM_OBJECT_ERROR: "invalidEnumObjectError"
            },
            /**
             * The log verbosity level to use when logging errors if no explicit level is given.
             * @type Number
             */
            DEFAULT_ERROR_LOG_VERBOSITY_LEVEL = 1,
            /**
             * The object that will be returned as the public interface of this module.
             */
            exports = {
                Errors: Errors
            };
    /**
     * Returns an error message for the case when a variable value of any type cannot be verified because it fails the supplied check, and a
     * default value will be used instead.
     * @param {String} name The name of the variable to be used to refer to it in the message
     * @param {} value
     * @param {} defaultValue
     * @param {String} [checkFailMessage] The explanation for message to be included
     */
    function _getCheckFailErrorMessage(name, value, defaultValue, checkFailMessage) {
        return "Invalid value for '" + name + "' (" + value + ")" + (checkFailMessage ? (": " + checkFailMessage) : ".") + " Using default value " + defaultValue + " instead.";
    }
    /**
     * Shows an error message for the case when a variable value of any type cannot be verified because it fails the supplied check, and a
     * default value will be used instead.
     * @param {String} name The name of the variable to be used to refer to it in the message
     * @param {} value
     * @param {} defaultValue
     * @param {String} [checkFailMessage] The explanation for message to be included
     */
    function _showCheckFailError(name, value, defaultValue, checkFailMessage) {
        application.showError(_getCheckFailErrorMessage(name, value, defaultValue, checkFailMessage));
    }
    /**
     * Logs an error message for the case when a variable value of any type cannot be verified because it fails the supplied check, and a
     * default value will be used instead.
     * @param {String} name
     * @param {} value
     * @param {} defaultValue
     * @param {String} [checkFailMessage]
     * @param {Number} [verbosityLevel=DEFAULT_ERROR_LOG_VERBOSITY_LEVEL]
     */
    function _logCheckFailError(name, value, defaultValue, checkFailMessage, verbosityLevel) {
        application.log_DEBUG(_getCheckFailErrorMessage(name, value, defaultValue, checkFailMessage), verbosityLevel !== undefined ? verbosityLevel : DEFAULT_ERROR_LOG_VERBOSITY_LEVEL);
    }
    /**
     * Returns an error message to be shown / logged when a variable value of any type fails type verification because if has a different type
     * than required.
     * @param {String} type
     * @param {String} name
     * @param {} value
     * @param {} defaultValue
     * @returns {String}
     */
    function _getTypeError(type, name, value, defaultValue) {
        return "Invalid value for '" + name +
                "'. Expected " + type + ", got a(n) " + ((typeof value === "object") ? value.constructor.name : (typeof value)) + " (" + value +
                "). Using default value " + ((defaultValue instanceof Array) ? ("[" + defaultValue.join(", ") + "]") : ("'" + defaultValue + "'")) + " instead.";
    }
    /**
     * Shows an error message for the case when a variable value of any type fails type verification because if has a different type
     * than required.
     * @param {String} type
     * @param {String} name
     * @param {} value
     * @param {} defaultValue
     * @returns {String}
     */
    function _showTypeError(type, name, value, defaultValue) {
        application.showError(_getTypeError(type, name, value, defaultValue));
    }
    /**
     * Logs an error message for the case when a variable value of any type fails type verification because if has a different type
     * than required.
     * @param {String} type
     * @param {String} name
     * @param {} value
     * @param {} defaultValue
     * @param {Number} [verbosityLevel=DEFAULT_ERROR_LOG_VERBOSITY_LEVEL]
     * @returns {String}
     */
    function _logTypeError(type, name, value, defaultValue, verbosityLevel) {
        application.log_DEBUG(_getTypeError(type, name, value, defaultValue), verbosityLevel !== undefined ? verbosityLevel : DEFAULT_ERROR_LOG_VERBOSITY_LEVEL);
    }
    /**
     * Returns an error message to be shown / logged when a variable value fails type verification because is not one of the available 
     * values defined by a passed enum object.
     * @param {String} name
     * @param {} value
     * @param {Object} enumObject
     * @param {} defaultValue
     * @returns {String}
     */
    function _getEnumValueError(name, value, enumObject, defaultValue) {
        return "Unrecognized '" + name + "' value: '" + value + "'. Possible values are are: " + utils.getEnumValues(enumObject).join(", ") + ". Default value '" + defaultValue + "' will be used instead.";
    }
    /**
     * Shows an error message for the case when a variable value fails type verification because is not one of the available values defined 
     * by a passed enum object.
     * @param {String} name
     * @param {} value
     * @param {Object} enumObject
     * @param {} defaultValue
     * @returns {String}
     */
    function _showEnumValueError(name, value, enumObject, defaultValue) {
        application.showError(_getEnumValueError(name, value, enumObject, defaultValue));
    }
    /**
     * Logs an error message for the case when a variable value fails type verification because is not one of the available values defined 
     * by a passed enum object.
     * @param {String} name
     * @param {} value
     * @param {Object} enumObject
     * @param {} defaultValue
     * @param {Number} [verbosityLevel=DEFAULT_ERROR_LOG_VERBOSITY_LEVEL]
     * @returns {String}
     */
    function _logEnumValueError(name, value, enumObject, defaultValue, verbosityLevel) {
        application.log_DEBUG(_getEnumValueError(name, value, enumObject, defaultValue), verbosityLevel !== undefined ? verbosityLevel : DEFAULT_ERROR_LOG_VERBOSITY_LEVEL);
    }
    // ----------------------------------------------------------------------
    // constants
    // generic type descriptors
    exports.NUMBER = "number";
    exports.VECTOR2 = {
        baseType: "array",
        length: 2,
        elementType: "number"
    };
    exports.VECTOR3 = {
        baseType: "array",
        length: 3,
        elementType: "number"
    };
    exports.COLOR3 = {
        baseType: "array",
        length: 3,
        elementType: "number",
        elementTypeParams: {
            range: [0, 1]
        }
    };
    exports.COLOR4 = {
        baseType: "array",
        length: 4,
        elementType: "number",
        elementTypeParams: {
            range: [0, 1]
        }
    };
    exports.DURATION = {
        baseType: "number",
        range: [0, undefined]
    };
    exports.ANGLE_DEGREES = {
        baseType: "number",
        range: [-360, 360]
    };
    // ----------------------------------------------------------------------
    // public functions
    /**
     * @typedef {Function} Types~BooleanCallback
     * @param {Boolean} safeValue
     * @returns {Boolean}
     */
    /**
     * @typedef {Object} Types~BooleanValueParams
     * @property {String} [name] The name of the variable you are trying to acquire a value for (to show in error messages)
     * @property {Boolean} [defaultValue] If the original value is invalid, this value will be returned instead.
     * @property {Types~BooleanCallback} [checkFunction] If the type of the value is correct and this function is given, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid.
     * @property {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @property {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     * @property {Boolean} [silentFallback=false]
     * @property {String} [error] enum Errors
     */
    /**
     * Returns a type-safe boolean value. If the given original value is invalid, will show an error message and return the given default 
     * value.
     * @param {} value The original value to be checked
     * @param {Types~BooleanValueParams} params
     * @returns {Boolean|null}
     */
    exports.getBooleanValue = function (value, params) {
        params = params || {};
        params.name = params.name || "unnamed boolean";
        if (typeof value === "boolean") {
            if (params.checkFunction && !params.checkFunction(value, params.parentObject)) {
                params.error = Errors.CHECK_FAIL_ERROR;
                if (!params.silentFallback) {
                    _showCheckFailError(params.name, value, params.defaultValue, params.checkFailMessage);
                } else {
                    _logCheckFailError(params.name, value, params.defaultValue, params.checkFailMessage);
                }
            } else {
                return value;
            }
        } else {
            params.error = Errors.TYPE_ERROR;
            if (!params.silentFallback) {
                _showTypeError("a boolean", params.name, value, params.defaultValue);
            } else {
                _logTypeError("a boolean", params.name, value, params.defaultValue);
            }
        }
        if (params.defaultValue !== null) {
            value = params.defaultValue;
            params.defaultValue = null;
            return exports.getBooleanValue(value, params);
        }
        return null;
    };
    /**
     * @typedef {Function} Types~NumberCallback
     * @param {Number} safeValue
     * @returns {Boolean}
     */
    /**
     * @typedef {Object} Types~NumberValueParams
     * @property {String} [name] The name of the variable you are trying to acquire a value for (to show in error messages)
     * @property {Number} [defaultValue] If the original value is invalid, this value will be returned instead.
     * @property {Types~NumberCallback} [checkFunction] If the type of the value is correct and this function is given, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid.
     * @property {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @property {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     * @property {Boolean} [silentFallback=false]
     */
    /**
     * Returns a type-safe number value. If the given original value is invalid, will show an error message and return the given default 
     * value.
     * @param {String} name The name of the variable you are trying to acquire a value for (to show in error messages)
     * @param {} value The original value to be checked
     * @param {Number} [defaultValue] If the original value is invalid, this value will be returned instead.
     * @param {Types~NumberCallback} [checkFunction] If the type of the value is correct and this function is given, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid.
     * @param {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @param {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     * @param {Boolean} [silentFallback=false]
     * @returns {Number|null}
     */
    exports.getNumberValue = function (name, value, defaultValue, checkFunction, checkFailMessage, parentObject, silentFallback) {
        if (typeof value === "number") {
            if (checkFunction) {
                if (!checkFunction(value, parentObject)) {
                    _showCheckFailError(name, value, defaultValue, checkFailMessage);
                    return (defaultValue !== null) ? exports.getNumberValue(name, defaultValue, null, checkFunction, checkFailMessage, parentObject) : null;
                }
            }
            return value;
        }
        if ((typeof defaultValue !== "number") || !silentFallback) {
            _showTypeError("a number", name, value, defaultValue);
        }
        return (defaultValue !== null) ? exports.getNumberValue(name, defaultValue, null, checkFunction, checkFailMessage, parentObject) : null;
    };
    /**
     * Returns a type-safe number value falling into a specific range. If the given original value is of invalid type, will show an error 
     * message and return the given default value, if it falls outside of the range, it will be increased / decreased to fit in (along with
     * showing an error message)
     * @param {String} name The name of the variable you are trying to acquire a value for (to show in error messages)
     * @param {} value The original value to be checked
     * @param {Number} [minValue] The minimum value for the range. If not given, check will be only done for the maximum value
     * @param {Number} [maxValue] The maximum value for the range. If not given, check will be only done for the minimum value
     * @param {Number} [defaultValue] If the original value is invalid, this value will be returned instead.
     * @param {Types~NumberCallback} [checkFunction] If the type of the value is correct and this function is given, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid.
     * @param {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @param {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     * @returns {Number|null}
     */
    exports.getNumberValueInRange = function (name, value, minValue, maxValue, defaultValue, checkFunction, checkFailMessage, parentObject) {
        if (typeof value === "number") {
            if (((minValue !== undefined) && (value < minValue)) || ((maxValue !== undefined) && (value > maxValue))) {
                application.showError("Invalid value for " + name + ": out of range (" + ((minValue !== undefined) ? minValue : "...") + "-" + ((maxValue !== undefined) ? maxValue : "...") + "). The setting will be changed to fit the valid range.");
                if (minValue !== undefined) {
                    value = Math.max(minValue, value);
                }
                if (maxValue !== undefined) {
                    value = Math.min(value, maxValue);
                }
            }
            if (checkFunction) {
                if (!checkFunction(value, parentObject)) {
                    _showCheckFailError(name, value, defaultValue, checkFailMessage);
                    return (defaultValue !== null) ? exports.getNumberValueInRange(name, defaultValue, minValue, maxValue, null, checkFunction, checkFailMessage, parentObject) : null;
                }
            }
            return value;
        }
        _showTypeError("a number", name, value, defaultValue);
        return (defaultValue !== null) ? exports.getNumberValueInRange(name, defaultValue, minValue, maxValue, null, checkFunction, checkFailMessage, parentObject) : null;
    };
    /**
     * @typedef {Function} Types~StringCallback
     * @param {String} safeValue
     * @returns {Boolean}
     */
    /**
     * @typedef {Object} Types~StringValueParams
     * @property {String} [name] The name of the variable you are trying to acquire a value for (to show in error messages)
     * @property {Number} [defaultValue] If the original value is invalid, this value will be returned instead.
     * @property {Types~StringCallback} [checkFunction] If the type of the value is correct and this function is given, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid.
     * @property {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @property {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     */
    /**
     * Returns a type-safe string value. If the given original value is invalid, will show an error message and return the given default 
     * value.
     * @param {String} name The name of the variable you are trying to acquire a value for (to show in error messages)
     * @param {} value The original value to be checked
     * @param {String} [defaultValue] If the original value is invalid, this value will be returned instead.
     * @param {Types~StringCallback} [checkFunction] If the type of the value is correct and this function is given, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid.
     * @param {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @param {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     * @returns {String|null}
     */
    exports.getStringValue = function (name, value, defaultValue, checkFunction, checkFailMessage, parentObject) {
        if (typeof value === "string") {
            if (checkFunction) {
                if (!checkFunction(value, parentObject)) {
                    _showCheckFailError(name, value, defaultValue, checkFailMessage);
                    return (defaultValue !== null) ? exports.getStringValue(name, defaultValue, null, checkFunction, checkFailMessage, parentObject) : null;
                }
            }
            return value;
        }
        _showTypeError("a string", name, value, defaultValue);
        return (defaultValue !== null) ? exports.getStringValue(name, defaultValue, null, checkFunction, checkFailMessage, parentObject) : null;
    };
    /**
     * @typedef {Object} Types~EnumValueParams
     * @property {String} [name] The name of the variable you are trying to acquire a value for (to show in error messages)
     * @property {String} [defaultValue] If the original value is invalid, this value will be returned instead.
     * @property {Types~NumberCallback} [checkFunction] If the type of the value is correct and this function is given, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid.
     * @property {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @property {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     * @property {Boolean} [silentFallback=false]
     * @property {String} [error] enum Errors
     */
    /**
     * If the given value is one of the possible enumeration values defined in the given enumeration object, it returns it, otherwise shows
     * a warning message about it to the user and returns the given default.
     * @param {Object} enumObject the object containing the valid enumeration values.
     * @param {} value The original value to be checked
     * @param {Types~EnumValueParams} params
     * @returns {}
     */
    exports.getEnumValue = function (enumObject, value, params) {
        var safeValue = utils.getSafeEnumValue(enumObject, value);
        params = params || {};
        params.name = params.name || "unnamed enum " + enumObject.constructor.name;
        if (safeValue !== null) {
            if (params.checkFunction && !params.checkFunction(safeValue, params.parentObject)) {
                params.error = Errors.CHECK_FAIL_ERROR;
                if (!params.silentFallback) {
                    _showCheckFailError(params.name, safeValue, params.defaultValue, params.checkFailMessage);
                } else {
                    _logCheckFailError(params.name, safeValue, params.defaultValue, params.checkFailMessage);
                }
            } else {
                return safeValue;
            }
        } else {
            if ((typeof enumObject !== "object") || (Object.keys(enumObject).length === 0)) {
                params.error = Errors.INVALID_ENUM_OBJECT_ERROR;
                application.showError("Invalid enum object specified for " + params.name + ": " + enumObject + ", and thus its value (" + value + ") cannot be verified!");
                return null;
            }
            params.error = Errors.ENUM_VALUE_ERROR;
            if (!params.silentFallback) {
                _showEnumValueError(params.name, value, enumObject, params.defaultValue);
            } else {
                _logEnumValueError(params.name, value, enumObject, params.defaultValue);
            }
        }
        if (params.defaultValue !== null) {
            value = params.defaultValue;
            params.defaultValue = null;
            return exports.getEnumValue(enumObject, value, params);
        }
        return null;
    };
    /**
     * @typedef {Function} Types~ObjectCallback
     * @param {Object} safeValue
     * @returns {Boolean}
     */
    /**
     * Returns a type-safe object value. If the given original value is invalid, will show an error message and return the given default 
     * value.
     * @param {String} name The name of the variable you are trying to acquire a value for (to show in error messages)
     * @param {} value The original value to be checked
     * @param {Object} [defaultValue] If the original value is invalid, this value will be returned instead.
     * @param {Types~ObjectCallback} [checkFunction] If the type of the value is correct and this function is given, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid.
     * @param {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @param {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     * @returns {Object|null}
     */
    exports.getObjectValue = function (name, value, defaultValue, checkFunction, checkFailMessage, parentObject) {
        if (typeof value === "object") {
            if (checkFunction) {
                if (!checkFunction(value, parentObject)) {
                    _showCheckFailError(name, value, defaultValue, checkFailMessage);
                    return (defaultValue !== null) ? exports.getObjectValue(name, defaultValue, null, checkFunction, checkFailMessage, parentObject) : null;
                }
            }
            return value;
        }
        _showTypeError("an object", name, value, defaultValue);
        return (defaultValue !== null) ? exports.getObjectValue(name, defaultValue, null, checkFunction, checkFailMessage, parentObject) : null;
    };
    /**
     * Executes type verification on a supplied value based on the passed type information. If the supplied value does not pass the
     * type verification, a default value will be returned.
     * @param {String} name The name of the variable you are trying to acquire a value for (to show in error messages)
     * @param {String|Object} type Either a string representation of the type (boolean/number/string/enum/object/array) or an object 
     * describing a custom value based on one of these. In the latter case the object has to contain its base type as the baseType properties
     * and any other type parameters directly as its properties
     * @param {} value The original value to be checked
     * @param {} defaultValue The default value to be returned in case the original value fails the verification
     * @param {Boolean} optional If true, undefined values will be accepted and returned without error, even if there is no default value set
     * @param {Object} [typeParams] The required and optional parameters to define the (constraints of the) type. Current options:
     * For number:
     * - (optional) range: an array of 2 optional numbers describing the minimum and maximum of the interval the value should be in
     * For enum:
     * - (required) values: the object that defines the valid enum values as its properties
     * For object:
     * - (optional) properties: an object to use for verifying the properties of the object
     * For array:
     * - (optional) elementType: if given, all elements of the array will be verified to be of this type. Can use the string or custom object
     * format as well
     * - (optional) elementTypeParams: any type parameters for the elements to be checked, in the same format as typeParams
     * - (optional) length: the array will only pass the verification if it has exactly the same length
     * @param {Function} [checkFunction] If the type of the value is correct and this function is given, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid. This will not be applied if the value to be tested is an object to be verified by an object definition object given through
     * the verify parameter.
     * @param {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @param {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     * @returns {}
     */
    exports.getValueOfType = function (name, type, value, defaultValue, optional, typeParams, checkFunction, checkFailMessage, parentObject) {
        typeParams = typeParams || {};
        if (value === undefined) {
            if (defaultValue !== undefined) {
                return (defaultValue !== null) ? exports.getValueOfType(name, type, defaultValue, null, optional, typeParams, checkFunction, checkFailMessage, parentObject) : null;
            }
            if (!optional) {
                application.showError("Missing required value of '" + name + "'!");
            }
            return undefined;
        }
        if (typeof type === "object") {
            // accept direct definition objects for describing properties
            if (!type.baseType) {
                return exports.getVerifiedObject(name, value, type);
            }
            return exports.getValueOfType(name, type.baseType, value, defaultValue, optional, type, checkFunction, checkFailMessage, parentObject);
        }
        switch (type) {
            case "boolean":
                return exports.getBooleanValue(value, {name: name, defaultValue: defaultValue, checkFunction: checkFunction, checkFailMessage: checkFailMessage, parentObject: parentObject});
            case "number":
                if (typeParams.range) {
                    return exports.getNumberValueInRange(name, value, typeParams.range[0], typeParams.range[1], defaultValue, checkFunction, checkFailMessage, parentObject);
                }
                return exports.getNumberValue(name, value, defaultValue, checkFunction, checkFailMessage, parentObject);
            case "string":
                return exports.getStringValue(name, value, defaultValue, checkFunction, checkFailMessage, parentObject);
            case "enum":
                if (typeParams.values) {
                    return exports.getEnumValue(typeParams.values, value, {name: name, defaultValue: defaultValue, checkFunction: checkFunction, checkFailMessage: checkFailMessage, parentObject: parentObject});
                }
                application.showError("Missing enum definition object for '" + name + "'!");
                return null;
            case "object":
                if (typeParams.properties) {
                    return exports.getVerifiedObject(name, value, typeParams.properties);
                }
                return exports.getObjectValue(name, value, defaultValue, checkFunction, checkFailMessage, parentObject);
            case "array":
                return exports.getArrayValue(name, value, typeParams.elementType, typeParams.elementTypeParams, typeParams, defaultValue, checkFunction, checkFailMessage, typeParams.elementCheck, typeParams.elementCheckFailMessage, parentObject);
            default:
                application.showError("Unknown type specified for '" + name + "': " + type);
                return null;
        }
    };
    /**
     * @typedef {Function} Types~ArrayCallback
     * @param {Array} safeValue
     * @returns {Boolean}
     */
    /**
     * Returns a type-safe array value. If the given original value is invalid, will show an error message and return the given default 
     * value.
     * @param {String} name The name of the variable you are trying to acquire a value for (to show in error messages)
     * @param {} value The original array to be checked
     * @param {String} [elementType] If given, the elements of the array will be checked to be of this type
     * @param {Object} [elementTypeParams] The type parameters for the elements (e.g. enum for enums, range for numbers, length for arrays)
     * @param {Number} [arrayParams] Can contain the required minimum, maximum or exact length of the array (minLength, maxLength, length)
     * @param {Array} [defaultValue] If the original value is invalid, this value will be returned instead.
     * @param {Types~ArrayCallback} [checkFunction] If the type of the value is correct and this function is give, it will be called with the 
     * value passed to it to perform any additional checks to confirm the validity of the value. It should return whether the value is 
     * valid.
     * @param {String} [checkFailMessage] An explanatory error message to show it the value is invalid because it fails the check.
     * @param {Function} [elementCheckFunction] A check function to be run for each element in the array
     * @param {String} [elementCheckFailMessage] An explanatory error message to show if elements of the array fail their check
     * @param {Object} [parentObject] If this value is the member of an object that is being verified, then this should be a reference to that object.
     * @returns {Boolean}
     */
    exports.getArrayValue = function (name, value, elementType, elementTypeParams, arrayParams, defaultValue, checkFunction, checkFailMessage, elementCheckFunction, elementCheckFailMessage, parentObject) {
        var result = [], resultElement;
        if (value instanceof Array) {
            if (arrayParams !== undefined) {
                if ((arrayParams.length !== undefined) && (value.length !== arrayParams.length)) {
                    application.showError("Invalid array length for '" + name + "'! Expected a length of " + arrayParams.length + " and got " + value.length + (defaultValue ? (". Using default value [" + defaultValue.join(", ") + "] instead.") : "."));
                    return defaultValue ? exports.getArrayValue(name, defaultValue, elementType, elementTypeParams, arrayParams, null, checkFunction, checkFailMessage, elementCheckFunction, elementCheckFailMessage, parentObject) : null;
                }
                if ((arrayParams.minLength !== undefined) && (value.length < arrayParams.minLength)) {
                    application.showError("Invalid array length for '" + name + "'! Expected a minimum length of " + arrayParams.minLength + " and got " + value.length + (defaultValue ? (". Using default value [" + defaultValue.join(", ") + "] instead.") : "."));
                    return defaultValue ? exports.getArrayValue(name, defaultValue, elementType, elementTypeParams, arrayParams, null, checkFunction, checkFailMessage, elementCheckFunction, elementCheckFailMessage, parentObject) : null;
                }
                if ((arrayParams.maxLength !== undefined) && (value.length > arrayParams.maxLength)) {
                    application.showError("Invalid array length for '" + name + "'! Expected a maximum length of " + arrayParams.maxLength + " and got " + value.length + (defaultValue ? (". Using default value [" + defaultValue.join(", ") + "] instead.") : "."));
                    return defaultValue ? exports.getArrayValue(name, defaultValue, elementType, elementTypeParams, arrayParams, null, checkFunction, checkFailMessage, elementCheckFunction, elementCheckFailMessage, parentObject) : null;
                }
            }
            if (elementType !== undefined) {
                value.forEach(function (element, index) {
                    resultElement = exports.getValueOfType(name + "[" + index + "]", elementType, element, null, false, elementTypeParams, elementCheckFunction, elementCheckFailMessage, parentObject);
                    if (resultElement !== null) {
                        result.push(resultElement);
                    }
                });
                value = result;
            }
            if (checkFunction) {
                if (!checkFunction(value)) {
                    _showCheckFailError(name, value, "[" + defaultValue.join(", ") + "]", checkFailMessage);
                    return (defaultValue !== null) ? exports.getArrayValue(name, defaultValue, elementType, elementTypeParams, arrayParams, null, checkFunction, checkFailMessage, elementCheckFunction, elementCheckFailMessage, parentObject) : null;
                }
            }
            return value;
        }
        _showTypeError("an array", name, value, defaultValue);
        return (defaultValue !== null) ? exports.getArrayValue(name, defaultValue, elementType, elementTypeParams, arrayParams, null, checkFunction, checkFailMessage, elementCheckFunction, elementCheckFailMessage, parentObject) : null;
    };
    /**
     * Verifies a given object's properties to be of certain types given by a passed object definition object. 
     * @param {String} name The value to be checked will be referred to by this name in error messages
     * @param {Object} value The object to be verified
     * @param {Object} definitionObject The object defining the properties as they should be. Each property should be defined as an object
     * itself, with a name property to identify it, a type property to describe the type (see getValueOfType), an optional defaultValue property,
     * which will cause the property to be added with this value, if it is missing from the original object (if a property without a default
     * value is missing, an error message will be displayed), and any other type parameters that getValueOfType accepts. If the original
     * object has any additional properties not included in the definition object, they will be discarded from the result, but an error
     * message will be shown about them.
     * @param {Object} [objectToAppendTo] If given, the resulting verified properties will be appended to this object instead of a new empty one
     * @param {Boolean} [doNotDiscard=false] If true, the properties of the object that are not in the definition will not be discarded
     * @param {Boolean} [silentDiscard=false] If true, there will be no warning shown about discarded / not defined but included properties
     * @param {String|Object} [propertyType] If given, the type can be omitted from the property definitions and if so, it will be considered to be this type
     * @returns {Object}
     */
    exports.getVerifiedObject = function (name, value, definitionObject, objectToAppendTo, doNotDiscard, silentDiscard, propertyType) {
        var propertyName, propertyDefinitionName, propertyDefinition, result = objectToAppendTo || {}, processedProperties = [], impliedType, i, impliedProperties;
        if (typeof value === "object") {
            for (propertyDefinitionName in definitionObject) {
                if (definitionObject.hasOwnProperty(propertyDefinitionName)) {
                    propertyDefinition = definitionObject[propertyDefinitionName];
                    if (result[propertyDefinition.name]) {
                        application.showError("'" + name + "' already has a property named '" + propertyDefinition.name + "', which will be overridden by a new value!");
                    }
                    // if no explicit type is given and the property definition object has no type either, imply that the property
                    // is of object type and the object properties of the property definition object describe the nested properties
                    // this way nested object can be described simply (e.g. parent: {name: "parentObject", CHILD: {name: "child", type: ...}}
                    // is equal to {name: "parentObject", type: {baseType: "object", properties: { CHILD: {name: "child", type: ... ...)
                    if (!propertyDefinition.type && !propertyType) {
                        impliedType = {};
                        impliedProperties = Object.keys(propertyDefinition);
                        for (i = 0; i < impliedProperties.length; i++) {
                            if (typeof propertyDefinition[impliedProperties[i]] === "object") {
                                impliedType[impliedProperties[i]] = propertyDefinition[impliedProperties[i]];
                            }
                        }
                    }
                    result[propertyDefinition.name] = exports.getValueOfType(
                            name + "." + propertyDefinition.name,
                            propertyDefinition.type || impliedType || propertyType,
                            value[propertyDefinition.name],
                            propertyDefinition.defaultValue,
                            propertyDefinition.optional,
                            {
                                // number
                                range: propertyDefinition.range,
                                // enum
                                values: propertyDefinition.values,
                                // array
                                elementType: propertyDefinition.elementType,
                                elementEnumObject: propertyDefinition.elementEnum,
                                length: propertyDefinition.length,
                                minLength: propertyDefinition.minLength,
                                maxLength: propertyDefinition.maxLength,
                                elementCheck: propertyDefinition.elementCheck,
                                elementCheckFailMessage: propertyDefinition.elementCheckFailMessage,
                                // object
                                properties: propertyDefinition.properties
                            },
                            propertyDefinition.check,
                            propertyDefinition.checkFailMessage,
                            value);
                    processedProperties.push(propertyDefinition.name);
                }
            }
            if (!silentDiscard || doNotDiscard) {
                for (propertyName in value) {
                    if (value.hasOwnProperty(propertyName)) {
                        if (processedProperties.indexOf(propertyName) < 0) {
                            if (!silentDiscard) {
                                application.showError(
                                        "Unrecognized property '" +
                                        propertyName + "' defined for '" + name +
                                        "'. The value of this property " +
                                        (propertyType ? "can be verified only against the default property type" : "cannot be verified ") +
                                        (doNotDiscard ? "but will be included." : "and will be discarded."));
                            }
                            if (doNotDiscard) {
                                if (propertyType) {
                                    result[propertyName] = exports.getValueOfType(
                                            name + "." + propertyName,
                                            propertyType,
                                            value[propertyName]);
                                } else {
                                    result[propertyName] = value[propertyName];
                                }

                            }
                        }
                    }
                }
            }
            return result;
        }
        application.showError("Invalid value for '" + name + "'. Expected an object, got a(n) " + (typeof value) + " (" + value + ").");
        return null;
    };
    /**
     * Reads, type verifies and returns a boolean value (or a supplied default) from local storage according to the specified parameters.
     * @param {String} storageLocation The key locating the value in local storage.
     * @param {Types~BooleanValueParams} params Same as for getBooleanValue.
     * @returns {null|Boolean}
     */
    exports.getBooleanValueFromLocalStorage = function (storageLocation, params) {
        var value;
        if (localStorage[storageLocation] === true.toString()) {
            value = true;
        } else if (localStorage[storageLocation] === false.toString()) {
            value = false;
        } else {
            value = localStorage[storageLocation];
        }
        params = params || {};
        params.name = params.name || "localStorage." + storageLocation;
        return exports.getBooleanValue(value, params);
    };
    /**
     * Reads, type verifies and returns a number value (or a supplied default) from local storage according to the specified parameters.
     * @param {String} storageLocation The key locating the value in local storage.
     * @param {Types~NumberValueParams} params
     * @returns {null|Number}
     */
    exports.getNumberValueFromLocalStorage = function (storageLocation, params) {
        var value = parseFloat(localStorage[storageLocation]);
        if (isNaN(value)) {
            value = localStorage[storageLocation];
        }
        params = params || {};
        params.name = params.name || "localStorage." + storageLocation;
        return exports.getNumberValue(params.name, value, params.defaultValue, params.checkFunction, params.checkFailMessage, params.parentObject, params.silentFallback);
    };
    /**
     * Reads, type verifies and returns an enum value (or a supplied default) from local storage according to the specified parameters.
     * @param {Object} enumObject The object describing the possible values for the enum.
     * @param {String} storageLocation The key locating the value in local storage.
     * @param {Types~EnumValueParams} params Same as for getEnumValue
     * @returns {any}
     */
    exports.getEnumValueFromLocalStorage = function (enumObject, storageLocation, params) {
        params = params || {};
        params.name = params.name || "localStorage." + storageLocation;
        return exports.getEnumValue(enumObject, localStorage[storageLocation], params);
    };
    /**
     * Reads, type verifies and returns a string value (or a supplied default) from local storage according to the specified parameters.
     * @param {String} storageLocation The key locating the value in local storage.
     * @param {Types~StringValueParams} params
     * @returns {null|String}
     */
    exports.getStringValueFromLocalStorage = function (storageLocation, params) {
        params = params || {};
        params.name = params.name || "localStorage." + storageLocation;
        return exports.getStringValue(params.name, localStorage[storageLocation], params.defaultValue, params.checkFunction, params.checkFailMessage);
    };
    /**
     * Reads, type verifies and returns a value of a given type (or a supplied default) from local storage according to the specified 
     * parameters. Currently only boolean and enum types are supported!
     * @param {String|Object} type The type descriptor string or object. (currently boolean / number / string / enum only!)
     * @param {String} storageLocation The key locating the value in local storage.
     * @param {Types~BooleanValueParams|Types~EnumValueParams} params
     * @returns {any}
     */
    exports.getValueOfTypeFromLocalStorage = function (type, storageLocation, params) {
        if (typeof type === "object") {
            params.values = type.values;
            return exports.getValueOfTypeFromLocalStorage(type.baseType, storageLocation, params);
        }
        switch (type) {
            case "boolean":
                return exports.getBooleanValueFromLocalStorage(storageLocation, params);
            case "number":
                return exports.getNumberValueFromLocalStorage(storageLocation, params);
            case "enum":
                return exports.getEnumValueFromLocalStorage(params.values, storageLocation, params);
            case "string":
                return exports.getStringValueFromLocalStorage(storageLocation, params);
            default:
                application.crash();
        }
    };
    /**
     * Returns a definition object defining an object structure with a string identifier ("name") and a numberic value.
     * @param {String} valueName The name of the property storing the numeric value.
     * @returns {Object}
     */
    exports.getNameAndValueDefinitionObject = function (valueName) {
        return {
            baseType: "object",
            properties: {
                NAME: {
                    name: "name",
                    type: "string"
                },
                VALUE: {
                    name: valueName,
                    type: "number"
                }
            }
        };
    };
    /**
     * Returns an object that can be used as an enum object in the type verification functions, based on an array storing the possible
     * enumeration values.
     * @param {Array} array
     * @returns {Object}
     */
    exports.getEnumObjectForArray = function (array) {
        var result = {}, i;
        for (i = 0; i < array.length; i++) {
            result[array[i]] = array[i];
        }
        return result;
    };
    // --------------------------------------------------------------------------------------------
    return exports;
});
/**
 * Copyright 2014-2015, 2020 Krisztián Nagy
 * @file A low level module with no dependencies.
 * Provides a class that represents asynchronously loaded resources to 
 * help transparently manage them. Provides an execution queue for the resource,
 * to which functions can be added to any time, but it is triggered only when 
 * the resource is ready to use.
 * Usage:
 * - use Resource as the parent class for objects that represent asynchronous resources
 * - call setToReady() on these objects when their loading finishes (-> in the callback function)
 * - use executeWhenReady() to call functions that can be only executed when the resource is loaded
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, setTimeout */

define('modules/async-resource',[],function () {
    "use strict";
    // #########################################################################
    /**
     * @class Ancestor class for all classes representing resources that need to 
     * be prepared (e.g. loaded from external source) before they can be used. 
     * As the loading happends asynchronously in many cases, this class provides 
     * a safe way to interact with the objects at any time, queuing the actions 
     * if the resource is not ready yet to use.
     */
    function AsyncResource() {
        /**
         * Whether the resource is ready to be used (its members can be 
         * accessed) or not
         * @type Boolean
         * @default false
         */
        this._readyToUse = false;
        /**
         * The queue of actions that will be performed when the resource will 
         * next be set ready
         * @type Function[]
         * @default []
         */
        this._onReadyQueue = [];
        /**
         * The length of the onReadyQueue that was triggered by the last setToReady() call - additional functions added to the queue after
         * the call will not be executed until another setToReady by checking this length
         * @type Number
         */
        this._triggeredOnreadyQueueLength = 0;
    }
    /**
     * Adds the given function to the queue to be executed ones the resource 
     * gets ready.
     * @param {Function} onReadyFunction
     */
    AsyncResource.prototype.addOnReadyFunction = function (onReadyFunction) {
        this._onReadyQueue.push(onReadyFunction);
    };
    /**
     * Returns if the resource is ready to be used at the moment. (i.e. 
     * properties are initialized)
     * @returns {Boolean}
     */
    AsyncResource.prototype.isReadyToUse = function () {
        return this._readyToUse;
    };
    /**
     * Sets the ready state to false, but does not erase the queued actions.
     */
    AsyncResource.prototype.resetReadyState = function () {
        this._readyToUse = false;
    };
    /**
     * Executes the onReady queue then erases it.
     */
    AsyncResource.prototype.executeOnReadyQueue = function () {
        var i;
        // if a function in the onreadyQueue adds new functions to the onReadyQueue, those should not be executed - if the resource was 
        // ready for them, they would not be added to the queue, but executed straight away
        this._triggeredOnreadyQueueLength = this._onReadyQueue.length;
        for (i = 0; i < this._triggeredOnreadyQueueLength; i++) {
            if (this._onReadyQueue[i]) {
                this._onReadyQueue[i].call(this);
            }
            this._onReadyQueue[i] = null;
        }
        this._onReadyQueue = (this._onReadyQueue.length > this._triggeredOnreadyQueueLength) ? this._onReadyQueue.slice(this._triggeredOnreadyQueueLength) : [];
    };
    /**
     * Sets the ready state of the resource and executes the queued actions that
     * were requested in advance. Also erases the queue.
     */
    AsyncResource.prototype.setToReady = function () {
        if (this._readyToUse === false) {
            this._readyToUse = true;
            this.executeOnReadyQueue();
        }
    };
    /**
     * Executes the first given function if the resourse is ready, otherwise 
     * queues it to be executed when it gets ready. Optionally takes a second 
     * function to be executed right now in case the resource is not ready yet 
     * to execute the first one (such as notifying the user).
     * @param {Function} functionToExecute The function to execute when the 
     * resource is ready (now or later).
     * @param {Function} [functionToExecuteIfNotReady] The function to be 
     * executed if the resource is not ready yet.
     * @param {Boolean} forceAsync If true, the first function will not be immediately 
     * executed even if it were possible, but it will be placed in the event queue
     * for immediate execution instead
     * @returns {Boolean} True if the first function got executed, false if it 
     * got queued.
     */
    AsyncResource.prototype.executeWhenReady = function (functionToExecute, functionToExecuteIfNotReady, forceAsync) {
        if (this._readyToUse) {
            if (forceAsync) {
                setTimeout(functionToExecute.bind(this), 0);
                return false;
            }
            functionToExecute.call(this);
            return true;
        }
        this.addOnReadyFunction(functionToExecute);
        if (functionToExecuteIfNotReady !== undefined) {
            functionToExecuteIfNotReady.call(this);
        }
        return false;
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        AsyncResource: AsyncResource
    };
});
/**
 * Copyright 2014-2015, 2017, 2020 Krisztián Nagy
 * @file Provides a class that can hold and manage asynchronously loaded resources.
 * Usage:
 * - subclass GenericResource to implement a kind of resource you want to manage e.g. TextFileResource (see the class description for details)
 * - create a JSON file containing a named list of objects that contain the init info for the TextFileResources you want to manage
 *   e.g. "textFiles": [ { "name": "first", "path": "textiles/first.txt" } ] in resources.json
 * - create a ResourceManager instance
 * - call requestConfigLoad("resources.json", [{"textFiles", TextFileResource}]) on the instance
 * - alternatively, you can use addResource("textFiles", new TextFileResource(...)) to add the resources manually
 * - after the config has been loaded, use getResource("textFiles", "first") to request one of the resources, then
 * - use ResourceManager.executeWhenReady() to run code after the resources have been loaded from file
 * - use requestResourceLoad() to initiate the loading of resources from files
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, Image */

/**
 * @param utils Used for comparing objects
 * @param application Required for error displaying and file loading functionality
 * @param asyncResource Uses AsyncResource as superclass for GenericResource, ResourceHolder and ResourceManager classes
 */
define('modules/resource-manager',[
    "utils/utils",
    "modules/application",
    "modules/async-resource"
], function (utils, application, asyncResource) {
    "use strict";
    // ------------------------------------------------------------------------------
    // constants
    var
            /**
             * Classes that are initialized without a name will be initialized with this name
             * @type String
             */
            UNNAMED_RESOURCE_NAME = "unnamed";
    // ##############################################################################
    /**
     * @class
     * To subclass, implement requiresReload(), _requestFiles() and _loadData() methods.
     * @extends AsyncResource
     * @param {String} name
     */
    function GenericResource(name) {
        asyncResource.AsyncResource.call(this);
        /**
         * @type String
         */
        this._name = name;
        /**
         * Whether this resource has been requested for download (and did not finish loading yet)
         * @type Boolean
         */
        this._requested = false;
        /**
         * The resource is currently being loaded (the request has been sent, but the answer has not been recieved)
         * @type Boolean
         */
        this._loading = false;
        /**
         * Has true value if there was an error during the last loading of data for this resource
         * @type Boolean
         */
        this._hasError = false;
        /**
         * Stores the parameters with which the resource has been requested last time
         * @type Object
         */
        this._requestParams = {};
    }
    GenericResource.prototype = new asyncResource.AsyncResource();
    GenericResource.prototype.constructor = GenericResource;
    /**
     * @returns {String}
     */
    GenericResource.prototype.getName = function () {
        return this._name;
    };
    /**
     * @param {Object} requestParams
     * @returns {Boolean}
     */
    GenericResource.prototype.isRequested = function (requestParams) {
        if (!this._requested) {
            return false;
        }
        if (requestParams) {
            if (!this._requestParams) {
                return false;
            }
            if (!utils.equivalent(this._requestParams, requestParams)) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param {Object} params
     */
    GenericResource.prototype.request = function (params) {
        if ((this._loading) && (!utils.equivalent(this._requestParams || null, params || null))) {
            application.showError("Attempting to request resource '" + this._name + "' with different parameters while it is being loaded!");
        } else {
            this._requested = true;
            this._requestParams = params;
        }
    };
    /**
     * 
     */
    GenericResource.prototype.requiresReload = function () {
        application.showError("Resource class does not implement requiresReload!");
    };
    /** 
     * @returns {Boolean}
     */
    GenericResource.prototype.isLoaded = function () {
        return this.isReadyToUse();
    };
    /**
     * Returns true if there was an error during the last loading of this resource (if the loading process finished, the resource is still
     * marked ready to use, but check this flag to whether using it would wield the expected results)
     * @returns {Boolean}
     */
    GenericResource.prototype.hasError = function () {
        return this._hasError;
    };
    /**
     * 
     */
    GenericResource.prototype._requestFiles = function () {
        application.showError("Attempting to request files for a resource type that has no file request function implemented!");
    };
    /**
     * @returns {Boolean} Whether the loading was successful (no errors)
     */
    GenericResource.prototype._loadData = function () {
        application.showError("Attempting to load data for a resource type that has no data loading function implemented!");
        return false;
    };
    /**
     * 
     */
    GenericResource.prototype.onFinalLoad = function () {
        this._requested = false;
        this._loading = false;
        this.setToReady();
    };
    /**
     * @param {Boolean} final
     * @param {Object} params
     */
    GenericResource.prototype._onFilesLoad = function (final, params) {
        this._hasError = this._hasError || !this._loadData(params);
        if (final === true) {
            this.onFinalLoad();
        }
    };
    /**
     * 
     */
    GenericResource.prototype.requestLoadFromFile = function () {
        if ((this.isReadyToUse() === false) && (this._requested === true) && (this._loading === false)) {
            this._loading = true;
            this._requestFiles(this._requestParams);
        }
    };
    /**
     * 
     * @returns {Object}
     */
    GenericResource.prototype.getData = function () {
        return null;
    };
    // ##############################################################################
    /**
     * @class A generic asynchronous resource that can be initialized using a JSON object passed to the constructor
     * @extends GenericResource
     * @param {Object} [dataJSON] The object storing the data (/configuration) based on which the resource should be initialized (optional
     * so that the class can be subclassed)
     * @param {String} [sourceFolder] The ID of the folder from where to load the source JSON file for deferred initialization
     * @param {Boolean} [nameIsOptional=false] If true, no error message will be given in case there is no name defined in the data JSON
     */
    function JSONResource(dataJSON, sourceFolder, nameIsOptional) {
        GenericResource.call(this, dataJSON ?
                (dataJSON.name || (nameIsOptional && ((dataJSON && dataJSON.source) || UNNAMED_RESOURCE_NAME)) || application.showError("Cannot initialize instance of " + this.constructor.name + ": a name is required!")) :
                null);
        /**
         * @type String
         */
        this._source = dataJSON ? (dataJSON.source || null) : null;
        /**
         * @type String
         */
        this._sourceFolder = sourceFolder;
        /**
         * Stores a reference to the object from which this class was initialized.
         * @type String
         */
        this._dataJSON = dataJSON;
        if (dataJSON) {
            if (!this._source) {
                this._loadData(dataJSON);
                this.setToReady();
            }
        }
    }
    JSONResource.prototype = new GenericResource();
    JSONResource.prototype.constructor = JSONResource;
    /**
     * @override
     * @returns {Boolean}
     */
    JSONResource.prototype.requiresReload = function () {
        if (this.isRequested()) {
            return false;
        }
        return !this.isLoaded();
    };
    /**
     * @override
     */
    JSONResource.prototype._requestFiles = function () {
        application.requestTextFile(this._sourceFolder, this._source, function (responseText) {
            this._onFilesLoad(true, JSON.parse(responseText));
        }.bind(this));
    };
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    JSONResource.prototype._loadData = function (dataJSON) {
        this._source = this._source || "";
        this._dataJSON = dataJSON;
        return true;
    };
    /**
     * Returns the object this resource was initialized from.
     * @returns {Object}
     */
    JSONResource.prototype.getData = function () {
        return this._dataJSON;
    };
    /**
     * Reinitializes the resource based on the stored data object. (can be used to modify a resource by modifying its data object and then calling
     * this - only to be used by the editor, not by the game!
     */
    JSONResource.prototype.reloadData = function () {
        this._loadData(this._dataJSON);
    };
    // ############################################################################################x
    /**
     * @class
     * @augments AsyncResource
     * @param {String} resourceType
     */
    function ResourceHolder(resourceType) {
        asyncResource.AsyncResource.call(this);
        /**
         * @type String
         */
        this._resourceType = resourceType;
        /**
         * To quickly access resources
         * @type Object.<String, GenericResource>
         */
        this._resources = {};
        /**
         * To maintain the order of resource
         * @type String[]
         */
        this._resourceNames = [];
        /**
         * @type Number
         */
        this._numLoadedResources = 0;
        /**
         * @type Number
         */
        this._numRequestedResources = 0;
    }
    ResourceHolder.prototype = new asyncResource.AsyncResource();
    ResourceHolder.prototype.constructor = ResourceHolder;
    /**
     * @returns {Boolean}
     */
    ResourceHolder.prototype.allResourcesAreLoaded = function () {
        return this._numLoadedResources === this._numRequestedResources;
    };
    /**
     * @param {GenericResource} resource
     * @param {Boolean} [unlisted=false] If true, the name of the resource will not be returned when asking for the list of
     * resource names, unless explicitly asked for
     * @returns {GenericResource}
     */
    ResourceHolder.prototype.addResource = function (resource, unlisted) {
        var resourceName = resource.getName();
        if (this._resources[resourceName]) {
            application.showError("Attemtping to add a resource named '" + resourceName + "' that already exists! Data will be overwritten.");
        } else if (!unlisted) {
            this._resourceNames.push(resourceName);
        }
        this._resources[resourceName] = resource;
        return this._resources[resourceName];
    };
    /**
     * @param {String} resourceName
     * @param {Object} params The parameters to be passed for the loading of the resource (and also for the check whether a reload is 
     * required). Every resource type can use their specific parameters for the check or the loading. If the general parameter "doNotLoad"
     * is set to true, the method will not initiate a loading of the resource, only return the resource object.
     * @returns {GenericResource}
     */
    ResourceHolder.prototype.getResource = function (resourceName, params) {
        var resource;
        if (!this._resources[resourceName]) {
            if (!params || params.allowNullResult !== true) {
                application.showError("Requested a resource named '" + resourceName + "' from " + this._resourceType + ", which does not exist.");
            }
            return null;
        }
        resource = this._resources[resourceName];
        if (!params || !params.doNotLoad) {
            if (resource.requiresReload(params)) {
                this._numRequestedResources++;
                this.resetReadyState();
                resource.resetReadyState();
                resource.executeWhenReady(function () {
                    this._numLoadedResources++;
                    if (this.allResourcesAreLoaded()) {
                        this.setToReady();
                    }
                }.bind(this));
            }
        }
        return resource;
    };
    /**
     * 
     */
    ResourceHolder.prototype.requestResourceLoad = function () {
        var resourceName;
        for (resourceName in this._resources) {
            if (this._resources.hasOwnProperty(resourceName)) {
                this._resources[resourceName].requestLoadFromFile();
            }
        }
    };
    /**
     * @param {Boolean} [includeUnlisted=false] 
     * @returns {String[]}
     */
    ResourceHolder.prototype.getResourceNames = function (includeUnlisted) {
        return includeUnlisted ? Object.keys(this._resources) : this._resourceNames;
    };
    /**
     * Changes the key at which a resource is stored (does not alter the configuration of the resource), maintaining its position in the
     * order of resources
     * @param {String} oldName
     * @param {String} newName
     */
    ResourceHolder.prototype.renameResource = function (oldName, newName) {
        if (oldName !== newName) {
            this._resources[newName] = this._resources[oldName];
            delete this._resources[oldName];
            this._resourceNames[this._resourceNames.indexOf(oldName)] = newName;
        }
    };
    /**
     * Changes the order in which the stored resource names are returned by moving one name into a new posiiton, specified by another name
     * (after which it will be inserted)
     * @param {String} nameOfResourceToMove
     * @param {String} targetResourceName
     */
    ResourceHolder.prototype.moveResourceAfter = function (nameOfResourceToMove, targetResourceName) {
        this._resourceNames.splice(this._resourceNames.indexOf(nameOfResourceToMove), 1);
        this._resourceNames.splice(this._resourceNames.indexOf(targetResourceName) + 1, 0, nameOfResourceToMove);
    };
    // ############################################################################################x
    /**
     * @class
     * @extends AsyncResource
     */
    function ResourceManager() {
        asyncResource.AsyncResource.call(this);
        /**
         * @type Object.<String, ResourceHolder>
         */
        this._resourceHolders = {};
        /**
         * @type Number
         */
        this._numLoadedResources = 0;
        /**
         * @type Number
         */
        this._numRequestedResources = 0;
        /**
         * @type Object.<String, Function[]>
         */
        this._onResourceTypeLoadFunctionQueues = {};
        /**
         * @type Function[]
         */
        this._onAnyResourceTypeLoadFunctionQueue = [];
        /**
         * @type Function[]
         */
        this._onResourceLoadFunctionQueue = [];
        /**
         * The constructors associated with the various resource types (during the latest resource config load)
         * @type Object.<String, Function>
         */
        this._resourceClasses = null;
        /**
         * The ID of the folder to use when loading the configuration of stored resources from file. This is passed to the constructor of
         * the resources as a second parameter.
         * @type String
         */
        this._sourceFolder = null;
    }
    // we set the Resource class as parent to add an execution queue to the resource
    // manage for when all resources have been loaded
    ResourceManager.prototype = new asyncResource.AsyncResource();
    ResourceManager.prototype.constructor = ResourceManager;
    /**
     * @override
     */
    ResourceManager.prototype.setToReady = function () {
        this._onResourceTypeLoadFunctionQueues = {};
        this._onAnyResourceTypeLoadFunctionQueue = [];
        this._onResourceLoadFunctionQueue = [];
        this._numRequestedResources = 0;
        this._numLoadedResources = 0;
        asyncResource.AsyncResource.prototype.setToReady.call(this);
    };
    /**
     * @param {String} resourceType
     * @param {Function} callback
     */
    ResourceManager.prototype.executeOnResourceTypeLoad = function (resourceType, callback) {
        this._onResourceTypeLoadFunctionQueues[resourceType] = this._onResourceTypeLoadFunctionQueues[resourceType] || [];
        this._onResourceTypeLoadFunctionQueues[resourceType].push(callback);
    };
    /**
     * @param {Function} callback
     */
    ResourceManager.prototype.executeOnAnyResourceTypeLoad = function (callback) {
        this._onAnyResourceTypeLoadFunctionQueue.push(callback);
    };
    /**
     * @typedef {Function} ResourceManager~resourceLoadCallback
     * @param {String} resourceName
     * @param {Number} numReqestedResources
     * @param {Number} numLoadedResources
     * @param {String} resourceType
     */
    /**
     * @param {ResourceManager~resourceLoadCallback} callback
     */
    ResourceManager.prototype.executeOnResourceLoad = function (callback) {
        this._onResourceLoadFunctionQueue.push(callback);
    };
    /**
     * @param {String} resourceType
     * @param {GenericResource} resource
     * @param {Boolean} [unlisted=false] If true, the name of the resource will not be returned when asking for the list of
     * resource names, unless explicitly asked for
     * @returns {GenericResource}
     */
    ResourceManager.prototype.addResource = function (resourceType, resource, unlisted) {
        this._resourceHolders[resourceType] = this._resourceHolders[resourceType] || new ResourceHolder(resourceType);
        return this._resourceHolders[resourceType].addResource(resource, unlisted);
    };
    /**
     * Similar to addResource, but creates the resource itself using the passed JSON to initialize it
     * @param {String} resourceType
     * @param {Object} dataJSON
     */
    ResourceManager.prototype.createResource = function (resourceType, dataJSON) {
        if (!this._resourceClasses) {
            application.showError("Cannot create resource of type '" + resourceType + "': no resource constructors were assigned!");
            return;
        }
        if (!this._resourceClasses[resourceType]) {
            application.showError("Cannot create resource of type '" + resourceType + "': no resource constructor was assigned for this resource type!");
            return;
        }
        this.addResource(resourceType, new this._resourceClasses[resourceType](dataJSON, this._sourceFolder));
    };
    /**
     * @param {String} resourceType
     * @param {String} resourceName
     */
    ResourceManager.prototype._onResourceLoad = function (resourceType, resourceName) {
        var i, queue;
        queue = this._onResourceLoadFunctionQueue;
        for (i = 0; i < queue.length; i++) {
            queue[i](resourceName, resourceType, this._numRequestedResources, this._numLoadedResources);
        }
        if (this.allResourcesOfTypeAreLoaded(resourceType)) {
            queue = this._onResourceTypeLoadFunctionQueues[resourceType] || [];
            for (i = 0; i < queue.length; i++) {
                queue[i]();
            }
        }
        if (this.allResourcesAreLoaded()) {
            this.setToReady();
        }
    };
    /**
     * @param {String} resourceType
     * @param {String} resourceName
     * @param {Object} params The parameters to be passed for the loading of the resource (and also for the check whether a reload is 
     * required). Every resource type can use their specific parameters for the check or the loading. If the general parameter "doNotLoad"
     * is set to true, the method will not initiate a loading of the resource, only return the resource object.
     * @returns {GenericResource}
     */
    ResourceManager.prototype.getResource = function (resourceType, resourceName, params) {
        var resource;
        resource = this._resourceHolders[resourceType] ? this._resourceHolders[resourceType].getResource(resourceName, params) : null;
        if (!resource) {
            if (!params || (params.allowNullResult !== true)) {
                application.showError("Requested a resource named '" + resourceName + "' of type '" + resourceType + "', which does not exist.");
            }
            return null;
        }
        if (!params || !params.doNotLoad) {
            if (resource.requiresReload(params)) {
                this._numRequestedResources++;
                this.resetReadyState();
                resource.request(params);
                resource.executeWhenReady(function () {
                    this._numLoadedResources++;
                    this._onResourceLoad(resourceType, resourceName);
                }.bind(this));
            }
        }
        return resource;
    };
    /**
     * @param {Boolean} [includeUnlisted=false] 
     */
    ResourceManager.prototype.requestAllResources = function (includeUnlisted) {
        var resourceType, resourceNames, i;
        for (resourceType in this._resourceHolders) {
            if (this._resourceHolders.hasOwnProperty(resourceType)) {
                resourceNames = this._resourceHolders[resourceType].getResourceNames(includeUnlisted);
                for (i = 0; i < resourceNames.length; i++) {
                    this.getResource(resourceType, resourceNames[i]);
                }
            }
        }
    };

    /**
     * @param {String} resourceType
     * @returns {Boolean}
     */
    ResourceManager.prototype.allResourcesOfTypeAreLoaded = function (resourceType) {
        return (this._resourceHolders[resourceType].isReadyToUse());
    };
    /**
     * Tells if all added resources have been already loaded.
     * @returns {Boolean}
     */
    ResourceManager.prototype.allResourcesAreLoaded = function () {
        return this._numLoadedResources === this._numRequestedResources;
    };
    /**
     * @param {String} filename
     * @param {String} fileType
     * @param {Object.<String, Function>} resourceTypes
     * @param {Function} callback
     */
    ResourceManager.prototype.requestConfigLoad = function (filename, fileType, resourceTypes, callback) {
        application.requestTextFile(fileType, filename, function (responseText) {
            this._loadConfigFromJSON(JSON.parse(responseText), resourceTypes);
            if (callback) {
                callback();
            }
        }.bind(this));
    };
    /**
     * @param {Object} configJSON
     * @param {Object.<String, Function>} resourceClasses
     */
    ResourceManager.prototype._loadConfigFromJSON = function (configJSON, resourceClasses) {
        var resourceType, resourceArray, i;
        this._resourceClasses = resourceClasses;
        this._sourceFolder = configJSON.config ? configJSON.config.sourceFolder : null;
        for (resourceType in resourceClasses) {
            if (resourceClasses.hasOwnProperty(resourceType)) {
                resourceArray = configJSON[resourceType];
                for (i = 0; i < resourceArray.length; i++) {
                    this.addResource(resourceType, new resourceClasses[resourceType](resourceArray[i], this._sourceFolder));
                }
            }
        }
    };
    /**
     * Initiates all requests needed to load all the stored resources from their 
     * associated files. If there are no resources needed to load, just executes
     * the action queue set for when all resources get loaded.
     */
    ResourceManager.prototype.requestResourceLoad = function () {
        var resourceType;
        application.log_DEBUG("Requesting loading of resources contained in the resource manager...", 2);
        if (this.allResourcesAreLoaded() === true) {
            application.log_DEBUG("There are no resources to load, executing set up callback queue right away...", 2);
            this.executeOnReadyQueue();
        } else {
            for (resourceType in this._resourceHolders) {
                if (this._resourceHolders.hasOwnProperty(resourceType)) {
                    application.log_DEBUG("Requesting the loading of " + resourceType + " from files...", 2);
                    this._resourceHolders[resourceType].requestResourceLoad();
                }
            }
        }
    };
    /**
     * @returns {String[]}
     */
    ResourceManager.prototype.getResourceTypes = function () {
        return Object.keys(this._resourceHolders);
    };
    /**
     * 
     * @param {String} resourceType
     * @returns {String[]}
     */
    ResourceManager.prototype.getResourceNames = function (resourceType) {
        if (!this._resourceHolders[resourceType]) {
            application.showError("Asked for the names of resources of type: '" + resourceType + "', but no such resource type exists!");
            return null;
        }
        return this._resourceHolders[resourceType].getResourceNames();
    };
    /**
     * Changes the key at which a resource is stored (does not alter the configuration of the resource), maintaining its position in the
     * order of resources
     * @param {String} resourceType The type of resource to be renamed
     * @param {String} oldName
     * @param {String} newName
     */
    ResourceManager.prototype.renameResource = function (resourceType, oldName, newName) {
        this._resourceHolders[resourceType].renameResource(oldName, newName);
    };
    /**
     * Changes the order in which the stored resource names are returned by moving one name into a new posiiton, specified by another name
     * (after which it will be inserted)
     * @param {String} resourceType The type of the resource to move
     * @param {String} nameOfResourceToMove
     * @param {String} targetResourceName
     */
    ResourceManager.prototype.moveResourceAfter = function (resourceType, nameOfResourceToMove, targetResourceName) {
        this._resourceHolders[resourceType].moveResourceAfter(nameOfResourceToMove, targetResourceName);
    };
    /**
     * @callback ResourceManager~executeCallback
     * @param {GenericResource} resource The resource to execute the callback on
     * @param {String} resourceType The ID of the type this resource belongs to within the resource manager
     */
    /**
     * Executes the given callback function for all the stored resources of the given type.
     * @param {String} resourceType 
     * @param {ResourceManager~executeCallback} callback
     * @param {Boolean} [includeUnlisted=false] 
     * @param {Boolean} [doNotRequest=false] 
     */
    ResourceManager.prototype.executeForAllResourcesOfType = function (resourceType, callback, includeUnlisted, doNotRequest) {
        var i, resourceNames;
        resourceNames = this._resourceHolders[resourceType].getResourceNames(includeUnlisted);
        for (i = 0; i < resourceNames.length; i++) {
            callback(this._resourceHolders[resourceType].getResource(resourceNames[i], {doNotLoad: doNotRequest}), resourceType);
        }
    };
    /**
     * Executes the given callback function for all the stored resources (of all types).
     * @param {ResourceManager~executeCallback} callback
     * @param {Boolean} [includeUnlisted=false] 
     */
    ResourceManager.prototype.executeForAllResources = function (callback, includeUnlisted) {
        var resourceTypes = Object.keys(this._resourceHolders), i;
        for (i = 0; i < resourceTypes.length; i++) {
            this.executeForAllResourcesOfType(resourceTypes[i], callback, includeUnlisted);
        }
    };
    return {
        GenericResource: GenericResource,
        JSONResource: JSONResource,
        ResourceManager: ResourceManager
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides an interface to interact with WebGL in a managed way. Offers
 * rather low level functionality, but using it is still much more transparent 
 * than accessing WebGL directly.
 * Usage:
 * - create a managed context and associate it with an HTML5 canvas element
 * - create the managed resources that you want to use (textures, shaders, models)
 * - set the data for the managed resources using their provided methods
 * - add the resources to the context
 * - set up the context
 * - set the shader and its uniforms using the managed resources
 * - use the render function of the model to render it to the context
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, Image, Float32Array, parseInt, document */

/**
 * @param utils Used for enum functionality
 * @param types Used for enum functionality
 * @param application This module uses the logging and error displaying functions of the generic application module
 * @param asyncResource This module uses the AsyncResource class for easier handling of managed context resource preparation
 */
define('modules/managed-gl',[
    "utils/utils",
    "utils/types",
    "modules/application",
    "modules/async-resource"
], function (utils, types, application, asyncResource) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // enums
            /**
             * An enumeration storing the possible values for texture filtering
             * @enum {String}
             */
            TextureFiltering = {
                BILINEAR: "bilinear",
                TRILINEAR: "trilinear",
                ANISOTROPIC: "anisotropic"
            },
            /**
             * Enumeration defining the available (supported) variables types in GLSL shaders.
             * @enum {String}
             * @type String
             */
            ShaderVariableType = {
                NONE: "none",
                FLOAT: "float",
                VEC2: "vec2",
                VEC3: "vec3",
                VEC4: "vec4",
                MAT2: "mat2",
                MAT3: "mat3",
                MAT4: "mat4",
                SAMPLER2D: "sampler2D",
                SAMPLER_CUBE: "samplerCube",
                INT: "int",
                BOOL: "bool",
                STRUCT: "struct"
            },
            /**
             * The possible blend modes based on which the blend function is set when a shader is applied.
             * @enum {String}
             * @type String
             */
            ShaderBlendMode = {
                NONE: "none",
                MIX: "mix",
                ADD: "add"
            },
            // ----------------------------------------------------------------------
            // Constants
            UNIFORM_NAME_PREFIX = "u_",
            UNIFORM_NAME_SUFFIX = "",
            TEXTURE_UNIFORM_NAME_PREFIX = "",
            TEXTURE_UNIFORM_NAME_SUFFIX = "Texture",
            CUBEMAP_UNIFORM_NAME_PREFIX = "",
            CUBEMAP_UNIFORM_NAME_SUFFIX = "Cubemap",
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * @type ManagedGLContext
             */
            _genericContext = null;
    Object.freeze(TextureFiltering);
    Object.freeze(ShaderVariableType);
    /**
     * Returns the size of one variable if the passed type if it is converted to a float vector. (how many floats does it occupy)
     * @param {String} shaderVariableType (enum ShaderVariableType)
     * @returns {Number}
     */
    function getFloatVectorSize(shaderVariableType) {
        switch (shaderVariableType) {
            case ShaderVariableType.NONE:
                return 0;
            case ShaderVariableType.FLOAT:
                return 1;
            case ShaderVariableType.VEC2:
                return 2;
            case ShaderVariableType.VEC3:
                return 3;
            case ShaderVariableType.VEC4:
                return 4;
            case ShaderVariableType.MAT2:
                return 4;
            case ShaderVariableType.MAT3:
                return 9;
            case ShaderVariableType.MAT4:
                return 16;
            case ShaderVariableType.SAMPLER2D:
                return 1;
            case ShaderVariableType.SAMPLER_CUBE:
                return 1;
            case ShaderVariableType.INT:
                return 1;
            case ShaderVariableType.BOOL:
                return 1;
            default:
                application.showError("Cannot determine vector size of GLSL type '" + shaderVariableType + "'!");
                return 0;
        }
    }
    /**
     * Returns how many 4 component vectors does a shader variable of the passed type take in space. (for counting shader requirements)
     * @param {String} shaderVariableType (enum ShaderVariableType)
     * @returns {Number}
     */
    function getVectorCount(shaderVariableType) {
        switch (shaderVariableType) {
            case ShaderVariableType.NONE:
                return 0;
            case ShaderVariableType.FLOAT:
                return 1;
            case ShaderVariableType.VEC2:
                return 1;
            case ShaderVariableType.VEC3:
                return 1;
            case ShaderVariableType.VEC4:
                return 1;
            case ShaderVariableType.MAT2:
                return 2;
            case ShaderVariableType.MAT3:
                return 3;
            case ShaderVariableType.MAT4:
                return 4;
            case ShaderVariableType.SAMPLER2D:
                return 1;
            case ShaderVariableType.SAMPLER_CUBE:
                return 1;
            case ShaderVariableType.INT:
                return 1;
            case ShaderVariableType.BOOL:
                return 1;
            default:
                application.showError("Cannot determine vector count of GLSL type '" + shaderVariableType + "'!");
                return 0;
        }
    }
    /**
     * Returns whether a shader variable of the passed type is a texture sampler.
     * @param {String} shaderVariableType (enum ShaderVariableType)
     * @returns {Boolean}
     */
    function isSamplerType(shaderVariableType) {
        return (shaderVariableType === ShaderVariableType.SAMPLER2D) ||
                (shaderVariableType === ShaderVariableType.SAMPLER_CUBE);
    }
    /**
     * Returns a numberic value that can be assigned as an int to a boolean GLSL variable.
     * @param {Boolean} value
     * @returns {Number}
     */
    function intValueOfBool(value) {
        return value ? 1 : 0;
    }
    // ############################################################################################
    /**
     * @class Represents a managed WebGL texture.
     * @param {String} name
     * @param {Image} image The Image object that contains the data of the
     * texture and can be passed to WebGL. It has to already contain the data
     * when you add this texture to any context.
     * @param {Boolean} [useMipmap=true] Whether mipmapping should be used with
     * this texture.
     * @returns {ManagedTexture}
     */
    function ManagedTexture(name, image, useMipmap) {
        /**
         * @type String
         */
        this._name = name;
        /**
         * Contains the data to be passed to WebGL.
         * @type Image
         */
        this._image = image;
        /**
         * Whether mipmapping should be used with this texture.
         * @type Boolean
         */
        this._mipmap = (useMipmap !== undefined) ? useMipmap : true;
        /**
         * The associative array of WebGL texture IDs belonging to managed 
         * contexts which this texture has been associated with. The keys are 
         * the names of the managed contexts, and values are the WebGL IDs 
         * (handles)
         * @type Object.<String, WebGLTexture>
         */
        this._ids = {};
        /**
         * The associative array of bound WebGL texture locations (texture unit indices)
         * belonging to managed contexts which this texture has been associated with. 
         * The keys are the names of the managed contexts, and values are the location
         * indices.
         * @type Object.<String, Number>
         */
        this._locations = {};
    }
    /**
     * @returns {String}
     */
    ManagedTexture.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the texture unit index where this texture has been last bound to within the context with the passed name.
     * @param {String} contextName
     * @returns {Number}
     */
    ManagedTexture.prototype.getLastTextureBindLocation = function (contextName) {
        return this._locations[contextName];
    };
    /**
     * Clears the cached value storing the last bind location for this texture, associated with the passed context name.
     * @param {String} contextName
     */
    ManagedTexture.prototype.forgetLastTextureBindLocation = function (contextName) {
        delete this._locations[contextName];
    };
    /**
     * Sets the minification filter to be used when sampling this texture. Requires the texture to be bound!
     * @param {WebGLRenderingContext} gl
     * @param {String} filtering (enum TextureFiltering)
     * @param {EXTTextureFilterAnisotropic} anisotropicFilterExt
     */
    ManagedTexture.prototype.setMinFiltering = function (gl, filtering, anisotropicFilterExt) {
        if (this._mipmap === false) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        } else {
            switch (filtering) {
                case TextureFiltering.BILINEAR:
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                    if (anisotropicFilterExt) {
                        gl.texParameterf(gl.TEXTURE_2D, anisotropicFilterExt.TEXTURE_MAX_ANISOTROPY_EXT, 1);
                    }
                    break;
                case TextureFiltering.TRILINEAR:
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    if (anisotropicFilterExt) {
                        gl.texParameterf(gl.TEXTURE_2D, anisotropicFilterExt.TEXTURE_MAX_ANISOTROPY_EXT, 1);
                    }
                    break;
                case TextureFiltering.ANISOTROPIC:
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    gl.texParameterf(gl.TEXTURE_2D, anisotropicFilterExt.TEXTURE_MAX_ANISOTROPY_EXT, 4);
                    break;
            }
            gl.generateMipmap(gl.TEXTURE_2D);
        }
    };
    /**
     * Creates the underlying WebGL texture object and associates it with the passed context name.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     */
    ManagedTexture.prototype.createGLTexture = function (contextName, gl) {
        this._ids[contextName] = gl.createTexture();
    };
    /**
     * Binds the underlying WebGL texture object with the passed context and caches the location where it was bound for later use, associated
     * with the passed context name.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {Number} location The texture unit index where to bind the texture.
     */
    ManagedTexture.prototype.bindGLTexture = function (contextName, gl, location) {
        gl.activeTexture(gl.TEXTURE0 + location);
        gl.bindTexture(gl.TEXTURE_2D, this._ids[contextName]);
        this._locations[contextName] = location;
    };
    /**
     * Loads the image data into the underlying WebGL texture object and sets up wrapping and filtering. Requires the texture to be bound!
     * @param {WebGLRenderingContext} gl
     * @param {String} filtering (enum TextureFiltering)
     * @param {EXTTextureFilterAnisotropic} anisotropicFilterExt
     */
    ManagedTexture.prototype.setupGLTexture = function (gl, filtering, anisotropicFilterExt) {
        // Upload the image into the texture.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._image);
        // Set the parameters so we can render any size image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        this.setMinFiltering(gl, filtering, anisotropicFilterExt);
    };
    /**
     * Deletes the underlying WebGL texture object associated with the passed context name.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     */
    ManagedTexture.prototype.deleteGLTexture = function (contextName, gl) {
        if (this._ids[contextName]) {
            gl.deleteTexture(this._ids[contextName]);
            delete this._ids[contextName];
            delete this._locations[contextName];
        }
    };
    // ############################################################################################
    /**
     * Creates a new Cubemap object.
     * @class Represents a cube mapped texture resource.
     * @param {String} name The name of cubemap resource
     * @param {String[6]} images An array containing the URLs of the 6 faces of
     * the cubemapped texture. The order of the pictures has to be X,Y,Z and within
     * that, always positive first.
     */
    function ManagedCubemap(name, images) {
        // properties for file resource management
        /**
         * The name by wich this resource will be referred to. (has to be unique for
         * each instance)
         * @type String
         */
        this._name = name;
        /**
         * 6 Image objects to manage the loading of the 6 textures of the faces from
         * their source files.
         * @type Image[6]
         */
        this._images = images;
        // properties for WebGL resource management
        /**
         * The associative array of WebGL cubemap IDs belonging to managed contexts 
         * which this cubemap has been associated with. The keys are the names of the managed
         * contexts, and values are the WebGL IDs (handles)
         * @type Object
         */
        this._ids = {};
        /**
         * The associative array of bound WebGL texture locations (texture unit indices)
         * belonging to managed contexts which this cubemap has been associated with. 
         * The keys are the names of the managed contexts, and values are the location
         * indices.
         * @type Object
         */
        this._locations = {};
    }
    /**
     * Getter for the property _name.
     * @returns {String}
     */
    ManagedCubemap.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the texture unit index where this cubemap has been last bound to within the context with the passed name.
     * @param {String} contextName
     * @returns {Number}
     */
    ManagedCubemap.prototype.getLastTextureBindLocation = function (contextName) {
        return this._locations[contextName];
    };
    /**
     * Clears the cached value storing the last bind location for this cubemap, associated with the passed context name.
     * @param {String} contextName
     */
    ManagedCubemap.prototype.forgetLastTextureBindLocation = function (contextName) {
        delete this._locations[contextName];
    };
    /**
     * Creates the underlying WebGL texture object and associates it with the passed context name.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     */
    ManagedCubemap.prototype.createGLTexture = function (contextName, gl) {
        this._ids[contextName] = gl.createTexture();
    };
    /**
     * Binds the underlying WebGL texture object with the passed context and caches the location where it was bound for later use, associated
     * with the passed context name.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {Number} location The texture unit index where to bind the texture.
     */
    ManagedCubemap.prototype.bindGLTexture = function (contextName, gl, location) {
        gl.activeTexture(gl.TEXTURE0 + location);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._ids[contextName]);
        this._locations[contextName] = location;
    };
    /**
     * Loads the image data into the underlying WebGL texture object and sets up wrapping and filtering. Requires the texture to be bound!
     * @param {WebGLRenderingContext} gl
     */
    ManagedCubemap.prototype.setupGLTexture = function (gl) {
        var type, i;
        // Set the parameters so we can render any size image.
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        type = [
            gl.TEXTURE_CUBE_MAP_POSITIVE_X,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
        ];
        // Upload the images into the texture.
        for (i = 0; i < 6; i++) {
            gl.texImage2D(type[i], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._images[i]);
        }
    };
    /**
     * Deletes the underlying WebGL texture object associated with the passed context name.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     */
    ManagedCubemap.prototype.deleteGLTexture = function (contextName, gl) {
        if (this._ids[contextName]) {
            gl.deleteTexture(this._ids[contextName]);
            delete this._ids[contextName];
            delete this._locations[contextName];
        }
    };
    // ############################################################################################
    /**
     * Creates a new ShaderAttribute.
     * @class A wrapper class for storing the attributes used in a given shader 
     * program. Used as a simple struct, doesn't have any methods, the only purpose
     * of it is to organize the storage of attribute properties.
     * @param {String} name Name of the shader attribute. (same as defined in the 
     * shader source)
     * @param {Number} size Size of the shader attribute: how many elements does
     * it have (e.g. float -> 1, vec3 -> 3)
     * @param {String} role Role of the shader attribute, based on which the
     * appropriate buffer will be assigned to it to supply the values.
     */
    function ShaderAttribute(name, size, role) {
        this.name = name;
        this.size = size;
        this.role = role;
    }
    // ############################################################################################
    /**
     * Creates a new ShaderUniform.
     * @class A class representing and wrapping a GLSL uniform variable.
     * @param {String} name The name of the uniform variable. Has to be the same
     * as the name specified in the GLSL source.
     * @param {String} type The type of the uniform variable. Only certain variable
     * types are supported. @see ShaderUniform#VariableTypes
     * @param {Number} arraySize If 0 or undefined, the uniform is not an array. If 
     * one or more, then gives the size of the uniform array.
     * @param {Boolean} unpacked If true, the uniform will be taken as an unpacked array when assigning a value to it - 
     * instead of assigning the passed array, each of its elements will be assigned to a uniform with the name suffixed
     * with the index of the value. Can only be used with arrays of samplers.
     */
    function ShaderUniform(name, type, arraySize, unpacked) {
        var i;
        // properties for file resource management
        /**
         * The name of the shader uniform, same as how declared in the shader source
         * file(s).
         * @type String
         */
        this._name = name;
        /**
         * The type of variable this uniform is, from an enumeration of supported
         * types. This is used to determine the appropriate assignment function.
         */
        this._type = types.getEnumValue(ShaderVariableType, type, {name: "uniform " + this._name + ".type", defaultValue: ShaderVariableType.NONE});
        /**
         * The length of the array in case this uniform is declared as an array in GLSL.
         * @type Number
         */
        this._arraySize = arraySize || 0;
        /**
         * If true, array values are assigned individually to uniforms with names suffixed by the indices of
         * the elements. Only valid for arrays of samplers.
         * @type Boolean
         */
        this._unpacked = unpacked;
        if (this._unpacked && (!isSamplerType(this._type) || (this._arraySize < 1))) {
            application.showError("Uniform '" + this._name + "' cannot be declared as an unpacked array!");
            this._unpacked = false;
        }
        /**
         * If the uniform is of struct type, other ShaderUniform instances represent
         * its members (and setting it will set the members instead). The members
         * are stored in this array.
         * @type ShaderUniform[]
         */
        this._members = (this._type === ShaderVariableType.STRUCT) ? [] : null;
        // properties for WebGL resource management
        /**
         * The associative array containing the locations of this uniform variable
         * belonging to different managed WebGL contexts. The keys are the names of the managed
         * contexts, and values are the locations.
         * @type Object
         */
        this._locations = {};
        /**
         * The associative array of numeric values that were last assigned to this uniform through webGL 
         * (and thus are retained) for each managed context, organized by the names of the contexts.
         * Only used for variable types that have a numeric (not array) value. 
         * Used to avoid assigning the same value multiple times.
         * @type Object
         */
        this._numericValues = {};
        /**
         * Cached string values for structs to use as the prefixes for the members when getting their locations
         * @type String[]
         */
        this._prefixes = null;
        if (this._type === ShaderVariableType.STRUCT) {
            this._prefixes = [];
            if (this._arraySize > 0) {
                for (i = 0; i < this._arraySize; i++) {
                    this._prefixes.push(this._name + "[" + i + "].");
                }
            } else {
                this._prefixes.push(this._name + ".");
            }
        }
        /**
         * The function to execute to set the value of the uniform on the GPU (see _setFloatArrayValue() for paramaters)
         * @type Function
         */
        this._setConstantValue = null;
        switch (this._type) {
            case ShaderVariableType.FLOAT:
                if (this._arraySize > 0) {
                    this._setConstantValue = this._setFloatArrayValue;
                } else {
                    this._setConstantValue = this._setFloatValue;
                }
                break;
            case ShaderVariableType.VEC2:
                this._setConstantValue = this._setVec2Value;
                break;
            case ShaderVariableType.VEC3:
                this._setConstantValue = this._setVec3Value;
                break;
            case ShaderVariableType.VEC4:
                this._setConstantValue = this._setVec4Value;
                break;
            case ShaderVariableType.MAT2:
                this._setConstantValue = this._setMat2Value;
                break;
            case ShaderVariableType.MAT3:
                this._setConstantValue = this._setMat3Value;
                break;
            case ShaderVariableType.MAT4:
                this._setConstantValue = this._setMat4Value;
                break;
            case ShaderVariableType.SAMPLER2D:
            case ShaderVariableType.SAMPLER_CUBE:
            case ShaderVariableType.INT:
                if (this._arraySize > 0) {
                    if (this._unpacked) {
                        this._setConstantValue = this._setUnpackedIntArrayValue;
                    } else {
                        this._setConstantValue = this._setIntArrayValue;
                    }
                } else {
                    this._setConstantValue = this._setIntValue;
                }
                break;
            case ShaderVariableType.BOOL:
                if (this._arraySize > 0) {
                    this._setConstantValue = this._setBoolArrayValue;
                } else {
                    this._setConstantValue = this._setBoolValue;
                }
                break;
            case ShaderVariableType.STRUCT:
                if (this._arraySize > 0) {
                    this._setConstantValue = this._setStructArrayValue;
                } else {
                    this._setConstantValue = this._setStructValue;
                }
                break;
        }
    }
    /**
     * Getter for the property _name.
     * @returns {String}
     */
    ShaderUniform.prototype.getName = function () {
        return this._name;
    };
    /**
     * Adds the given shader uniform to the list of members this uniforms has (for
     * struct type uniforms)
     * @param {ShaderUniform} member
     */
    ShaderUniform.prototype.addMember = function (member) {
        if (this._type === ShaderVariableType.STRUCT) {
            this._members.push(member);
        } else {
            application.showError("Attempting to add a member to uniform " + this._name + ", which is not of struct type!");
        }
    };
    /**
     * Gets the location of the uniform in the supplied rendering context and stores it associated with the passed context name for faster 
     * reference with getLocation later.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl 
     * @param {ManagedShader} shader The shader which this uniform belongs to.
     * @param {String} [uniformName] The exact uniform name to use (including prefixes and suffixes) when querying the
     * position
     */
    ShaderUniform.prototype.saveLocation = function (contextName, gl, shader, uniformName) {
        uniformName = uniformName || this._name;
        if (!this._locations[contextName]) {
            this._locations[contextName] = {};
        }
        this._locations[contextName][uniformName] = gl.getUniformLocation(shader.getIDForContext(contextName), uniformName);
    };
    /**
     * Deletes the cached uniform locations associated with the passed context name. If the uniform has members, their cached locations are 
     * erased, too.
     * @param {String} contextName
     */
    ShaderUniform.prototype.forgetLocations = function (contextName) {
        var i, j;
        delete this._locations[contextName];
        this._numericValues = {};
        if (this._members) {
            for (i = 0; i < this._arraySize; i++) {
                for (j = 0; j < this._members.length; j++) {
                    this._members[j].forgetLocations(contextName);
                }
            }
        }
    };
    /**
     * Gets the location of this uniform valid in the supplied context. For simple uniform types, the location
     * has to be grabbed from the context with a saveLocation prior to the usage of this, otherwise it will 
     * return undefined! For complex types (with locationPrefix), the location is grabbed from GL here, if
     * necessary.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader The shader which this uniform belongs to.
     * @param {String} [locationPrefix] Same as for the setValue() method
     * @param {String} [locationSuffix] For unpacked arrays, the suffix identifying the element (index)
     * @returns {WebGLUniformLocation}
     */
    ShaderUniform.prototype.getLocation = function (contextName, gl, shader, locationPrefix, locationSuffix) {
        var uniformName = (locationPrefix || "") + this._name + (locationSuffix || "");
        if ((locationPrefix || locationSuffix) && (!this._locations[contextName] || (this._locations[contextName][uniformName] === undefined))) {
            this.saveLocation(contextName, gl, shader, uniformName);
        }
        return this._locations[contextName][uniformName];
    };
    /**
     * If this uniform is an array, returns the length of the array, otherwise returns 0.
     * @returns {Number}
     */
    ShaderUniform.prototype.getArraySize = function () {
        return this._arraySize;
    };
    /**
     * Returns the name of this uniform with general uniform prefixes and suffixes removed.
     * @returns {String}
     */
    ShaderUniform.prototype.getRawName = function () {
        var result = this._name, parts;
        if (UNIFORM_NAME_PREFIX.length > 0) {
            parts = result.split(UNIFORM_NAME_PREFIX);
            result = parts[parts.length - 1];
        }
        if (UNIFORM_NAME_SUFFIX.length > 0) {
            result = result.split(UNIFORM_NAME_SUFFIX)[0];
        }
        return result;
    };
    /**
     * If this is a 2D texture sampler, this will return the type of texture it is sampling based on its name (with prefixes and suffixes
     * removed), otherwise will return null. Uniforms without the proper prefixes and suffixes also return null.
     * @returns {String|null}
     */
    ShaderUniform.prototype.getTextureType = function () {
        var result, parts;
        if (this._type !== ShaderVariableType.SAMPLER2D) {
            return null;
        }
        result = this.getRawName();
        if (TEXTURE_UNIFORM_NAME_PREFIX.length > 0) {
            parts = result.split(TEXTURE_UNIFORM_NAME_PREFIX);
            if (parts.length < 2) {
                return null;
            }
            result = parts[parts.length - 1];
        }
        if (TEXTURE_UNIFORM_NAME_SUFFIX.length > 0) {
            parts = result.split(TEXTURE_UNIFORM_NAME_SUFFIX);
            if (parts.length < 2) {
                return null;
            }
            result = parts[0];
        }
        return result;
    };
    /**
     * If this is a cubemap texture sampler, this will return the name of the cubemap it is sampling based on its name (with prefixes and suffixes
     * removed), otherwise will return null. Uniforms without the proper prefixes and suffixes also return null.
     * @returns {String|null}
     */
    ShaderUniform.prototype.getCubemapName = function () {
        var result, parts;
        if (this._type !== ShaderVariableType.SAMPLER_CUBE) {
            return null;
        }
        result = this.getRawName();
        if (CUBEMAP_UNIFORM_NAME_PREFIX.length > 0) {
            parts = result.split(CUBEMAP_UNIFORM_NAME_PREFIX);
            if (parts.length < 2) {
                return null;
            }
            result = parts[parts.length - 1];
        }
        if (CUBEMAP_UNIFORM_NAME_SUFFIX.length > 0) {
            parts = result.split(CUBEMAP_UNIFORM_NAME_SUFFIX);
            if (parts.length < 2) {
                return null;
            }
            result = parts[0];
        }
        return result;
    };
    /**
     * @static
     * Returns a name prefixed and suffixed like general uniform variables.
     * @param {String} rawName
     * @returns {String}
     */
    ShaderUniform.prototype.getUniformName = function (rawName) {
        return UNIFORM_NAME_PREFIX + rawName + UNIFORM_NAME_SUFFIX;
    };
    /**
     * Returns the raw uniform name to be used for a texture sampler corresponding to a texture with the passed type / role (e.g. "diffuse")
     * Applying the general uniform prefixes and suffixes to this name will give the final uniform name for the sampler.
     * (e.g. diffuse -> diffuseTexture -> u_diffuseTexture)
     * @param {String} textureType
     * @returns {String}
     */
    ShaderUniform.prototype.getTextureUniformRawName = function (textureType) {
        return TEXTURE_UNIFORM_NAME_PREFIX + textureType + TEXTURE_UNIFORM_NAME_SUFFIX;
    };
    /**
     * Returns the raw uniform name to be used for a cube sampler corresponding to a cubemap with the passed name / role
     * Applying the general uniform prefixes and suffixes to this name will give the final uniform name for the sampler.
     * @param {String} cubemapName
     * @returns {String}
     */
    ShaderUniform.prototype.getCubemapUniformRawName = function (cubemapName) {
        return CUBEMAP_UNIFORM_NAME_PREFIX + cubemapName + CUBEMAP_UNIFORM_NAME_SUFFIX;
    };
    /**
     * Sets the value of the shader uniform in the specified GL context to the passed value.
     * @param {String} contextName The name of the managed GL context
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader The shader which this uniform belongs to.
     * @param {Number[]} value The new uniform value.
     * The type of this argument should be appropriate to the uniform type.
     * For structs, it needs to be an Object with properties which have names
     * equal to the names of the members of the struct and the values are of 
     * appropriate type for the corresponding member.
     * @param {String} locationPrefix For uniform struct members, this string has to
     * contain the prefix that needs to be appended before their name to get their
     * access string to grab their location from the GL context. E.g. for 
     * "lights[3].color", the name would be "color" and so the prefix should be
     * "lights[3]."
     */
    ShaderUniform.prototype._setFloatArrayValue = function (contextName, gl, shader, value, locationPrefix) {
        gl.uniform1fv(this.getLocation(contextName, gl, shader, locationPrefix), value);
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Number} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setFloatValue = function (contextName, gl, shader, value, locationPrefix) {
        if (locationPrefix || (this._numericValues[contextName] !== value)) {
            gl.uniform1f(this.getLocation(contextName, gl, shader, locationPrefix), value);
            this._numericValues[contextName] = value;
        }
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Number[]} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setVec2Value = function (contextName, gl, shader, value, locationPrefix) {
        gl.uniform2fv(this.getLocation(contextName, gl, shader, locationPrefix), value);
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Number[]} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setVec3Value = function (contextName, gl, shader, value, locationPrefix) {
        gl.uniform3fv(this.getLocation(contextName, gl, shader, locationPrefix), value);
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Number[]} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setVec4Value = function (contextName, gl, shader, value, locationPrefix) {
        gl.uniform4fv(this.getLocation(contextName, gl, shader, locationPrefix), value);
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Float32Array} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setMat2Value = function (contextName, gl, shader, value, locationPrefix) {
        gl.uniformMatrix2fv(this.getLocation(contextName, gl, shader, locationPrefix), false, value);
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Float32Array} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setMat3Value = function (contextName, gl, shader, value, locationPrefix) {
        gl.uniformMatrix3fv(this.getLocation(contextName, gl, shader, locationPrefix), false, value);
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Float32Array} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setMat4Value = function (contextName, gl, shader, value, locationPrefix) {
        gl.uniformMatrix4fv(this.getLocation(contextName, gl, shader, locationPrefix), false, value);
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Number[]} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setUnpackedIntArrayValue = function (contextName, gl, shader, value, locationPrefix) {
        var i;
        for (i = 0; i < value.length; i++) {
            gl.uniform1i(this.getLocation(contextName, gl, shader, locationPrefix, i.toString()), value[i]);
        }
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Number[]} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setIntArrayValue = function (contextName, gl, shader, value, locationPrefix) {
        gl.uniform1iv(this.getLocation(contextName, gl, shader, locationPrefix), value);
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Number} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setIntValue = function (contextName, gl, shader, value, locationPrefix) {
        if (locationPrefix || (this._numericValues[contextName] !== value)) {
            gl.uniform1i(this.getLocation(contextName, gl, shader, locationPrefix), value);
            this._numericValues[contextName] = value;
        }
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Boolean[]} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setBoolArrayValue = function (contextName, gl, shader, value, locationPrefix) {
        gl.uniform1iv(this.getLocation(contextName, gl, shader, locationPrefix), value.map(intValueOfBool));
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Boolean} value
     * @param {String} locationPrefix
     */
    ShaderUniform.prototype._setBoolValue = function (contextName, gl, shader, value, locationPrefix) {
        var numericValue = value ? 1 : 0;
        if (locationPrefix || (this._numericValues[contextName] !== numericValue)) {
            gl.uniform1i(this.getLocation(contextName, gl, shader, locationPrefix), numericValue);
            this._numericValues[contextName] = numericValue;
        }
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Object[]} value
     */
    ShaderUniform.prototype._setStructArrayValue = function (contextName, gl, shader, value) {
        var i, j, memberName, memberCount = this._members.length;
        // for structs, launch recursive assignment of members
        // we stop at the first null member of the array
        for (i = 0; i < value.length && (value[i] !== null); i++) {
            for (j = 0; j < memberCount; j++) {
                if (value[i][this._members[j]._name] !== undefined) {
                    memberName = this._members[j]._name;
                    this._members[j]._setConstantValue(contextName, gl, shader, value[i][memberName], this._prefixes[i]);
                }
            }
        }
    };
    /**
     * See _setFloatArrayValue()
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader
     * @param {Object} value
     */
    ShaderUniform.prototype._setStructValue = function (contextName, gl, shader, value) {
        var i, memberName, memberCount = this._members.length;
        for (i = 0; i < memberCount; i++) {
            if (value[this._members[i]._name] !== undefined) {
                memberName = this._members[i]._name;
                this._members[i]._setConstantValue(contextName, gl, shader, value[memberName], this._prefixes[0]);
            }
        }
    };
    /**
     * Sets the value of the shader uniform in the specified GL context to the return value
     * of the passed value function. Passing a function makes sure whatever 
     * calculations need to take place, they are (can be) calculated right before 
     * the uniform assignment if necessary.
     * @param {String} contextName The managed GL context
     * @param {WebGLRenderingContext} gl
     * @param {ManagedShader} shader The shader which this uniform belongs to.
     * @param {Function} valueFunction The function to calculate the uniform value.
     * The return type of this function should be appropriate to the uniform type.
     * For structs, it needs to return an Object with properties which have names
     * equal to the names of the members of the struct and the values are of 
     * appropriate type for the corresponding member.
     * @param {String} locationPrefix For uniform struct members, this string has to
     * contain the prefix that needs to be appended before their name to get their
     * access string to grab their location from the GL context. E.g. for 
     * "lights[3].color", the name would be "color" and so the prefix should be
     * "lights[3]."
     */
    ShaderUniform.prototype.setValue = function (contextName, gl, shader, valueFunction, locationPrefix) {
        this._setConstantValue(contextName, gl, shader, valueFunction(contextName), locationPrefix);
    };
    /**
     * Returns how many 4 component vectors does this uniform variable take (for counting shader requirements).
     * @returns {Number}
     */
    ShaderUniform.prototype.getVectorCount = function () {
        var result, i;
        if (this._type === ShaderVariableType.STRUCT) {
            result = 0;
            for (i = 0; i < this._members.length; i++) {
                result += this._members[i].getVectorCount();
            }
            return result * (this._arraySize || 1);
        }
        return getVectorCount(this._type) * (this._arraySize || 1);
    };
    /**
     * Returns whether the uniform has a texture sampler type (or an array of such)
     * @returns {Boolean}
     */
    ShaderUniform.prototype.isSamplerType = function () {
        return isSamplerType(this._type);
    };
    // ############################################################################################
    /**
     * @class A wrapper class that represents a WebGL vertex buffer object.
     * @param {String} name The name by which this buffer can be referred to.
     * @param {String} role The role of the data in this buffer (e.g. position, 
     * normal, color)
     * @param {Number} vectorSize The number of components in one element of te VBO.
     * @param {Number} numVectors Number of vectors in this buffer.
     */
    function VertexBuffer(name, role, vectorSize, numVectors) {
        /**
         * The name by which this buffer can be referred to. The buffer will be
         * bound to vertex attributes having the same name.
         * @type String
         */
        this._name = name;
        /**
         * The usage role of the data stored in this buffer. This will determine
         * what data this buffer gets filled when grabbing the data from the 3D
         * model resources
         * @type String.
         */
        this._role = role;
        /**
         * The number of (Float32) components in one item of this buffer. E.g. for
         * buffer storing vec2 elements, set to 2.
         * @type Number
         */
        this._vectorSize = vectorSize;
        /**
         * The actual data stored in this buffer.
         * @type Float32Array
         */
        this._data = new Float32Array(numVectors * this._vectorSize);
        /**
         * The WebGL handles for this vertex buffer object.
         * @type Object.<String, WebGLBuffer>
         */
        this._ids = {};
        /**
         * The associative array of the locations (vertex attribute indices) of 
         * this vertex buffer associated with different shaders. The keys are the
         * names of the shaders, and the values are the indices of the vertex
         * attribute that is associated with the data in this vertex buffer in that
         * shader.
         * @type Object
         */
        this._locations = {};
        /**
         * The number of vectors that have been progressively filled in the data array using addVector().
         * @type Number
         */
        this._filledVectors = 0;
        /**
         * A flag to mark if the data referenced by this vertex buffer has changed since last update to the GPU
         * @type Boolean
         */
        this._dirty = false;
    }
    /**
     * Returns the name of this vertex buffer.
     * @returns {String}
     */
    VertexBuffer.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the role that the data in this buffer fulfills. (e.g. location
     * or color)
     * @returns {String}
     */
    VertexBuffer.prototype.getRole = function () {
        return this._role;
    };
    /**
     * Sets (overwrites) a part of the data array of this buffer (before sending it 
     * to the GPU memory)
     * @param {Float32Array} data The data to be assigned.
     * @param {Number} start The index of the first vector to be assigned. Starting
     * from this, the data as long as the length of 'data' parameter will be 
     * overwritten.
     */
    VertexBuffer.prototype.setData = function (data, start) {
        this._data.set(data, start * this._vectorSize);
    };
    /**
     * Returns the number of vectors this buffer is currently able to store.
     * @returns {Number}
     */
    VertexBuffer.prototype.getSize = function () {
        return this._data.length / this._vectorSize;
    };
    /**
     * Erases the current content and sets a new size for this buffer.
     * @param {Number} size The new number of vectors the buffer should be able to store.
     */
    VertexBuffer.prototype.resize = function (size) {
        this._data = new Float32Array(size * this._vectorSize);
    };
    /**
     * Using this method, the data array can be filled progressively, with one vector each time.
     * @param {Number[]|Float32Array} vector A float vector to be added to the array. Needs to be _vectorSize long.
     */
    VertexBuffer.prototype.addVector = function (vector) {
        this._data.set(vector, this._filledVectors * this._vectorSize);
        this._filledVectors++;
    };
    /**
     * After calling this method, the buffer data can be filled again from the beginning using addVector().
     */
    VertexBuffer.prototype.resetFilledVectors = function () {
        this._filledVectors = 0;
    };
    /**
     * Frees the data stored in the normal RAM (for use after it is already in GPU 
     * memory)
     */
    VertexBuffer.prototype.freeData = function () {
        this._data = null;
    };
    /**
     * Mark that the vertex buffer data has changed and needs to be updated on the GPU
     */
    VertexBuffer.prototype.markDirty = function () {
        this._dirty = true;
    };
    /**
     * Creates the needed VBO in the supplied context and sends over the data (set
     * by setData) using it to the GPU, then erases the original data array. (unless otherwise specified)
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     * @param {Boolean} [keepData=false] If true, the stored data is not erased.
     */
    VertexBuffer.prototype.loadToGPUMemory = function (contextName, gl, keepData) {
        this._ids[contextName] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._ids[contextName]);
        gl.bufferData(
                gl.ARRAY_BUFFER,
                this._data,
                gl.STATIC_DRAW);
        if (!keepData) {
            this.freeData();
        }
    };
    /**
     * Binds the vertex buffer to the vertex attribute that has the same name as
     * this buffer (but only if needed because it is bound to a different index at 
     * the moment) within the passed shader and context and also enables the
     * corresponding vertex attribute array.
     * @param {ManagedGLContext} context
     * @param {ManagedShader} shader
     * @param {Boolean} [instanced=false] Whether to bind this buffer as an instance attribute buffer rather than a vertex attribute buffer
     * for instancing.
     */
    VertexBuffer.prototype.bind = function (context, shader, instanced) {
        if ((this._locations[shader.getName()] === undefined) || (this._locations[shader.getName()] === -1)) {
            this._locations[shader.getName()] = context.gl.getAttribLocation(shader.getIDForContext(context.getName()), this._name);
        }
        var location = this._locations[shader.getName()];
        if (location >= 0) {
            if ((context.getBoundVertexBuffer(location) !== this) || this._dirty) {
                application.log_DEBUG("Binding " + (instanced ? "instance" : "vertex") + " buffer '" + this._name + "' to attribute location " + location + " in shader '" + shader.getName() + "'.", 3);
                if (instanced) {
                    this.loadToGPUMemory(context.getName(), context.gl, true);
                } else {
                    context.gl.bindBuffer(context.gl.ARRAY_BUFFER, this._ids[context.getName()]);
                }
                context.gl.vertexAttribPointer(location, this._vectorSize, context.gl.FLOAT, false, 0, 0);
                this._dirty = false;
            }
            context.setBoundVertexBuffer(location, this, !!instanced);
        }
    };
    /**
     * Deletes the corresponding WebGL buffer object.
     * @param {ManagedGLContext} context
     */
    VertexBuffer.prototype.delete = function (context) {
        var shaderName, location;
        context.gl.deleteBuffer(this._ids[context.getName()]);
        for (shaderName in this._locations) {
            if (this._locations.hasOwnProperty(shaderName)) {
                location = this._locations[shaderName];
                if (context.getBoundVertexBuffer(location) === this) {
                    context.setBoundVertexBuffer(location, null, false);
                }
            }
        }
        delete this._ids[context.getName()];
        if (Object.keys(this._ids).length === 0) {
            this.freeData();
            this._locations = {};
        }
    };
    // ############################################################################################
    /**
     * @class A wrapper class around a WebGL Frame Buffer Object (FBO) for managed
     * functionality.
     * @param {String} name The name of the buffer to be created and later be referred to.
     * @param {Number} width The width of the frame buffer. (pixels/texels)
     * @param {Number} height The height of the frame buffer. (pixels/texels)
     * @param {Boolean} [depthOnly=false] If true and depth textures are supported, then only a depth texture will be attached to this 
     * framebuffer object.
     * @returns {FrameBuffer}
     */
    function FrameBuffer(name, width, height, depthOnly) {
        /**
         * The name by which this buffer can be referred to.
         * @type String
         */
        this._name = name;
        /**
         * The WebGL handle for this frame buffer object.
         * @type WebGLBuffer
         */
        this._id = null;
        /**
         * The width in pixels/texels.
         * @type Number
         */
        this._width = width;
        /**
         * The height in pixels/texels.
         * @type Number
         */
        this._height = height;
        /**
         * If true and depth textures are supported, then only a depth texture will be attached to this framebuffer object.
         * @type Boolean
         */
        this._depthOnly = !!depthOnly;
        /**
         * The WebGL handle for the texture object created for this buffer's color
         * attachment.
         * @type WebGLTexture
         */
        this._textureID = null;
        /**
         * The index of the texture unit the texture of this buffer's color attachment
         * was / should be bound to.
         * @type Number
         */
        this._textureLocation = this.TEXTURE_LOCATION_NOT_SET;
        /**
         * The WebGL handle for the render buffer object created for this buffer's
         * depth attachment.
         * @type WebGLRenderBuffer
         */
        this._renderBufferID = null;
    }
    /**
     * Value for texture bind locations that have not been explicitly set
     * @constant
     * @type Number
     */
    FrameBuffer.prototype.TEXTURE_LOCATION_NOT_SET = -1;
    /**
     * Returns the name of this buffer.
     * @returns {String}
     */
    FrameBuffer.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the width of (the area represented by) this buffer in pixels/texels
     * @returns {String}
     */
    FrameBuffer.prototype.getWidth = function () {
        return this._width;
    };
    /**
     * Returns the texture unit index where the texture associated with this 
     * framebuffer has been last bound to.
     * @returns {Number}
     */
    FrameBuffer.prototype.getLastTextureBindLocation = function () {
        return this._textureLocation;
    };
    /**
     * Erases the stored texture unit index corresponding to the last binding location of the texture of this framebuffer.
     */
    FrameBuffer.prototype.forgetLastTextureBindLocation = function () {
        this._textureLocation = this.TEXTURE_LOCATION_NOT_SET;
    };
    /**
     * Creates the WebGL frame buffer object for this buffer, then creates and 
     * sets up a texture for holding the color attachment and a render buffer 
     * for holding the depth attachment and attaches them to this frame buffer.
     * @param {ManagedGLContext} context
     */
    FrameBuffer.prototype.setup = function (context) {
        var status;
        // calling setup on a frame buffer that has already been set up has no effect
        if (this._id) {
            return;
        }
        this._id = context.gl.createFramebuffer();
        context.gl.bindFramebuffer(context.gl.FRAMEBUFFER, this._id);
        this._textureID = context.gl.createTexture();
        this._textureLocation = context.bindTexture(this);
        context.gl.texParameteri(context.gl.TEXTURE_2D, context.gl.TEXTURE_MAG_FILTER, context.gl.NEAREST);
        context.gl.texParameteri(context.gl.TEXTURE_2D, context.gl.TEXTURE_MIN_FILTER, context.gl.NEAREST);
        context.gl.texParameteri(context.gl.TEXTURE_2D, context.gl.TEXTURE_WRAP_S, context.gl.CLAMP_TO_EDGE);
        context.gl.texParameteri(context.gl.TEXTURE_2D, context.gl.TEXTURE_WRAP_T, context.gl.CLAMP_TO_EDGE);
        if (this._depthOnly && context.areDepthTexturesAvailable()) {
            context.gl.texImage2D(context.gl.TEXTURE_2D, 0, context.gl.DEPTH_COMPONENT, this._width, this._height, 0, context.gl.DEPTH_COMPONENT, context.gl.UNSIGNED_SHORT, null);
            context.gl.framebufferTexture2D(context.gl.FRAMEBUFFER, context.gl.DEPTH_ATTACHMENT, context.gl.TEXTURE_2D, this._textureID, 0);
        } else {
            context.gl.texImage2D(context.gl.TEXTURE_2D, 0, context.gl.RGBA, this._width, this._height, 0, context.gl.RGBA, context.gl.UNSIGNED_BYTE, null);
            this._renderBufferID = context.gl.createRenderbuffer();
            context.gl.bindRenderbuffer(context.gl.RENDERBUFFER, this._renderBufferID);
            context.gl.renderbufferStorage(context.gl.RENDERBUFFER, context.gl.DEPTH_COMPONENT16, this._width, this._height);
            context.gl.framebufferTexture2D(context.gl.FRAMEBUFFER, context.gl.COLOR_ATTACHMENT0, context.gl.TEXTURE_2D, this._textureID, 0);
            context.gl.framebufferRenderbuffer(context.gl.FRAMEBUFFER, context.gl.DEPTH_ATTACHMENT, context.gl.RENDERBUFFER, this._renderBufferID);
        }
        status = context.gl.checkFramebufferStatus(context.gl.FRAMEBUFFER);
        switch (status) {
            case context.gl.FRAMEBUFFER_COMPLETE:
                application.log_DEBUG("Framebuffer '" + this._name + "' successfully created.", 2);
                break;
            case context.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                application.showGraphicsError("Incomplete status for framebuffer '" + this._name + "': The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");
                break;
            case context.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                application.showGraphicsError("Incomplete status for framebuffer '" + this._name + "': Attachment missing.");
                break;
            case context.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                application.showGraphicsError("Incomplete status for framebuffer '" + this._name + "': Height and width of the attachment are not the same.");
                break;
            case context.gl.FRAMEBUFFER_UNSUPPORTED:
                application.showGraphicsError("Incomplete status for framebuffer '" + this._name + "': The format of the attachment is not supported or depth and stencil attachments are not the same renderbuffer.");
                break;
            default:
                application.showGraphicsError("Unknown framebuffer status for '" + this._name + "' (" + status + ")!");
        }
    };
    /**
     * Binds the frame buffer to the given context. Subsequent rendering will
     * use this frame buffer.
     * @param {ManagedGLContext} context
     */
    FrameBuffer.prototype.bind = function (context) {
        context.gl.bindFramebuffer(context.gl.FRAMEBUFFER, this._id);
    };
    /**
     * Binds the texture corresponding to this frame buffer object to the texture unit with the specified index.
     * @param {WebGLRenderingContext} gl
     * @param {Number} place
     */
    FrameBuffer.prototype.bindGLTexture = function (gl, place) {
        gl.activeTexture(gl.TEXTURE0 + place);
        gl.bindTexture(gl.TEXTURE_2D, this._textureID);
        this._textureLocation = place;
    };
    /**
     * Deletes the corresponding WebGL frame buffer object and the objects
     * associated with its attachments.
     * @param {ManagedGLContext} context
     */
    FrameBuffer.prototype.delete = function (context) {
        context.gl.deleteTexture(this._textureID);
        if (!this._depthOnly || !context.areDepthTexturesAvailable()) {
            context.gl.deleteRenderbuffer(this._renderBufferID);
        }
        context.gl.deleteFramebuffer(this._id);
        this._id = null;
    };
    // ############################################################################################
    /**
     * @typedef {Object} ManagedShader~ShaderRequirements
     * @property {Number} requiredVertexUniformVectors
     * @property {Number} requiredAttributeVectors
     * @property {Number} requiredVaryingVectors
     * @property {Number} requiredTextureUnits
     * @property {Number} requiredFragmentUniformVectors
     */
    /**
     * @class
     * @param {String} name
     * @param {String} vertexShaderSource
     * @param {String} fragmentShaderSource
     * @param {String} blendMode (enum ShaderBlendMode) 
     * @param {Object.<String, String>} vertexAttributeRoles
     * @param {Object.<String, String>} instanceAttributeRoles
     * @param {Object.<String, String} replacedDefines 
     * @param {Boolean} unpackSamplerArrays If true, arrays of sampler uniforms will be unpacked - that is, substituted 
     * with individual sampler variables for each index in the shader source
     */
    function ManagedShader(name, vertexShaderSource, fragmentShaderSource, blendMode, vertexAttributeRoles, instanceAttributeRoles, replacedDefines, unpackSamplerArrays) {
        // properties for file resource management
        /**
         * The name of the shader program it can be referred to with later. Has to
         * be unique.
         * @type String
         */
        this._name = name;
        /**
         * (enum ShaderBlendMode) 
         * The type of blending to be used with this shader.
         * @type String
         */
        this._blendMode = blendMode;
        /**
         * The list of vertex attribute properties of this shader.
         * @type ShaderAttribute[]
         */
        this._vertexAttributes = [];
        /**
         * The list of instance attribute properties of this shader.
         * @type ShaderAttribute[]
         */
        this._instanceAttributes = [];
        /**
         * The list of shader uniforms of this shader.
         * @type ShaderUniform[]
         */
        this._uniforms = [];
        /**
         * The source code of the vertex shader.
         * @type String
         */
        this._vertexShaderSource = vertexShaderSource;
        /**
         * The source code of the fragment shader.
         * @type String
         */
        this._fragmentShaderSource = fragmentShaderSource;
        // properties for WebGL resource management
        /**
         * The associative array of WebGL program IDs belonging to managed contexts 
         * which this program has been associated with. The keys are the names of the managed
         * contexts, and values are the WebGL IDs (handles)
         * @type Object
         */
        this._ids = {};
        /**
         * The array of objects storing the instance attribute buffers organized by their names. Each element of the array stores the buffers
         * for one instance queue.
         * @type Array.<Object.<String, VertexBuffer>>
         */
        this._instanceAttributeBuffers = [];
        /**
         * The names of uniform variables that are replaced by instance attributes, if the shader is instanced, organized by the names of
         * instance attributes they are replaced by.
         * @type Object.<String, String>
         */
        this._uniformNamesForInstanceAttributeNames = instanceAttributeRoles;
        /**
         * The list of names of the instance attributes for easily cycling through them.
         * @type String[]
         */
        this._instanceAttributeNames = Object.keys(instanceAttributeRoles);
        /**
         * The numver of 4 component vectors used up by the uniforms in the vertex shader.
         * @type Number
         */
        this._numVertexUniformVectors = 0;
        /**
         * The numver of 4 component vectors used up by the attributes in the vertex shader.
         * @type Number
         */
        this._numAttributeVectors = 0;
        /**
         * The numver of 4 component vectors used up by the varyings in the fragment shader.
         * @type Number
         */
        this._numVaryingVectors = 0;
        /**
         * The number of texture units used up by the uniforms in the fragment shader.
         * @type Number
         */
        this._numTextureUnits = 0;
        /**
         * The numver of 4 component vectors used up by the uniforms in the fragment shader.
         * @type Number
         */
        this._numFragmentUniformVectors = 0;
        if (!this._vertexShaderSource) {
            application.showError("Cannot initialize shader '" + this._name + "': no vertex shader source specified!");
        } else if (!this._fragmentShaderSource) {
            application.showError("Cannot initialize shader '" + this._name + "': no fragment shader source specified!");
        } else {
            this._parseShaderSources(vertexAttributeRoles, replacedDefines, unpackSamplerArrays);
        }
    }
    /**
     * @param {String} name
     * @returns {Boolean}
     */
    ManagedShader.prototype._hasUniform = function (name) {
        var i;
        for (i = 0; i < this._uniforms.length; i++) {
            if (this._uniforms[i].getName() === name) {
                return true;
            }
        }
        return false;
    };
    /**
     * Returns the uniform belonging to this shader having the passed name.
     * @param {String} name
     * @returns {ShaderUniform}
     */
    ManagedShader.prototype._getUniform = function (name) {
        var i;
        for (i = 0; i < this._uniforms.length; i++) {
            if (this._uniforms[i].getName() === name) {
                return this._uniforms[i];
            }
        }
        return null;
    };
    /**
     * @param {Object.<String, String>} attributeRoles The associative array binding the attribute names in the shader source to their roles
     * (which determines what kind of data will be bound to the respective attribute array). Format: {attributeName: attributeRole, ...}
     * @param {Object.<String, String>} [replacedDefines] Values defined in the shader source using #define will be replaced by the values
     * provided in this object (e.g. #define CONST 3 will be changed to #define CONST 5 if {CONST: 5} is passed.
     * @param {Boolean} unpackSamplerArrays If true, arrays of sampler uniforms will be unpacked - that is, substituted 
     * with individual sampler variables for each index in the shader source
     */
    ManagedShader.prototype._parseShaderSources = function (attributeRoles, replacedDefines, unpackSamplerArrays) {
        var
                VERTEX_SHADER_INDEX = 0,
                FRAGMENT_SHADER_INDEX = 1,
                i, k, l, shaderType,
                sourceLines, words, delimiters, index,
                attributeName, attributeSize, attributeRole,
                uniform, uniformName, variableType, variableArraySize, arraySizeString, unpacked,
                defines = {}, sourceChanged, localVariableNames, localVariableSizes = {},
                isNotEmptyString = function (s) {
                    return s !== "";
                },
                isPrecisionQualifier = function (s) {
                    return (s === "highp") || (s === "mediump") || (s === "lowp");
                },
                isBuiltInGLSLType = function (s) {
                    return utils.getSafeEnumValue(ShaderVariableType, s, ShaderVariableType.NONE) !== ShaderVariableType.NONE;
                },
                addStructMembers = function (uniform, uniformType) {
                    var structFound, innerWords, j, typeIndex;
                    structFound = false;
                    for (j = 0; j < sourceLines.length; j++) {
                        innerWords = sourceLines[j].split(" ");
                        if (!structFound) {
                            if ((innerWords[0] === "struct") && (innerWords[1].split("{")[0] === uniformType)) {
                                structFound = true;
                            }
                        } else {
                            innerWords = innerWords.filter(isNotEmptyString);
                            if ((innerWords.length > 0) && (innerWords[innerWords.length - 1].split(";")[0] === "}")) {
                                break;
                            }
                            if (innerWords.length >= 2) {
                                typeIndex = isPrecisionQualifier(innerWords[0]) ? 1 : 0;
                                uniform.addMember(new ShaderUniform(innerWords[typeIndex + 1].split(";")[0], innerWords[typeIndex], 0));
                            }
                        }
                    }
                };
        for (shaderType = 0; shaderType < 2; shaderType++) {
            switch (shaderType) {
                case VERTEX_SHADER_INDEX:
                    sourceLines = this._vertexShaderSource.split("\n");
                    break;
                case FRAGMENT_SHADER_INDEX:
                    sourceLines = this._fragmentShaderSource.split("\n");
                    break;
            }
            sourceChanged = false;
            for (i = 0; i < sourceLines.length; i++) {
                if (sourceLines[i].length > 0) {
                    words = sourceLines[i].split(/\s+|[\(\)\[\]\{\}\+\?\-!<>=*\/\^\|\&,;]/);
                    delimiters = sourceLines[i].match(/\s+|[\(\)\[\]\{\}\+\?\-!<>=*\/\^\|\&,;]/g);
                    // parsing defines
                    if (words[0] === "#define") {
                        if (replacedDefines && (replacedDefines[words[1]] !== undefined)) {
                            defines[words[1]] = replacedDefines[words[1]];
                            if (words[2] !== replacedDefines[words[1]]) {
                                sourceLines[i] = sourceLines[i].replace(words[2], replacedDefines[words[1]]);
                                sourceChanged = true;
                            }
                        } else {
                            defines[words[1]] = words[2];
                        }
                    }
                    // parsing attributes
                    else if ((shaderType === VERTEX_SHADER_INDEX) && (words[0] === "attribute")) {
                        index = isPrecisionQualifier(words[1]) ? 3 : 2;
                        attributeName = words[index];
                        variableType = words[index - 1];
                        attributeSize = getFloatVectorSize(variableType);
                        attributeRole = attributeRoles[attributeName];
                        this._numAttributeVectors += getVectorCount(variableType);
                        if (attributeRole === undefined) {
                            if (this._uniformNamesForInstanceAttributeNames.hasOwnProperty(attributeName)) {
                                attributeRole = this._uniformNamesForInstanceAttributeNames[attributeName];
                                this._instanceAttributes.push(new ShaderAttribute(attributeName, attributeSize, attributeRole));
                            } else {
                                application.showError("Role for attribute named '" + attributeName + "' not found for shader '" + this._name + "'!");
                                return;
                            }
                        } else {
                            this._vertexAttributes.push(new ShaderAttribute(attributeName, attributeSize, attributeRole));
                        }
                    }
                    // parsing uniforms
                    else if (words[0] === "uniform") {
                        index = isPrecisionQualifier(words[1]) ? 3 : 2;
                        uniformName = words[index];
                        variableType = words[index - 1];
                        if (this._hasUniform(uniformName) === false) {
                            if (delimiters[index] === "[") {
                                unpacked = false;
                                arraySizeString = words[index + 1];
                                if (defines[arraySizeString]) {
                                    arraySizeString = defines[arraySizeString];
                                }
                                variableArraySize = parseInt(arraySizeString, 10);
                                // unpacking sampler array declarations to declarations of individual samplers
                                if (isSamplerType(variableType) && unpackSamplerArrays) {
                                    sourceLines[i] = "";
                                    for (k = 0; k < variableArraySize; k++) {
                                        for (l = 0; l < index; l++) {
                                            sourceLines[i] += words[l];
                                            sourceLines[i] += delimiters[l];
                                        }
                                        sourceLines[i] += uniformName + k.toString() + ";\n";
                                    }
                                    sourceChanged = true;
                                    unpacked = true;
                                }
                            } else {
                                variableArraySize = 0;
                            }
                            if (!isBuiltInGLSLType(variableType)) {
                                uniform = new ShaderUniform(uniformName, "struct", variableArraySize);
                                addStructMembers(uniform, variableType);
                                this._uniforms.push(uniform);
                            } else {
                                this._uniforms.push(new ShaderUniform(uniformName, variableType, variableArraySize, unpacked));
                            }
                        }
                        switch (shaderType) {
                            case VERTEX_SHADER_INDEX:
                                this._numVertexUniformVectors += this._getUniform(uniformName).getVectorCount();
                                break;
                            case FRAGMENT_SHADER_INDEX:
                                this._numFragmentUniformVectors += this._getUniform(uniformName).getVectorCount();
                                if (isSamplerType(variableType)) {
                                    this._numTextureUnits += this._getUniform(uniformName).getVectorCount();
                                }
                                break;
                            default:
                                application.crash();
                        }
                    }
                    // parsing varyings
                    else if (words[0] === "varying") {
                        index = isPrecisionQualifier(words[1]) ? 3 : 2;
                        variableType = words[index - 1];
                        if (shaderType === FRAGMENT_SHADER_INDEX) {
                            if (delimiters[index] === "[") {
                                arraySizeString = words[index + 1];
                                if (defines[arraySizeString]) {
                                    arraySizeString = defines[arraySizeString];
                                }
                                variableArraySize = parseInt(arraySizeString, 10);
                            } else {
                                variableArraySize = 1;
                            }
                            this._numVaryingVectors += getVectorCount(variableType) * variableArraySize;
                        }
                    }
                    // parsing array sizes of local variables
                    else {
                        index = 0;
                        while (words[index] === "") {
                            index++;
                        }
                        if (isBuiltInGLSLType(words[index]) || isPrecisionQualifier(words[index])) {
                            index = isPrecisionQualifier(words[index]) ? index + 2 : index + 1;
                            if (delimiters[index] === "[") {
                                arraySizeString = words[index + 1];
                                if (defines[arraySizeString]) {
                                    arraySizeString = defines[arraySizeString];
                                }
                                localVariableSizes[words[index]] = parseInt(arraySizeString, 10);
                            }
                        }
                        // removing lines wich access array variables out of bounds according to replaced defines
                        else {
                            for (k = 0; k < this._uniforms.length; k++) {
                                index = words.indexOf(this._uniforms[k].getName());
                                if (index >= 0) {
                                    if ((this._uniforms[k].getArraySize() > 0) && (delimiters[index] === "[")) {
                                        if ((parseInt(words[index + 1], 10).toString() === words[index + 1]) && (parseInt(words[index + 1], 10) >= this._uniforms[k].getArraySize())) {
                                            sourceLines[i] = "";
                                            sourceChanged = true;
                                            break;
                                        }
                                        // removing [] operators from unpacked array references
                                        if (this._uniforms[k].isSamplerType() && unpackSamplerArrays) {
                                            sourceLines[i] = "";
                                            // adding the content of the line before the uniform name reference
                                            for (l = 0; l < index; l++) {
                                                sourceLines[i] += words[l];
                                                sourceLines[i] += delimiters[l];
                                            }
                                            // adding the uniform name reference suffixed with the index directly
                                            sourceLines[i] += words[index] + words[index + 1];
                                            // adding the content of the line after the uniform index closing bracket
                                            for (l = index + 2; l < delimiters.length; l++) {
                                                sourceLines[i] += words[l];
                                                sourceLines[i] += delimiters[l];
                                            }
                                            sourceLines[i] += words[words.length - 1];
                                            sourceChanged = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            localVariableNames = Object.keys(localVariableSizes);
                            for (k = 0; k < localVariableNames.length; k++) {
                                index = words.indexOf(localVariableNames[k]);
                                if (index >= 0) {
                                    if (delimiters[index] === "[") {
                                        if ((parseInt(words[index + 1], 10).toString() === words[index + 1]) && (parseInt(words[index + 1], 10) >= localVariableSizes[words[index]])) {
                                            sourceLines[i] = "";
                                            sourceChanged = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (sourceChanged) {
                switch (shaderType) {
                    case VERTEX_SHADER_INDEX:
                        this._vertexShaderSource = sourceLines.join("\n");
                        break;
                    case FRAGMENT_SHADER_INDEX:
                        this._fragmentShaderSource = sourceLines.join("\n");
                        break;
                }
            }
        }
    };
    /**
     * Getter for the _name property.
     * @returns {String}
     */
    ManagedShader.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the WebGL ID of this program valid in the managed context with the passed name.
     * Error checking is not performed - if there is no valid ID for this context,
     * it will return undefined.
     * @param {String} contextName
     * @returns {WebGLProgram}
     */
    ManagedShader.prototype.getIDForContext = function (contextName) {
        return this._ids[contextName];
    };
    /**
     * Returns the array of vertex attributes of this shader.
     * @returns {ShaderAttribute[]}
     */
    ManagedShader.prototype.getVertexAttributes = function () {
        return this._vertexAttributes;
    };
    /**
     * Returns the vertex attribute with the given name.
     * @param {String} name
     * @returns {ShaderAttribute}
     */
    ManagedShader.prototype.getVertexAttribute = function (name) {
        var i;
        for (i = 0; i < this._vertexAttributes.length; i++) {
            if (this._vertexAttributes[i].name === name) {
                return this._vertexAttributes[i];
            }
        }
        return null;
    };
    /**
     * Returns the instance attribute with the given name.
     * @param {String} name
     * @returns {ShaderAttribute}
     */
    ManagedShader.prototype.getInstanceAttribute = function (name) {
        var i;
        for (i = 0; i < this._instanceAttributes.length; i++) {
            if (this._instanceAttributes[i].name === name) {
                return this._instanceAttributes[i];
            }
        }
        return null;
    };
    /**
     * Using the passed rendering context, creates, compiles, and links the corresponding WebGL program and caches the locations of its
     * uniforms so it will be ready to use.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     */
    ManagedShader.prototype.setupGLProgram = function (contextName, gl) {
        var vertexShader, infoLog, fragmentShader, prog, i;
        if (!this._vertexShaderSource || !this._fragmentShaderSource) {
            application.log_DEBUG("ERROR: Cannot set up GL shader program for '" + this._name + "', because the vertex or fragment shader source is missing!", 1);
            this._ids[contextName] = null;
            return;
        }
        // create and compile vertex shader
        vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, this._vertexShaderSource);
        gl.compileShader(vertexShader);
        // detect and display compilation errors
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            infoLog = gl.getShaderInfoLog(vertexShader);
            application.showGraphicsError("Compiling GLSL vertex shader of '" + this._name + "' failed.", application.ErrorSeverity.SEVERE, "More details:\n" + infoLog, gl);
            this._ids[contextName] = null;
            return;
        }
        // create and compile fragment shader
        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, this._fragmentShaderSource);
        gl.compileShader(fragmentShader);
        // detect and display compilation errors
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            infoLog = gl.getShaderInfoLog(fragmentShader);
            application.showGraphicsError("Compiling GLSL fragment shader of '" + this._name + "' failed.", application.ErrorSeverity.SEVERE, "More details:\n" + infoLog, gl);
            this._ids[contextName] = null;
            return;
        }
        // create and link shader program
        this._ids[contextName] = gl.createProgram();
        prog = this._ids[contextName];
        gl.attachShader(prog, vertexShader);
        gl.attachShader(prog, fragmentShader);
        gl.linkProgram(prog);
        // detect and display linking errors
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            infoLog = gl.getProgramInfoLog(prog);
            application.showGraphicsError("Linking GLSL shader '" + this._name + "' failed.", application.ErrorSeverity.SEVERE, "More details: " + infoLog, gl);
            gl.deleteProgram(prog);
            this._ids[contextName] = null;
            return;
        }
        // cache uniform locations - this is necessary for simple uniforms before use
        for (i = 0; i < this._uniforms.length; i++) {
            this._uniforms[i].saveLocation(contextName, gl, this);
        }
    };
    /**
     * Returns the blend mode to be used when rendering with this shader.
     * @returns {String} enum ShaderBlendMode
     */
    ManagedShader.prototype.getBlendMode = function () {
        return this._blendMode;
    };
    /**
     * Assigns the uniforms that have an associated value function in 
     * uniformValueFunctions, by calculating the value using those functions.
     * @param {ManagedGLContext} context The context in which the assignment needs
     * to happen.
     * @param {Object} uniformValueFunctions An associative array containing 
     * functions to calculate the values of uniforms, with the names of the uniforms
     * as keys.
     */
    ManagedShader.prototype.assignUniforms = function (context, uniformValueFunctions) {
        var i;
        if (uniformValueFunctions) {
            for (i = 0; i < this._uniforms.length; i++) {
                if (uniformValueFunctions[this._uniforms[i].getName()] !== undefined) {
                    this._uniforms[i].setValue(context.getName(), context.gl, this, uniformValueFunctions[this._uniforms[i].getName()]);
                }
            }
        }
    };
    /**
     * Binds the appropriate vertex buffers to the indices of the vertex attributes that this shader has.
     * @param {ManagedGLContext} context
     */
    ManagedShader.prototype.bindVertexBuffers = function (context) {
        var i;
        context.clearVertexBufferUsage();
        for (i = 0; i < this._vertexAttributes.length; i++) {
            context.getVertexBuffer(this._vertexAttributes[i].name).bind(context, this);
        }
        context.disableUnusedVertexBuffers();
    };
    /**
     * If the shader has a uniform array variable with the given name, this will return the length
     * of that array, otherwise it will return 0.
     * @param {String} uniformName
     * @returns {Number}
     */
    ManagedShader.prototype.getUniformArrayLength = function (uniformName) {
        var i;
        for (i = 0; i < this._uniforms.length; i++) {
            if (this._uniforms[i].getName() === uniformName) {
                return this._uniforms[i].getArraySize();
            }
        }
        return 0;
    };
    /**
     * Returns what types of textures does this shader need to be bound, based on the names of its uniform sampler variables.
     * @returns {Array}
     */
    ManagedShader.prototype.getTextureTypes = function () {
        var i, textureType, result = [];
        for (i = 0; i < this._uniforms.length; i++) {
            textureType = this._uniforms[i].getTextureType();
            if (textureType) {
                result.push(textureType);
            }
        }
        return result;
    };
    /**
     * Returns the names of cubemaps this shader needs to be bound, based on the names of its uniform sampler variables.
     * @returns {Array}
     */
    ManagedShader.prototype.getCubemapNames = function () {
        var i, cubemapName, result = [];
        for (i = 0; i < this._uniforms.length; i++) {
            cubemapName = this._uniforms[i].getCubemapName();
            if (cubemapName) {
                result.push(cubemapName);
            }
        }
        return result;
    };
    /**
     * Creates instance buffers for all the instance attributes of this shader. The created buffers are saved at the given index and can be
     * accessed later using it, so that multiple instance queues using the same shader can be managed by giving them different indices.
     * @param {Number} index
     * @param {Number} instanceCount
     */
    ManagedShader.prototype.createInstanceBuffers = function (index, instanceCount) {
        var i, attributeName;
        // if we don't have a storage for this instane queue yet, grow the array
        if (this._instanceAttributeBuffers.length < index + 1) {
            this._instanceAttributeBuffers = this._instanceAttributeBuffers.concat(new Array(index - this._instanceAttributeBuffers.length + 1));
        }
        // for each instance attribute, a new buffer is created or the existing one is set up (so that when rendering a new frame, existing
        // buffers can be reused even if the indices for the instance queues change)
        for (i = 0; i < this._instanceAttributeNames.length; i++) {
            attributeName = this._instanceAttributeNames[i];
            if (!this._instanceAttributeBuffers[index]) {
                this._instanceAttributeBuffers[index] = {};
            }
            if (!this._instanceAttributeBuffers[index][attributeName]) {
                this._instanceAttributeBuffers[index][attributeName] = new VertexBuffer(
                        attributeName,
                        this._uniformNamesForInstanceAttributeNames[attributeName],
                        this.getInstanceAttribute(attributeName).size,
                        instanceCount);
            } else {
                this._instanceAttributeBuffers[index][attributeName].resize(instanceCount);
                this._instanceAttributeBuffers[index][attributeName].resetFilledVectors();
                this._instanceAttributeBuffers[index][attributeName].markDirty();
            }
        }
    };
    /**
     * Adds the data of one instance to the instance buffers (of all instance attributes) at the given index, using the values of the 
     * uniforms the instance would have assigned if it was not rendered in instanced mode.
     * @param {Number} index
     * @param {Object.<String, Function>} uniformValueFunctions The functions for getting the uniform values of all instance attributes
     * (must contain a function for every attribute!)
     */
    ManagedShader.prototype.addDataToInstanceBuffers = function (index, uniformValueFunctions) {
        var i, attributeName, uniformName;
        for (i = 0; i < this._instanceAttributeNames.length; i++) {
            attributeName = this._instanceAttributeNames[i];
            uniformName = this._instanceAttributeBuffers[index][attributeName].getRole();
            this._instanceAttributeBuffers[index][attributeName].addVector(uniformValueFunctions[uniformName](utils.EMPTY_STRING));
        }
    };
    /**
     * Sends the data to WebGL using the passed context from the instance buffers (of all indices) stored at the passed index as well as
     * binds them to the correct attribute locations and sets them to instanced.
     * @param {ManagedGLContext} context
     * @param {Number} index
     */
    ManagedShader.prototype.bindAndFillInstanceBuffers = function (context, index) {
        var i;
        for (i = 0; i < this._instanceAttributeNames.length; i++) {
            this._instanceAttributeBuffers[index][this._instanceAttributeNames[i]].bind(context, this, true);
        }
    };
    /**
     * Deletes all the stored instance buffers created for the passed context.
     * @param {Number} context
     */
    ManagedShader.prototype.deleteInstanceBuffers = function (context) {
        var i, j;
        for (i = 0; i < this._instanceAttributeBuffers.length; i++) {
            for (j = 0; j < this._instanceAttributeNames.length; j++) {
                this._instanceAttributeBuffers[i][this._instanceAttributeNames[j]].delete(context);
            }
        }
        this._instanceAttributeBuffers = [];
    };
    /**
     * Deletes the underlying WebGL program object and erases the cached uniform locations associated with the passed context name.
     * @param {String} contextName
     * @param {WebGLRenderingContext} gl
     */
    ManagedShader.prototype.deleteGLProgram = function (contextName, gl) {
        var i;
        if (this._ids[contextName]) {
            // cache uniform locations
            for (i = 0; i < this._uniforms.length; i++) {
                this._uniforms[i].forgetLocations(contextName);
            }
            gl.deleteProgram(this._ids[contextName]);
            delete this._ids[contextName];
        }
    };
    /**
     * Returns whether this shader is guaranteed to be supported if the passed requirements are satisfied by the graphics driver.
     * @param {ManagedShader~ShaderRequirements} requirements
     * @returns {Boolean}
     */
    ManagedShader.prototype.isAllowedByRequirements = function (requirements) {
        return (this._numAttributeVectors <= requirements.requiredAttributeVectors) &&
                (this._numVertexUniformVectors <= requirements.requiredVertexUniformVectors) &&
                (this._numVaryingVectors <= requirements.requiredVaryingVectors) &&
                (this._numTextureUnits <= requirements.requiredTextureUnits) &&
                (this._numFragmentUniformVectors <= requirements.requiredFragmentUniformVectors);
    };
    // ############################################################################################
    /**
     * Creates a managed WebGL context for the given HTML5 canvas element.
     * @class Adds higher level management functions to the WebGLRenderingContext
     * class. {@link Texture}, {@link Cubemap}, {@link Shader} and
     * {@link Model} resources can be linked to it, and can set up the vertex
     * buffers according to the linked model resources.
     * @extends AsyncResource
     * @param {String} name The name of the context.
     * @param {HTMLCanvasElement} canvas The canvas for which the context is to be
     * created.
     * @param {Boolean} [antialiasing=false] Whether antialising should be turned on for
     * this context. If the WebGL implementation does not support antialiasing, this
     * will have no effect.
     * @param {Boolean} [alpha=true] Whether alpha channel support (blending with the HTML element behind the
     * canvas) should be turned on for this context.
     * @param {String} filtering What kind of texture filtering should be used for
     * 2D textures. Supported values are: bilinear, trilinear, anisotropic (which
     * will be 4:1)
     * @param {Boolean} [supressAntialiasingError=false] If true, no error will be shown if antialiasing is requested but not supported.
     * @returns {ManagedGLContext}
     */
    function ManagedGLContext(name, canvas, antialiasing, alpha, filtering, supressAntialiasingError) {
        asyncResource.AsyncResource.call(this);
        /**
         * The name of the context by which it can be referred to.
         * @type String
         */
        this._name = name;
        /**
         * A reference to the canvas the context of which this object wraps.
         * @type HTMLCanvasElement
         */
        this._canvas = canvas;
        /**
         * The contained basic WebGL rendering context.
         * @type WebGLRenderingContext
         */
        this.gl = null;
        /**
         * Whether antialiasing is enabled for the WebGL context.
         * @type Boolean
         */
        this._antialiasing = (antialiasing === true);
        /**
         * Whether alpha channel support (blending with the HTML element behind the
         * canvas) is turned on for this context.
         * @type Boolean
         */
        this._alpha = (alpha === undefined) || alpha;
        /**
         * What filtering is used for 2D textures. Supported values are: bilinear,
         * trilinear and anisotropic. Attempting to create the context with anisotropic
         * filtering will cause it to probe if the functionality is available, and will
         * set 4:1 anisotropic filtering up if so, otherwise revert back to trilinear
         * filtering.
         * @type String
         */
        this._filtering = null;
        /**
         * Holder for the handle of the anisotropic filter WebGL extension.
         * @type EXTTextureFilterAnisotropic
         */
        this.anisotropicFilterExt = null;
        /**
         * Holder for the handle of the ANGLE_instanced_arrays WebGL extension.
         * @type ANGLEInstancedArrays
         */
        this.instancingExt = null;
        /**
         * Holder for the handle of the WEBGL_depth_texture WebGL extension.
         * @type WebGLDepthTexture
         */
        this.depthTextureExt = null;
        /**
         * The list of associated shaders. This needs to be stored in order to bind
         * the vertex buffer objects to the corresponding attributes of the shaders
         * after the buffers are created. However, the shaders are created and 
         * managed using a {@link ResourceManager}, and this context only references 
         * them.
         * A VBO is created for each attribute with a different name and then bound
         * to its index, therefore attributes with tha same name contained in these
         * shaders must share the same index as well.
         * @type Shader[]
         */
        this._shaders = [];
        /**
         * The list of associated models. This needs to be stored in order to fill 
         * the vertex buffer objects with data from these models when the buffers 
         * are created. <br/>
         * The model objects are created and managed using a {@link ResourceManager}, 
         * and this context only references them.
         * @type Model[]
         */
        this._models = [];
        /**
         * The associative array of vertex buffer objects, stored by their names 
         * (which equal the names of their corresponding attributes) as the keys.
         * @type Object
         */
        this._vertexBuffers = null;
        /**
         * The list of the vertex buffer objects bound to each vertex attribute
         * array index. (the index in the array corresponds to the vertex attribute
         * array index)
         * @type VertexBuffer[]
         */
        this._boundVertexBuffers = [];
        /**
         * Whether the vertex attribute arrays belonging to the vertex attributes
         * are currently enabled (to check easily - prevent unnecessary 
         * enable/disable GL calls)
         * @type Boolean[]
         */
        this._vertexBuffersEnabled = [];
        /**
         * Flags marking which vertex attributes are to be used (have valid
         * vertex buffers bound to them, their arrays should be enabled)
         * @type Boolean[]
         */
        this._vertexBuffersUsed = [];
        /**
         * Flags marking which vertex attributes have a non-zero divisor
         * set for them for instancing (to check easily - prevent unnecessary
         * divisor setting GL calls)
         * @type Boolean[]
         */
        this._vertexBuffersInstanced = [];
        /**
         * The associative array of frame buffer objects, stored by their names 
         * (which equal the names of their corresponding attributes) as the keys.
         * @type Object
         */
        this._frameBuffers = {};
        /**
         * Whether a specific (non-null) framebuffer is currently bound
         * @type Boolean
         */
        this._hasBoundFrameBuffer = false;
        /**
         * A reference to the currently used shader in order to quickly dismiss 
         * calls that aim to set the same again.
         * @type ManagedShader
         */
        this._currentShader = null;
        /**
         * The stored value of the current (lastly set) blend mode (enum ShaderBlendMode)
         * @type String
         */
        this._currentBlendMode = null;
        /**
         * The stored value of the current (lastly set) color mask (Boolean[4])
         * @type Array
         */
        this._currentColorMask = null;
        /**
         * The stored value of the current (lastly set) depth mask
         * @type Boolean
         */
        this._currentDepthMask = false;
        /**
         * Whether blending is currently enabled for the wrapped GL context.
         * @type Boolean
         */
        this._blendingEnabled = false;
        /**
         * The list of textures added to this context.
         * @type (ManagedTexture|ManagedCubemap)[]
         */
        this._textures = [];
        /**
         * The list of references to the currently bound textures in order to 
         * quickly dismiss calls that aim to bind the same texture to the same place
         * again. The indices mark which texture unit index the texture is bound 
         * to.
         * @type {texture: (ManagedTexture|ManagedCubemap|Framebuffer), reserved: Boolean}[]
         */
        this._boundTextures = [];
        /**
         * The maximum number of simultaneously bound textures supported by the
         * WebGL implementation.
         * @type Number
         */
        this._maxBoundTextures = 0;
        /**
         * When all texture unit places has been taken, new textures will be bound
         * to this rotating index so that subsequent binds will not replace each other
         * on the same unit.
         * @type Number
         */
        this._nextTextureBindLocation = 0;
        /**
         * The maximum supported 2D texture size. Attempting to add a texture to
         * the context that is bigger should fail.
         * @type Number
         */
        this._maxTextureSize = 0;
        /**
         * The maximum supported cubemap texture size. Attempting to add a 
         * cubemap texture to the context that is bigger should fail.
         * @type Number
         */
        this._maxCubemapSize = 0;
        /**
         * The maximum supported render buffer size. Attempting to create a 
         * render buffer in the context that is bigger should fail.
         * @type Number
         */
        this._maxRenderbufferSize = 0;
        /**
         * The number of supported vertex attributes.
         * @type Number
         */
        this._maxVertexAttributes = 0;
        /**
         * The number of supported uniform vectors in the vertex shader.
         * @type Number
         */
        this._maxVertexShaderUniforms = 0;
        /**
         * The number of supported uniform vectors in the fragment shader.
         * @type Number
         */
        this._maxFragmentShaderUniforms = 0;
        /**
         * The number of supported varying vectors in shader programs.
         * @type Number
         */
        this._maxVaryings = 0;
        this._createContext(supressAntialiasingError);
        this.setFiltering(filtering);
    }
    ManagedGLContext.prototype = new asyncResource.AsyncResource();
    ManagedGLContext.prototype.constructor = ManagedGLContext;
    /**
     * Creates the underlying WebGL context and its extension objects. (the ones that are available)
     * @param {Boolean} [supressAntialiasingError=false] If true, no error will be shown if antialiasing is requested but not supported
     */
    ManagedGLContext.prototype._createContext = function (supressAntialiasingError) {
        var gl_, contextParameters;
        application.log_DEBUG("Initializing WebGL context...", 1);
        // -------------------------------------------------------------------------------------------------------
        // creating the WebGLRenderingContext
        contextParameters = {alpha: this._alpha, antialias: this._antialiasing};
        // some implementations throw an exception, others don't, but all return null
        // if the creation fails, so handle that case
        try {
            // Try to grab the standard context.
            this.gl = this._canvas.getContext("webgl", contextParameters);
        } catch (ignore) {
        }
        // if creating a normal context fails, fall back to experimental, but notify the user
        if (!this.gl) {
            application.log_DEBUG("Initializing a regular context failed, initializing experimental context...", 1);
            contextParameters.alpha = false;
            try {
                this.gl = this._canvas.getContext("experimental-webgl", contextParameters);
            } catch (ignore) {
            }
            if (!this.gl) {
                application.showError("Unable to initialize WebGL.",
                        application.ErrorSeverity.CRITICAL,
                        "It looks like your device, browser or graphics drivers do not " +
                        "support web 3D graphics. Make sure your browser and graphics " +
                        "drivers are updated to the latest version, and you are using " +
                        "a modern web browser (Firefox or Chrome are recommended).\n" +
                        "Please note that some phones or handheld devices do not have 3D " +
                        "web capabilities, even if you use the latest software.");
                return;
            }
            application.showError("Your device appears to only have experimental WebGL (web based 3D) support.",
                    undefined, "This application relies on 3D web features, and without full support, " +
                    "the graphics of the application might be displayed with glitches or not at all. " +
                    "If you experience problems, it is recommended to use lower graphics quality settings.");
        }
        gl_ = this.gl;
        if (this._antialiasing && !(gl_.getContextAttributes().antialias)) {
            if (!supressAntialiasingError) {
                application.showGraphicsError("Antialiasing is enabled in graphics settings but it is not supported.",
                        application.ErrorSeverity.MINOR,
                        "Your graphics driver, browser or device unfortunately does not support antialiasing. To avoid " +
                        "this error message showing up again, disable antialiasing in the graphics settings or try " +
                        "running the application in a different browser. Antialiasing will not work, but otherwise this " +
                        "error will have no consequences.", gl_);
            }
            this._antialiasing = false;
        }
        // -------------------------------------------------------------------------------------------------------
        // save the information about WebGL limits
        this._maxBoundTextures = gl_.getParameter(gl_.MAX_TEXTURE_IMAGE_UNITS);
        this._maxVertexTextures = gl_.getParameter(gl_.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        this._maxTextureSize = gl_.getParameter(gl_.MAX_TEXTURE_SIZE);
        this._maxCubemapSize = gl_.getParameter(gl_.MAX_CUBE_MAP_TEXTURE_SIZE);
        this._maxRenderbufferSize = gl_.getParameter(gl_.MAX_RENDERBUFFER_SIZE);
        this._maxVertexAttributes = gl_.getParameter(gl_.MAX_VERTEX_ATTRIBS);
        this._maxVertexShaderUniforms = gl_.getParameter(gl_.MAX_VERTEX_UNIFORM_VECTORS);
        this._maxFragmentShaderUniforms = gl_.getParameter(gl_.MAX_FRAGMENT_UNIFORM_VECTORS);
        this._maxVaryings = gl_.getParameter(gl_.MAX_VARYING_VECTORS);
        application.log("WebGL context successfully created.\n" + this.getInfoString(), 1);
        // -------------------------------------------------------------------------------------------------------
        // initializing extensions
        // anisotropic filtering
        this.anisotropicFilterExt = gl_.getExtension("EXT_texture_filter_anisotropic");
        if (this.anisotropicFilterExt === null) {
            application.log("Anisotropic filtering not available.", 1);
        } else {
            application.log("Anisotropic filtering successfully initialized.", 1);
        }
        // instancing extension
        this.instancingExt = gl_.getExtension("ANGLE_instanced_arrays");
        if (this.instancingExt === null) {
            application.log("Instancing is not available, and so it will be disabled.", 1);
        } else {
            application.log("Instancing successfully initialized.", 1);
        }
        // depth textures
        this.depthTextureExt = gl_.getExtension("WEBGL_depth_texture");
        if (this.depthTextureExt === null) {
            application.log("Depth textures not available, and so will be disabled.", 1);
        } else {
            application.log("Depth texture extension successfully initialized.", 1);
        }
        // -------------------------------------------------------------------------------------------------------
        // some basic settings on the context state machine
        gl_.clearDepth(1.0);
        gl_.colorMask(true, true, true, true);
        this._currentColorMask = [true, true, true, true];
        gl_.depthMask(true);
        this._currentDepthMask = true;
        gl_.enable(gl_.BLEND);
        this._blendingEnabled = true;
        gl_.enable(gl_.DEPTH_TEST);
        gl_.depthFunc(gl_.LEQUAL);
        gl_.enable(gl_.CULL_FACE);
        gl_.cullFace(gl_.BACK);
        gl_.frontFace(gl_.CCW);
    };
    /**
     * Returns a string containing detailed information about the graphics support and driver limits of this context.
     * @returns {String}
     */
    ManagedGLContext.prototype.getInfoString = function () {
        return this.gl ?
                "WebGL version: " + this.gl.getParameter(this.gl.VERSION) + "\n" +
                "Shading language version: " + this.gl.getParameter(this.gl.SHADING_LANGUAGE_VERSION) + "\n" +
                "WebGL vendor: " + this.gl.getParameter(this.gl.VENDOR) + "\n" +
                "WebGL renderer: " + this.gl.getParameter(this.gl.RENDERER) + "\n" +
                "Available vertex shader uniform vectors: " + this._maxVertexShaderUniforms + "\n" +
                "Available vertex attributes: " + this._maxVertexAttributes + "\n" +
                "Available texture units in vertex shaders: " + this._maxVertexTextures + "\n" +
                "Available varying vectors: " + this._maxVaryings + "\n" +
                "Available fragment shader uniform vectors: " + this._maxFragmentShaderUniforms + "\n" +
                "Available texture units: " + this._maxBoundTextures + "\n" +
                "Maximum texture size: " + this._maxTextureSize + "\n" +
                "Maximum cubemap size: " + this._maxCubemapSize + "\n" +
                "Maximum renderbuffer size: " + this._maxRenderbufferSize
                :
                "N/A";
    };
    /**
     * Returns the name of this managed context.
     * @returns {String}
     */
    ManagedGLContext.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns whether antialiasing is used for this context.
     * @returns {Boolean}
     */
    ManagedGLContext.prototype.isAntialiased = function () {
        return this._antialiasing;
    };
    /**
     * Returns the type of currently set texture filtering.
     * @returns {String}
     */
    ManagedGLContext.prototype.getFiltering = function () {
        return this._filtering;
    };
    /**
     * Sets a new (minification) filtering mode and applies it to all textures that have been added to the context.
     * @param {String} value (enum TextureFiltering)
     */
    ManagedGLContext.prototype.setFiltering = function (value) {
        var i;
        value = utils.getSafeEnumValue(TextureFiltering, value, this._filtering);
        if (value !== this._filtering) {
            this._filtering = value;
            if (this._filtering === TextureFiltering.ANISOTROPIC) {
                if (!this.anisotropicFilterExt) {
                    application.log_DEBUG("Anisotropic filtering is set, but the required extension is not available. Trilinear filtering will be used.", 1);
                    this._filtering = TextureFiltering.TRILINEAR;
                }
            }
            for (i = 0; i < this._textures.length; i++) {
                if (this._textures[i].setMinFiltering) {
                    // force bind textures, as texture param changes apply to the last bound texture
                    this.bindTexture(this._textures[i], undefined, undefined, true);
                    this._textures[i].setMinFiltering(this.gl, this._filtering, this.anisotropicFilterExt);
                }
            }
        }
    };
    /**
     * Returns whether anisotropic filtering is supported for this context by the graphics driver.
     * @returns {Boolean}
     */
    ManagedGLContext.prototype.isAnisotropicFilteringAvailable = function () {
        return !!this.anisotropicFilterExt;
    };
    /**
     * Returns whether instancing is supported for this context by the graphics driver.
     * @returns {Boolean}
     */
    ManagedGLContext.prototype.isInstancingAvailable = function () {
        return !!this.instancingExt;
    };
    /**
     * Returns whether depth textures are supported for this context by the graphics driver.
     * @returns {Boolean}
     */
    ManagedGLContext.prototype.areDepthTexturesAvailable = function () {
        return !!this.depthTextureExt;
    };
    /**
     * Updates the color mask to be used for subsequent rendering, if needed.
     * @param {Boolean[4]} value Flags for the RGBA components - whether they should be updated when rendering.
     */
    ManagedGLContext.prototype.setColorMask = function (value) {
        if (this._currentColorMask[0] !== value[0] ||
                this._currentColorMask[1] !== value[1] ||
                this._currentColorMask[2] !== value[2] ||
                this._currentColorMask[3] !== value[3]) {
            this.gl.colorMask(value[0], value[1], value[2], value[3]);
            this._currentColorMask = value;
        }
    };
    /**
     * Updates the depth mask to be used for subsequent rendering, if needed.
     * @param {Boolean} value Whether the depth buffer should be updated when rendering.
     */
    ManagedGLContext.prototype.setDepthMask = function (value) {
        if (this._currentDepthMask !== value) {
            this.gl.depthMask(value);
            this._currentDepthMask = value;
        }
    };
    /**
     * Turns on blending for subsequent rendering calls.
     */
    ManagedGLContext.prototype.enableBlending = function () {
        if (!this._blendingEnabled) {
            this.gl.enable(this.gl.BLEND);
            this._blendingEnabled = true;
        }
    };
    /**
     * Turns off blending for subsequent rendering calls.
     */
    ManagedGLContext.prototype.disableBlending = function () {
        if (this._blendingEnabled) {
            this.gl.disable(this.gl.BLEND);
            this._blendingEnabled = false;
        }
    };
    /**
     * Adds the shader reference to the list of shaders to be used when the vertex
     * buffer objects are created and bound to shader attributes. (if needed)
     * @param {ManagedShader} shader
     */
    ManagedGLContext.prototype.addShader = function (shader) {
        if (this._shaders.indexOf(shader) < 0) {
            this._shaders.push(shader);
            shader.setupGLProgram(this._name, this.gl);
            this.resetReadyState();
        }
    };
    /**
     * Adds the model reference to the list of models to be used when the vertex
     * buffer objects are created and filled with data. 
     * @param {Model} model
     */
    ManagedGLContext.prototype.addModel = function (model) {
        if (this._models.indexOf(model) < 0) {
            this._models.push(model);
            this.resetReadyState();
        }
    };
    /**
     * Returns the vertex buffer with the given name, if such exists. Otherwise
     * returns undefined.
     * @param {String} name
     * @returns {VertexBuffer}
     */
    ManagedGLContext.prototype.getVertexBuffer = function (name) {
        return this._vertexBuffers[name];
    };
    /**
     * Adds the vertex buffer object given as parameter.
     * @param {VertexBuffer} vertexBuffer
     */
    ManagedGLContext.prototype.addVertexBuffer = function (vertexBuffer) {
        if (this._vertexBuffers[vertexBuffer.getName()] === undefined) {
            this._vertexBuffers[vertexBuffer.getName()] = vertexBuffer;
        }
    };
    /**
     * Returns the vertex buffer which is currently bound to the passed vertex
     * attribute index.
     * @param {Number} attributeLocation
     * @returns {VertexBuffer}
     */
    ManagedGLContext.prototype.getBoundVertexBuffer = function (attributeLocation) {
        return this._boundVertexBuffers[attributeLocation];
    };
    /**
     * Sets the vertex buffer as the currently bound buffer for the passed vertex
     * attribute index. (does not actually bind the buffer!)
     * If the buffer was not enabled (and the passed vertexBuffer is not null)
     * then also enables it (if null disables)
     * If needed for instancing, changes the attribute divisor as well.
     * @param {Number} attributeLocation
     * @param {VertexBuffer} [vertexBuffer]
     * @param {Boolean} instanced Should not be undefined!
     */
    ManagedGLContext.prototype.setBoundVertexBuffer = function (attributeLocation, vertexBuffer, instanced) {
        this._boundVertexBuffers[attributeLocation] = vertexBuffer;
        this._vertexBuffersUsed[attributeLocation] = !!vertexBuffer;
        if (vertexBuffer) {
            if (!this._vertexBuffersEnabled[attributeLocation]) {
                this.gl.enableVertexAttribArray(attributeLocation);
                this._vertexBuffersEnabled[attributeLocation] = true;
            }
            if (this.instancingExt) {
                if (instanced !== this._vertexBuffersInstanced[attributeLocation]) {
                    this.instancingExt.vertexAttribDivisorANGLE(attributeLocation, instanced ? 1 : 0);
                    this._vertexBuffersInstanced[attributeLocation] = instanced;
                }
            }
        } else {
            if (this._vertexBuffersEnabled[attributeLocation]) {
                this.gl.disableVertexAttribArray(attributeLocation);
                this._vertexBuffersEnabled[attributeLocation] = false;
            }
        }
    };
    /**
     * Mark all vertex buffers as unused (call before binding the buffers for a new shader, so the proper arrays can be enabled/disabled)
     */
    ManagedGLContext.prototype.clearVertexBufferUsage = function () {
        var i;
        for (i = 0; i < this._vertexBuffersUsed.length; i++) {
            this._vertexBuffersUsed[i] = false;
        }
    };
    /**
     * Disables the vertex attribute buffers that are enabled but not marked as used
     */
    ManagedGLContext.prototype.disableUnusedVertexBuffers = function () {
        var i;
        for (i = 0; i < this._vertexBuffersEnabled.length; i++) {
            if (this._vertexBuffersEnabled[i] && !this._vertexBuffersUsed[i]) {
                this.gl.disableVertexAttribArray(i);
                this._vertexBuffersEnabled[i] = false;
            }
        }
    };
    /**
     * Passes the data to the stored vertex buffer objects.
     * @param {Object} data The data to store in the vertex buffers. It has to be
     * an associative array storing the Float32Arrays of the data organized by the
     * role (String) of the vertex buffer they are to be stored in as the key.
     * @param {Number} startIndex The starting index in the buffers from where to
     * set the data.
     */
    ManagedGLContext.prototype.setVertexBufferData = function (data, startIndex) {
        var vbName;
        for (vbName in this._vertexBuffers) {
            if (this._vertexBuffers.hasOwnProperty(vbName)) {
                if (data[this._vertexBuffers[vbName].getRole()] !== undefined) {
                    this._vertexBuffers[vbName].setData(data[this._vertexBuffers[vbName].getRole()], startIndex);
                }
            }
        }
    };
    /**
     * Based on the stored shader references, creates a vertex buffer object to each 
     * attribute with a unique name, fills them with data using the stored model
     * references and then binds the vertex buffer objects to the corresponding
     * attribute indices.
     */
    ManagedGLContext.prototype.setupVertexBuffers = function () {
        var i, j, vbName, sumVertices, vertexAttributes, bufferSize;
        if (this.isReadyToUse() === true) {
            return;
        }
        // delete possibly previously created buffers
        for (vbName in this._vertexBuffers) {
            if (this._vertexBuffers.hasOwnProperty(vbName)) {
                this._vertexBuffers[vbName].delete(this);
            }
        }
        // counting the number of vertices we need to put into the vertex buffers
        sumVertices = 0;
        for (i = 0; i < this._models.length; i++) {
            sumVertices = sumVertices + this._models[i].getBufferSize(this);
        }
        // creating and loading an index buffer (just with ascending numbers)
        // so that drawElements can also be used for rendering
        // this code can be useful later, when actual indexed rendering will be supported
        /*var indexBufferData = new Array(sumVertices);
         for (i = 0; i < sumVertices; i++) {
         indexBufferData[i] = i;
         }
         var indexBuffer = this.gl.createBuffer();
         this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
         this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexBufferData), this.gl.STATIC_DRAW);*/
        // creating a Float32Array of the appropriate size for each needed buffer
        this._vertexBuffers = {};
        for (i = 0; i < this._shaders.length; i++) {
            vertexAttributes = this._shaders[i].getVertexAttributes();
            for (j = 0; j < vertexAttributes.length; j++) {
                this.addVertexBuffer(new VertexBuffer(vertexAttributes[j].name, vertexAttributes[j].role, vertexAttributes[j].size, sumVertices));
            }
        }
        // filling the buffer data arrays from model data
        bufferSize = 0;
        for (i = 0; i < this._models.length; i++) {
            for (j = this._models[i].getMinLOD(); j <= this._models[i].getMaxLOD(); j++) {
                bufferSize += this._models[i].loadToVertexBuffers(this, bufferSize, j);
            }
        }
        // load the data to GPU memory and bind the attributes of the shaders with 
        // the corresponding VBOs
        for (vbName in this._vertexBuffers) {
            if (this._vertexBuffers.hasOwnProperty(vbName)) {
                this._vertexBuffers[vbName].loadToGPUMemory(this._name, this.gl);
            }
        }
        // bind the vertex buffers to the vertex attribute indices in each shader
        // and save this bindings for later use when a shader is selected
        this._currentShader = null;
        for (i = 0; i < this._shaders.length; i++) {
            this.setCurrentShader(this._shaders[i]);
        }
    };
    /**
     * Returns the frame buffer with the given name, if such exists. Otherwise
     * returns undefined.
     * @param {String} name
     * @returns {FrameBuffer}
     */
    ManagedGLContext.prototype.getFrameBuffer = function (name) {
        return this._frameBuffers[name];
    };
    /**
     * Adds the passed frame buffer object to the managed context.
     * @param {FrameBuffer} frameBuffer
     * @param {Boolean} [replace=false] If true and a buffer already exists with the same name, it will be
     * replaced by this new one (otherwise, the old one is kept and the new one disregarded)
     */
    ManagedGLContext.prototype.addFrameBuffer = function (frameBuffer, replace) {
        if ((this._frameBuffers[frameBuffer.getName()] === undefined) || replace) {
            application.log_DEBUG("Adding new framebuffer '" + frameBuffer.getName() + "' to context (" + this._name + ")...", 2);
            this._frameBuffers[frameBuffer.getName()] = frameBuffer;
            if (this.isReadyToUse()) {
                this._frameBuffers[frameBuffer.getName()].setup(this);
            }
        }
    };
    /**
     * Sets up all the previously added frame buffers.
     */
    ManagedGLContext.prototype.setupFrameBuffers = function () {
        var fbName;
        if (this.isReadyToUse()) {
            return;
        }
        for (fbName in this._frameBuffers) {
            if (this._frameBuffers.hasOwnProperty(fbName)) {
                this._frameBuffers[fbName].setup(this);
            }
        }
    };
    /**
     * Deletes all the previously added frame buffers.
     */
    ManagedGLContext.prototype.clearFrameBuffers = function () {
        var fbName;
        for (fbName in this._frameBuffers) {
            if (this._frameBuffers.hasOwnProperty(fbName)) {
                this._frameBuffers[fbName].delete(this);
            }
        }
        this._frameBuffers = {};
    };
    /**
     * Does all preparations for the previously added resources (shader, models,
     * frame buffers...) that are needed to be able to start rendering. After 
     * this method, the context is ready to render any resources that have been 
     * added to it up to this point.
     */
    ManagedGLContext.prototype.setup = function () {
        application.log_DEBUG("Setting up context '" + this._name + "'...", 2);
        this.setupVertexBuffers();
        this.setupFrameBuffers();
        this.setToReady();
    };
    /**
     * Clears the stored state and the list of frame buffers of the managed context, but keeps the
     * added resources (textures, cubemaps, models, shaders)
     */
    ManagedGLContext.prototype.clear = function () {
        var i;
        application.log_DEBUG("Clearing context '" + this._name + "'...", 2);
        this.clearFrameBuffers();
        this._currentShader = null;
        for (i = 0; i < this._boundTextures.length; i++) {
            this.unbindTexture(this._boundTextures[i].texture);
        }
        this._boundTextures = [];
        for (i = 0; i < this._textures.length; i++) {
            this._textures[i].forgetLastTextureBindLocation(this._name);
        }
        for (i = 0; i < this._boundVertexBuffers.length; i++) {
            this.gl.disableVertexAttribArray(i);
        }
        this._boundVertexBuffers.length = 0;
        this._vertexBuffersUsed.length = 0;
        this._vertexBuffersEnabled.length = 0;
        this._vertexBuffersInstanced.length = 0;
    };
    /**
     * Removes all the shader added to this managed context and deletes their underlying WebGL shaders.
     * @returns {undefined}
     */
    ManagedGLContext.prototype.removeShaders = function () {
        var i;
        for (i = 0; i < this._shaders.length; i++) {
            this._shaders[i].deleteInstanceBuffers(this);
            this._shaders[i].deleteGLProgram(this._name, this.gl);
        }
        this._shaders = [];
        this._currentShader = null;
    };
    /**
     * Sets the stored framebuffer with the passed name as the current framebuffer
     * to render to. If no name (or any falsy value) is given, sets the screen 
     * as the current rendering target.
     * @param {String} [name]
     */
    ManagedGLContext.prototype.setCurrentFrameBuffer = function (name) {
        if (name) {
            this._frameBuffers[name].bind(this);
            this._hasBoundFrameBuffer = true;
        } else if (this._hasBoundFrameBuffer) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            this._hasBoundFrameBuffer = false;
        }
    };
    /**
     * Returns the currently set shader.
     * @returns {ManagedShader}
     */
    ManagedGLContext.prototype.getCurrentShader = function () {
        return this._currentShader;
    };
    /**
     * Sets up the provided shader for usage within the provided scene.
     * @param {ManagedShader} shader The shader to set as current.
     * @returns {Boolean} Whether the current shader has been changed as a result of this call
     */
    ManagedGLContext.prototype.setCurrentShader = function (shader) {
        var newBlendMode, prog;
        if (this._currentShader !== shader) {
            application.log_DEBUG("Switching to shader: " + shader.getName(), 3);
            prog = shader.getIDForContext(this._name);
            if (prog) {
                this.gl.useProgram(prog);
                newBlendMode = shader.getBlendMode();
                switch (newBlendMode) {
                    case ShaderBlendMode.MIX:
                        if (this._currentBlendMode !== newBlendMode) {
                            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                            this._currentBlendMode = newBlendMode;
                        }
                        break;
                    case ShaderBlendMode.ADD:
                        if (this._currentBlendMode !== newBlendMode) {
                            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE);
                            this._currentBlendMode = newBlendMode;
                        }
                        break;
                    case ShaderBlendMode.NONE:
                        break;
                    default:
                        application.crash();
                }
                shader.bindVertexBuffers(this);
                this._currentShader = shader;
                return true;
            }
            application.log_DEBUG("ERROR: trying to switch to non-initialized shader: '" + shader.getName() + "'!", 3);
            this._currentShader = null;
        }
        return false;
    };
    /**
     * Adds the passed texture to the list of associated textures, if needed. (so e.g. when the texture filtering mode for this context is 
     * changed, it will be changed for this texture as well)
     * @param {ManagedTexture|ManagedCubemap} texture
     */
    ManagedGLContext.prototype.addTexture = function (texture) {
        if (this._textures.indexOf(texture) < 0) {
            this._textures.push(texture);
            texture.createGLTexture(this._name, this.gl);
            this.bindTexture(texture);
            texture.setupGLTexture(this.gl, this._filtering, this.anisotropicFilterExt);
        }
    };
    /**
     * Binds the given {@link Texture} or {@link Cubemap} resource or the texture
     * associated to the given {@link FrameBuffer} resource to the given texture unit index.
     * @param {ManagedTexture|ManagedCubemap|FrameBuffer} texture The resource to bind for rendering.
     * @param {Number} place To which activeTexture place is the texture to be bound.
     * If omitted, the texture will be bound to any free unit if one is available, and 
     * to a unit with a rotating index, if no free units are available. If a specific
     * index is given, that index will be reserved for this texture, and will not be
     * automatically assigned during later binds.
     * @param {Boolean} reservePlace If true, an automatic index will be bound as if 
     * no index was specified, but that index will be reserved for the texture.
     * @param {Boolean} [force=false] If true, the texture will be rebound even if it is already bound to the same unit (to be used if
     * texture parameters are to be changed, because then the change applies to the last bound texture)
     * @return {Number} The texture unit index the texture was bound to.
     */
    ManagedGLContext.prototype.bindTexture = function (texture, place, reservePlace, force) {
        // if a specific place was given for the bind, reserve that 
        // (or the automatically found) place for this texture
        var reserved = (place !== undefined) || reservePlace;
        // if needed, determine the bind locaton automatically
        if (place === undefined) {
            // find out if there is a preferred bind location
            place = texture.getLastTextureBindLocation(this._name);
            // if there is no preferred location or another texture is bound to the preferred location,
            // find the first free place, and bind the texture there
            if ((place === undefined) || (place === FrameBuffer.prototype.TEXTURE_LOCATION_NOT_SET) || (this._boundTextures[place].texture !== texture)) {
                place = 0;
                while ((place < this._maxBoundTextures) && (place < this._boundTextures.length) && (this._boundTextures[place])) {
                    place++;
                }
                // if there is no free space left, bind to a rotating location, excluding the reserved
                // locations
                if (place === this._maxBoundTextures) {
                    while (this._boundTextures[this._nextTextureBindLocation].reserved) {
                        this._nextTextureBindLocation = (this._nextTextureBindLocation + 1) % this._maxBoundTextures;
                    }
                    place = this._nextTextureBindLocation;
                    this._nextTextureBindLocation = (this._nextTextureBindLocation + 1) % this._maxBoundTextures;
                }
            }
        }
        // only bind to it the given texture location if currenty it is unbound or a different texture is bound to it (or if forced)
        if (!this._boundTextures[place] || (this._boundTextures[place].texture !== texture) || force) {
            if (texture instanceof ManagedTexture) {
                application.log_DEBUG("Binding texture: '" + texture.getName() + "' to texture unit " + place + (reserved ? ", reserving place." : "."), 3);
                texture.bindGLTexture(this._name, this.gl, place);
            } else
            if (texture instanceof ManagedCubemap) {
                application.log_DEBUG("Binding cubemap texture: '" + texture.getName() + "' to texture unit " + place + (reserved ? ", reserving place." : "."), 3);
                texture.bindGLTexture(this._name, this.gl, place);
            } else
            if (texture instanceof FrameBuffer) {
                application.log_DEBUG("Binding framebuffer texture: '" + texture.getName() + "' to texture unit " + place + (reserved ? ", reserving place." : "."), 3);
                texture.bindGLTexture(this.gl, place);
            } else {
                application.showError("Cannot set object: '" + texture.toString() + "' as current texture, because it is not of an appropriate type.");
            }
            this._boundTextures[place] = {texture: texture, reserved: reserved};
        }
        // make sure the reserve state is updated even if no bind happened
        if (this._boundTextures[place].reserved !== reserved) {
            this._boundTextures[place].reserved = reserved;
            application.log_DEBUG((reserved ? "Reserved" : "Freed") + " texture unit index " + place + ".", 3);
        }
        return place;
    };
    /**
     * If the passed texture is currently bound to a texture unit, removes that binding.
     * @param {ManagedTexture|ManagedCubemap|Framebuffer} texture
     */
    ManagedGLContext.prototype.unbindTexture = function (texture) {
        var place = texture && texture.getLastTextureBindLocation(this._name);
        if ((place !== undefined) && (place >= 0) && (this._boundTextures[place] === texture)) {
            this.gl.activeTexture(this.gl.TEXTURE0 + place);
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, null);
            this._boundTextures[place] = null;
            texture.forgetLastTextureBindLocation(this._name);
        }
    };
    /**
     * Removes the passed texture if it has been added to the context before as well as deletes its underlying WebGL texture object.
     * @param {ManagedTexture|ManagedCubemap} texture
     */
    ManagedGLContext.prototype.removeTexture = function (texture) {
        var index = this._textures.indexOf(texture);
        if (index >= 0) {
            this.unbindTexture(texture);
            texture.deleteGLTexture(this._name, this.gl);
            this._textures.splice(index, 1);
        }
    };
    /**
     * Returns whether the graphics driver's support level satisfies the given requirements.
     * @param {ManagedShader~ShaderRequirements} requirements
     * @returns {Boolean}
     */
    ManagedGLContext.prototype.satisfiesRequirements = function (requirements) {
        return (this._maxVertexAttributes >= requirements.requiredAttributeVectors) &&
                (this._maxVertexShaderUniforms >= requirements.requiredVertexUniformVectors) &&
                (this._maxVaryings >= requirements.requiredVaryingVectors) &&
                (this._maxFragmentShaderUniforms >= requirements.requiredFragmentUniformVectors) &&
                (this._maxBoundTextures >= requirements.requiredTextureUnits);
    };
    /**
     * Returns the maximum size of textures supported by the graphics driver for this context.
     * @returns {Number}
     */
    ManagedGLContext.prototype.getMaxTextureSize = function () {
        return this._maxTextureSize;
    };
    /**
     * Returns the maximum size of cube mapped textures supported by the graphics driver for this context.
     * @returns {Number}
     */
    ManagedGLContext.prototype.getMaxCubemapSize = function () {
        return this._maxCubemapSize;
    };
    /**
     * Returns the maximum size of render buffers supported by the graphics driver for this context.
     * @returns {Number}
     */
    ManagedGLContext.prototype.getMaxRenderbufferSize = function () {
        return this._maxRenderbufferSize;
    };
    // -------------------------------------------------------------------------
    // Augmenting application
    /**
     * Displays information about an error that has occured in relation with WebGL,
     * adding some basic WebGL support info for easier troubleshooting.
     * @param {String} message A brief error message to show.
     * @param {String} [severity] (enum application.ErrorSeverity) The severity level of the error.
     * @param {String} [details] Additional details to show about the error,
     * with possible explanations or tips how to correct this error.
     */
    application.showGraphicsError = function (message, severity, details) {
        application.showError(message, severity, (details ? (details + "\n\n") : "") + "This is a graphics related error.\n" +
                "Information about your graphics support:\n" +
                _genericContext.getInfoString());
    };
    // -------------------------------------------------------------------------
    // Initizalization
    _genericContext = new ManagedGLContext("", document.createElement("canvas"), true, true, TextureFiltering.BILINEAR, true);
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        TextureFiltering: TextureFiltering,
        ShaderVariableType: ShaderVariableType,
        ShaderBlendMode: ShaderBlendMode,
        getUniformName: ShaderUniform.prototype.getUniformName,
        getTextureUniformRawName: ShaderUniform.prototype.getTextureUniformRawName,
        getCubemapUniformRawName: ShaderUniform.prototype.getCubemapUniformRawName,
        ManagedTexture: ManagedTexture,
        ManagedCubemap: ManagedCubemap,
        ManagedShader: ManagedShader,
        FrameBuffer: FrameBuffer,
        ManagedGLContext: ManagedGLContext,
        requirementsAreSatisfied: _genericContext.satisfiesRequirements.bind(_genericContext),
        getMaxTextureSize: _genericContext.getMaxTextureSize.bind(_genericContext),
        getMaxCubemapSize: _genericContext.getMaxCubemapSize.bind(_genericContext),
        getMaxRenderbufferSize: _genericContext.getMaxRenderbufferSize.bind(_genericContext),
        isAntialiasingAvailable: _genericContext.isAntialiased.bind(_genericContext),
        isAnisotropicFilteringAvailable: _genericContext.isAnisotropicFilteringAvailable.bind(_genericContext),
        isInstancingAvailable: _genericContext.isInstancingAvailable.bind(_genericContext),
        areDepthTexturesAvailable: _genericContext.areDepthTexturesAvailable.bind(_genericContext)
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides functions that work on arrays of numbers as mathematical vectors.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, Float32Array */

define('utils/vectors',[],function () {
    "use strict";
    var vec = {},
            // -----------------------------------------------------------------------------
            // Constants
            CLOSE_TO_ONE = 0.99999,
            CLOSE_TO_ZERO = 0.0000001,
            /**
             * The number of auxiliary vectors that should be created.
             * @type Number
             */
            AUX_VECTOR_COUNT = 20,
            // ----------------------------------------------------------------------
            // private variables
            /**
             * Stores auxiliary vectors used for holding the results of temporary calculations. Operations returning a new vector can have
             * an alternate version which uses one of the auxiliary vectors, thus avoiding creating a new array. This can
             * be utilized by the users of this library by using the auxiliary version where the result is not persistently needed.
             * There is a fixed amount of these vectors available and the operations cycle through them, so they can be used in (not too
             * deep) combined operations, but not for recursion.
             * @type Number[4][]
             */
            _auxVectors = [],
            /**
             * The index of the auxiliary vector to be used for the next auxiliary vector operation.
             * @type Number
             */
            _auxVectorIndex = 0,
            /**
             * An auxiliary 3D vector using typed array that can be used to convert a regular vector to a format to be passed as a shader
             * uniform without creating a new Float32Array.
             * @type Float32Array
             */
            _auxFloatVector3 = new Float32Array([0, 0, 0]),
            /**
             * An auxiliary 4D vector using typed array that can be used to convert a regular vector to a format to be passed as a shader
             * uniform without creating a new Float32Array.
             * @type Float32Array
             */
            _auxFloatVector4 = new Float32Array([0, 0, 0, 0]);
    // -----------------------------------------------------------------------------
    // Constant vectors
    /**
     * A constant 3D null vector.
     * @type Number[3]
     */
    vec.NULL3 = [0, 0, 0];
    Object.freeze(vec.NULL3);
    /**
     * A constant 4D null vector.
     * @type Number[4]
     */
    vec.NULL4 = [0, 0, 0, 0];
    Object.freeze(vec.NULL4);
    /**
     * A constant 4D null position vector (W is 1)
     * @type Number[4]
     */
    vec.NULL4W1 = [0, 0, 0, 1];
    Object.freeze(vec.NULL4W1);
    /**
     * A constant 2D unit vector pointing towards the positive X direction.
     * @type Number[3]
     */
    vec.UNIT2_X = [1, 0];
    Object.freeze(vec.UNIT2_X);
    /**
     * A constant 2D unit vector pointing towards the positive Y direction.
     * @type Number[3]
     */
    vec.UNIT2_Y = [0, 1];
    Object.freeze(vec.UNIT2_Y);
    /**
     * A constant 3D unit vector pointing towards the positive X direction.
     * @type Number[3]
     */
    vec.UNIT3_X = [1, 0, 0];
    Object.freeze(vec.UNIT3_X);
    /**
     * A constant 3D unit vector pointing towards the positive Y direction.
     * @type Number[3]
     */
    vec.UNIT3_Y = [0, 1, 0];
    Object.freeze(vec.UNIT3_Y);
    /**
     * A constant 3D unit vector pointing towards the positive Z direction.
     * @type Number[3]
     */
    vec.UNIT3_Z = [0, 0, 1];
    Object.freeze(vec.UNIT3_Z);
    // -----------------------------------------------------------------------------
    // Functions that create a vector
    /**
     * Returns a 3D vector that is perpendicular to the passed 3D vector (one of the infinite possibilities)
     * @param {Number[3]} v
     * @returns {Number[3]}
     */
    vec.perpendicular3 = function (v) {
        return [v[1], -v[0], 0];
    };
    /**
     * Converts the passed vector to a 3D Float32Array using an auxiliary vector instead of creating a new one. To be used when passing
     * a vector as a shader uniform.
     * @param {Number[3]} v
     * @returns {Float32Array}
     */
    vec.floatVector3Aux = function (v) {
        _auxFloatVector3[0] = v[0];
        _auxFloatVector3[1] = v[1];
        _auxFloatVector3[2] = v[2];
        return _auxFloatVector3;
    };
    /**
     * Converts the passed vector to a 4D Float32Array using an auxiliary vector instead of creating a new one. To be used when passing
     * a vector as a shader uniform.
     * @param {Number[4]} v
     * @returns {Float32Array}
     */
    vec.floatVector4Aux = function (v) {
        _auxFloatVector4[0] = v[0];
        _auxFloatVector4[1] = v[1];
        _auxFloatVector4[2] = v[2];
        _auxFloatVector4[3] = v[3];
        return _auxFloatVector4;
    };
    // -----------------------------------------------------------------------------
    // Functions of a single vector
    /**
     * Returns the length of a 2D vector.
     * @param {Number[2]} v The 2D vector.
     * @returns {Number} Length of v.
     */
    vec.length2 = function (v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };
    /**
     * Returns the length of a 3D vector.
     * @param {Number[3]} v The 3D vector.
     * @returns {Number} Length of v.
     */
    vec.length3 = function (v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    };
    /**
     * Returns the square of the length of a 3D vector.
     * @param {Number[3]} v The 3D vector.
     * @returns {Number} The squared of the length of v.
     */
    vec.length3Squared = function (v) {
        return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    };
    /**
     * Returns a string representation of the given 3D vector.
     * @param {Number[3]} v A 3D vector.
     * @param {Number} [decimals=2] The number of decimals to show for the vector's
     * components.
     * @returns {String}
     */
    vec.toString3 = function (v, decimals) {
        decimals = decimals || 2;
        return v[0].toFixed(decimals) + " " + v[1].toFixed(decimals) + " " + v[2].toFixed(decimals);
    };
    /**
     * Returns a string representation of the given 4D vector.
     * @param {Number[4]} v A 4D vector.
     * @param {Number} [decimals=2] The number of decimals to show for the vector's
     * components.
     * @returns {String}
     */
    vec.toString4 = function (v, decimals) {
        decimals = decimals || 2;
        return v[0].toFixed(decimals) + " " + v[1].toFixed(decimals) + " " + v[2].toFixed(decimals) + " " + v[3].toFixed(decimals);
    };
    /**
     * @typedef {Object} YawAndPitch
     * @property {Number} yaw The yaw angle in radians
     * @property {Number} pitch The pitch angle in radians
     */
    /**
     * Returns a pair of angles: (yaw;pitch) describing the direction of the passed vectors, with (0;0) corresponding to the positive Y 
     * direction, a positive yaw corresponding to a counter-clockwise rotation angle around the Z axis in radians and the pitch 
     * corresponding to a counter-clockwise rotation around the yaw-rotated X axis in radians.
     * @param {Number[3]} v
     * @returns {YawAndPitch}
     */
    vec.getYawAndPitch = function (v) {
        var result = {}, yawRotated;
        if (Math.abs(v[2]) > CLOSE_TO_ONE) {
            result.yaw = 0;
            result.pitch = (v[2] > 0) ? -Math.PI / 2 : Math.PI / 2;
        } else {
            result.yaw = vec.angle2yCapped(v[0], v[1]);
            if (v[0] > 0) {
                result.yaw = -result.yaw;
            }
            yawRotated = vec.rotated2(v, -result.yaw);
            result.pitch = vec.angle2xCapped(yawRotated[1], v[2]);
            if (v[2] < 0) {
                result.pitch = -result.pitch;
            }
        }
        return result;
    };
    /**
     * @typedef {Object} YawAndRoll
     * @property {Number} yaw The yaw angle in radians
     * @property {Number} roll The roll angle in radians
     */
    /**
     * Returns a pair of angles: (yaw;roll) describing the direction of the passed vectors, with (0;0) corresponding to the positive Y 
     * direction, a positive yaw corresponding to a counter-clockwise rotation angle around the Z axis in radians and the roll 
     * corresponding to a counter-clockwise rotation around the Y axis in radians.
     * @param {Number[3]} v
     * @param {Boolean} [positiveYawOnly=false] When true, larger than 90 degrees roll angles will be returned with positive yaw angles
     * instead of flipping the roll angle 180 degrees and inverting the yaw angle.
     * @returns {YawAndRoll}
     */
    vec.getRollAndYaw = function (v, positiveYawOnly) {
        var result = {}, rollRotated;
        if (Math.abs(v[1]) > CLOSE_TO_ONE) {
            result.roll = 0;
            result.yaw = (v[1] > 0) ? 0 : Math.PI;
        } else {
            result.roll = vec.angle2xCapped(v[0], v[2]);
            if (v[2] < 0) {
                result.roll = -result.roll;
            }
            rollRotated = vec.rotated2([v[0], v[2]], -result.roll);
            result.yaw = vec.angle2yCapped(rollRotated[0], v[1]);
            if (!positiveYawOnly && (Math.abs(result.roll) > Math.PI / 2)) {
                result.yaw = -result.yaw;
                result.roll -= Math.PI * Math.sign(result.roll);
            }
        }
        return result;
    };
    /**
     * @typedef {Object} PitchAndRoll
     * @property {Number} pitch The pitch angle in radians
     * @property {Number} roll The roll angle in radians
     */
    /**
     * Returns a pair of angles: (pitch;roll) describing the direction of the passed vectors, with (0;0) corresponding to the positive Y 
     * direction, a positive pitch corresponding to a counter-clockwise rotation angle around the X axis in radians and the roll 
     * corresponding to a counter-clockwise rotation around the Y axis in radians.
     * @param {Number[3]} v
     * @param {Boolean} [positivePitchOnly=false] When true, larger than 90 degrees roll angles will be returned with positive pitch angles
     * instead of flipping the roll angle 180 degrees and inverting the pitch angle.
     * @returns {PitchAndRoll}
     */
    vec.getRollAndPitch = function (v, positivePitchOnly) {
        var result = {}, rollRotated;
        if (Math.abs(v[1]) > CLOSE_TO_ONE) {
            result.roll = 0;
            result.pitch = (v[1] > 0) ? 0 : Math.PI;
        } else {
            result.roll = vec.angle2yCapped(v[0], v[2]);
            if (v[0] > 0) {
                result.roll = -result.roll;
            }
            rollRotated = vec.rotated2([v[0], v[2]], -result.roll);
            result.pitch = vec.angle2xCapped(v[1], rollRotated[1]);
            if (!positivePitchOnly && (Math.abs(result.roll) > Math.PI / 2)) {
                result.pitch = -result.pitch;
                result.roll -= Math.PI * Math.sign(result.roll);
            }
        }
        return result;
    };
    // -----------------------------------------------------------------------------
    // Functions that transform a vector and return a new, transformed vector

    /**
     * Returns a 4D vector created from a 3D one by appending the given w component.
     * @param {Number[3]} v The original 3D vector.
     * @param {Number} w The W component to be added.
     * @returns {Number[4]} A 4D vector with the components of v, with w appended.
     */
    vec.vector4From3 = function (v, w) {
        return [v[0], v[1], v[2], w];
    };
    /**
     * Returns a 4D vector created from a 3D one by appending 1.0 to it.
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[3]} v The original 3D vector.
     * @returns {Number[4]} A 4D vector with the components of v, with 1.0 appended.
     */
    vec.vector4From3Aux = function (v) {
        var aux = _auxVectors[_auxVectorIndex];
        aux[0] = v[0];
        aux[1] = v[1];
        aux[2] = v[2];
        aux[3] = 1;
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns a 3D vector with the passed coordinates
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @returns {Number[3]}
     */
    vec.vector3Aux = function (x, y, z) {
        var aux = _auxVectors[_auxVectorIndex];
        aux[0] = x;
        aux[1] = y;
        aux[2] = z;
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns the (1,0,0) 3D X unit vector
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @returns {Number[3]}
     */
    vec.x3Aux = function () {
        var aux = _auxVectors[_auxVectorIndex];
        aux[0] = 1;
        aux[1] = 0;
        aux[2] = 0;
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns the (0,1,0) 3D Y unit vector
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @returns {Number[3]}
     */
    vec.y3Aux = function () {
        var aux = _auxVectors[_auxVectorIndex];
        aux[0] = 0;
        aux[1] = 1;
        aux[2] = 0;
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns the (0,0,1) 3D Z unit vector
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @returns {Number[3]}
     */
    vec.z3Aux = function () {
        var aux = _auxVectors[_auxVectorIndex];
        aux[0] = 0;
        aux[1] = 0;
        aux[2] = 1;
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns the passed 2D vector scaled to unit length.
     * @param {Number[2]} v A 2D vector
     * @returns {Number[2]} The normalized 3D vector.
     */
    vec.normal2 = function (v) {
        var
                divisor = Math.sqrt(v[0] * v[0] + v[1] * v[1]),
                factor = (divisor === 0) ? 1.0 : 1.0 / divisor;
        return [v[0] * factor, v[1] * factor];
    };
    /**
     * Returns the passed 3D vector scaled to unit length.
     * @param {Number[3]} v A 3D vector
     * @returns {Number[3]} The normalized 3D vector.
     */
    vec.normal3 = function (v) {
        var
                divisor = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]),
                factor = (divisor === 0) ? 1.0 : 1.0 / divisor;
        return [v[0] * factor, v[1] * factor, v[2] * factor];
    };
    /**
     * Returns the passed 3D vector scaled to unit length.
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[3]} v A 3D vector
     * @returns {Number[3]} The normalized 3D vector.
     */
    vec.normal3Aux = function (v) {
        var
                divisor = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]),
                factor = (divisor === 0) ? 1.0 : 1.0 / divisor,
                aux = _auxVectors[_auxVectorIndex];
        aux[0] = v[0] * factor;
        aux[1] = v[1] * factor;
        aux[2] = v[2] * factor;
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns a 2D vector multiplied by a scalar.
     * @param {Number[2]} v A 2D vector.
     * @param {Number} s A scalar.
     * @returns {Number[2]} v multiplied by s.
     */
    vec.scaled2 = function (v, s) {
        return [
            v[0] * s, v[1] * s
        ];
    };
    /**
     * Returns a 3D vector multiplied by a scalar.
     * @param {Number[3]} v A 3D vector.
     * @param {Number} s A scalar.
     * @returns {Number[3]} v multiplied by s.
     */
    vec.scaled3 = function (v, s) {
        return [
            v[0] * s, v[1] * s, v[2] * s
        ];
    };
    /**
     * Returns a 3D vector multiplied by a scalar.
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[3]} v A 3D vector.
     * @param {Number} s A scalar.
     * @returns {Number[3]} v multiplied by s.
     */
    vec.scaled3Aux = function (v, s) {
        var aux = _auxVectors[_auxVectorIndex];
        aux[0] = v[0] * s;
        aux[1] = v[1] * s;
        aux[2] = v[2] * s;
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns a 4D vector multiplied by a scalar.
     * @param {Number[4]} v A 3D vector.
     * @param {Number} s A scalar.
     * @returns {Number[4]} v multiplied by s.
     */
    vec.scaled4 = function (v, s) {
        return [
            v[0] * s, v[1] * s, v[2] * s, v[3] * s
        ];
    };
    /**
     * Returns the vector which Rotating the given 2D vector (or the first to components of a 3D, 4D vector) counter-clockwise results in.
     * @param {Number[2]} v 
     * @param {Number} angle The angle of rotation, in radians
     * @returns {Number[2]} 
     */
    vec.rotated2 = function (v, angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle),
                result = [0, 0];
        result[0] = v[0] * cosAngle + v[1] * -sinAngle;
        result[1] = v[0] * sinAngle + v[1] * cosAngle;
        return result;
    };

    // -----------------------------------------------------------------------------
    // Functions and operations with two vectors

    /**
     * Returns the sum of two 3D vectors.
     * @param {Number[3]} v1 The first 3D vector.
     * @param {Number[3]} v2 The second 3D vector.
     * @returns {Number[3]} The sum of v1 and v2.
     */
    vec.sum3 = function (v1, v2) {
        return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
    };
    /**
     * Returns the sum of the 3D vectors given in the passed array.
     * @param {Number[3][]} vectors
     * @returns {Number[3]}
     */
    vec.sumArray3 = function (vectors) {
        var result = [0, 0, 0], i;
        for (i = 0; i < vectors.length; i++) {
            result[0] += vectors[i][0];
            result[1] += vectors[i][1];
            result[2] += vectors[i][2];
        }
        return result;
    };
    /**
     * Returns the difference of two 3D vectors.
     * @param {Number[3]} v1 The first 3D vector.
     * @param {Number[3]} v2 The second 3D vector.
     * @returns {Number[3]} The difference of v1 and v2.
     */
    vec.diff3 = function (v1, v2) {
        return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
    };
    /**
     * Returns the difference of two 3D vectors.
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[3]} v1 The first 3D vector.
     * @param {Number[3]} v2 The second 3D vector.
     * @returns {Number[3]} The difference of v1 and v2.
     */
    vec.diff3Aux = function (v1, v2) {
        var aux = _auxVectors[_auxVectorIndex];
        aux[0] = v1[0] - v2[0];
        aux[1] = v1[1] - v2[1];
        aux[2] = v1[2] - v2[2];
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns the difference of the 3D translation components of two 4x4 transformation matrices.
     * @param {Float32Array} m1 The first 4x4 matrix.
     * @param {Float32Array} m2 The second 4x4 matrix.
     * @returns {Number[3]}
     */
    vec.diffTranslation3 = function (m1, m2) {
        return [m1[12] - m2[12], m1[13] - m2[13], m1[14] - m2[14]];
    };
    /**
     * Returns the difference of the 3D translation components of two 4x4 transformation matrices.
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m1 The first 4x4 matrix.
     * @param {Float32Array} m2 The second 4x4 matrix.
     * @returns {Number[3]}
     */
    vec.diffTranslation3Aux = function (m1, m2) {
        var aux = _auxVectors[_auxVectorIndex];
        aux[0] = m1[12] - m2[12];
        aux[1] = m1[13] - m2[13];
        aux[2] = m1[14] - m2[14];
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns the dot product of the 2 given 3D vectors.
     * @param {Number[3]} v1 A 3D vector.
     * @param {Number[3]} v2 A 3D vector.
     * @returns {Number} The dot product.
     */
    vec.dot3 = function (v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    };
    /**
     * Returns the cross product of the 2 given 3D vectors.
     * @param {Number[3]} v1 A 3D vector.
     * @param {Number[3]} v2 A 3D vector.
     * @returns {Number[3]} The cross product.
     */
    vec.cross3 = function (v1, v2) {
        return [
            v1[1] * v2[2] - v1[2] * v2[1],
            v1[2] * v2[0] - v1[0] * v2[2],
            v1[0] * v2[1] - v1[1] * v2[0]
        ];
    };
    /**
     * Returns the angle of the two 2D unit vectors in radians.
     * @param {Number[2]} v1 The first 2D vector.
     * @param {Number[2]} v2 The second 2D vector.
     * @returns {Number} The angle in radian.
     */
    vec.angle2u = function (v1, v2) {
        return Math.acos(v1[0] * v2[0] + v1[1] * v2[1]);
    };
    /**
     * Returns the angle of the a 2D vector and the X unit vector
     * Returns NaN for null vectors!
     * @param {Number} x The x coordinate of the vector
     * @param {Number} y The y coordinate of the vector
     * @returns {Number} The angle in radian.
     */
    vec.angle2x = function (x, y) {
        return Math.acos(x / Math.sqrt(x * x + y * y));
    };
    /**
     * Returns the angle of the a 2D vector and the Y unit vector
     * Returns NaN for null vectors!
     * @param {Number} x The x coordinate of the vector
     * @param {Number} y The y coordinate of the vector
     * @returns {Number} The angle in radian.
     */
    vec.angle2y = function (x, y) {
        return Math.acos(y / Math.sqrt(x * x + y * y));
    };
    /**
     * Returns the angle of the two 2D unit vectors in radians. The dot product
     * of the vectors is capped between -1.0 and 1.0, and so this cannot return
     * NaN accidentally (with the product falling slightly out of range due to
     * float inaccuracy)
     * @param {Number[2]} v1 The first 2D vector.
     * @param {Number[2]} v2 The second 2D vector.
     * @returns {Number} The angle in radian.
     */
    vec.angle2uCapped = function (v1, v2) {
        return (Math.acos(Math.min(Math.max(-1.0, v1[0] * v2[0] + v1[1] * v2[1]), 1.0)));
    };
    /**
     * Returns the angle of the a 2D vector and the X unit vector. This cannot return
     * NaN accidentally (with the cosine slightly out of range due to float inaccuracy)
     * Still, (consistently) returns NaN for null vectors!
     * @param {Number} x The x coordinate of the vector
     * @param {Number} y The y coordinate of the vector
     * @returns {Number} The angle in radian.
     */
    vec.angle2xCapped = function (x, y) {
        return Math.acos(Math.min(Math.max(-1.0, x / Math.sqrt(x * x + y * y)), 1.0));
    };
    /**
     * Returns the angle of the a 2D vector and the Y unit vector. This cannot return
     * NaN accidentally (with the cosine slightly out of range due to float inaccuracy)
     * Still, (consistently) returns NaN for null vectors!
     * @param {Number} x The x coordinate of the vector
     * @param {Number} y The y coordinate of the vector
     * @returns {Number} The angle in radian.
     */
    vec.angle2yCapped = function (x, y) {
        return Math.acos(Math.min(Math.max(-1.0, y / Math.sqrt(x * x + y * y)), 1.0));
    };
    /**
     * Returns the angle of the two 3D unit vectors in radians.
     * @param {Number[3]} v1 A 3D unit vector.
     * @param {Number[3]} v2 A 3D unit vector.
     * @returns {Number} The angle in radian.
     */
    vec.angle3u = function (v1, v2) {
        return Math.acos(v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]);
    };
    /**
     * Returns the angle of the two 3D unit vectors in radians. The dot product
     * of the vectors is capped between -1.0 and 1.0, and so this cannot return
     * NaN accidentally (with the product falling slightly out of range due to
     * float inaccuracy)
     * @param {Number[3]} v1 A 3D unit vector.
     * @param {Number[3]} v2 A 3D unit vector.
     * @returns {Number} The angle in radian.
     */
    vec.angle3uCapped = function (v1, v2) {
        return Math.acos(Math.min(Math.max(-1.0, v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]), 1.0));
    };

    // -----------------------------------------------------------------------------
    // Multiplying vectors with matrices.

    /**
     * Multiplies the given 3D row vector with the given 3x3 matrix. (from the right)
     * @param {Number[3]} v A 3D vector.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Number[3]} v*m
     */
    vec.prodVec3Mat3 = function (v, m) {
        return [
            m[0] * v[0] + m[3] * v[1] + m[6] * v[2],
            m[1] * v[0] + m[4] * v[1] + m[7] * v[2],
            m[2] * v[0] + m[5] * v[1] + m[8] * v[2]
        ];
    };
    /**
     * Multiplies the given 3D row vector with the given 3x3 matrix. (from the right)
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[3]} v A 3D vector.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Number[3]} v*m
     */
    vec.prodVec3Mat3Aux = function (v, m) {
        var aux = _auxVectors[_auxVectorIndex];
        vec.setProdVec3Mat3(aux, v, m);
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Multiplies the given 3D row vector with the top left 3x3 submatrix of the 
     * given 4x4 matrix. (from the right)
     * @param {Number[3]} v A 3D vector.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[3]} v*m'
     */
    vec.prodVec3Mat4 = function (v, m) {
        return [
            m[0] * v[0] + m[4] * v[1] + m[8] * v[2],
            m[1] * v[0] + m[5] * v[1] + m[9] * v[2],
            m[2] * v[0] + m[6] * v[1] + m[10] * v[2]
        ];
    };
    /**
     * Multiplies the given 3D row vector with the top left 3x3 submatrix of the the given 4x4 matrix. (from the right)
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[3]} v A 3D vector.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[3]} v*m
     */
    vec.prodVec3Mat4Aux = function (v, m) {
        var aux = _auxVectors[_auxVectorIndex];
        vec.setProdVec3Mat4(aux, v, m);
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Multiplies the given 4D row vector with the given 4x4 matrix. (from the right)
     * @param {Number[4]} v A 4D vector.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]} v*m
     */
    vec.prodVec4Mat4 = function (v, m) {
        return [
            m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3],
            m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3],
            m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3],
            m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3]
        ];
    };
    /**
     * Returns the product of the given 4D row vector with the given 4x4 matrix. (from the right)
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[4]} v A 4D vector.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]} v*m
     */
    vec.prodVec4Mat4Aux = function (v, m) {
        var aux = _auxVectors[_auxVectorIndex];
        vec.setProdVec4Mat4(aux, v, m);
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Multiplies the a 4D row vector: (X, 0, 0, 1) with the given 4x4 matrix. (from the right)
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number} x The X coordinate of the vector
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]} v*m
     */
    vec.prodVecX4Mat4Aux = function (x, m) {
        var aux = _auxVectors[_auxVectorIndex];
        vec.setProdVecX4Mat4(aux, x, m);
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Multiplies the a 4D row vector: (0, Y, 0, 1) with the given 4x4 matrix. (from the right)
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number} y The Y coordinate of the vector
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]} v*m
     */
    vec.prodVecY4Mat4Aux = function (y, m) {
        var aux = _auxVectors[_auxVectorIndex];
        vec.setProdVecY4Mat4(aux, y, m);
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Returns the product of the translation component of a 4x4 matrix and a 4x4 model matrix (a matrix
     * with translation, rotation and scaling, but no projection)
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[4]} tm A 4x4 transformation matrix (only the translation component is considered)
     * @param {Float32Array} mm A 4x4 model matrix
     * @returns {Number[4]} Only the first three components are set
     */
    vec.prodTranslationModel3Aux = function (tm, mm) {
        var aux = _auxVectors[_auxVectorIndex];
        vec.setProdTranslationModel3(aux, tm, mm);
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Multiplies the given 3x3 matrix with the given 3D row vector. (from the right)
     * @param {Float32Array} m A 3x3 matrix.
     * @param {Number[3]} v A 3D vector.
     * @returns {Number[3]} m*v
     */
    vec.prodMat3Vec3 = function (m, v) {
        return [
            m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
            m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
            m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
        ];
    };
    /**
     * Multiplies the given 3D row vector with the top left 3x3 submatrix of the 
     * given 4x4 matrix. (from the left)
     * @param {Float32Array} m A 4x4 matrix.
     * @param {Number[3]} v A 3D vector.
     * @returns {Number[3]} m'*v
     */
    vec.prodMat4Vec3 = function (m, v) {
        return [
            m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
            m[4] * v[0] + m[5] * v[1] + m[6] * v[2],
            m[8] * v[0] + m[9] * v[1] + m[10] * v[2]
        ];
    };
    /**
     * Multiplies the given 4x4 matrix with the given 4D row vector. (from the right)
     * @param {Float32Array} m A 4x4 matrix.
     * @param {Number[4]} v A 4D vector.
     * @returns {Number[4]} m*v
     */
    vec.prodMat4Vec4 = function (m, v) {
        return [
            m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3],
            m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3],
            m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3],
            m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]
        ];
    };
    // -----------------------------------------------------------------------------
    // Functions that modify an existing vector
    /**
     * Modifies the passed 3D vector, setting it to a null vector.
     * @param {Number[3]} v
     */
    vec.setNull3 = function (v) {
        v[0] = 0;
        v[1] = 0;
        v[2] = 0;
    };
    /**
     * Modifies the passed 3D vector, to be identical to the second passed vector.
     * @param {Number[3]} left A 3D vector
     * @param {Number[3]} right A 3D vector
     */
    vec.setVector3 = function (left, right) {
        left[0] = right[0];
        left[1] = right[1];
        left[2] = right[2];
    };
    /**
     * Modifies the passed 4D vector, to be identical to the second passed vector.
     * @param {Number[4]} left A 4D vector
     * @param {Number[4]} right A 4D vector
     */
    vec.setVector4 = function (left, right) {
        left[0] = right[0];
        left[1] = right[1];
        left[2] = right[2];
        left[3] = right[3];
    };
    /**
     * Negates the passed 2D vector
     * @param {Number[2]} v
     */
    vec.negate2 = function (v) {
        v[0] = -v[0];
        v[1] = -v[1];
    };
    /**
     * Scales the passed 2D vector to unit length.
     * @param {Number[2]} v A 2D vector
     * @returns {Number[2]} v
     */
    vec.normalize2 = function (v) {
        var
                divisor = Math.sqrt(v[0] * v[0] + v[1] * v[1]),
                factor = (divisor === 0) ? 1.0 : 1.0 / divisor;
        v[0] *= factor;
        v[1] *= factor;
        return v;
    };
    /**
     * Scales the passed 3D vector to unit length.
     * @param {Number[3]} v A 3D vector
     * @returns {Number[3]} v
     */
    vec.normalize3 = function (v) {
        var
                divisor = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]),
                factor = (divisor === 0) ? 1.0 : 1.0 / divisor;
        v[0] *= factor;
        v[1] *= factor;
        v[2] *= factor;
        return v;
    };
    /**
     * Normalizes the passed 4D vector by dividing all its coordinates by the last (4th) coordinate.
     * @param {Number[4]} v
     */
    vec.normalize4D = function (v) {
        v[3] = v[3] || CLOSE_TO_ZERO;
        v[0] /= v[3];
        v[1] /= v[3];
        v[2] /= v[3];
        v[3] = 1;
    };
    /**
     * Multiplies the passed 3D vector with the passed scalar and then returns it.
     * @param {Number[3]} v
     * @param {Number} s
     * @returns {Number[3]} v
     */
    vec.scale3 = function (v, s) {
        v[0] *= s;
        v[1] *= s;
        v[2] *= s;
        return v;
    };
    /**
     * Modifies the pased 3D vector, setting it to be the sum of the other two passed vectors
     * @param {Number[3]} v The 3D vector to modify
     * @param {Number[3]} v1
     * @param {Number[3]} v2
     */
    vec.setSum3 = function (v, v1, v2) {
        v[0] = v1[0] + v2[0];
        v[1] = v1[1] + v2[1];
        v[2] = v1[2] + v2[2];
    };
    /**
     * Adds the 3D vector v2 to the 3D vector v1, modifying v1 in-place.
     * @param {Number[3]} v1
     * @param {Number[3]} v2
     */
    vec.add3 = function (v1, v2) {
        v1[0] += v2[0];
        v1[1] += v2[1];
        v1[2] += v2[2];
    };
    /**
     * Modifies the pased 3D vector, setting it to be the difference of the other two passed vectors
     * @param {Number[3]} v The 3D vector to modify
     * @param {Number[3]} v1
     * @param {Number[3]} v2
     */
    vec.setDiff3 = function (v, v1, v2) {
        v[0] = v1[0] - v2[0];
        v[1] = v1[1] - v2[1];
        v[2] = v1[2] - v2[2];
    };
    /**
     * Subtracts the 3D vector v2 to the 3D vector v1, modifying v1 in-place.
     * @param {Number[3]} v1
     * @param {Number[3]} v2
     */
    vec.sub3 = function (v1, v2) {
        v1[0] -= v2[0];
        v1[1] -= v2[1];
        v1[2] -= v2[2];
    };
    /**
     * Cross multiplies the passed v1 vector with v2 in-place.
     * @param {Number[3]} v1 A 3D vector.
     * @param {Number[3]} v2 A 3D vector.
     */
    vec.mulCross3 = function (v1, v2) {
        var v30 = v1[0], v31 = v1[1], v32 = v1[2];
        v1[0] = v31 * v2[2] - v32 * v2[1];
        v1[1] = v32 * v2[0] - v30 * v2[2];
        v1[2] = v30 * v2[1] - v31 * v2[0];
    };
    /**
     * Rotates the given 2D vector (or the first to components of a 3D, 4D vector) counter-clockwise, modifying it in-place.
     * @param {Number[2]} v 
     * @param {Number} angle The angle of rotation, in radians
     */
    vec.rotate2 = function (v, angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle),
                x = v[0];
        v[0] = v[0] * cosAngle + v[1] * -sinAngle;
        v[1] = x * sinAngle + v[1] * cosAngle;
    };
    /**
     * Sets the passed 3D vector to the translation component of the passed 4x4 matrix.
     * @param {Number[3]} v A 3D vector
     * @param {Float32Array} m A 4x4 transformation matrix
     * @returns {Number[3]} v
     */
    vec.setTranslationVector3 = function (v, m) {
        v[0] = m[12];
        v[1] = m[13];
        v[2] = m[14];
        return v;
    };
    /**
     * Returns the difference of a 3D vector and the translation component of a 4x4 transformation matrix
     * @param {Number[3]} v The 3D vector.
     * @param {Float32Array} m The 4x4 transformation matrix.
     * @returns {Number[3]} The difference of v and the translation component of m.
     */
    vec.diffVec3Mat4 = function (v, m) {
        return [v[0] - m[12], v[1] - m[13], v[2] - m[14]];
    };
    /**
     * Returns the difference of a 3D vector and the translation component of a 4x4 transformation matrix
     * Uses one of the auxiliary vectors instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[3]} v The 3D vector.
     * @param {Float32Array} m The 4x4 transformation matrix.
     * @returns {Number[3]} The difference of v and the translation component of m.
     */
    vec.diffVec3Mat4Aux = function (v, m) {
        var aux = _auxVectors[_auxVectorIndex];
        aux[0] = v[0] - m[12];
        aux[1] = v[1] - m[13];
        aux[2] = v[2] - m[14];
        _auxVectorIndex = (_auxVectorIndex + 1) % AUX_VECTOR_COUNT;
        return aux;
    };
    /**
     * Multiplies the given 3D row vector with the given 3x3 matrix from the right, modifying it in-place.
     * @param {Number[3]} v A 3D vector.
     * @param {Float32Array} m A 3x3 matrix.
     */
    vec.mulVec3Mat3 = function (v, m) {
        var vox = v[0], voy = v[1], voz = v[2];
        v[0] = m[0] * vox + m[3] * voy + m[6] * voz;
        v[1] = m[1] * vox + m[4] * voy + m[7] * voz;
        v[2] = m[2] * vox + m[5] * voy + m[8] * voz;
    };
    /**
     * Sets the given vector to be equal to the product of the given 3D row vector and the given 3x3 matrix.
     * @param {Number[3]} v The 3D vector to modify
     * @param {Number[3]} vl A 3D vector on the left of the multiplication
     * @param {Float32Array} mr A 3x3 matrix on the right of the multiplication
     */
    vec.setProdVec3Mat3 = function (v, vl, mr) {
        v[0] = mr[0] * vl[0] + mr[3] * vl[1] + mr[6] * vl[2];
        v[1] = mr[1] * vl[0] + mr[4] * vl[1] + mr[7] * vl[2];
        v[2] = mr[2] * vl[0] + mr[5] * vl[1] + mr[8] * vl[2];
    };
    /**
     * Multiplies the given 3D row vector by the top left 3x3 submatrix of the given 4x4 matrix from the right, modifying it in-place.
     * @param {Number[3]} v The vector to modify
     * @param {Float32Array} m A 4x4 matrix.
     */
    vec.mulVec3Mat4 = function (v, m) {
        var vox = v[0], voy = v[1], voz = v[2];
        v[0] = m[0] * vox + m[4] * voy + m[8] * voz;
        v[1] = m[1] * vox + m[5] * voy + m[9] * voz;
        v[2] = m[2] * vox + m[6] * voy + m[10] * voz;
    };
    /**
     * Sets the given vector to be equal to the product of the given 3D row vector and the top left 3x3 submatrix of the the given 4x4 matrix.
     * @param {Number[3]} v The vector to modify
     * @param {Number[3]} vl A 3D vector.
     * @param {Float32Array} mr A 4x4 matrix.
     */
    vec.setProdVec3Mat4 = function (v, vl, mr) {
        v[0] = mr[0] * vl[0] + mr[4] * vl[1] + mr[8] * vl[2];
        v[1] = mr[1] * vl[0] + mr[5] * vl[1] + mr[9] * vl[2];
        v[2] = mr[2] * vl[0] + mr[6] * vl[1] + mr[10] * vl[2];
    };
    /**
     * Multiplies the given 4D row vector by the given 4x4 matrix from the right, modifying it in-place.
     * @param {Number[4]} v A 4D vector on the left of the multiplication
     * @param {Float32Array} m A 4x4 matrix on the right of the multiplication
     */
    vec.mulVec4Mat4 = function (v, m) {
        var vox = v[0], voy = v[1], voz = v[2], vow = v[3];
        v[0] = m[0] * vox + m[4] * voy + m[8] * voz + m[12] * vow;
        v[1] = m[1] * vox + m[5] * voy + m[9] * voz + m[13] * vow;
        v[2] = m[2] * vox + m[6] * voy + m[10] * voz + m[14] * vow;
        v[3] = m[3] * vox + m[7] * voy + m[11] * voz + m[15] * vow;
    };
    /**
     * Sets the given vector to be equal to the product of the given 4D row vector and the given 4x4 matrix.
     * @param {Number[4]} v The 4D vector to modify
     * @param {Number[4]} vl A 4D vector on the left of the multiplication
     * @param {Float32Array} mr A 4x4 matrix on the right of the multiplication
     */
    vec.setProdVec4Mat4 = function (v, vl, mr) {
        v[0] = mr[0] * vl[0] + mr[4] * vl[1] + mr[8] * vl[2] + mr[12] * vl[3];
        v[1] = mr[1] * vl[0] + mr[5] * vl[1] + mr[9] * vl[2] + mr[13] * vl[3];
        v[2] = mr[2] * vl[0] + mr[6] * vl[1] + mr[10] * vl[2] + mr[14] * vl[3];
        v[3] = mr[3] * vl[0] + mr[7] * vl[1] + mr[11] * vl[2] + mr[15] * vl[3];
    };
    /**
     * Sets the given vector to be equal to the product of the 4D row vector: (X, 0, 0, 1) and the given 4x4 matrix.
     * @param {Number[4]} v The 4D vector to modify
     * @param {Number} x The X coordinate of the 4D vector on the left of the multiplication
     * @param {Float32Array} mr A 4x4 matrix on the right of the multiplication
     */
    vec.setProdVecX4Mat4 = function (v, x, mr) {
        v[0] = mr[0] * x + mr[12];
        v[1] = mr[1] * x + mr[13];
        v[2] = mr[2] * x + mr[14];
        v[3] = mr[3] * x + mr[15];
    };
    /**
     * Sets the given vector to be equal to the product of the 4D row vector: (0, Y, 0, 1) and the given 4x4 matrix.
     * @param {Number[4]} v The 4D vector to modify
     * @param {Number} y The Y coordinate of the 4D vector on the left of the multiplication
     * @param {Float32Array} mr A 4x4 matrix on the right of the multiplication
     */
    vec.setProdVecY4Mat4 = function (v, y, mr) {
        v[0] = mr[4] * y + mr[12];
        v[1] = mr[5] * y + mr[13];
        v[2] = mr[6] * y + mr[14];
        v[3] = mr[7] * y + mr[15];
    };
    /**
     * Sets the given 3D vector to be equal to the product of the translation component of a 4x4 matrix and a 4x4 model matrix (a matrix
     * with translation, rotation and scaling, but no projection)
     * @param {Number[3]} v The 3D vector to modify
     * @param {Float32Array} tm A 4x4 transformation matrix (only the translation component is considered)
     * @param {Float32Array} mm A 4x4 model matrix
     */
    vec.setProdTranslationModel3 = function (v, tm, mm) {
        v[0] = mm[0] * tm[12] + mm[4] * tm[13] + mm[8] * tm[14] + mm[12];
        v[1] = mm[1] * tm[12] + mm[5] * tm[13] + mm[9] * tm[14] + mm[13];
        v[2] = mm[2] * tm[12] + mm[6] * tm[13] + mm[10] * tm[14] + mm[14];
    };
    /*
     * Sets the given 3D vector to be equal to the (first 3 elements of the) second row of the passed 4x4 matrix
     * @param {Number[3]} v The 3D vector to modify
     * @param {Float32Array} m The 4x4 matrix to extract the row from
     */
    vec.setRowB43 = function (v, m) {
        v[0] = m[4];
        v[1] = m[5];
        v[2] = m[6];
    };
    /**
     * Normalizes the passed 2D vector and returns its length
     * @param {Number[2]} v
     * @returns {Number}
     */
    vec.extractLength2 = function (v) {
        var
                divisor = Math.sqrt(v[0] * v[0] + v[1] * v[1]),
                factor = (divisor === 0) ? 1.0 : 1.0 / divisor;
        v[0] *= factor;
        v[1] *= factor;
        return divisor;
    };
    /**
     * Normalizes the passed 3D vector and returns its length
     * @param {Number[3]} v
     * @returns {Number}
     */
    vec.extractLength3 = function (v) {
        var
                divisor = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]),
                factor = (divisor === 0) ? 1.0 : 1.0 / divisor;
        v[0] *= factor;
        v[1] *= factor;
        v[2] *= factor;
        return divisor;
    };
    // ----------------------------------------------------------------------
    // Initialization
    (function () {
        var i;
        for (i = 0; i < AUX_VECTOR_COUNT; i++) {
            _auxVectors.push([0, 0, 0, 0]);
        }
    }());
    // ----------------------------------------------------------------------
    // Returning the public interface
    return vec;
});
/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file 
 * Provides a class representing a 3D model with several meshes storing the geometry of the model at different levels of detail. The model
 * can be edited directly, loaded from an EgomModel (egm) file, can provide its vertex data in a format suitable to be loaded to WebGL
 * vertex buffers as well as load it itself to vertex buffers and render it. Functions for generating and returning several simple models
 * are also included.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, Float32Array, parseFloat, Document */

/**
 * @param vec Used for vector operations to create / manipulate normal vectors.
 * @param application Used for displaying errors and logging.
 */
define('modules/egom-model',[
    "utils/vectors",
    "modules/application"
], function (vec, application) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // enums
            VertexAttributeRole = {
                POSITION: "position",
                POSITION4: "position4",
                TEXTURE_COORDINATES: "texCoord",
                NORMAL: "normal",
                COLOR: "color",
                GROUP_INDICES: "groupIndices",
                TRIANGLE_INDEX: "triangleIndex"
            },
            // ------------------------------------------------------------------------------
            // constants
            DEFAULT_SQUARE_TEX_COORDINATES = [[0, 0], [1, 1]],
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * @typedef {Object} ModelDebugStats
             * @property {Number} triangleDrawCalls The number of non-instanced draw calls using triangle rendering.
             * @property {Number} triangles The number of triangles rendered via non-instanced draw calls.
             * @property {Number} lineDrawCalls The number of non-instanced draw calls using line rendering.
             * @property {Number} lines The number of lines rendered via non-instanced draw calls.
             * @property {Number} instancedTriangleDrawCalls The number of instanced draw calls using triangle rendering.
             * @property {Number} instancedTriangles The number of triangles rendered via instanced draw calls.
             * @property {Number} instancedLineDrawCalls The number of instanced draw calls using line rendering.
             * @property {Number} instancedLines The number of lines rendered via instanced draw calls.
             */
            // debug
            /**
             * An object to collect statistics about rendering for debug mode
             * @type ModelDebugStats
             */
            _DEBUG_STATS = {
                triangleDrawCalls: 0,
                triangles: 0,
                lineDrawCalls: 0,
                lines: 0,
                instancedTriangleDrawCalls: 0,
                instancedTriangles: 0,
                instancedLineDrawCalls: 0,
                instancedLines: 0
            },
            // general
            /**
             * The list of EgomModel versions that can be loaded from file.
             * @type String[]
             */
            _supportedVersions = ["3.3"];
    // freezing enum objects
    Object.freeze(VertexAttributeRole);
    // -------------------------------------------------------------------------
    // Public functions
    /**
     * Resets the counters for rendering statistics.
     */
    function resetDebugStats() {
        _DEBUG_STATS.triangleDrawCalls = 0;
        _DEBUG_STATS.triangles = 0;
        _DEBUG_STATS.lineDrawCalls = 0;
        _DEBUG_STATS.lines = 0;
        _DEBUG_STATS.instancedTriangleDrawCalls = 0;
        _DEBUG_STATS.instancedTriangles = 0;
        _DEBUG_STATS.instancedLineDrawCalls = 0;
        _DEBUG_STATS.instancedLines = 0;
    }
    /**
     * Returns the rendering statistics collected since the last reset.
     * @returns {ModelDebugStats}
     */
    function getDebugStats() {
        return _DEBUG_STATS;
    }
    // ############################################################################################
    /**
     * @class Represents a vertex in 3D space.
     * @param {Number} x 
     * @param {Number} y 
     * @param {Number} z 
     * @param {Number[2]} texCoords Texture coordinates.
     */
    function Vertex(x, y, z, texCoords) {
        /**
         * The X coordinate of the vertex.
         * @type Number
         */
        this.x = x;
        /**
         * The Y coordinate of the vertex.
         * @type Number
         */
        this.y = y;
        /**
         * The Z coordinate of the vertex.
         * @type Number
         */
        this.z = z;
        // if no texture coordinates were given, default to (x;y)
        texCoords = texCoords || [this.x, this.y];
        /**
         * The U (horizontal) texture coordinate of the vertex.
         * @type Number
         */
        this.u = texCoords[0];
        /**
         * The V (vertical) texture coordinate of the vertex.
         * @type Number
         */
        this.v = texCoords[1];
    }
    /**
     * Returns the texture coordinates associated with this vertex.
     * @returns {Number[2]}
     */
    Vertex.prototype.getTexCoords = function () {
        return [this.u, this.v];
    };
    /**
     * Sets the X coordinate of the vertex.
     * @param {Number} x
     */
    Vertex.prototype.setX = function (x) {
        this.x = x;
    };
    /**
     * Sets the Y coordinate of the vertex.
     * @param {Number} y
     */
    Vertex.prototype.setY = function (y) {
        this.y = y;
    };
    /**
     * Sets the Z coordinate of the vertex.
     * @param {Number} z
     */
    Vertex.prototype.setZ = function (z) {
        this.z = z;
    };
    // ############################################################################################
    /**
     * @class Represents a line connecting two vertices in a model.
     * @param {Number} a The index of the starting vertex of the line.
     * @param {Number} b The index of the end vertex of the line.
     * @param {Number[3]} color The color of the line. ([red, green, blue])
     * @param {Number[3]} normal The normal vector associated with the line.
     */
    function Line(a, b, color, normal) {
        /**
         * The index (in the model) of the starting vertex of the line.
         * @type Number
         */
        this.a = a;
        /**
         * The index (in the model) of the end vertex of the line.
         * @type Number
         */
        this.b = b;
        /**
         * The color of the line for rendering. ([red, green, blue])
         * @type Number
         */
        this.color = color;
        /**
         * The normal vector associated with the line for shading.
         * @type Number[3]
         */
        this.normal = normal;
    }
    // ############################################################################################
    /**
     * @class Represents a triangular face between 3 vertices of a model.
     * @param {Mesh} model The model to which this triangle is added.
     * @param {Number} a The index of the first vertex.
     * @param {Number} b The index of the second vertex.
     * @param {Number} c The index of the third vertex.
     * @param {Number[4]} color The color of the triangle. ([red, green, blue, alpha])
     * @param {Number[3][2]} texCoords The texture coordinates of the triangle's 
     * vertices. Format: [[a.u,a.v],[b.u,b.v],[c.u,c.v]]
     * @param {Number[][3]} [normals] The normal vectors of the triangle's vertices.
     * If the three vertives are the same, it is enough to pass an array with only
     * one element.
     * @param {Number} [groupIndices] The indices of the groups this triangle belongs to.
     */
    function Triangle(model, a, b, c, color, texCoords, normals, groupIndices) {
        /**
         * The model to which this triangle is added.
         * @type Mesh
         */
        this._mesh = model;
        /**
         * The index (in the model) of the first vertex of the triangle.
         * @type Number
         */
        this.a = a;
        /**
         * The index (in the model) of the second vertex of the triangle.
         * @type Number
         */
        this.b = b;
        /**
         * The index (in the model) of the third vertex of the triangle.
         * @type Number
         */
        this.c = c;
        /**
         * The RGBA color of the triangle. ([red, green, blue, alpha])
         * @type Number[4]
         */
        this.color = color;
        /**
         * The texture coordinates of the triangle's vertices. Format: 
         * [[a.u,a.v],[b.u,b.v],[c.u,c.v]]
         * @type Number[3][2]
         */
        this.texCoords = texCoords;
        /**
         * The normal vector(s) of the triangle's vertices. May have one (uniform
         * normal across the triangle) or three (different normal per vertex)
         * elements.
         * @type Number[][3]
         */
        this.normals = normals || vec.normalize3(vec.cross3(this._mesh.getVector(a, b), this._mesh.getVector(a, c)));
        /**
         * The indices of the groups (of various types) this triangle belongs to. Currently two groups types are used: the first index
         * indicates the transform group and the second one the luminosity group.
         * @type Number[2]
         */
        this.groupIndices = groupIndices || [0, 0];
    }
    /**
     * Returns the normal vector belonging to one of the vertices of this triangle.
     * @param {Number} index The index of the vertex (within the triangle: 0,1 or 2)
     * @returns {Number[3]}
     */
    Triangle.prototype.getNormal = function (index) {
        return (this.normals[index] || this.normals[0]);
    };
    // ############################################################################################
    /**
     * @class Stores the attributes that a mesh has associated with a managed
     * WebGL context.
     */
    function MeshContextProperties() {
        /**
         * The index marking where the data belonging to the lines of this 
         * model starts in the vertex buffer objects.
         * @type Number
         */
        this.bufferStartWireframe = 0;
        /**
         * The index marking where the data belonging to the triangles of this 
         * model starts in the vertex buffer objects.
         * @type Number
         */
        this.bufferStartSolid = 0;
        /**
         * The index marking where the data belonging to the transparent 
         * triangles of this model starts in the vertex buffer objects.
         * @type Number
         */
        this.bufferStartTransparent = 0;
    }
    // ############################################################################################
    /**
     * @class A single, specific mesh consisting of lines (for wireframe rendering) and 
     * triangles (for solid rendering) that connect 3D vertices. Multiple such
     * meshes that represent the same 3D model on different levels of detail
     * are grouped together in the Model class.
     */
    function Mesh() {
        /**
         * The array of vertices of the model. These can be referenced by index
         * when defining lines or triangles.
         * @type Vertex[]
         */
        this._vertices = [];
        /**
         * The array of lines of the model for wireframe rendering.
         * @type Line[]
         */
        this._lines = [];
        /**
         * The array of triangles of the model for solid rendering.
         * @type Triangle[]
         */
        this._triangles = [];
        /**
         * The size of the model. It is the double of the (absolute) largest coordinate
         * found among the vertices.
         * @type Number
         */
        this._size = 0;
        /**
         * The largest positive X coordinate found among the vertices.
         * @type Number
         */
        this._maxX = 0;
        /**
         * The largest negative X coordinate found among the vertices.
         * @type Number
         */
        this._minX = 0;
        /**
         * The largest positive Y coordinate found among the vertices.
         * @type Number
         */
        this._maxY = 0;
        /**
         * The largest negative Y coordinate found among the vertices.
         * @type Number
         */
        this._minY = 0;
        /**
         * The largest positive Z coordinate found among the vertices.
         * @type Number
         */
        this._maxZ = 0;
        /**
         * The largest negative Z coordinate found among the vertices.
         * @type Number
         */
        this._minZ = 0;
        /**
         * The number of opaque triangles this model contains.
         * @type Number
         */
        this._nOpaqueTriangles = 0;
        /**
         * The number of transparent triangles this model contains.
         * @type Number
         */
        this._nTransparentTriangles = 0;
        /**
         * An associative array storing ModelContextProperties objects for each
         * context this mesh is associated with, organized by the names of the
         * contexts.
         * @type Object.<String, MeshContextProperties>
         */
        this._contextProperties = {};
        /**
         * The default texture coordinates for newly added triangles and quads.
         * @type Number[4][2]
         */
        this._texCoords = [[0, 1], [1, 1], [1, 0], [0, 0]];
        /**
         * The default group indices for newly added triangles and lines.
         * @type Number
         */
        this._currentGroupIndices = [0, 0];
        /**
         * A property for convenience and optimization, all filler null vectors
         * point to this object instead of creating a separate vertex object
         * for each.
         * @type Vertex
         */
        this._nullVertex = new Vertex(0.0, 0.0, 0.0);
    }
    /**
     * Returns the number of lines this model contains.
     * @returns {Number}
     */
    Mesh.prototype.getNumLines = function () {
        return this._lines.length;
    };
    /**
     * Returns the number of completely opaque triangles this model contains.
     * @returns {Number}
     */
    Mesh.prototype.getNumOpaqueTriangles = function () {
        return this._nOpaqueTriangles;
    };
    /**
     * Returns the number of transparent (not completely opaque) triangles this 
     * model contains.
     * @returns {Number}
     */
    Mesh.prototype.getNumTransparentTriangles = function () {
        return this._nTransparentTriangles;
    };
    /**
     * Returns the number of triangles this model contains.
     * @param {Boolean} [transparent] Whether to count the transparent or the opaque triangles. If not given, both will be counted.
     * @returns {Number}
     */
    Mesh.prototype.getNumTriangles = function (transparent) {
        if (transparent === undefined) {
            return this._triangles.length;
        }
        return transparent ? this._nTransparentTriangles : this._nOpaqueTriangles;
    };
    /**
     * Resets all data stored in the mesh, so a new geometry can be built inside
     * this object.
     */
    Mesh.prototype.resetMesh = function () {
        this.resetVertices();
        this.resetLines();
        this.resetTriangles();
    };
    /**
     * Deletes the vertices of the mesh and resets related properties.
     */
    Mesh.prototype.resetVertices = function () {
        this._vertices = [];
        this._maxX = 0;
        this._minX = 0;
        this._maxY = 0;
        this._minY = 0;
        this._maxZ = 0;
        this._minZ = 0;
    };
    /**
     * Sets the vertex data belonging to the passed index.
     * @param {Number} index The index of the vertex to create/overwrite. Can
     * be bigger than the currently available indices, in which case the needed
     * new vertices will be created at (0;0;0).
     * @param {Vertex} vertex
     */
    Mesh.prototype.setVertex = function (index, vertex) {
        var i, distance;
        // if we are setting a vertex with a higher index than the currently stored
        // ones, create new vertices in between
        if (this._vertices.length < index) {
            for (i = this._vertices.length; i < index; i++) {
                this._vertices[i] = this._nullVertex;
            }
        }
        // set the vertex
        this._vertices[index] = vertex;
        // update the size related data
        distance = vec.length3([this._vertices[index].x, this._vertices[index].y, this._vertices[index].z]);
        if (2 * distance > this._size) {
            this._size = 2 * distance;
        }
        if (this._vertices[index].x > this._maxX) {
            this._maxX = this._vertices[index].x;
        }
        if (this._vertices[index].x < this._minX) {
            this._minX = this._vertices[index].x;
        }
        if (this._vertices[index].y > this._maxY) {
            this._maxY = this._vertices[index].y;
        }
        if (this._vertices[index].y < this._minY) {
            this._minY = this._vertices[index].y;
        }
        if (this._vertices[index].z > this._maxZ) {
            this._maxZ = this._vertices[index].z;
        }
        if (this._vertices[index].z < this._minZ) {
            this._minZ = this._vertices[index].z;
        }
    };
    /**
     * Adds a new vertex to the first available index.
     * @param {Number[3]} position
     * @param {Number[2]} [texCoords]
     */
    Mesh.prototype.appendVertex = function (position, texCoords) {
        this.setVertex(this._vertices.length, new Vertex(position[0], position[1], position[2], texCoords));
    };
    /**
     * Deletes the lines of the mesh.
     */
    Mesh.prototype.resetLines = function () {
        this._lines = [];
    };
    /**
     * Adds a new line to the mesh. Does not check if the same line already
     * exists.
     * @param {Line} line
     */
    Mesh.prototype.addLine = function (line) {
        this._lines.push(line);
    };
    /**
     * Replaces the line stored at the given index with a new one.
     * @param {Number} index
     * @param {Line} line
     */
    Mesh.prototype.setLine = function (index, line) {
        this._lines[index] = line;
    };
    /**
     * Deletes the triangles of the mesh and resets related properties.
     */
    Mesh.prototype.resetTriangles = function () {
        this._triangles = [];
        this._nOpaqueTriangles = 0;
        this._nTransparentTriangles = 0;
    };
    /**
     * Returns a vector pointing from one vertex to the other.
     * @param {Vertex} vertex1Index The index of the vertex that is at the origin of
     * the vector.
     * @param {Vertex} vertex2Index The index of the vertex that is at the descitation
     * of the vector.
     * @returns {Number[3]}
     */
    Mesh.prototype.getVector = function (vertex1Index, vertex2Index) {
        return [
            this._vertices[vertex2Index].x - this._vertices[vertex1Index].x,
            this._vertices[vertex2Index].y - this._vertices[vertex1Index].y,
            this._vertices[vertex2Index].z - this._vertices[vertex1Index].z];
    };
    /**
     * Adds a new triangle to the mesh. Does not check if the same triangle
     * already exists. Also adds 3 lines corresponding to the edges of the 
     * triangle, unless specified otherwise in the parameters.
     * @param {Triangle} triangle
     * @param {Boolean} [withoutLines=false]
     */
    Mesh.prototype.addTriangle = function (triangle, withoutLines) {
        this._triangles.push(triangle);
        // the default setting is to also add the corresponding border lines of the triangle
        if (!withoutLines) {
            this._lines.push(new Line(triangle.a, triangle.b, triangle.color, triangle.getNormal(0)));
            this._lines.push(new Line(triangle.b, triangle.c, triangle.color, triangle.getNormal(0)));
            this._lines.push(new Line(triangle.c, triangle.a, triangle.color, triangle.getNormal(0)));
        }
        // important to update the appropriate count
        if (triangle.color[3] < 1.0) {
            this._nTransparentTriangles++;
        } else {
            this._nOpaqueTriangles++;
        }
    };
    /**
     * @typedef {Object} Mesh~TriangleParams
     * @property {Number[4]} color 
     * @property {Boolean} useVertexTexCoords Whether to take the texture coordinates from the vertices of the model (if not, the default 
     * ones set for the model or the custom ones given will be used)
     * @property {Number[3][2]} texCoords The texture coordinates of the vertices of the triangle
     * @property {Number[][3]} normals The normal vector(s) for the triangle. If one vector is given, it will be used for all three 
     * vertices, if 3 are given, they will be used separately. If none are given, the normal of th surface of the triangles will be 
     * generated and used.
     * @property {Number[2]} groupIndices The indices of the groups to which to add the triangle.
     */
    /**
     * Creates a triangle using the supplied and the default editing parameters
     * and adds it to the mesh.
     * @param {Number} a The index of the first vertex of the triangle.
     * @param {Number} b The index of the second vertex of the triangle.
     * @param {Number} c The index of the third vertex of the triangle.
     * @param {Mesh~TriangleParams} params The parameters of the triangle. 
     * @returns {Triangle} The added triangle
     */
    Mesh.prototype.addTriangleWithParams = function (a, b, c, params) {
        var color, texCoords, normals, groupIndices, triangle;
        // the default color is opaque white
        color = params.color || [1.0, 1.0, 1.0, 1.0];
        // texture coordinates may be taken from the vertices, from the parameters
        // passed to this function or from the default coordinates set for the model
        texCoords = params.useVertexTexCoords ?
                [this._vertices[a].getTexCoords(), this._vertices[b].getTexCoords(), this._vertices[c].getTexCoords()] :
                (params.texCoords || [this._texCoords[0], this._texCoords[1], this._texCoords[2]]);
        // normals are taken from the parameters - can be 1 or 3 element long
        normals = params.normals;
        // if not specified, use the model's default group index
        groupIndices = params.groupIndices || this._currentGroupIndices;
        // create and add the new triangle
        triangle = new Triangle(this, a, b, c, color, texCoords, normals, groupIndices);
        this.addTriangle(triangle, params.withoutLines);
        return triangle;
    };
    /**
     * Adds two triangles forming a quadrilateral between 4 vertices.
     * @param {Number} a The index of the first vertex of the quad.
     * @param {Number} b The index of the second vertex of the quad.
     * @param {Number} c The index of the third vertex of the quad.
     * @param {Number} d The index of the fourth vertex of the quad.
     * @param {Mesh~TriangleParams} params The parameters of the quad in the same format as with
     * single triangles.
     */
    Mesh.prototype.addQuad = function (a, b, c, d, params) {
        var triangle1Params, triangle2Params, color, normals;
        params = params || {};
        // adding the first triangle
        // first, create the approrpiate parameters for the triangle based on the
        // parameters given for the quad
        triangle1Params = Object.create(params);
        // no lines should be added, as we will add the 4 lines for the whole quad
        // in the end
        triangle1Params.withoutLines = true;
        // for texture coordinates and normals, the first 3 values need to be used
        triangle1Params.texCoords = params.useVertexTexCoords ?
                [this._vertices[a].getTexCoords(), this._vertices[b].getTexCoords(), this._vertices[c].getTexCoords()] :
                (params.texCoords ?
                        [params.texCoords[0], params.texCoords[1], params.texCoords[2]] :
                        [this._texCoords[0], this._texCoords[1], this._texCoords[2]]);
        triangle1Params.normals = params.normals ?
                (params.normals.length === 4 ?
                        [params.normals[0], params.normals[1], params.normals[2]] :
                        params.normals) :
                null;
        this.addTriangleWithParams(a, b, c, triangle1Params);
        // adding the first triangle
        triangle2Params = Object.create(params);
        triangle2Params.texCoords = params.useVertexTexCoords ?
                [this._vertices[c].getTexCoords(), this._vertices[d].getTexCoords(), this._vertices[a].getTexCoords()] :
                (params.texCoords ?
                        [params.texCoords[2], params.texCoords[3], params.texCoords[0]] :
                        [this._texCoords[2], this._texCoords[3], this._texCoords[0]]);
        triangle2Params.normals = params.normals ?
                (params.normals.length === 4 ?
                        [params.normals[2], params.normals[3], params.normals[0]] :
                        params.normals) :
                null;
        this.addTriangleWithParams(c, d, a, triangle2Params);
        // adding the 4 lines around the quad
        if (!params.withoutLines) {
            color = params.color || [1.0, 1.0, 1.0, 1.0];
            normals = params.normals ? params.normals[0] : this._triangles[this._triangles.length - 1].getNormal(0);
            this._lines.push(new Line(a, b, color, normals));
            this._lines.push(new Line(b, c, color, normals));
            this._lines.push(new Line(c, d, color, normals));
            this._lines.push(new Line(d, a, color, normals));
        }
    };
    /**
     * Returns the size of the model, which is calculated as the double of the
     * farthest (X,Y or Z) vertex coordinate to be found in the model.
     * @returns {Number}
     */
    Mesh.prototype.getSize = function () {
        return this._size;
    };
    /**
     * Returns the greatest positive X vertex coordinate to be found in the model.
     * @returns {Number}
     */
    Mesh.prototype.getMaxX = function () {
        return this._maxX;
    };
    /**
     * Returns the greatest negative X vertex coordinate to be found in the model.
     * @returns {Number}
     */
    Mesh.prototype.getMinX = function () {
        return this._minX;
    };
    /**
     * Returns the greatest positive Y vertex coordinate to be found in the model.
     * @returns {Number}
     */
    Mesh.prototype.getMaxY = function () {
        return this._maxY;
    };
    /**
     * Returns the greatest negative Y vertex coordinate to be found in the model.
     * @returns {Number}
     */
    Mesh.prototype.getMinY = function () {
        return this._minY;
    };
    /**
     * Returns the greatest positive Z vertex coordinate to be found in the model.
     * @returns {Number}
     */
    Mesh.prototype.getMaxZ = function () {
        return this._maxZ;
    };
    /**
     * Returns the greatest negative Z vertex coordinate to be found in the model.
     * @returns {Number}
     */
    Mesh.prototype.getMinZ = function () {
        return this._minZ;
    };
    /**
     * Returns the width of the model, which is calculated as the difference
     * between the smallest and greatest X coordinates found among the vertices.
     * @returns {Number}
     */
    Mesh.prototype.getWidth = function () {
        return this._maxX - this._minX;
    };
    /**
     * Returns the height of the model, which is calculated as the difference
     * between the smallest and greatest Y coordinates found among the vertices.
     * @returns {Number}
     */
    Mesh.prototype.getHeight = function () {
        return this._maxY - this._minY;
    };
    /**
     * Returns the depth of the model, which is calculated as the difference
     * between the smallest and greatest Z coordinates found among the vertices.
     * @returns {Number}
     */
    Mesh.prototype.getDepth = function () {
        return this._maxZ - this._minZ;
    };
    /**
     * Returns the vertex buffer data for this model, organized in an associative
     * array by the roles of the different data (e.g. position, texCoord)
     * @param {Boolean} wireframe Whether the data for wireframe rendering (lines)
     * needs to be returned.
     * @param {Number} [startIndex=0] The starting index where the buffer data
     * will be used (inside a bigger buffer with data from multiple models).
     * Triangles can be indexed uniquely across all models by requesting the
     * model data with the right start index for each.
     * @param {Boolean} [position4=false] If true, a 4th coordinate will be 
     * included in the vertex positions, containing the index of the vertex
     * within the primitive (e.g. for triangles, 0, 1 or 2)
     * @returns {Object} An associative array, with all the buffer data for this
     * model. (Float32Arrays)
     * The names of the properties correspond to the roles of each of the arrays:
     * position, texCoord, normal, color, groupIndices.
     * The dataSize property contains the number of vertices.
     */
    Mesh.prototype.getBufferData = function (wireframe, startIndex, position4) {
        var i, j, nLines, nTriangles, ix, index,
                vertexData, texCoordData, normalData, colorData,
                groupIndexData, triangleIndexData, result;
        startIndex = startIndex || 0;
        if (wireframe === true) {
            nLines = this._lines.length;
            if (position4) {
                vertexData = new Float32Array(nLines * 8);
                for (i = 0; i < nLines; i++) {
                    vertexData[i * 8] = this._vertices[this._lines[i].a].x;
                    vertexData[i * 8 + 1] = this._vertices[this._lines[i].a].y;
                    vertexData[i * 8 + 2] = this._vertices[this._lines[i].a].z;
                    vertexData[i * 8 + 3] = 0;
                    vertexData[i * 8 + 4] = this._vertices[this._lines[i].b].x;
                    vertexData[i * 8 + 5] = this._vertices[this._lines[i].b].y;
                    vertexData[i * 8 + 6] = this._vertices[this._lines[i].b].z;
                    vertexData[i * 8 + 7] = 1;
                }
            } else {
                vertexData = new Float32Array(nLines * 6);
                for (i = 0; i < nLines; i++) {
                    vertexData[i * 6] = this._vertices[this._lines[i].a].x;
                    vertexData[i * 6 + 1] = this._vertices[this._lines[i].a].y;
                    vertexData[i * 6 + 2] = this._vertices[this._lines[i].a].z;
                    vertexData[i * 6 + 3] = this._vertices[this._lines[i].b].x;
                    vertexData[i * 6 + 4] = this._vertices[this._lines[i].b].y;
                    vertexData[i * 6 + 5] = this._vertices[this._lines[i].b].z;
                }
            }
            texCoordData = new Float32Array(nLines * 4);
            for (i = 0; i < nLines; i++) {
                texCoordData[i * 4] = 0.0;
                texCoordData[i * 4 + 1] = 1.0;
                texCoordData[i * 4 + 2] = 1.0;
                texCoordData[i * 4 + 3] = 1.0;
            }
            normalData = new Float32Array(nLines * 6);
            for (i = 0; i < nLines; i++) {
                normalData[i * 6] = this._lines[i].normal[0];
                normalData[i * 6 + 1] = this._lines[i].normal[1];
                normalData[i * 6 + 2] = this._lines[i].normal[2];
                normalData[i * 6 + 3] = this._lines[i].normal[0];
                normalData[i * 6 + 4] = this._lines[i].normal[1];
                normalData[i * 6 + 5] = this._lines[i].normal[2];
            }
            colorData = new Float32Array(nLines * 8);
            for (i = 0; i < nLines; i++) {
                colorData[i * 8] = this._lines[i].color[0];
                colorData[i * 8 + 1] = this._lines[i].color[1];
                colorData[i * 8 + 2] = this._lines[i].color[2];
                colorData[i * 8 + 3] = 1.0;
                colorData[i * 8 + 4] = this._lines[i].color[0];
                colorData[i * 8 + 5] = this._lines[i].color[1];
                colorData[i * 8 + 6] = this._lines[i].color[2];
                colorData[i * 8 + 7] = 1.0;
            }
            groupIndexData = new Float32Array(nLines * 4);
            for (i = 0; i < nLines; i++) {
                groupIndexData[i * 4] = 0;
                groupIndexData[i * 4 + 1] = 0;
                groupIndexData[i * 4 + 2] = 0;
                groupIndexData[i * 4 + 3] = 0;
            }
            nTriangles = this._triangles.length;
            triangleIndexData = new Float32Array(nTriangles * 3);
            for (i = 0; i < nTriangles; i++) {
                triangleIndexData[i * 12] = 0;
                triangleIndexData[i * 12 + 1] = 0;
                triangleIndexData[i * 12 + 2] = 0;
                triangleIndexData[i * 12 + 3] = 0;
                triangleIndexData[i * 12 + 4] = 0;
                triangleIndexData[i * 12 + 5] = 0;
                triangleIndexData[i * 12 + 6] = 0;
                triangleIndexData[i * 12 + 7] = 0;
                triangleIndexData[i * 12 + 8] = 0;
                triangleIndexData[i * 12 + 9] = 0;
                triangleIndexData[i * 12 + 10] = 0;
                triangleIndexData[i * 12 + 11] = 0;
            }
        } else {
            nTriangles = this._triangles.length;
            if (position4) {
                vertexData = new Float32Array(nTriangles * 12);
                for (i = 0; i < nTriangles; i++) {
                    vertexData[i * 12] = this._vertices[this._triangles[i].a].x;
                    vertexData[i * 12 + 1] = this._vertices[this._triangles[i].a].y;
                    vertexData[i * 12 + 2] = this._vertices[this._triangles[i].a].z;
                    vertexData[i * 12 + 3] = 0;
                    vertexData[i * 12 + 4] = this._vertices[this._triangles[i].b].x;
                    vertexData[i * 12 + 5] = this._vertices[this._triangles[i].b].y;
                    vertexData[i * 12 + 6] = this._vertices[this._triangles[i].b].z;
                    vertexData[i * 12 + 7] = 1;
                    vertexData[i * 12 + 8] = this._vertices[this._triangles[i].c].x;
                    vertexData[i * 12 + 9] = this._vertices[this._triangles[i].c].y;
                    vertexData[i * 12 + 10] = this._vertices[this._triangles[i].c].z;
                    vertexData[i * 12 + 11] = 2;
                }
            } else {
                vertexData = new Float32Array(nTriangles * 9);
                for (i = 0; i < nTriangles; i++) {
                    vertexData[i * 9] = this._vertices[this._triangles[i].a].x;
                    vertexData[i * 9 + 1] = this._vertices[this._triangles[i].a].y;
                    vertexData[i * 9 + 2] = this._vertices[this._triangles[i].a].z;
                    vertexData[i * 9 + 3] = this._vertices[this._triangles[i].b].x;
                    vertexData[i * 9 + 4] = this._vertices[this._triangles[i].b].y;
                    vertexData[i * 9 + 5] = this._vertices[this._triangles[i].b].z;
                    vertexData[i * 9 + 6] = this._vertices[this._triangles[i].c].x;
                    vertexData[i * 9 + 7] = this._vertices[this._triangles[i].c].y;
                    vertexData[i * 9 + 8] = this._vertices[this._triangles[i].c].z;
                }
            }
            texCoordData = new Float32Array(nTriangles * 6);
            for (i = 0; i < nTriangles; i++) {
                texCoordData[i * 6] = this._triangles[i].texCoords[0][0];
                texCoordData[i * 6 + 1] = this._triangles[i].texCoords[0][1];
                texCoordData[i * 6 + 2] = this._triangles[i].texCoords[1][0];
                texCoordData[i * 6 + 3] = this._triangles[i].texCoords[1][1];
                texCoordData[i * 6 + 4] = this._triangles[i].texCoords[2][0];
                texCoordData[i * 6 + 5] = this._triangles[i].texCoords[2][1];
            }
            normalData = new Float32Array(nTriangles * 9);
            for (i = 0; i < nTriangles; i++) {
                normalData[i * 9] = this._triangles[i].getNormal(0)[0];
                normalData[i * 9 + 1] = this._triangles[i].getNormal(0)[1];
                normalData[i * 9 + 2] = this._triangles[i].getNormal(0)[2];
                normalData[i * 9 + 3] = this._triangles[i].getNormal(1)[0];
                normalData[i * 9 + 4] = this._triangles[i].getNormal(1)[1];
                normalData[i * 9 + 5] = this._triangles[i].getNormal(1)[2];
                normalData[i * 9 + 6] = this._triangles[i].getNormal(2)[0];
                normalData[i * 9 + 7] = this._triangles[i].getNormal(2)[1];
                normalData[i * 9 + 8] = this._triangles[i].getNormal(2)[2];
            }
            colorData = new Float32Array(nTriangles * 12);
            for (i = 0; i < nTriangles; i++) {
                colorData[i * 12] = this._triangles[i].color[0];
                colorData[i * 12 + 1] = this._triangles[i].color[1];
                colorData[i * 12 + 2] = this._triangles[i].color[2];
                colorData[i * 12 + 3] = this._triangles[i].color[3];
                colorData[i * 12 + 4] = this._triangles[i].color[0];
                colorData[i * 12 + 5] = this._triangles[i].color[1];
                colorData[i * 12 + 6] = this._triangles[i].color[2];
                colorData[i * 12 + 7] = this._triangles[i].color[3];
                colorData[i * 12 + 8] = this._triangles[i].color[0];
                colorData[i * 12 + 9] = this._triangles[i].color[1];
                colorData[i * 12 + 10] = this._triangles[i].color[2];
                colorData[i * 12 + 11] = this._triangles[i].color[3];
            }
            groupIndexData = new Float32Array(nTriangles * 6);
            for (i = 0; i < nTriangles; i++) {
                groupIndexData[i * 6] = this._triangles[i].groupIndices[0];
                groupIndexData[i * 6 + 1] = this._triangles[i].groupIndices[1];
                groupIndexData[i * 6 + 2] = this._triangles[i].groupIndices[0];
                groupIndexData[i * 6 + 3] = this._triangles[i].groupIndices[1];
                groupIndexData[i * 6 + 4] = this._triangles[i].groupIndices[0];
                groupIndexData[i * 6 + 5] = this._triangles[i].groupIndices[1];
            }
            triangleIndexData = new Float32Array(nTriangles * 12);
            for (i = 0; i < nTriangles; i++) {
                ix = startIndex + i;
                index = [];
                for (j = 0; j < 4; j++) {
                    index[j] = (ix % 256) / 255.0;
                    ix = Math.floor(ix / 256.0);
                }
                triangleIndexData[i * 12] = index[0];
                triangleIndexData[i * 12 + 1] = index[1];
                triangleIndexData[i * 12 + 2] = index[2];
                triangleIndexData[i * 12 + 3] = index[3];
                triangleIndexData[i * 12 + 4] = index[0];
                triangleIndexData[i * 12 + 5] = index[1];
                triangleIndexData[i * 12 + 6] = index[2];
                triangleIndexData[i * 12 + 7] = index[3];
                triangleIndexData[i * 12 + 8] = index[0];
                triangleIndexData[i * 12 + 9] = index[1];
                triangleIndexData[i * 12 + 10] = index[2];
                triangleIndexData[i * 12 + 11] = index[3];
            }
        }
        result = {};
        result[position4 ? VertexAttributeRole.POSITION4 : VertexAttributeRole.POSITION] = vertexData;
        result[VertexAttributeRole.TEXTURE_COORDINATES] = texCoordData;
        result[VertexAttributeRole.NORMAL] = normalData;
        result[VertexAttributeRole.COLOR] = colorData;
        result[VertexAttributeRole.GROUP_INDICES] = groupIndexData;
        result[VertexAttributeRole.TRIANGLE_INDEX] = triangleIndexData;
        result.dataSize = (wireframe ? this._lines.length * 2 : this._triangles.length * 3);
        return result;
    };
    /**
     * Returns the size of the vertex buffer data (number of vertices) that this
     * mesh has for the specified context.
     * @param {Boolean} wireframe
     * @param {Boolean} solid
     * @returns {Number}
     */
    Mesh.prototype.getBufferSize = function (wireframe, solid) {
        return (wireframe ? this._lines.length * 2 : 0) + (solid ? this._triangles.length * 3 : 0);
    };
    /**
     * Loads the model's vertex data into the vertex buffer objects of the specified
     * context. Data for wireframe and solid rendering is added based on whether
     * the model has been previously added to the context in the respective mode.
     * @param {ManagedGLContext} context
     * @param {Number} startIndex The data will be added starting from this 
     * vertex index within the buffer objects.
     * @param {Boolean} wireframe
     * @param {Boolean} solid
     * @param {Boolean} [position4=false] If true, a 4th coordinate will be 
     * included in the vertex positions, containing the index of the vertex
     * within the primitive (e.g. for triangles, 0, 1 or 2)
     * @returns {Number} The number of vertices for which data has been added.
     */
    Mesh.prototype.loadToVertexBuffers = function (context, startIndex, wireframe, solid, position4) {
        var bufferData = null,
                dataSize = 0,
                props = this._contextProperties[context.getName()] || new MeshContextProperties();
        if (wireframe) {
            bufferData = this.getBufferData(true, startIndex, position4);
            props.bufferStartWireframe = startIndex;
            context.setVertexBufferData(bufferData, startIndex);
            dataSize += bufferData.dataSize;
            startIndex += bufferData.dataSize;
        }
        if (solid) {
            bufferData = this.getBufferData(false, startIndex, position4);
            props.bufferStartSolid = startIndex;
            props.bufferStartTransparent = startIndex + this._nOpaqueTriangles * 3;
            context.setVertexBufferData(bufferData, startIndex);
            dataSize += bufferData.dataSize;
            startIndex += bufferData.dataSize;
        }
        this._contextProperties[context.getName()] = props;
        return dataSize;
    };
    /**
     * Renders the model within the passed context, with the specified rendering
     * mode (wireframe or solid).
     * @param {ManagedGLContext} context The context into which the model is to
     * be rendered. The model has to be added to this context previously in the
     * same rendering mode, and the context needs to be set up afterwards for
     * rendering.
     * @param {Boolean} wireframe Whether the model should be rendered in 
     * wireframe mode.
     * @param {Boolean} opaque Whether only the opaque parts of the model should be
     * rendered. False means only transparent parts, and undefined (omitted) means
     * the whole model. Only effective in solid rendering mode.
     */
    Mesh.prototype.render = function (context, wireframe, opaque) {
        var props = this._contextProperties[context.getName()];
        if (wireframe === true) {
            context.gl.drawArrays(context.gl.LINES, props.bufferStartWireframe, 2 * this._lines.length);
            _DEBUG_STATS.lineDrawCalls++;
            _DEBUG_STATS.lines += this._lines.length;
            //context.gl.drawElements(context.gl.LINES, 2 * this._lines.length, context.gl.UNSIGNED_SHORT, props.bufferStartWireframe * 2);
        } else {
            switch (opaque) {
                case true:
                    context.gl.drawArrays(context.gl.TRIANGLES, props.bufferStartSolid, 3 * this._nOpaqueTriangles);
                    _DEBUG_STATS.triangles += this._nOpaqueTriangles;
                    //context.gl.drawElements(context.gl.TRIANGLES, 3 * this._nOpaqueTriangles, context.gl.UNSIGNED_SHORT, props.bufferStartSolid * 2);
                    break;
                case false:
                    context.gl.drawArrays(context.gl.TRIANGLES, props.bufferStartTransparent, 3 * this._nTransparentTriangles);
                    _DEBUG_STATS.triangles += this._nTransparentTriangles;
                    //context.gl.drawElements(context.gl.TRIANGLES, 3 * this._nTransparentTriangles, context.gl.UNSIGNED_SHORT, props.bufferStartTransparent * 2);
                    break;
                case undefined:
                    context.gl.drawArrays(context.gl.TRIANGLES, props.bufferStartSolid, 3 * this._triangles.length);
                    _DEBUG_STATS.triangles += this._triangles.length;
                    //context.gl.drawElements(context.gl.TRIANGLES, 3 * this._triangles.length, context.gl.UNSIGNED_SHORT, props.bufferStartSolid * 2);
                    break;
            }
            _DEBUG_STATS.triangleDrawCalls++;
        }
    };
    /**
     * Similar to the regular render method, but this renders the given number of instances of the mesh using instancing.
     * @param {ManagedGLContext} context
     * @param {Boolean} wireframe
     * @param {Boolean} [opaque]
     * @param {Number} instanceCount
     */
    Mesh.prototype.renderInstances = function (context, wireframe, opaque, instanceCount) {
        var props = this._contextProperties[context.getName()];
        if (wireframe === true) {
            context.instancingExt.drawArraysInstancedANGLE(context.gl.LINES, props.bufferStartWireframe, 2 * this._lines.length, instanceCount);
            _DEBUG_STATS.instancedLineDrawCalls++;
            _DEBUG_STATS.instancedLines += this._lines.length * instanceCount;
        } else {
            switch (opaque) {
                case true:
                    context.instancingExt.drawArraysInstancedANGLE(context.gl.TRIANGLES, props.bufferStartSolid, 3 * this._nOpaqueTriangles, instanceCount);
                    _DEBUG_STATS.instancedTriangles += this._nOpaqueTriangles * instanceCount;
                    break;
                case false:
                    context.instancingExt.drawArraysInstancedANGLE(context.gl.TRIANGLES, props.bufferStartTransparent, 3 * this._nTransparentTriangles, instanceCount);
                    _DEBUG_STATS.instancedTriangles += this._nTransparentTriangles * instanceCount;
                    break;
                case undefined:
                    context.instancingExt.drawArraysInstancedANGLE(context.gl.TRIANGLES, props.bufferStartSolid, 3 * this._triangles.length, instanceCount);
                    _DEBUG_STATS.instancedTriangles += this._triangles.length * instanceCount;
                    break;
            }
            _DEBUG_STATS.instancedTriangleDrawCalls++;
        }
    };
    /**
     * Adds a cuboid geometry to the object. (both vertices and faces)
     * @param {Number} x The X coordinate of the center of the cuboid.
     * @param {Number} y The Y coordinate of the center of the cuboid.
     * @param {Number} z The Z coordinate of the center of the cuboid.
     * @param {Number} width The width (X dimension) of the cuboid.
     * @param {Number} height The height (Y dimension) of the cuboid.
     * @param {Number} depth The depth (Z dimension) of the cuboid.
     * @param {Number[4]} color The color of the faces of the cuboid 
     * ([red,green,blue,alpha])
     * @param {Number[4][2]} textureCoordinates The texture coordinates for the 
     * faces of the cuboid (the two coordinates for each of the 4 vertices of one
     * face.
     * @param {Boolean} cullFace Whether the faces facing the inside of the cuboid
     * should be culled (omitted)
     */
    Mesh.prototype.addCuboid = function (x, y, z, width, height, depth, color, textureCoordinates, cullFace) {
        var i, i0, normals, params;
        i0 = +this._vertices.length;

        // front
        this.appendVertex([x - width / 2, y - height / 2, z + depth / 2]);
        this.appendVertex([x + width / 2, y - height / 2, z + depth / 2]);
        this.appendVertex([x + width / 2, y + height / 2, z + depth / 2]);
        this.appendVertex([x - width / 2, y + height / 2, z + depth / 2]);
        // back
        this.appendVertex([x - width / 2, y + height / 2, z - depth / 2]);
        this.appendVertex([x + width / 2, y + height / 2, z - depth / 2]);
        this.appendVertex([x + width / 2, y - height / 2, z - depth / 2]);
        this.appendVertex([x - width / 2, y - height / 2, z - depth / 2]);
        // top
        this.appendVertex([x + width / 2, y + height / 2, z - depth / 2]);
        this.appendVertex([x - width / 2, y + height / 2, z - depth / 2]);
        this.appendVertex([x - width / 2, y + height / 2, z + depth / 2]);
        this.appendVertex([x + width / 2, y + height / 2, z + depth / 2]);
        // bottom
        this.appendVertex([x - width / 2, y - height / 2, z - depth / 2]);
        this.appendVertex([x + width / 2, y - height / 2, z - depth / 2]);
        this.appendVertex([x + width / 2, y - height / 2, z + depth / 2]);
        this.appendVertex([x - width / 2, y - height / 2, z + depth / 2]);
        // right
        this.appendVertex([x + width / 2, y - height / 2, z - depth / 2]);
        this.appendVertex([x + width / 2, y + height / 2, z - depth / 2]);
        this.appendVertex([x + width / 2, y + height / 2, z + depth / 2]);
        this.appendVertex([x + width / 2, y - height / 2, z + depth / 2]);
        // left
        this.appendVertex([x - width / 2, y + height / 2, z - depth / 2]);
        this.appendVertex([x - width / 2, y - height / 2, z - depth / 2]);
        this.appendVertex([x - width / 2, y - height / 2, z + depth / 2]);
        this.appendVertex([x - width / 2, y + height / 2, z + depth / 2]);

        normals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
        params = {
            color: color,
            texCoords: textureCoordinates
        };

        for (i = 0; i < 6; i++) {
            params.normals = [normals[i]];
            this.addQuad(i0 + (i * 4), i0 + (i * 4) + 1, i0 + (i * 4) + 2, i0 + (i * 4) + 3, params);
            if (!cullFace) {
                params.normals = [vec.scaled3(normals[i], -1)];
                this.addQuad(i0 + (i * 4) + 2, i0 + (i * 4) + 1, i0 + (i * 4), i0 + (i * 4) + 3, params);
            }
        }

    };
    // ############################################################################################
    /**
     * @struct Stores the attributes that a model has associated with a managed
     * WebGL context.
     * @returns {ModelContextProperties}
     */
    function ModelContextProperties() {
        /**
         * Whether the wireframe model is used in the context.
         * @type Boolean
         */
        this.wireframe = false;
        /**
         * Whether the solid model is used in the context.
         * @type Boolean
         */
        this.solid = false;
        /**
         * The minimum LOD with which this model has been added to the context.
         * The vertex buffer data should be filled with the mesh data starting
         * from this LOD, when the context is initialized.
         * @type Number
         */
        this.minLOD = 0;
        /**
         * The maximum LOD with which this model has been added to the context.
         * The vertex buffer data should be filled with the mesh data up to this 
         * LOD, when the context is initialized.
         * @type Number
         */
        this.maxLOD = 0;
    }
    // ############################################################################################
    /**
     * @class Combines different Mesh object into one, multi-LOD 3D model and
     * provides functionality for loading these different LODs from a single or
     * multiple files.
     */
    function Model() {
        /**
         * The mesh ordered by their LOD (the index corresponds to the LOD of
         * the mesh)
         * @type Mesh[]
         */
        this._meshes = [];
        /**
         * The minimum LOD for which this model currently stores info. It is set
         * when mesh info is loaded from a file.
         * @type Number
         */
        this._minLOD = this.LOD_NOT_SET;
        /**
         * The maximum LOD for which this model currently stores info. It is set
         * when mesh info is loaded from a file.
         * @type Number
         */
        this._maxLOD = this.LOD_NOT_SET;
        /**
         * The name of this model.
         * @type String
         */
        this._name = null;
        /**
         * The object storing the info (meta) properties of the model.
         * @type Object
         */
        this._infoProperties = {};
        /**
         * The length of one model-space unit in meters.
         * @type Number
         */
        this._scale = 1;
        /**
         * An associative array storing ModelContextProperties objects for each
         * context this model is associated with, organized by the names of the
         * contexts.
         * @type Object.<String, ModelContextProperties>
         */
        this._contextProperties = {};
        /**
         * Whether a 4 coordinate (XYZW) position vertex attribute should be used
         * for this model, the 4th coordinate containing the index of the vertex
         * within the primitive (0-1 for lines, 0-1-2 for triangles)
         * @type Boolean
         */
        this._position4 = false;
    }
    /**
     * The value for LOD levels that have not been set yet
     * @constant
     * @type Number
     */
    Model.prototype.LOD_NOT_SET = -1;

    /**
     * Returns the name of the model. (not the same as the filename - a name can be
     * set directly, or read from the model file)
     * @returns {String}
     */
    Model.prototype.getName = function () {
        return this._name;
    };
    /**
     * Sets a name for the model.
     * @param {String} name
     */
    Model.prototype.setName = function (name) {
        this._name = name;
    };
    /**
     * Returns the minimum LOD this model has a mesh for.
     * @returns {Number}
     */
    Model.prototype.getMinLOD = function () {
        return this._minLOD;
    };
    /**
     * Returns the maximum LOD this model has a mesh for.
     * @returns {Number}
     */
    Model.prototype.getMaxLOD = function () {
        return this._maxLOD;
    };
    /**
     * Sets whether to include the index of vertices within the primitive in
     * the position attributes as the W coordinate (valid for subsequent 
     * getBufferData() / loadToVertexBuffers() calls)
     * @param {Boolean} value
     */
    Model.prototype.includeVertexIndicesInPosition = function (value) {
        this._position4 = value;
    };
    /**
     * Returns the LOD closest to the specified level this model has a mesh for.
     * @param {Number} lod
     * @returns {Number}
     */
    Model.prototype.getClosestAvailableLOD = function (lod) {
        return Math.min(Math.max(this.getMinLOD(), lod), this.getMaxLOD());
    };

    /**
     * Extends the covered LOD range if needed to include the passed range.
     * @param {Number} minLOD
     * @param {Number} maxLOD
     */
    Model.prototype.updateLODInfo = function (minLOD, maxLOD) {
        this._minLOD = (this._minLOD === this.LOD_NOT_SET) ? minLOD : (minLOD < this._minLOD ? minLOD : this._minLOD);
        this._maxLOD = (this._maxLOD === this.LOD_NOT_SET) ? maxLOD : (maxLOD > this._maxLOD ? maxLOD : this._maxLOD);
    };

    /**
     * Returns the mesh containing this model at the given LOD.
     * @param {Number} lod
     * @returns {Mesh}
     */
    Model.prototype.getMeshWithLOD = function (lod) {
        var i;
        for (i = this._meshes.length; i <= lod; i++) {
            this._meshes.push(new Mesh());
            this._maxLOD = i;
        }
        return this._meshes[lod];
    };

    /**
     * Directly sets the vertex of the passed index in the meshes belonging in the passed LOD range (no LOD existence check)
     * @param {Number} minLOD
     * @param {Number} maxLOD
     * @param {Number} index
     * @param {Vertex} vertex
     */
    Model.prototype.setVertex = function (minLOD, maxLOD, index, vertex) {
        var i;
        for (i = minLOD; i <= maxLOD; i++) {
            this._meshes[i].setVertex(index, vertex);
        }
    };
    /**
     * Directly adds the passed line in the meshes belonging in the passed LOD range (no LOD existence check)
     * @param {Number} minLOD
     * @param {Number} maxLOD
     * @param {Line} line
     */
    Model.prototype.addLineDirect = function (minLOD, maxLOD, line) {
        var i;
        for (i = minLOD; i <= maxLOD; i++) {
            this._meshes[i].addLine(line);
        }
    };
    /**
     * Directly adds a triangle with the passed parameters in the meshes belonging in the passed LOD range (no LOD existence check),
     * and also returns it
     * @param {Number} minLOD
     * @param {Number} maxLOD
     * @param {Number} a
     * @param {Number} b
     * @param {Number} c
     * @param {Mesh~TriangleParams} params
     * @returns {Triangle} The added triangle
     */
    Model.prototype.addTriangleDirect = function (minLOD, maxLOD, a, b, c, params) {
        var i, triangle = this._meshes[minLOD].addTriangleWithParams(a, b, c, params);
        for (i = minLOD + 1; i <= maxLOD; i++) {
            this._meshes[i].addTriangle(triangle, params.withoutLines);
        }
        return triangle;
    };
    /**
     * Loads the model data from the passed JSON object.
     * @param {String} filename
     * @param {Object} dataJSON
     * @param {Number} defaultLOD
     * @returns {Boolean} Whether the model has been successfully loaded.
     */
    Model.prototype.loadFromJSON = function (filename, dataJSON, defaultLOD) {
        var i, str,
                minLoadedLOD = null,
                maxLoadedLOD = null,
                defaultMinLOD = null,
                defaultMaxLOD = null,
                minLOD, maxLOD,
                version, colorPalette,
                params,
                nVertices, nLines, nTriangles,
                index, vertex, line, length,
                resetNewLoadedMeshes = function (newMinLoadedLOD, newMaxLoadedLOD) {
                    var lod;
                    if (minLoadedLOD === null) {
                        for (lod = newMinLoadedLOD; lod <= newMaxLoadedLOD; lod++) {
                            this.getMeshWithLOD(lod).resetMesh();
                        }
                        minLoadedLOD = newMinLoadedLOD;
                        maxLoadedLOD = newMaxLoadedLOD;
                    } else {
                        for (lod = newMinLoadedLOD; lod < minLoadedLOD; lod++) {
                            this.getMeshWithLOD(lod).resetMesh();
                        }
                        for (lod = maxLoadedLOD + 1; lod <= newMaxLoadedLOD; lod++) {
                            this.getMeshWithLOD(lod).resetMesh();
                        }
                        minLoadedLOD = newMinLoadedLOD < minLoadedLOD ? newMinLoadedLOD : minLoadedLOD;
                        maxLoadedLOD = newMaxLoadedLOD > maxLoadedLOD ? newMaxLoadedLOD : maxLoadedLOD;
                    }
                }.bind(this);
        defaultLOD = defaultLOD || 0;
        application.log_DEBUG("Loading EgomModel data from file: " + filename + " ...", 2);
        // checking the passed JSON file
        if (typeof dataJSON !== "object") {
            application.showError("'" + filename + "' does not appear to be a JSON file.",
                    application.ErrorSeverity.SEVERE,
                    "A model was supposed to be loaded from this file, but only models of EgomModel JSON format are accepted.");
            return false;
        }
        // checking EgomModel version
        version = dataJSON.version;
        if (!version) {
            application.showError("Model from file: '" + filename + "' could not be loaded, because the file version could not have been determined.", application.ErrorSeverity.SEVERE);
            return false;
        }
        if (_supportedVersions.indexOf(version) < 0) {
            application.showError("Model from file: '" + filename + "' could not be loaded, because the version of the file (" + version + ") is not supported.",
                    application.ErrorSeverity.SEVERE, "Supported versions are: " + _supportedVersions.join(", ") + ".");
            return false;
        }
        // loading info properties
        colorPalette = null;
        this._infoProperties = dataJSON.info || {};
        this._name = dataJSON.info.name || null;
        this._scale = dataJSON.info.scale || 1;
        defaultMinLOD = dataJSON.info.LOD[0] === null ? defaultLOD : dataJSON.info.LOD[0];
        defaultMaxLOD = dataJSON.info.LOD[1] === null ? defaultLOD : dataJSON.info.LOD[1];
        this.updateLODInfo(defaultMinLOD, defaultMaxLOD);
        resetNewLoadedMeshes(defaultMinLOD, defaultMaxLOD);
        colorPalette = dataJSON.info.colorPalette;
        // loading vertices
        nVertices = dataJSON.vertices.length;
        index = 0;
        for (i = 0; i < nVertices; i++) {
            length = dataJSON.vertices[i].length;
            if (length === 1) {
                index += dataJSON.vertices[i][0];
            } else {
                if (dataJSON.vertices[i].length >= 5) {
                    minLOD = dataJSON.vertices[i][3];
                    maxLOD = dataJSON.vertices[i][4];
                } else {
                    minLOD = defaultMinLOD;
                    maxLOD = defaultMaxLOD;
                }
                vertex = new Vertex(dataJSON.vertices[i][0], dataJSON.vertices[i][1], dataJSON.vertices[i][2]); // x,y,z
                this.setVertex(minLOD, maxLOD, index, vertex);
                index++;
            }
        }
        application.log_DEBUG("Loaded " + nVertices + " vertices.", 3);
        // loading lines
        nLines = dataJSON.lines.length;
        for (i = 0; i < nLines; i++) {
            if (dataJSON.lines[i].length >= 8) {
                minLOD = dataJSON.lines[i][6];
                maxLOD = dataJSON.lines[i][7];
            } else {
                minLOD = defaultMinLOD;
                maxLOD = defaultMaxLOD;
            }
            line = new Line(
                    dataJSON.lines[i][0], // a
                    dataJSON.lines[i][0] + dataJSON.lines[i][1], // b
                    colorPalette[dataJSON.lines[i][2]],
                    0,
                    dataJSON.lines[i].slice(3, 6)); // normal
            this.addLineDirect(minLOD, maxLOD, line);
        }
        application.log_DEBUG("Loaded " + nLines + " lines.", 3);
        // loading triangles
        nTriangles = dataJSON.triangles.length;
        params = {};
        for (i = 0; i < nTriangles; i++) {
            // triangles are defined by 3 arrays:
            // first: [a, b, c, color, <texCoords(6)>, <lod(2)>] where texCoords are omitted if the same as for the previous triangle, lod is omitted if default
            // second: normals: one normal if same for all three vertices, three normals (flattened to 9 numbers) if different, empty array if normals are the same as previous triangle
            // third: group indices: omitted if default, empty array if the same as for the previous triangle
            length = dataJSON.triangles[i][0].length;
            if ((length === 6) || (length === 12)) { // two cases, with and without texCoords being omitted
                minLOD = dataJSON.triangles[i][0][length - 2];
                maxLOD = dataJSON.triangles[i][0][length - 1];
            } else {
                minLOD = defaultMinLOD;
                maxLOD = defaultMaxLOD;
            }
            params.color = colorPalette[dataJSON.triangles[i][0][3]];
            params.texCoords = (length >= 10) ? [dataJSON.triangles[i][0].slice(4, 6), dataJSON.triangles[i][0].slice(6, 8), dataJSON.triangles[i][0].slice(8, 10)] : params.texCoords;
            params.normals = (dataJSON.triangles[i][1].length > 0) ?
                    ((dataJSON.triangles[i][1].length > 3) ?
                            [dataJSON.triangles[i][1].slice(0, 3), dataJSON.triangles[i][1].slice(3, 6), dataJSON.triangles[i][1].slice(6, 9)] :
                            [dataJSON.triangles[i][1]]) :
                    params.normals;
            params.groupIndices = (dataJSON.triangles[i].length >= 3) ?
                    ((dataJSON.triangles[i][2].length > 0) ? dataJSON.triangles[i][2] : params.groupIndices) :
                    null;
            params.withoutLines = true;
            index = dataJSON.triangles[i][0][0];
            this.addTriangleDirect(minLOD, maxLOD,
                    index, // a
                    index + dataJSON.triangles[i][0][1], // b
                    index + dataJSON.triangles[i][0][2], // c
                    params);
        }
        application.log_DEBUG("Loaded " + nTriangles + " triangles.", 3);
        application.log_DEBUG("Model loaded: " + this._name + ". Details: " + this._minLOD + "-" + this._maxLOD, 2);
        if (application.isDebugVersion()) {
            str = "Number of triangles per LOD for " + this._name + ": ";
            for (i = this._minLOD; i <= this._maxLOD; i++) {
                str += " [" + i + "]: " + this.getMeshWithLOD(i).getNumTriangles();
            }
            application.log_DEBUG(str, 2);
        }
        return true;
    };
    /**
     * Returns the scale factor of this model i.e. what is the meaning of 1 coordinate
     * unit in meters.
     * @returns {Number}
     */
    Model.prototype.getScale = function () {
        return this._scale;
    };
    /**
     * Calls the given value function by passing it all of the meshes one after the other, and returns the highest value it returns from
     * these calls. 
     * @param {Number} [lod] If given, the functon will be called only for the mesh with the given LOD
     * @param {Function} valueFunction
     */
    Model.prototype._getLargestValueOfMeshes = function (lod, valueFunction) {
        var result, current;
        if (lod !== undefined) {
            return valueFunction(this.getMeshWithLOD(lod));
        }
        for (lod = this._minLOD; lod <= this._maxLOD; lod++) {
            current = valueFunction(this.getMeshWithLOD(lod));
            if ((result === undefined) || (current > result)) {
                result = current;
            }
        }
        return result;
    };
    /**
     * Calls the given value function by passing it all of the meshes one after the other, and returns the lowest value it returns from
     * these calls. 
     * @param {Number} [lod] If given, the functon will be called only for the mesh with the given LOD
     * @param {Function} valueFunction
     */
    Model.prototype._getLowestValueOfMeshes = function (lod, valueFunction) {
        var result, current;
        if (lod !== undefined) {
            return valueFunction(this.getMeshWithLOD(lod));
        }
        for (lod = this._minLOD; lod <= this._maxLOD; lod++) {
            current = valueFunction(this.getMeshWithLOD(lod));
            if ((result === undefined) || (current < result)) {
                result = current;
            }
        }
        return result;
    };
    /**
     * Returns the size of the model, which is calculated as the double of the
     * farthest (X,Y or Z) vertex coordinate to be found in the model.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getSize = function (lod) {
        return this._getLargestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getSize() : 0;
        });
    };

    /**
     * Returns the greatest positive X vertex coordinate to be found in the 
     * model.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getMaxX = function (lod) {
        return this._getLargestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getMaxX() : 0;
        });
    };

    /**
     * Returns the greatest negative X vertex coordinate to be found in the 
     * model.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getMinX = function (lod) {
        return this._getLowestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getMinX() : 0;
        });
    };

    /**
     * Returns the greatest positive Y vertex coordinate to be found in the 
     * model.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getMaxY = function (lod) {
        return this._getLargestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getMaxY() : 0;
        });
    };

    /**
     * Returns the greatest negative Y vertex coordinate to be found in the 
     * model.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getMinY = function (lod) {
        return this._getLowestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getMinY() : 0;
        });
    };

    /**
     * Returns the greatest positive Z vertex coordinate to be found in the 
     * model.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getMaxZ = function (lod) {
        return this._getLargestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getMaxZ() : 0;
        });
    };

    /**
     * Returns the greatest negative Z vertex coordinate to be found in the 
     * model.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getMinZ = function (lod) {
        return this._getLowestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getMinZ() : 0;
        });
    };

    /**
     * Returns the width of the model, which is calculated as the difference
     * between the smallest and greatest X coordinates found among the vertices.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getWidth = function (lod) {
        return this._getLargestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getWidth() : 0;
        });
    };

    /**
     * Returns the height of the model, which is calculated as the difference
     * between the smallest and greatest Y coordinates found among the vertices.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getHeight = function (lod) {
        return this._getLargestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getHeight() : 0;
        });
    };

    /**
     * Returns the depth of the model, which is calculated as the difference
     * between the smallest and greatest Z coordinates found among the vertices.
     * @param {Number} [lod] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getDepth = function (lod) {
        return this._getLargestValueOfMeshes(lod, function (mesh) {
            return mesh ? mesh.getDepth() : 0;
        });
    };

    /**
     * Returns the width of the model in meters.
     * @param {Number} [lod=0] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getWidthInMeters = function (lod) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        return this.getWidth(lod) * this._scale;
    };

    /**
     * Returns the height of the model in meters.
     * @param {Number} [lod=0] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getHeightInMeters = function (lod) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        return this.getHeight(lod) * this._scale;
    };

    /**
     * Returns the depth of the model in meters.
     * @param {Number} [lod=0] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getDepthInMeters = function (lod) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        return this.getDepth(lod) * this._scale;
    };

    /**
     * Returns the number of lines this model contains.
     * @param {Number} [lod=0] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getNumLines = function (lod) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        return (lod >= 0) ? this.getMeshWithLOD(lod).getNumLines() : 0;
    };

    /**
     * Returns the number of completely opaque triangles this model contains.
     * @param {Number} [lod=0] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getNumOpaqueTriangles = function (lod) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        return this.getMeshWithLOD(lod).getNumOpaqueTriangles();
    };

    /**
     * Returns the number of transparent triangles this model contains.
     * @param {Number} [lod=0] The level of detail of the mesh to consider.
     * @returns {Number}
     */
    Model.prototype.getNumTransparentTriangles = function (lod) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        return this.getMeshWithLOD(lod).getNumTransparentTriangles();
    };

    /**
     * Returns the number of triangles this model contains.
     * @param {Number} [lod=0] The level of detail of the mesh to consider.
     * @param {Boolean} [transparent] Whether to count the transparent or the opaque triangles. If not given, both will be counted.
     * @returns {Number}
     */
    Model.prototype.getNumTriangles = function (lod, transparent) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        return (lod >= 0) ? this.getMeshWithLOD(lod).getNumTriangles(transparent) : 0;
    };

    /**
     * Adds this model to the passed ManagedGLContext in the specified drawing
     * mode (wireframe or solid), so that later the vertex buffers of the 
     * context can be filled with its data.
     * @param {ManagedGLContext} context The context to which the model should 
     * be added.
     * @param {Boolean} wireframe Whether to add the model for wireframe 
     * drawing.
     * Both modes can be added after each other with two calls of this 
     * functions.
     */
    Model.prototype.addToContext = function (context, wireframe) {
        this._minLOD = (this._minLOD !== this.LOD_NOT_SET) ? this._minLOD : 0;
        this._maxLOD = (this._maxLOD !== this.LOD_NOT_SET) ? this._maxLOD : 0;
        // get the already stored properties for easier access
        var props = this._contextProperties[context.getName()];
        // If the model hasn't been added to this context at all yet, add it with
        // the appropriate mode.
        if (!props) {
            application.log_DEBUG("Adding model (" + this._name + ") to context (" + (wireframe ? "wireframe" : "solid") + " mode)...", 2);
            props = new ModelContextProperties();
            props.wireframe = wireframe;
            props.solid = !wireframe;
            props.minLOD = this._minLOD;
            props.maxLOD = this._maxLOD;
            context.addModel(this);
            // If the model itself was added, check if it has been added with this
            // mode, and if not, the context needs to be reset in order to trigger
            // a new vertex buffer loading next time it is initialized, since new
            // data will need to be loaded to the buffers.
        } else {
            if (!props.wireframe && wireframe) {
                application.log_DEBUG("Adding model (" + this._name + ") to context in wireframe mode)...", 2);
                props.wireframe = true;
                context.resetReadyState();
            }
            if (!props.solid && !wireframe) {
                application.log_DEBUG("Adding model (" + this._name + ") to context in solid mode)...", 2);
                props.solid = true;
                context.resetReadyState();
            }
            if (props.minLOD > this._minLOD) {
                application.log_DEBUG("Adding model (" + this._name + ") to context with minimum LOD " + this._minLOD + "...", 2);
                props.minLOD = this._minLOD;
                context.resetReadyState();
            }
            if (props.maxLOD < this._maxLOD) {
                application.log_DEBUG("Adding model (" + this._name + ") to context with maximum LOD " + this._maxLOD + "...", 2);
                props.maxLOD = this._maxLOD;
                context.resetReadyState();
            }
        }
        // update the stored parameters
        this._contextProperties[context.getName()] = props;
    };

    /**
     * Clears all previous bindings to managed WebGL contexts. After this, the
     * model needs to be added again to contexts if it needs to be rendered in
     * them.
     */
    Model.prototype.clearContextBindings = function () {
        var contextName;
        for (contextName in this._contextProperties) {
            if (this._contextProperties.hasOwnProperty(contextName)) {
                delete this._contextProperties[contextName];
            }
        }
    };

    /**
     * Returns the data about this 3D model that is in a proper format to be 
     * loaded into GL vertex buffers.
     * @param {Boolean} wireframe Whether data for wireframe rendering should
     * be returned (false -> solid rendering)
     * @param {Number} startIndex The current size of the vertex buffers to
     * which the data from this model is to be added to, so that correct
     * indices will be calculated.
     * @param {Number} [lod=0] The LOD of the mesh to be added (only one mesh
     * may be added at a time)
     * @returns {Object}
     */
    Model.prototype.getBufferData = function (wireframe, startIndex, lod) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        return this._meshes[lod].getBufferData(wireframe, startIndex, this._position4);
    };

    /**
     * Returns the size of the vertex buffer data (number of vertices) that this
     * model has for the specified context.
     * @param {ManagedGLContext} context
     * @returns {Number}
     */
    Model.prototype.getBufferSize = function (context) {
        var i,
                props = this._contextProperties[context.getName()],
                result = 0;
        for (i = props.minLOD; i <= props.maxLOD; i++) {
            result += this._meshes[i].getBufferSize(props.wireframe, props.solid);
        }
        return result;
    };

    /**
     * Loads the model's vertex data into the vertex buffer objects of the specified
     * context. Data for wireframe and solid rendering is added based on whether
     * the model has been previously added to the context in the respective mode.
     * @param {ManagedGLContext} context
     * @param {Number} startIndex The data will be added starting from this 
     * vertex index within the buffer objects.
     * @param {Number} [lod=0]
     * @returns {Number} The number of vertices for which data has been added.
     */
    Model.prototype.loadToVertexBuffers = function (context, startIndex, lod) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        var props = this._contextProperties[context.getName()];
        return this._meshes[lod].loadToVertexBuffers(context, startIndex, props.wireframe, props.solid, this._position4);
    };

    /**
     * Renders the model within the passed context, with the specified rendering
     * mode (wireframe or solid).
     * @param {ManagedGLContext} context The context into which the model is to
     * be rendered. The model has to be added to this context previously in the
     * same rendering mode, and the context needs to be set up afterwards for
     * rendering.
     * @param {Boolean} wireframe Whether the model should be rendered in 
     * wireframe mode.
     * @param {Boolean} opaque Whether only the opaque parts of the model should be
     * rendered. False means only transparent parts, and undefined (omitted) means
     * the whole model. Only effective in solid rendering mode.
     * @param {Number} [lod=0]
     */
    Model.prototype.render = function (context, wireframe, opaque, lod) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        this._meshes[lod].render(context, wireframe, opaque);
    };
    /**
     * Similar to the regular render method, but this renders the given number of instances of the model using instancing.
     * @param {ManagedGLContext} context
     * @param {Boolean} wireframe
     * @param {Boolean} [opaque]
     * @param {Number} [lod=0]
     * @param {Number} instanceCount
     */
    Model.prototype.renderInstances = function (context, wireframe, opaque, lod, instanceCount) {
        lod = (lod !== undefined) ? lod : this._minLOD;
        this._meshes[lod].renderInstances(context, wireframe, opaque, instanceCount);
    };

    /**
     * Adds a new vertex to the currently edited mesh(es).
     * @param {Number[3]} position
     * @param {Number[2]} [texCoords]
     */
    Model.prototype.appendVertex = function (position, texCoords) {
        this.getMeshWithLOD(0).appendVertex(position, texCoords);
    };

    /**
     * Adds a new line to the currently edited mesh(es).
     * @param {Line} line
     */
    Model.prototype.addLine = function (line) {
        this.getMeshWithLOD(0).addLine(line);
    };

    /**
     * Adds two triangles forming a quadrilateral between 4 vertices.
     * @param {Number} a The index of the first vertex of the quad.
     * @param {Number} b The index of the second vertex of the quad.
     * @param {Number} c The index of the third vertex of the quad.
     * @param {Number} d The index of the fourth vertex of the quad.
     * @param {Object} params The parameters of the quad in the same format as with
     * single triangles.
     * @see Model#addTriangle
     */
    Model.prototype.addQuad = function (a, b, c, d, params) {
        this.getMeshWithLOD(0).addQuad(a, b, c, d, params);
    };

    /**
     * Adds a cuboid geometry to the object. (both vertices and faces)
     * @param {Number} x The X coordinate of the center of the cuboid.
     * @param {Number} y The Y coordinate of the center of the cuboid.
     * @param {Number} z The Z coordinate of the center of the cuboid.
     * @param {Number} width The width (X dimension) of the cuboid.
     * @param {Number} height The height (Y dimension) of the cuboid.
     * @param {Number} depth The depth (Z dimension) of the cuboid.
     * @param {Number[4]} color The color of the faces of the cuboid 
     * ([red,green,blue,alpha])
     * @param {Number[4][2]} textureCoordinates The texture coordinates for the 
     * faces of the cuboid (the two coordinates for each of the 4 vertices of one
     * face.
     * @param {Boolean} cullFace Whether the faces facing the inside of the cuboid
     * should be culled (omitted)
     */
    Model.prototype.addCuboid = function (x, y, z, width, height, depth, color, textureCoordinates, cullFace) {
        this.getMeshWithLOD(0).addCuboid(x, y, z, width, height, depth, color, textureCoordinates, cullFace);
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        VertexAttributeRole: VertexAttributeRole,
        resetDebugStats: resetDebugStats,
        getDebugStats: getDebugStats,
        Model: Model,
        /**
         * Sets up and returns a simple model that is suitable to be used for
         * rendering Full Viewport Quads. (FVQ)
         * @param {String} [name] The name of the model to be created.
         * @returns {Model}
         */
        fvqModel: function (name) {
            var result = new Model();
            if (name) {
                result.setName(name);
            }

            result.appendVertex([-1, -1, 0]);
            result.appendVertex([1, -1, 0]);
            result.appendVertex([1, 1, 0]);
            result.appendVertex([-1, 1, 0]);

            result.addQuad(0, 1, 2, 3);

            return result;
        },
        /**
         * Sets up and returns a simple model that contains a two sided XY square.
         * @param {String} [name] The name of the model to be created.
         * @param {Number[2][2]} [textureCoordinates] The texture coordinates to use - top-left and bottom-right, in (0;0) - (1;1) space
         * @returns {Model}
         */
        squareModel: function (name, textureCoordinates) {
            var result = new Model(), tc;
            if (name) {
                result.setName(name);
            }
            tc = textureCoordinates || DEFAULT_SQUARE_TEX_COORDINATES;

            result.appendVertex([-1, -1, 0]);
            result.appendVertex([1, -1, 0]);
            result.appendVertex([1, 1, 0]);
            result.appendVertex([-1, 1, 0]);

            result.addQuad(0, 1, 2, 3, {texCoords: [[tc[0][0], tc[1][1]], [tc[1][0], tc[1][1]], [tc[1][0], tc[0][1]], [tc[0][0], tc[0][1]]]});

            return result;
        },
        /**
         * Sets up and returns a simple model that is suitable for rendering billboards that turn around one axis to face the camera. The 
         * model contains one square to serve as the turning side view (with texture coordinates corresponding to the upper half of the 
         * texture) and a set of intersecting squares that are perpendicular to the first one (with texture coordinates corresponding to the 
         * lower half of the texture), to serve as the front/back view(s) so that the billboard does not look flat at sharp angles.
         * @param {String} [name] The name of the model to be created.
         * @param {Number[]} [intersections] A set of numbers between -1 and 1 representing the points where the squares serving as the 
         * front view should be created along the side view square.
         * @param {Number} width On X and Z axes, the model will be "trimmed" using this ratio (should be between 0 and 1), by multiplying 
         * both its vertex and texture coordinates.
         * @returns {Model}
         */
        turningBillboardModel: function (name, intersections, width) {
            var i,
                    tLeft = 0.5 - 0.5 * width, tRight = 0.5 + 0.5 * width,
                    tTop = 0.75 - 0.25 * width, tBottom = 0.75 + 0.25 * width,
                    result = new Model();
            if (name) {
                result.setName(name);
            }

            result.appendVertex([-width, -1, 0]);
            result.appendVertex([width, -1, 0]);
            result.appendVertex([width, 1, 0]);
            result.appendVertex([-width, 1, 0]);

            result.addQuad(0, 1, 2, 3, {texCoords: [[tLeft, 0.5], [tRight, 0.5], [tRight, 0.0], [tLeft, 0.0]]});

            if (intersections) {
                for (i = 0; i < intersections.length; i++) {
                    result.appendVertex([width, intersections[i], -width]);
                    result.appendVertex([-width, intersections[i], -width]);
                    result.appendVertex([-width, intersections[i], width]);
                    result.appendVertex([width, intersections[i], width]);

                    result.addQuad(((i + 1) * 4), ((i + 1) * 4) + 1, ((i + 1) * 4) + 2, ((i + 1) * 4) + 3,
                            {
                                texCoords:
                                        [[tLeft, tBottom], [tRight, tBottom], [tRight, tTop], [tLeft, tTop]]
                            });
                    result.addQuad(((i + 1) * 4) + 3, ((i + 1) * 4) + 2, ((i + 1) * 4) + 1, ((i + 1) * 4),
                            {
                                texCoords:
                                        [[tLeft, tBottom], [tRight, tBottom], [tRight, tTop], [tLeft, tTop]]
                            });
                }
            }

            return result;
        },
        /**
         * Sets up and returns a simple model that contains a cuboid (XYZ-box)  
         * with the given properties.
         * @param {String} [name] The name of the model to be created.
         * @param {Number} width Size of the box along the X axis.
         * @param {Number} height Size of the box along the Y axis.
         * @param {Number} depth Size of the box along the Z axis.
         * @param {Number[4]} color A vector containing the RGBA components of the 
         * desired box color.
         * @returns {Model}
         */
        cuboidModel: function (name, width, height, depth, color) {
            var result = new Model();
            if (name) {
                result.setName(name);
            }
            result.addCuboid(0, 0, 0, width, height, depth, color, [[0, 1], [1, 1], [1, 0], [0, 0]], false);
            return result;
        },
        /**
         * Sets up and returns a simple model that contains a two vertices, the
         * first of which is in the origo, connected by a line.
         * @param {String} [name] The name of the model to be created.
         * @param {Number[3]} vector The vector pointing from the origo towards 
         * the second vertex.
         * @param {Number[3]} color The RGB components of the color to use for 
         * the line.
         * @returns {Model}
         */
        lineModel: function (name, vector, color) {
            var result = new Model();
            if (name) {
                result.setName(name);
            }
            result.appendVertex([0.0, 0.0, 0.0]);
            result.appendVertex(vector);
            result.addLine(new Line(0, 1, color, vector));
            return result;
        },
        /**
         * Creates and returns a model with lines forming a uniform grid on
         * the XY plane.
         * @param {String} [name] The name to set for the model
         * @param {Number} width The size on the grid on the X axis
         * @param {Number} height The size of the grid on the Y axis
         * @param {Number} xCount The number of lines dividing the X axis
         * @param {Number} yCount The number of lines dividing the Y axis
         * @param {Number[3]} color The color of the lines
         */
        gridModel: function (name, width, height, xCount, yCount, color) {
            var i, v = [0, 0, 0], normal = [0, 0, 1], result = new Model();
            if (name) {
                result.setName(name);
            }
            for (i = 0; i < xCount; i++) {
                v[0] = width * (i / (xCount - 1) - 0.5);
                v[1] = height * -0.5;
                result.appendVertex(v);
                v[1] = height * 0.5;
                result.appendVertex(v);
                result.addLine(new Line(i * 2, i * 2 + 1, color, normal));
            }
            for (i = 0; i < yCount; i++) {
                v[0] = width * -0.5;
                v[1] = height * (i / (yCount - 1) - 0.5);
                result.appendVertex(v);
                v[0] = width * 0.5;
                result.appendVertex(v);
                result.addLine(new Line((xCount + i) * 2, (xCount + i) * 2 + 1, color, normal));
            }
            return result;
        },
        /**
         * Creates and returns a model with lines forming a cirle on the XY plane,
         * with an extra line pointing up from the center of the cirle towards +Z
         * @param {String} [name] The name to set for the model
         * @param {Number} count The amount of vertices to create the circle
         * @param {Number[3]} color The color of the lines
         */
        positionMarkerModel: function (name, count, color) {
            var i, v = [1, 0, 0], normal = [0, 0, 1], angle, result = new Model();
            if (name) {
                result.setName(name);
            }
            result.appendVertex(v);
            for (i = 1; i < count; i++) {
                angle = (i / count) * 2 * Math.PI;
                v[0] = Math.cos(angle);
                v[1] = Math.sin(angle);
                result.appendVertex(v);
                result.addLine(new Line(i - 1, i, color, normal));
            }
            result.addLine(new Line(i - 1, 0, color, normal));
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            result.appendVertex(v);
            v[2] = 1;
            result.appendVertex(v);
            result.addLine(new Line(i, i + 1, color, normal));
            return result;
        }
    };
});
/**
 * Copyright 2016-2018, 2020 Krisztián Nagy
 * @file This module provides some wrappers for Web Audio API functions for easier use.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 0.1
 */

/*global define, AudioContext */

// some type hints for the current version of the web Audio API

/**
 * @callback AudioNode~connectFunction
 * @param {AudioNode} destination
 */

/**
 * @typedef {Object} AudioNode 
 * @property {AudioNode~connectFunction} connect
 */

/**
 * @callback AudioParam~linearRampToValueAtTimeFunction
 * @param {Number} value
 * @param {Number} endTime
 */

/**
 * @typedef {AudioNode} AudioParam 
 * @property {Number} value
 * @property {AudioParam~linearRampToValueAtTimeFunction} linearRampToValueAtTime
 * @returns {AudioParam} 
 */

/**
 * @typedef {Object} AudioBuffer
 */

/**
 * @typedef {AudioNode} AudioBufferSourceNode
 * @property {AudioBuffer} buffer
 * @property {Boolean} loop
 */

/**
 * @typedef {AudioNode} GainNode
 * @property {AudioParam} gain
 */

/**
 * @callback PannerNode~setPositionFunction
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */

/**
 * @typedef {AudioNode} PannerNode
 * @property {PannerNode~setPositionFunction} setPosition
 * @property {AudioParam} positionX
 * @property {AudioParam} positionY
 * @property {AudioParam} positionZ
 */

/**
 * @typedef {AudioNode} DynamicsCompressorNode
 */

/**
 * @callback AudioContext~createBufferSourceFunction
 * @returns {AudioBufferSourceNode}
 */

/**
 * @callback AudioContext~createGainFunction
 * @returns {GainNode}
 */

/**
 * @callback AudioContext~createPannerFunction
 * @returns {PannerNode}
 */

/**
 * @callback AudioContext~createDynamicsCompressorFunction
 * @returns {DynamicsCompressorNode}
 */

/**
 * @typedef {Object} AudioContext
 * @property {AudioContext~createBufferSourceFunction} createBufferSource
 * @property {AudioContext~createGainFunction} createGain
 * @property {AudioContext~createPannerFunction} createPanner
 * @property {AudioContext~createDynamicsCompressorFunction} createDynamicsCompressor
 */

/** 
 * @param application Used for showing error messages.
 */
define('modules/audio',[
    "modules/application"
], function (application) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Enums
            /**
             * @enum {Number}
             * When sound sources are created, they need to be put in one of these categories. Each category has a gain node at the end of 
             * the audio graph through which the volume of that category can be set individually. 
             * For simplicity there are only two static categories now, but in fact this could be generalized by allowing arbitrary string
             * IDs for categories and creating and connecting gain nodes for new categories on-the-fly.
             * @type Object
             */
            SoundCategory = {
                /**
                 * Attempting to play a sound in this category will result in an error - this is to prevent playing sounds with undefined
                 * category
                 */
                NOME: 0,
                /**
                 * A category for sound effects - typically short, possibly spatialized
                 */
                SOUND_EFFECT: 1,
                /**
                 * A category for songs to play - typically longer, not spatialized
                 */
                MUSIC: 2,
                /**
                 * A category for sounds of the UI - typically short, not spatialized
                 */
                UI: 3
            },
            /**
             * @enum {String}
             * Encompasses the possible panning models for panner nodes
             * @type Object
             */
            PanningModel = {
                EQUAL_POWER: "equalpower",
                HRTF: "HRTF"
            },
            // ----------------------------------------------------------------------
            // Constants
            /**
             * When calling a ramp function without a duration parameter, this duration is used
             * @type Number
             */
            DEFAULT_RAMP_DURATION = 0.010,
            /**
             * When creating a sound source without a rolloff factor parameter, this value is used
             * @type Number
             */
            DEFAULT_ROLLOFF_FACTOR = 0.01,
            /**
             * When creating a sound source without a panning model given, this panning model is used
             * @type String
             */
            DEFAULT_PANNING_MODEL = PanningModel.EQUAL_POWER,
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * Stores a reference to all the loaded buffers, organized by the names of the sound files they were loaded from - so that one
             * sound files is only loaded once.
             * @type Object
             */
            _buffers = {},
            /**
             * Used for setting the master volume for sound effects - all effect nodes are going through this.
             * @type GainNode
             */
            _effectGain,
            /**
             * Used for setting the master volume for music - all music nodes are going through this.
             * @type GainNode
             */
            _musicGain,
            /**
             * Used for setting the master volume for UI - all UI nodes are going through this.
             * @type GainNode
             */
            _uiGain,
            /**
             * Used for setting the master volume for all sounds - all sound nodes are going through this.
             * @type GainNode
             */
            _masterGain,
            /**
             * Used for dynamic compression at the end of the audio graph.
             * @type DynamicsCompressorNode
             */
            _compressor,
            /**
             * A common sound clip that is used to play sounds for which no persistent sound clip needs to be created (to avoid creating
             * unnecessary objects) 
             * @type SoundClip
             */
            _clip,
            /**
             * A common sound source that is used to play sounds for which no persistent sound source needs to be created (to avoid creating
             * unnecessary objects) 
             * @type SoundSource
             */
            _source,
            /**
             * A reference the audio context of the API.
             * @type AudioContext
             */
            _context;
    // ----------------------------------------------------------------------
    // Private functions
    /**
     * Ramps the gain of the passed node
     * @param {GainNode} gainNode
     * @param {Number} volume The target value to change to
     * @param {Number} [duration=DEFAULT_RAMP_DURATION] The duration of the ramp, in seconds
     * @param {Boolean} [onlyIfDifferent=false] If true, then the ramp will not be applied in case a ramp is already in progress towards the
     * same value.
     * @param {Boolean} [exponential=false] If true, an exponential instead of linear ramp will be used, and the duration will be interpreted
     * as decay time instead
     */
    function _rampVolume(gainNode, volume, duration, exponential) {
        var currentTime = _context.currentTime;
        gainNode.gain.cancelScheduledValues(currentTime);
        gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
        if (exponential) {
            gainNode.gain.setTargetAtTime(volume, currentTime, duration || DEFAULT_RAMP_DURATION);
        } else {
            gainNode.gain.linearRampToValueAtTime(volume, currentTime + (duration || DEFAULT_RAMP_DURATION));
        }
    }
    // ##############################################################################
    /**
     * @class
     * Represents a 3D sound source that can be used to play sound clips positioned in 3D space according to the settings given for this
     * object.
     * @param {Number[3]} position The initial camera-space position of the sound source
     * @param {Number} [rolloffFactor=DEFAULT_ROLLOFF_FACTOR] The factor to determine how loud the sound should be at a 
     * specific distance. The formula used: 1 / (1 + rolloffFactor * (d - 1)), where d is the distance (reverse mode with refDistance=1)
     * @param {String} [panningModel=DEFAULT_PANNING_MODEL] (enum PanningModel) The panning model to use (see Web Audio API)
     */
    function SoundSource(position, rolloffFactor, panningModel) {
        /**
         * The camera-space position of the sound source
         * @type Number[3]
         */
        this._position = position ? position.slice() : null;
        /**
         * The factor to determine how loud the sound should be at a specific distance
         * @type Number
         */
        this._rolloffFactor = rolloffFactor || DEFAULT_ROLLOFF_FACTOR;
        /**
         * A reference to the node used to control the spatial position of this sound
         * @type PannerNode
         */
        this._pannerNode = null;
        /**
         * (enum PanningModel) See the Web Audio API
         * @type String
         */
        this._panningModel = panningModel || DEFAULT_PANNING_MODEL;
        /**
         * Associated sound clips organized by the names of the samples they play. This can be used
         * to stack clips - instead of adding multiple clips of the same sample at the same time or with
         * a short time difference, only one is added, and the others just increase its volume
         * @type Object.<String, SoundClip>
         */
        this._clips = {};
    }
    /**
     * If necessary, creates, and returns the AudioNode to which nodes can be connected to play their output at the 3D position determined
     * by this sound source.
     * @returns {PannerNode}
     */
    SoundSource.prototype.getNode = function () {
        if (!this._pannerNode) {
            this._pannerNode = _context.createPanner();
            this._pannerNode.panningModel = this._panningModel;
            this._pannerNode.refDistance = 1;
            this._pannerNode.rolloffFactor = this._rolloffFactor;
            this._pannerNode.setPosition(this._position[0], this._position[1], this._position[2]);
            this._pannerNode.connect(_effectGain);
        }
        return this._pannerNode;
    };
    /**
     * Sets a new position for the sound source. 
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     */
    SoundSource.prototype.setPosition = function (x, y, z) {
        var currentTime;
        if ((x !== this._position[0]) || (y !== this._position[1]) || (z !== this._position[2])) {
            this._position[0] = x;
            this._position[1] = y;
            this._position[2] = z;
            if (this._pannerNode) {
                // if possible, ramp with a small interval to avoid clicks / pops resulting from abrupt changes
                // this requires more processing (AudioParam events), so only apply if the clip is not muted
                if ((this._pannerNode.positionX) && (!this._gainNode || (this._gainNode.gain.value > 0))) {
                    currentTime = _context.currentTime;
                    // avoid inserting new events if possible
                    if (this._pannerNode.positionX.value !== x) {
                        this._pannerNode.positionX.cancelScheduledValues(currentTime);
                        this._pannerNode.positionX.setValueAtTime(this._pannerNode.positionX.value, currentTime);
                        this._pannerNode.positionX.linearRampToValueAtTime(x, currentTime + DEFAULT_RAMP_DURATION);
                    }
                    if (this._pannerNode.positionY.value !== y) {
                        this._pannerNode.positionY.cancelScheduledValues(currentTime);
                        this._pannerNode.positionY.setValueAtTime(this._pannerNode.positionY.value, currentTime);
                        this._pannerNode.positionY.linearRampToValueAtTime(y, currentTime + DEFAULT_RAMP_DURATION);
                    }
                    if (this._pannerNode.positionZ.value !== z) {
                        this._pannerNode.positionZ.cancelScheduledValues(currentTime);
                        this._pannerNode.positionZ.setValueAtTime(this._pannerNode.positionZ.value, currentTime);
                        this._pannerNode.positionZ.linearRampToValueAtTime(z, currentTime + DEFAULT_RAMP_DURATION);
                    }
                    // if the clip is muted or the position AudioParams are not available, do the fallback
                } else {
                    this._pannerNode.setPosition(x, y, z);
                }
            }
        }
    };
    /**
     * Sets the stored sound clip reference associated with the passed (sample) name
     * @param {String} name
     * @param {SoundClip} clip
     */
    SoundSource.prototype.setClip = function (name, clip) {
        this._clips[name] = clip;
    };
    /**
     * Returns the sound clip associated with the passed name (if any)
     * @param {String} name
     * @returns {SoundClip}
     */
    SoundSource.prototype.getClip = function (name) {
        return this._clips[name];
    };
    /**
     * Removes the reference to the stored panner node (if any) and disconnects all other nodes from the panner node
     */
    SoundSource.prototype.destroy = function () {
        if (this._pannerNode) {
            this._pannerNode.disconnect();
        }
        this._pannerNode = null;
    };
    // ##############################################################################
    /**
     * @class
     * Can be used to play a specific sound sample using the Web Audio API. Can be connected to a SoundSource to position the sound in 3D
     * space or used on its own to simply play it at a desired volume.
     * @param {Number} soundCategory (enum SoundCategory) The category this sound belongs to
     * @param {String} sampleName The name of the sounds sample. Must be loaded for playback (loading is not  handled by this class), cannot
     * be changed later.
     * @param {Number} [volume=1] The volume at which to play the sound sample (in case of 3D sounds, at the reference distance: 1). Can be
     * modified later, but if omitted, no gain node will be added for this source, which means a volume of 1 that cannot be changed.
     * @param {Boolean} [loop=false] Whether the sound sample should be played in looping mode.
     * @param {Boolean} [shouldStack=false] If true, whenever the clip is set to play at an associated sound source, 
     * the sound source will be checked for clips of the same sample, and this clip will be stacked if possible
     * @param {Number} [stackTimeThreshold=0] The time threshold for stacking (maximum time difference, in seconds)
     * @param {Number} [stackVolumeFactor=1] The factor to multiply the volume of stacked sound clips by
     * @param {SoundSource} [soundSource] The (spatial) sound source that emits this clip (category must be sound effect), to position it
     * in 3D
     */
    function SoundClip(soundCategory, sampleName, volume, loop, shouldStack, stackTimeThreshold, stackVolumeFactor, soundSource) {
        /**
         * (enum SoundCategory) The category of this sound, allowing the user to set a separate master volume per category
         * @type Number
         */
        this._soundCategory = soundCategory;
        /**
         * The name of the sounds sample
         * @type String
         */
        this._sampleName = sampleName;
        /**
         * The current volume at which to play the sound sample 
         * @type Number
         */
        this._volume = volume;
        /**
         * Whether the sound sample should be played in looping mode
         * @type Boolean
         */
        this._loop = loop;
        /**
         * If true, whenever the clip is set to play at an associated sound source, the sound source 
         * is checked for clips of the same sample, and this clip will be stacked if possible
         * @type Boolean
         */
        this._shouldStack = shouldStack || false;
        /**
         * If set to stack, the clip will be stacked only if the play time difference between it and the 
         * other clip is less than this amount, in seconds
         * @type Number
         */
        this._stackTimeThreshold = stackTimeThreshold || 0;
        /**
         * When stacking this clip on top of another, the volume increase will be multiplied by this factor
         * @type Number
         */
        this._stackVolumeFactor = stackVolumeFactor || 1;
        /**
         * A reference to the buffer source node used to play this sound
         * @type AudioBufferSourceNode
         */
        this._sourceNode = null;
        /**
         * A reference to the gain node attached to the source, used to control its volume
         * @type GainNode
         */
        this._gainNode = null;
        /**
         * The timestamp of the moment the sample started playing (AudioContext.currentTime)
         * @type Number
         */
        this._playbackStartTime = 0;
        /**
         * A flag marking whether the playback of this sound is in progress
         * @type Boolean
         */
        this._playing = false;
        /**
         * A flag marging whether the stopping of playback has already been scheduled
         * @type Boolean
         */
        this._stopping = false;
        /**
         * The function to execute whenever the playback of the sample stops / finishes
         * @type Function
         */
        this._onFinish = null;
        /**
         * Function to execute on the ended event of the BufferSourceNode playing this clip (instance level)
         * @type Function
         */
        this._onEnded = null;
        /**
         * The associated sound source to position this clip in 3D
         * @type SoundSource
         */
        this._soundSource = null;
        if (soundSource) {
            this.setSource(soundSource);
        }
    }
    /**
     * Sets a sound source to be used for spatial 3D positioning of this clip - can only be used once, and only on sounds that have the
     * sound effect category!
     * @param {SoundSource} value
     */
    SoundClip.prototype.setSource = function (value) {
        if (this._soundCategory !== SoundCategory.SOUND_EFFECT) {
            application.showError("Cannot set sound source for clip '" + this._sampleName + "', because its sound category is not sound effect!");
        } else if (this._soundSource) {
            application.showError("Cannot set sound source for clip '" + this._sampleName + "', because it already has a source!");
        } else if (this._playing) {
            application.showError("Cannot set sound source for clip '" + this._sampleName + "', because it is already playing!");
        } else {
            this._soundSource = value;
        }
    };
    /**
     * Returns the volume currently set for this clip (the actual playback volume might be ramping towards this)
     * @returns {Number}
     */
    SoundClip.prototype.getVolume = function () {
        return (this._volume !== undefined) ? this._volume : 1;
    };
    /**
     * Sets a new volume for the clip. Effective only if an initial volume was specified (even if it was 1.0)
     * @param {Number} volume
     */
    SoundClip.prototype.setVolume = function (volume) {
        this._volume = volume;
        if (this._gainNode) {
            this._gainNode.gain.value = volume;
        }
    };
    /**
     * Increases the volume of the clip. Effective only if an initial volume was specified (even if it was 1.0)
     * @param {Number} amount
     */
    SoundClip.prototype.increaseVolume = function (amount) {
        this._volume += amount;
        if (this._gainNode) {
            this._gainNode.gain.value = this._volume;
        }
    };
    /**
     * Changes the volume of the clip via a linear or exponential ramp
     * @param {Number} volume The target value to change to
     * @param {Number} [duration=DEFAULT_RAMP_DURATION] The duration of the ramp, in seconds
     * @param {Boolean} [onlyIfDifferent=false] If true, then the ramp will not be applied in case a ramp is already in progress towards the
     * same value.
     * @param {Boolean} [exponential=false] If true, an exponential instead of linear ramp will be used, and the duration will be interpreted
     * as decay time instead
     */
    SoundClip.prototype.rampVolume = function (volume, duration, onlyIfDifferent, exponential) {
        if (this._gainNode && (!onlyIfDifferent || (this._volume !== volume))) {
            _rampVolume(this._gainNode, volume, duration, exponential);
        }
        this._volume = volume;
    };
    /**
     * Returns the current position (offset) of playback (where we are within the sample, starting from the beginning, in seconds)
     * @returns {Number}
     */
    SoundClip.prototype.getPlaybackPosition = function () {
        var time = _context.currentTime - this._playbackStartTime;
        return this._loop ? (time % _buffers[this._sampleName].duration) : Math.min(time, _buffers[this._sampleName].duration);
    };
    /**
     * Returns whether the sound sample is currently being played.
     * @returns {Boolean}
     */
    SoundClip.prototype.isPlaying = function () {
        return this._playing;
    };
    /**
     * Function to execute on the ended event of the BufferSourceNode playing this clip (class level)
     */
    SoundClip.prototype._handleEnded = function () {
        this._playing = false;
    };
    /**
     * Recreates the audio nodes, starting the playback of the clip over
     * @param {Number} offset From where to begin playback within the clip, in seconds
     * @param {Function} onFinish The function to call when the playback finishes / stops
     */
    SoundClip.prototype._startPlayingSample = function (offset, onFinish) {
        var currentNode;
        this._sourceNode = _context.createBufferSource();
        this._sourceNode.buffer = _buffers[this._sampleName];
        if (onFinish) {
            // effectively saving the onFinish() function within a closure
            this._sourceNode.onended = function () {
                this._playing = false;
                onFinish();
            }.bind(this);
        } else {
            // do not create new functions if not necessary
            this._onEnded = this._onEnded || this._handleEnded.bind(this);
            this._sourceNode.onended = this._onEnded;
        }
        this._onFinish = onFinish;
        currentNode = this._sourceNode;
        if (this._volume !== undefined) {
            this._gainNode = _context.createGain();
            this._gainNode.gain.value = this._volume;
            currentNode.connect(this._gainNode);
            currentNode = this._gainNode;
        }
        if (this._loop) {
            this._sourceNode.loop = true;
        }
        if (this._soundSource) {
            currentNode.connect(this._soundSource.getNode());
        } else {
            switch (this._soundCategory) {
                case SoundCategory.SOUND_EFFECT:
                    currentNode.connect(_effectGain);
                    break;
                case SoundCategory.MUSIC:
                    currentNode.connect(_musicGain);
                    break;
                case SoundCategory.UI:
                    currentNode.connect(_uiGain);
                    break;
                default:
                    application.showError("Cannot play sound '" + this._sampleName + "', because it has an unkown category: " + this._soundCategory);
            }
        }
        this._playing = true;
        this._stopping = false;
        this._sourceNode.start(_context.currentTime, offset);
        this._playbackStartTime = _context.currentTime - offset;
    };
    /**
     * Starts a new playback of the sound clip. If a previous, non looping playback is in progress, the reference to it will be
     * dropped and the parameters of this class will control the new playback. If a looping playback is in progress, this method does 
     * nothing.
     * @param {Boolean} [restart=false] If true, the previous (last) playback from this sound will be stopped in case it is still playing
     * @param {Function} [onFinish] If given, this function will be executed when the sample finished its playback (for looping sounds, this
     * means when stop is called)
     */
    SoundClip.prototype.play = function (restart, onFinish) {
        var /** @type SoundClip */  clipToStackTo;
        if (_buffers[this._sampleName]) {
            if (this._playing) {
                if (restart) {
                    this.stopPlaying();
                } else if (this._loop) {
                    return;
                }
            }
            // stacking if we should
            if (this._soundSource && this._shouldStack) {
                clipToStackTo = this._soundSource.getClip(this._sampleName);
                if (clipToStackTo && clipToStackTo.isPlaying() && (clipToStackTo.getPlaybackPosition() <= this._stackTimeThreshold)) {
                    clipToStackTo.increaseVolume(this._volume * this._stackVolumeFactor);
                } else {
                    // start a new stack
                    this._startPlayingSample(0, onFinish);
                    if (this._soundSource) {
                        this._soundSource.setClip(this._sampleName, this);
                    }
                }
            } else {
                // simply start playing if stacking is disabled
                this._startPlayingSample(0, onFinish);
            }
        } else if (this._sampleName) {
            application.showError("Attempting to play back '" + this._sampleName + "', which is not loaded!");
        }
    };
    /**
     * Stops the playback of the sound (useful mostly for looping sounds)
     * @param {Number} [rampDuration=0] If given the volume will be ramped to 0 for this duration before stopping, in seconds
     */
    SoundClip.prototype.stopPlaying = function (rampDuration) {
        if (this._sourceNode && this._playing && !this._stopping) {
            if (rampDuration) {
                this.rampVolume(0, rampDuration);
                setTimeout(this._sourceNode.stop.bind(this._sourceNode), rampDuration * 1000);
                this._stopping = true;
            } else {
                this._sourceNode.stop();
            }
        }
    };
    /**
     * Stops the looped playback of the sound when it reaches the end of its current interval
     */
    SoundClip.prototype.stopLoop = function () {
        if (this._sourceNode && this._playing && !this._stopping) {
            this._sourceNode.loop = false;
            this._stopping = true;
        }
    };
    /**
     * Stops the playback of the sound and removes references to the audio nodes
     */
    SoundClip.prototype.destroy = function () {
        this.stopPlaying();
        this._sourceNode = null;
        this._gainNode = null;
        this._position = null;
    };
    // ----------------------------------------------------------------------
    // Public functions
    /**
     * Loads a sound sample to a buffer and saves a reference to it for future use.
     * @param {String} name The by which to save the sound sample (to be used later when playing back or creating sound sources for it)
     * @param {XMLHTTPRequest} request The request which was used to download the sound sample (it should contain the (encoded) sample in an
     * arraybuffer type response)
     * @param {Function} [successCallback] A function to execute if the decoding of the sample is successful
     * @param {Function} [failureCallback] A function to execute if the decoding of the sample fails
     */
    function loadSample(name, request, successCallback, failureCallback) {
        _context.decodeAudioData(request.response, function (buffer) {
            _buffers[name] = buffer;
            if (successCallback) {
                successCallback();
            }
        }, function () {
            application.showError("Decoding audio sample '" + name + "' failed!");
            if (failureCallback) {
                failureCallback();
            }
        });
    }
    /**
     * Plays back a loaded sound sample without creating a persistent sound source (or any reference) for it.
     * @param {String} sampleName The name of the sample to be played
     * @param {Number} [volume=1] The volume at which to play back the sample
     * @param {Number[3]} [position] The camera-space position of the sound source, in case the sound should be spatialized
     * @param {Number} [rolloffFactor=1] The rolloff factor of the sound in case it is spatialized. See SoundSource for how the volume is
     * calculated based on it
     */
    function playSound(sampleName, volume, position, rolloffFactor) {
        SoundClip.call(_clip, SoundCategory.SOUND_EFFECT, sampleName, volume, false);
        if (position) {
            SoundSource.call(_source, position, rolloffFactor, DEFAULT_PANNING_MODEL);
            _clip.setSource(_source);
        }
        _clip.play();
    }
    /**
     * Sets a master volume applied to all sound effects.
     * @param {Number} value
     * @param {Number} [duration=DEFAULT_RAMP_DURATION] The volume will be ramped for this duration, in seconds
     */
    function setEffectVolume(value, duration) {
        _rampVolume(_effectGain, value, duration);
    }
    /**
     * Sets a master volume applied to music.
     * @param {Number} value
     * @param {Number} [duration=DEFAULT_RAMP_DURATION] The volume will be ramped for this duration, in seconds
     */
    function setMusicVolume(value, duration) {
        _rampVolume(_musicGain, value, duration);
    }
    /**
     * Sets a master volume applied to UI sounds.
     * @param {Number} value
     * @param {Number} [duration=DEFAULT_RAMP_DURATION] The volume will be ramped for this duration, in seconds
     */
    function setUIVolume(value, duration) {
        _rampVolume(_uiGain, value, duration);
    }
    /**
     * Sets a master volume applied to all sounds.
     * @param {Number} value
     * @param {Number} [duration=DEFAULT_RAMP_DURATION] The volume will be ramped for this duration, in seconds
     */
    function setMasterVolume(value, duration) {
        _rampVolume(_masterGain, value, duration);
    }
    /**
     * Resumes audio playback (in case auto-play was prevented, this needs to be called from the event handler
     * of user interaction, such as a button click, to start audio playback in general)
     */
    function resume() {
        _context.resume();
    }
    // -------------------------------------------------------------------------
    // Initizalization
    _context = new AudioContext();
    _masterGain = _context.createGain();
    _masterGain.connect(_context.destination);
    _compressor = _context.createDynamicsCompressor();
    _compressor.connect(_masterGain);
    _effectGain = _context.createGain();
    _effectGain.connect(_compressor);
    _musicGain = _context.createGain();
    _musicGain.connect(_compressor);
    _uiGain = _context.createGain();
    _uiGain.connect(_masterGain);
    _clip = new SoundClip();
    _source = new SoundSource();
    // -------------------------------------------------------------------------
    // Public interface
    return {
        SoundCategory: SoundCategory,
        PanningModel: PanningModel,
        SoundClip: SoundClip,
        SoundSource: SoundSource,
        loadSample: loadSample,
        playSound: playSound,
        setEffectVolume: setEffectVolume,
        setMusicVolume: setMusicVolume,
        setUIVolume: setUIVolume,
        setMasterVolume: setMasterVolume,
        resume: resume
    };
});


/**
 * Copyright 2014-2017, 2020 Krisztián Nagy
 * @file Augments the functionality of ResourceManager to provide a customized resource manager class storing various media resources,
 * for which the respective classes are also provided. These classes are based on the classes of ManagedGL and EgomModel.
 * The provided resource manager is ready to use, can load media resource descriptions from a specified JSON file, then mark the 
 * specific resources for loading (e.g. getTexture(params)) and load them when requested.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, Image, window */

/**
 * @param utils Used for comparing objects for equality
 * @param types Used for verifying enum values
 * @param application Used for file loading, logging and displaying error messages
 * @param resourceManager This module builds on the functionality of the general resource manager module
 * @param managedGL Provides resource classes that can load and create for ManagedTextures, ManagedCubeMaps and ManagedShaders
 * @param egomModel Provides resource classes that can load and create Egom Models
 * @param audio Used for easy access to the Web Audio API for playing back sound resources
 */
define('modules/media-resources',[
    "utils/utils",
    "utils/types",
    "modules/application",
    "modules/resource-manager",
    "modules/managed-gl",
    "modules/egom-model",
    "modules/audio"
], function (utils, types, application, resourceManager, managedGL, egomModel, audio) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // enums
            /**
             * @enum {String}
             * Stores the currently handled shader type values.
             */
            ShaderType = {
                VERTEX: "vertex",
                FRAGMENT: "fragment"
            },
            // ------------------------------------------------------------------------------
            // constants
            /**
             * In the resource description file, texture resources will be initialized from the array with this name
             * @type String
             */
            TEXTURE_ARRAY_NAME = "textures",
            /**
             * In the resource description file, cubemap resources will be initialized from the array with this name
             * @type String
             */
            CUBEMAP_ARRAY_NAME = "cubemaps",
            /**
             * In the resource description file, shader resources will be initialized from the array with this name
             * @type String
             */
            SHADER_ARRAY_NAME = "shaders",
            /**
             * In the resource description file, model resources will be initialized from the array with this name
             * @type String
             */
            MODEL_ARRAY_NAME = "models",
            /**
             * When asked to be loaded from files, texture resources will look for the files in the folder with this ID (not URL)
             * @type String
             */
            TEXTURE_FOLDER = "texture",
            /**
             * When asked to be loaded from files, cubemap resources will look for the files in the folder with this ID (not URL)
             * @type String
             */
            CUBEMAP_FOLDER = "texture",
            /**
             * When asked to be loaded from files, shader resources will look for the files in the folder with this ID (not URL)
             * @type String
             */
            SHADER_FOLDER = "shader",
            /**
             * When asked to be loaded from files, model resources will look for the files in the folder with this ID (not URL)
             * @type String
             */
            MODEL_FOLDER = "model",
            /**
             * In the resource description file, sound effect resources will be initialized from the array with this name
             * @type String
             */
            SOUND_EFFECT_ARRAY_NAME = "soundEffects",
            /**
             * When asked to be loaded from files, sound effect resources will look for the files in the folder with this ID (not URL)
             * @type String
             */
            SOUND_EFFECT_FOLDER = "soundEffect",
            /**
             * In the resource description file, music resources will be initialized from the array with this name
             * @type String
             */
            MUSIC_ARRAY_NAME = "music",
            /**
             * When asked to be loaded from files, music resources will look for the files in the folder with this ID (not URL)
             * @type String
             */
            MUSIC_FOLDER = "music",
            /**
             * Lines in shader sources starting with this string are treated as include statements referencing another shader source file
             * to be inserted into the source in the place of the line, with the name (path) of the file to be inserted starting after this
             * prefix.
             * @type String
             */
            SHADER_INCLUDE_STATEMENT_PREFIX = '#include "',
            /**
             * When parsing an include statement in a shader source, this suffix at the end of the line of the include statement is not 
             * considered to be the part of the path of the referenced file.
             * @type String
             */
            SHADER_INCLUDE_STATEMENT_SUFFIX = '"',
            /**
             * During the loading of shaders, sources that could not be downloaded will be set to this value to mark that their download
             * has finished (unsuccessfully). They are nulled out at the end of the loading process.
             * @type String
             */
            EMPTY_SHADER_SOURCE = "-",
            // ------------------------------------------------------------------------------
            // module variables
            /**
             * @typedef {Object} ShaderIncludeCacheObject
             * @property {String} source
             * @property {Function[]} onLoad
             */
            /**
             * Stores the texts of the already downloaded shader includes (shader sources that are included in another source) and the 
             * onLoad queues of the ones that being downloaded.
             * @type Object.<String, ShaderIncludeCacheObject>
             */
            _shaderIncludeCache = {},
            /**
             * Stores the Image objects created for downloading texture images for each path (within the textures folder), so that when the
             * same image file is needed two times, the same Image object can be used by looking it up in this object
             * @type Object.<String, Image>
             */
            _textureImageCache = {},
            /**
             * Stores the Image objects created for downloading cubemap face images for each path (within the cubemaps folder), so that when 
             * the same image file is needed two times, the same Image object can be used by looking it up in this object
             * @type Object.<String, Image>
             */
            _cubemapImageCache = {},
            /**
             * This media resource manager will be used to load and access the media resources.
             * @type MediaResourceManager
             */
            _resourceManager;
    // freezing enum objects
    Object.freeze(ShaderType);
    // ############################################################################################
    /**
     * @class
     * @extends GenericResource
     * @param {Object} [dataJSON]
     */
    function MediaResource(dataJSON) {
        resourceManager.GenericResource.call(this, dataJSON ? dataJSON.name : "");
        /**
         * Stores a reference to the object from which this class was initialized.
         * @type String
         */
        this._dataJSON = dataJSON;
        if (dataJSON) {
            this._loadConfig(dataJSON);
        }
    }
    MediaResource.prototype = new resourceManager.GenericResource();
    MediaResource.prototype.constructor = MediaResource;
    /**
     * Loads the configuration of the resource from the passed JSON object - override this to set all properties of the resource!
     * @param {Object} dataJSON
     */
    MediaResource.prototype._loadConfig = function (dataJSON) {
        this._dataJSON = dataJSON;
    };
    /**
     * Returns the object this resource was initialized from.
     * @returns {Object}
     */
    MediaResource.prototype.getData = function () {
        return this._dataJSON;
    };
    /**
     * Reinitializes the resource based on the stored data object. (can be used to modify a resource by modifying its data object and then calling
     * this - only to be used by the editor, not by the game!
     */
    MediaResource.prototype.reloadData = function () {
        this._loadConfig(this._dataJSON);
        this.resetReadyState();
    };
    // ############################################################################################
    /**
     * @typedef {Object} TextureResource~ManagedTextureCacheObject
     * @property {String[]} types
     * @property {String[]} qualityPreferenceList
     * @property {Object.<String, ManagedTexture>} textures
     */
    /**
     * @class
     * @extends MediaResource
     * @param {Object} dataJSON
     */
    function TextureResource(dataJSON) {
        MediaResource.call(this, dataJSON);
    }
    TextureResource.prototype = new MediaResource();
    TextureResource.prototype.constructor = TextureResource;
    /**
     * 
     * @param {Object} dataJSON
     */
    TextureResource.prototype._loadConfig = function (dataJSON) {
        MediaResource.prototype._loadConfig.call(this, dataJSON);
        /**
         * @type String
         */
        this._basepath = dataJSON.basepath;
        /**
         * @type String
         */
        this._format = dataJSON.format;
        /**
         * @type Boolean
         */
        this._useMipmap = (dataJSON.useMipmap === true);
        /**
         * @type Object.<String, String>
         */
        this._typeSuffixes = dataJSON.typeSuffixes;
        /**
         * @type Object.<String, String>
         */
        this._qualitySuffixes = dataJSON.qualitySuffixes;
        /**
         * @type Number
         */
        this._loadedImages = 0;
        /**
         * @type Number
         */
        this._imagesToLoad = 0;
        /**
         * @type Object.<String, Object.<String, Image>>
         */
        this._images = {};
        /**
         * @type Object.<String, Object.<String, ManagedTexture>>
         */
        this._managedTextures = {};
        /**
         * @type TextureResource~ManagedTextureCacheObject[]
         */
        this._cachedManagedTexturesOfTypes = [];
    };
    /**
     * @param {String} type
     * @param {String} quality
     * @returns {String}
     */
    TextureResource.prototype._getPath = function (type, quality) {
        return this._basepath + this._typeSuffixes[type] + this._qualitySuffixes[quality] + "." + this._format;
    };
    /**
     * @param {String} type
     * @param {String} quality
     * @returns {Function}
     */
    TextureResource.prototype._getOnLoadImageFunction = function (type, quality) {
        var path = this._getPath(type, quality);
        return function () {
            this._loadedImages++;
            this._onFilesLoad(this._loadedImages === this._imagesToLoad, {path: path});
        }.bind(this);
    };
    /**
     * Displays an error message for the case when the source file for this texture with the passed name could not be loaded.
     * @param {String} filename
     */
    TextureResource.prototype._handleError = function (filename) {
        application.showError("Could not load texture '" + this._name + "': downloading file '" + filename + "' failed!");
        this._loadedImages++;
        this._onFilesLoad(this._loadedImages === this._imagesToLoad, {path: filename, error: true});
    };
    /**
     * @typedef {Object} TextureResource~RequestParams
     * @property {String[]} [types] 
     * @property {String[]} [qualities] 
     * @property {String[]} [qualityPreferenceList]
     */
    /**
     * Returns the one from the preference list of passed quality identifiers that is available for this texture and has the highest 
     * preference. (lowest index in the list)
     * @param {String[]} qualityPreferenceList
     * @returns {String}
     */
    TextureResource.prototype._getMostFittingQuality = function (qualityPreferenceList) {
        var i, index, mostFittingQuality,
                qualities = this.getQualities(),
                mostFittingQualityIndex = -1;
        for (i = 0; i < qualities.length; i++) {
            index = qualityPreferenceList.indexOf(qualities[i]);
            if ((index >= 0) && ((mostFittingQualityIndex === -1) || (index < mostFittingQualityIndex))) {
                mostFittingQualityIndex = index;
                mostFittingQuality = qualityPreferenceList[index];
            }
        }
        if (mostFittingQualityIndex === -1) {
            application.showError("Texture '" + this.getName() + "' is not available in any of the qualities: [" + qualityPreferenceList.join(", ") + "]!");
            return null;
        }
        return mostFittingQuality;
    };
    /**
     * If a quality preference list is given in the params, resolves it to the most fitting quality.
     * @param {TextureResource~RequestParams} params
     * @returns {TextureResource~RequestParams}
     */
    TextureResource.prototype._getProcessedParams = function (params) {
        params = params || {};
        params.types = params.types || Object.keys(this._typeSuffixes);
        params.qualities = params.qualities || (params.qualityPreferenceList && [this._getMostFittingQuality(params.qualityPreferenceList)]) || Object.keys(this._qualitySuffixes);
        delete params.qualityPreferenceList;
        return params;
    };
    /**
     * @override
     * @param {TextureResource~RequestParams} params
     * @returns {Boolean}
     */
    TextureResource.prototype.requiresReload = function (params) {
        var i, j;
        params = this._getProcessedParams(params);
        if (this.isRequested(params)) {
            return false;
        }
        for (i = 0; i < params.types.length; i++) {
            if (this._typeSuffixes.hasOwnProperty(params.types[i])) {
                if (!this._images[params.types[i]]) {
                    return true;
                }
                for (j = 0; j < params.qualities.length; j++) {
                    if (this._qualitySuffixes.hasOwnProperty(params.qualities[j])) {
                        if (!this._images[params.types[i]][params.qualities[j]]) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };
    /**
     * @override
     * @param {TextureResource~RequestParams} params
     */
    TextureResource.prototype._requestFiles = function (params) {
        var i, j, type, quality, path;
        params = this._getProcessedParams(params);
        for (i = 0; i < params.types.length; i++) {
            type = params.types[i];
            if (this._typeSuffixes.hasOwnProperty(type)) {
                this._images[type] = this._images[type] || {};
                for (j = 0; j < params.qualities.length; j++) {
                    quality = params.qualities[j];
                    if (this._qualitySuffixes.hasOwnProperty(quality)) {
                        if (!this._images[type][quality]) {
                            path = this._getPath(type, quality);
                            if (!_textureImageCache[path]) {
                                _textureImageCache[path] = new Image();
                                this._imagesToLoad++;
                                this._images[type][quality] = _textureImageCache[path];
                                this._images[type][quality].onload = this._getOnLoadImageFunction(type, quality).bind(this);
                                this._images[type][quality].onerror = this._handleError.bind(this, path);
                            } else {
                                this._images[type][quality] = _textureImageCache[path];
                            }
                        }
                    }
                }
            }
        }
        // setting the src property of an Image object will automatically result in an asynchronous
        // request to grab the image source file
        for (i = 0; i < params.types.length; i++) {
            type = params.types[i];
            if (this._typeSuffixes.hasOwnProperty(type)) {
                for (j = 0; j < params.qualities.length; j++) {
                    quality = params.qualities[j];
                    if (this._qualitySuffixes.hasOwnProperty(quality)) {
                        if (!this._images[type][quality].src) {
                            this._images[type][quality].src = application.getFileURL(TEXTURE_FOLDER, this._getPath(type, quality));
                        }
                    }
                }
            }
        }
        // it is possible that all images could be set from cache and no loading is needed
        if (this._loadedImages === this._imagesToLoad) {
            this._onFilesLoad(true, {path: this._basepath});
        }
    };
    /**
     * @override
     * @param {Object} params
     * @returns {Boolean}
     */
    TextureResource.prototype._loadData = function (params) {
        if (!params.error) {
            application.log_DEBUG("Texture from file: " + params.path + " has been loaded.", 2);
            return true;
        }
        application.log_DEBUG("WARNING: Texture from file: " + params.path + " could not be loaded.", 1);
        return false;
    };
    /**
     * @returns {String[]}
     */
    TextureResource.prototype.getQualities = function () {
        return Object.keys(this._qualitySuffixes);
    };
    /**
     * @param {String} type
     * @param {String} quality
     * @returns {ManagedTexture}
     */
    TextureResource.prototype.getManagedTexture = function (type, quality) {
        if (this.isReadyToUse() === false) {
            application.showError("Cannot get managed GL texture for '" + this.getName() + "', as it has not been loaded from file yet!");
            return null;
        }
        if (!this._images[type]) {
            application.showError("The requested texture '" + this.getName() + "' has no type '" + type + "' available!");
            type = Object.keys(this._images)[0];
        }
        this._managedTextures[type] = this._managedTextures[type] || {};
        this._managedTextures[type][quality] =
                this._managedTextures[type][quality] ||
                new managedGL.ManagedTexture(this.getName(), this._images[type][quality], this._useMipmap);
        return this._managedTextures[type][quality];
    };
    /**
     * @param {String[]} types
     * @param {String[]} qualityPreferenceList
     * @returns {Object.<String, ManagedTexture>} 
     */
    TextureResource.prototype.getManagedTexturesOfTypes = function (types, qualityPreferenceList) {
        var i, result, mostFittingQuality;
        types.sort();
        // return from cache if possible
        for (i = 0; i < this._cachedManagedTexturesOfTypes.length; i++) {
            if (utils.arraysEqual(types, this._cachedManagedTexturesOfTypes[i].types) && utils.arraysEqual(qualityPreferenceList, this._cachedManagedTexturesOfTypes[i].qualityPreferenceList)) {
                return this._cachedManagedTexturesOfTypes[i].textures;
            }
        }
        result = {};
        mostFittingQuality = this._getMostFittingQuality(qualityPreferenceList);
        for (i = 0; i < types.length; i++) {
            result[types[i]] = this.getManagedTexture(types[i], mostFittingQuality);
        }
        // cache the result
        this._cachedManagedTexturesOfTypes.push({
            types: types,
            qualityPreferenceList: qualityPreferenceList,
            textures: result
        });
        return result;
    };
    // ############################################################################################x
    /**
     * @class Represents a cube mapped texture resource.
     * @extends MediaResource
     * @param {Object} dataJSON
     */
    function CubemapResource(dataJSON) {
        MediaResource.call(this, dataJSON);
    }
    CubemapResource.prototype = new MediaResource();
    CubemapResource.prototype.constructor = CubemapResource;
    /**
     * @override
     * @param {Object} dataJSON
     */
    CubemapResource.prototype._loadConfig = function (dataJSON) {
        MediaResource.prototype._loadConfig.call(this, dataJSON);
        /**
         * @type String
         */
        this._basepath = dataJSON.basepath;
        /**
         * @type String
         */
        this._format = dataJSON.format;
        /**
         * @type String[]
         */
        this._imageNames = dataJSON.imageNames;
        /**
         * @type Object.<String, String>
         */
        this._qualitySuffixes = dataJSON.qualitySuffixes;
        /**
         * @type Number
         */
        this._loadedImages = 0;
        /**
         * @type Number
         */
        this._imagesToLoad = 0;
        /**
         * @type Object.<String, Image>
         */
        this._images = {};
        /**
         * @type {cubemap: ManagedCubemap, qualityPreferenceList: String[]}[]
         */
        this._cachedManagedCubemaps = [];
    };
    /**
     * 
     * @param {String} face
     * @param {String} quality
     * @returns {String}
     */
    CubemapResource.prototype._getPath = function (face, quality) {
        return this._basepath + this._imageNames[face] + this._qualitySuffixes[quality] + "." + this._format;
    };
    /**
     * 
     * @param {String} face
     * @param {string} quality
     * @returns {Function}
     */
    CubemapResource.prototype._getOnLoadImageFunction = function (face, quality) {
        var path = this._getPath(face, quality);
        return function () {
            this._loadedImages++;
            this._onFilesLoad(this._loadedImages === this._imagesToLoad, {path: path});
        }.bind(this);
    };
    /**
     * Displays an error message for the case when the source file for this cubemap with the passed name could not be loaded.
     * @param {String} filename
     */
    CubemapResource.prototype._handleError = function (filename) {
        application.showError("Could not load cube mapped texture '" + this._name + "': downloading file '" + filename + "' failed!");
        this._loadedImages++;
        this._onFilesLoad(this._loadedImages === this._imagesToLoad, {path: filename, error: true});
    };
    /**
     * @typedef {Object} CubemapResource~RequestParams
     * @property {String[]} [qualities] 
     * @property {String[]} [qualityPreferenceList]
     */
    /**
     * Returns the one from the preference list of passed quality identifiers that is available for this cubemap and has the highest 
     * preference. (lowest index in the list)
     * @param {String[]} qualityPreferenceList
     * @returns {String}
     */
    CubemapResource.prototype._getMostFittingQuality = function (qualityPreferenceList) {
        var i, index, mostFittingQuality,
                qualities = this.getQualities(),
                mostFittingQualityIndex = -1;
        for (i = 0; i < qualities.length; i++) {
            index = qualityPreferenceList.indexOf(qualities[i]);
            if ((index >= 0) && ((mostFittingQualityIndex === -1) || (index < mostFittingQualityIndex))) {
                mostFittingQualityIndex = index;
                mostFittingQuality = qualityPreferenceList[index];
            }
        }
        if (mostFittingQualityIndex === -1) {
            application.showError("Cubemap '" + this.getName() + "' is not available in any of the qualities: [" + qualityPreferenceList.join(", ") + "]!");
            return null;
        }
        return mostFittingQuality;
    };
    /**
     * If a quality preference list is given in the params, resolves it to the most fitting quality.
     * @param {CubemapResource~RequestParams} params
     * @returns {CubemapResource~RequestParams}
     */
    CubemapResource.prototype._getProcessedParams = function (params) {
        params = params || {};
        params.qualities = params.qualities || (params.qualityPreferenceList && [this._getMostFittingQuality(params.qualityPreferenceList)]) || Object.keys(this._qualitySuffixes);
        delete params.qualityPreferenceList;
        return params;
    };
    /**
     * @override
     * @param {CubemapResource~RequestParams} params 
     * @returns {Boolean}
     */
    CubemapResource.prototype.requiresReload = function (params) {
        var face, i;
        params = this._getProcessedParams(params);
        if (this.isRequested(params)) {
            return false;
        }
        for (face in this._imageNames) {
            if (this._imageNames.hasOwnProperty(face)) {
                if (!this._images[face]) {
                    return true;
                }
                for (i = 0; i < params.qualities.length; i++) {
                    if (this._qualitySuffixes.hasOwnProperty(params.qualities[i])) {
                        if (!this._images[face][params.qualities[i]]) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };
    /**
     * @override
     * @param {CubemapResource~RequestParams} params 
     */
    CubemapResource.prototype._requestFiles = function (params) {
        var face, i, quality, path;
        params = this._getProcessedParams(params);
        for (face in this._imageNames) {
            if (this._imageNames.hasOwnProperty(face)) {
                this._images[face] = this._images[face] || {};
                for (i = 0; i < params.qualities.length; i++) {
                    quality = params.qualities[i];
                    if (this._qualitySuffixes.hasOwnProperty(quality)) {
                        if (!this._images[face][quality]) {
                            path = this._getPath(face, quality);
                            if (!_cubemapImageCache[path]) {
                                _cubemapImageCache[path] = new Image();
                                this._imagesToLoad++;
                                this._images[face][quality] = _cubemapImageCache[path];
                                this._images[face][quality].onload = this._getOnLoadImageFunction(face, quality).bind(this);
                                this._images[face][quality].onerror = this._handleError.bind(this, path);
                            } else {
                                this._images[face][quality] = _cubemapImageCache[path];
                            }
                        }
                    }
                }
            }
        }
        // setting the src property of an Image object will automatically result in an asynchronous
        // request to grab the image source file
        for (face in this._imageNames) {
            if (this._imageNames.hasOwnProperty(face)) {
                for (i = 0; i < params.qualities.length; i++) {
                    quality = params.qualities[i];
                    if (this._qualitySuffixes.hasOwnProperty(quality)) {
                        if (!this._images[face][quality].src) {
                            this._images[face][quality].src = application.getFileURL(CUBEMAP_FOLDER, this._getPath(face, quality));
                        }
                    }
                }
            }
        }
        // it is possible that all images could be set from cache and no loading is needed
        if (this._loadedImages === this._imagesToLoad) {
            this._onFilesLoad(true, {path: this._basepath});
        }
    };
    /**
     * @override
     * @param {Object} params
     * @returns {Boolean}
     */
    CubemapResource.prototype._loadData = function (params) {
        if (!params.error) {
            application.log_DEBUG("Face '" + params.path + "' of cubemap named '" + this.getName() + "' has been loaded.", 2);
            return true;
        }
        application.log_DEBUG("WARNING: Face '" + params.path + "' of cubemap named '" + this.getName() + "' could not be loaded.", 1);
        return false;
    };
    /**
     * @returns {String[]}
     */
    CubemapResource.prototype.getQualities = function () {
        return Object.keys(this._qualitySuffixes);
    };
    /**
     * @param {String[]} qualityPreferenceList
     * @returns {ManagedCubemap}
     */
    CubemapResource.prototype.getManagedCubemap = function (qualityPreferenceList) {
        var i, result, mostFittingQuality;
        if (this.isReadyToUse() === false) {
            application.showError("Cannot get managed GL cubemap for '" + this.getName() + "', as it has not been loaded from file yet!");
            return null;
        }
        // return from cache if possible
        for (i = 0; i < this._cachedManagedCubemaps.length; i++) {
            if (utils.arraysEqual(qualityPreferenceList, this._cachedManagedCubemaps[i].qualityPreferenceList)) {
                return this._cachedManagedCubemaps[i].cubemap;
            }
        }
        mostFittingQuality = this._getMostFittingQuality(qualityPreferenceList);
        result = new managedGL.ManagedCubemap(this.getName(), [
            this._images.posX[mostFittingQuality],
            this._images.negX[mostFittingQuality],
            this._images.posY[mostFittingQuality],
            this._images.negY[mostFittingQuality],
            this._images.posZ[mostFittingQuality],
            this._images.negZ[mostFittingQuality]
        ]);
        // cache the result
        this._cachedManagedCubemaps.push({
            qualityPreferenceList: qualityPreferenceList,
            cubemap: result
        });
        return result;
    };
    // ############################################################################################
    /**
     * @typedef {Object} ShaderResource~ManagedShaderBinding
     * @property {ManagedShader} managedShader
     * @property {Object.<String, String>} replacedDefines
     */
    /**
     * @class 
     * @extends MediaResource
     * @param {Object} dataJSON
     */
    function ShaderResource(dataJSON) {
        MediaResource.call(this, dataJSON);
    }
    ShaderResource.prototype = new MediaResource();
    ShaderResource.prototype.constructor = ShaderResource;
    /**
     * @override
     * @param {Object} dataJSON
     */
    ShaderResource.prototype._loadConfig = function (dataJSON) {
        MediaResource.prototype._loadConfig.call(this, dataJSON);
        /**
         * The names of the variants of this shaders organized by the variant names.
         * @type Object.<String, String>
         */
        this._variantShaderNames = dataJSON.variants || null;
        /**
         * @type String
         */
        this._vertexShaderSourcePath = dataJSON.vertexShaderSource;
        /**
         * @type String
         */
        this._fragmentShaderSourcePath = dataJSON.fragmentShaderSource;
        /**
         * (enum ShaderBlendMode)
         * @type String
         */
        this._blendMode = types.getEnumValue(managedGL.ShaderBlendMode, dataJSON.blendMode, {name: "shader.blendMode"});
        /**
         * The roles of the vertex attributes (= the name of the data array returned by the model from which they should get their values)
         * organized by the names of the vertex attributes.
         * @type Object.<String, String>
         */
        this._vertexAttributeRoles = dataJSON.vertexAttributeRoles;
        /**
         * The roles of the instance attributes (= the names of the uniforms they replace) organized by the names of the instance attributes.
         * @type Object.<String, String>
         */
        this._instanceAttributeRoles = dataJSON.instanceAttributeRoles || {};
        /**
         * @type String
         */
        this._vertexShaderSource = null;
        /**
         * @type String
         */
        this._fragmentShaderSource = null;
        /**
         * @type ShaderResource~ManagedShaderBinding[]
         */
        this._managedShaderBindings = [];
        /**
         * The total number of shader includes (references shader source files to be inserted into the sources of this shader) of the sources
         * of this shader.
         * @type Number
         */
        this._shaderIncludesToLoad = 0;
        /**
         * The number of already loaded and inserted shader includes of this shader.
         * @type Number
         */
        this._shaderIncludesLoaded = 0;
    };
    /**
     * If all source files needed to assemble the final sources of this shader have been loaded and inserted, marks the shader as ready.
     */
    ShaderResource.prototype._checkAllSourcesLoaded = function () {
        if (this._vertexShaderSource && this._fragmentShaderSource && (this._shaderIncludesLoaded === this._shaderIncludesToLoad)) {
            if (this._vertexShaderSource === EMPTY_SHADER_SOURCE) {
                this._vertexShaderSource = null;
            }
            if (this._fragmentShaderSource === EMPTY_SHADER_SOURCE) {
                this._fragmentShaderSource = null;
            }
            this.onFinalLoad();
        }
    };
    /**
     * To be called when a new shader include (references file) has finished downloading - saves the text of the file to the cache and calls
     * the resolution method as well as any other functions queued to execute on the loading of this file. (i.e. this will call the resolution
     * as many times as it has been requested so far for this particular file)
     * @param {String} shaderType (enum ShaderType) The type of the shader in which to insert the source of the downloaded file.
     * @param {String} includeSourceFilename The name of the file (the path by which it was referenced)
     * @param {String} responseText The text of the downloaded file.
     */
    ShaderResource.prototype._loadIncludeSource = function (shaderType, includeSourceFilename, responseText) {
        var i;
        _shaderIncludeCache[includeSourceFilename].source = responseText;
        this._resolveInclude(shaderType, includeSourceFilename);
        for (i = 0; i < _shaderIncludeCache[includeSourceFilename].onLoad.length; i++) {
            _shaderIncludeCache[includeSourceFilename].onLoad[i]();
        }
    };
    /**
     * Extracts the name (path) of the referenced file from the passed source line.
     * @param {String} sourceLine Should be an include statement
     */
    ShaderResource.prototype._getIncludeFileName = function (sourceLine) {
        return sourceLine.substr(SHADER_INCLUDE_STATEMENT_PREFIX.length, sourceLine.length - (SHADER_INCLUDE_STATEMENT_PREFIX.length + SHADER_INCLUDE_STATEMENT_SUFFIX.length));
    };
    /**
     * Inserts the (downloaded and cached) text of an include file into the source of the shader of the passed type. Only replaces the first
     * occurence of the include statement. (that refers to the file with the passed name (path)
     * @param {String} shaderType (enum ShaderType) The type of the shader in which to insert the source of the downloaded file.
     * @param {String} includeFileName
     */
    ShaderResource.prototype._resolveInclude = function (shaderType, includeFileName) {
        var i, includeText = _shaderIncludeCache[includeFileName].source, sourceLines;
        switch (shaderType) {
            case ShaderType.VERTEX:
                sourceLines = this._vertexShaderSource.split("\n");
                break;
            case ShaderType.FRAGMENT:
                sourceLines = this._fragmentShaderSource.split("\n");
                break;
            default:
                application.crash();
        }
        for (i = 0; i < sourceLines.length; i++) {
            if (sourceLines[i].substr(0, SHADER_INCLUDE_STATEMENT_PREFIX.length) === SHADER_INCLUDE_STATEMENT_PREFIX) {
                if (includeFileName === this._getIncludeFileName(sourceLines[i])) {
                    sourceLines[i] = includeText;
                    switch (shaderType) {
                        case ShaderType.VERTEX:
                            this._vertexShaderSource = sourceLines.join("\n");
                            break;
                        case ShaderType.FRAGMENT:
                            this._fragmentShaderSource = sourceLines.join("\n");
                            break;
                        default:
                            application.crash();
                    }
                    this._resolveSource(shaderType, includeText);
                    break;
                }
            }
        }
        this._shaderIncludesLoaded++;
        this._checkAllSourcesLoaded();
    };
    /**
     * Parses the passed shader source text for include statements and either replaces them if the referenced file has already been downloaded
     * and cached or initiates their download and queues the replacement for when the download has finished.
     * @param {String} shaderType (enum ShaderType) The type of the shader in which to insert the source of the downloaded files.
     * @param {String} sourceText The whole or a part of the source of the shader source to scan for include statements.
     */
    ShaderResource.prototype._resolveSource = function (shaderType, sourceText) {
        var i, sourceLines = sourceText.split("\n"), includeSourceFilenames = [];
        for (i = 0; i < sourceLines.length; i++) {
            if (sourceLines[i].substr(0, SHADER_INCLUDE_STATEMENT_PREFIX.length) === SHADER_INCLUDE_STATEMENT_PREFIX) {
                includeSourceFilenames.push(this._getIncludeFileName(sourceLines[i]));
                this._shaderIncludesToLoad++;
            }
        }
        for (i = 0; i < includeSourceFilenames.length; i++) {
            if (_shaderIncludeCache[includeSourceFilenames[i]]) {
                if (_shaderIncludeCache[includeSourceFilenames[i]].source) {
                    this._resolveInclude(shaderType, includeSourceFilenames[i]);
                } else {
                    _shaderIncludeCache[includeSourceFilenames[i]].onLoad.push(this._resolveInclude.bind(this, shaderType, includeSourceFilenames[i]));
                }
            } else {
                _shaderIncludeCache[includeSourceFilenames[i]] = {
                    onLoad: []
                };
                application.requestTextFile(SHADER_FOLDER, includeSourceFilenames[i], this._loadIncludeSource.bind(this, shaderType, includeSourceFilenames[i]));
            }
        }
    };
    /**
     * @override
     * @returns {Boolean}
     */
    ShaderResource.prototype.requiresReload = function () {
        if (this.isRequested()) {
            return false;
        }
        return !this.isLoaded();
    };
    /**
     * @override
     */
    ShaderResource.prototype._requestFiles = function () {
        application.requestTextFile(SHADER_FOLDER, this._vertexShaderSourcePath, function (responseText) {
            this._onFilesLoad(false, {shaderType: ShaderType.VERTEX, text: responseText});
        }.bind(this));
        application.requestTextFile(SHADER_FOLDER, this._fragmentShaderSourcePath, function (responseText) {
            this._onFilesLoad(false, {shaderType: ShaderType.FRAGMENT, text: responseText});
        }.bind(this));
    };
    /**
     * @override
     * @param {Object} params
     * @returns {Boolean}
     */
    ShaderResource.prototype._loadData = function (params) {
        switch (types.getEnumValue(ShaderType, params.shaderType, {
                name: "shaderType", defaultValue: null})) {
            case ShaderType.VERTEX:
                this._vertexShaderSource = params.text || EMPTY_SHADER_SOURCE;
                break;
            case ShaderType.FRAGMENT:
                this._fragmentShaderSource = params.text || EMPTY_SHADER_SOURCE;
                break;
            default:
                application.crash();
        }
        if (params.text) {
            this._resolveSource(params.shaderType, params.text);
        }
        this._checkAllSourcesLoaded();
        if (!params.text) {
            application.log_DEBUG("ERROR: There was an error loading " + params.shaderType + " shader of shader program '" + this._name + "'!", 1);
            return false;
        }
        return true;
    };
    /**
     * Returns the name of the shader that is stored by the passed variant name for this shader.
     * @param {String} variantName
     * @returns {String|null} Null, if there is no such variant for this shader.
     */
    ShaderResource.prototype.getVariantShaderName = function (variantName) {
        return this._variantShaderNames ? this._variantShaderNames[variantName] : null;
    };
    /**
     * @param {Object.<String, String>} [replacedDefines] Values defined in the shader source using #define will be replaced by the values
     * provided in this object (e.g. #define CONST 3 will be changed to #define CONST 5 if {CONST: 5} is passed.
     * @param {Boolean} unpackSamplerArrays If true, arrays of sampler uniforms will be unpacked - that is, substituted 
     * with individual sampler variables for each index in the shader source
     * @returns {ManagedShader}
     */
    ShaderResource.prototype.getManagedShader = function (replacedDefines, unpackSamplerArrays) {
        var i;
        if (this.isReadyToUse() === false) {
            application.showError("Cannot get managed GL shader for '" + this.getName() + "', as it has not been loaded from file yet!");
            return null;
        }
        replacedDefines = replacedDefines || null;
        for (i = 0; i < this._managedShaderBindings.length; i++) {
            if (utils.objectsEqual(this._managedShaderBindings[i].replacedDefines, replacedDefines)) {
                return this._managedShaderBindings[i].managedShader;
            }
        }
        this._managedShaderBindings.push({
            managedShader: new managedGL.ManagedShader(this.getName(), this._vertexShaderSource, this._fragmentShaderSource, this._blendMode, this._vertexAttributeRoles, this._instanceAttributeRoles, replacedDefines, unpackSamplerArrays),
            replacedDefines: replacedDefines
        });
        return this._managedShaderBindings[this._managedShaderBindings.length - 1].managedShader;
    };
    /**
     * Returns the (resolved) vertex shader source code
     * @returns {String}
     */
    ShaderResource.prototype.getVertexShaderSource = function () {
        return this._vertexShaderSource;
    };
    /**
     * Returns the (resolved) fragment shader source code
     * @returns {String}
     */
    ShaderResource.prototype.getFragmentShaderSource = function () {
        return this._fragmentShaderSource;
    };
    // ############################################################################################x
    /**
     * @typedef {Object} ModelResource~FileDescriptor
     * @property {String} suffix
     * @property {Number} maxLOD
     */
    /**
     * @class
     * @extends MediaResource
     * @param {Object} dataJSON
     */
    function ModelResource(dataJSON) {
        MediaResource.call(this, dataJSON);
    }
    ModelResource.prototype = new MediaResource();
    ModelResource.prototype.constructor = ModelResource;
    /**
     * @override
     * @param {Object} dataJSON
     */
    ModelResource.prototype._loadConfig = function (dataJSON) {
        MediaResource.prototype._loadConfig.call(this, dataJSON);
        if (dataJSON.model) {
            this._model = dataJSON.model;
            this._files = [];
            this._dataJSON = null;
            this.setToReady();
            return;
        }
        /**
         * @type String
         */
        this._basepath = dataJSON.basepath;
        /**
         * @type String
         */
        this._format = dataJSON.format;
        /**
         * @type ModelResource~FileDescriptor[]
         */
        this._files = dataJSON.files;
        /**
         * @type Number
         */
        this._loadedFiles = 0;
        /**
         * @type Number
         */
        this._filesToLoad = 0;
        /**
         * @type Model
         */
        this._model = null;
        /**
         * @type Number
         */
        this._maxLoadedLOD = -1;
    };
    /**
     * @param {Number} maxLOD
     * @returns {String}
     */
    ModelResource.prototype._getPath = function (maxLOD) {
        var i;
        for (i = 0; i < this._files.length; i++) {
            if (this._files[i].maxLOD === maxLOD) {
                return this._basepath + this._files[i].suffix + "." + this._format;
            }
        }
        return null;
    };
    /**
     * @override
     * @param {Object} params
     * @returns {Boolean}
     */
    ModelResource.prototype.requiresReload = function (params) {
        if (this.isRequested(params)) {
            return false;
        }
        if (this._files.length === 0) {
            return false;
        }
        if (params && (typeof params.maxLOD === "number")) {
            return params.maxLOD > this._maxLoadedLOD;
        }
        if (this.getMaxLOD() !== null) {
            return this.requiresReload({maxLOD: this.getMaxLOD()});
        }
        return false;
    };
    /**
     * @returns {Number|null}
     */
    ModelResource.prototype.getMaxLOD = function () {
        var i, result = null;
        for (i = 0; i < this._files.length; i++) {
            if ((result === null) || (this._files[i].maxLOD > result)) {
                result = this._files[i].maxLOD;
            }
        }
        return result;
    };
    /**
     * @param {Number} maxLOD
     */
    ModelResource.prototype._requestFile = function (maxLOD) {
        this._filesToLoad++;
        application.requestTextFile(MODEL_FOLDER, this._getPath(maxLOD), function (responseText) {
            this._loadedFiles++;
            this._onFilesLoad(this._filesToLoad === this._loadedFiles, {maxLOD: maxLOD, text: responseText});
        }.bind(this));
    };
    /**
     * @override
     * @param {Object} params
     */
    ModelResource.prototype._requestFiles = function (params) {
        var lod, maxLOD;
        params = params || {};
        // if a maxmimum LOD was requested
        if (params.maxLOD !== undefined) {
            // first look for the highest LOD file at or below the requested level
            for (lod = params.maxLOD; lod >= 0; lod--) {
                if (this._getPath(lod) !== null) {
                    this._requestFile(lod);
                    return;
                }
            }
            // if no files are available at all at or below the requested LOD level, check for higher quality ones
            if ((lod < 0) && (this._files.length > 0)) {
                maxLOD = this.getMaxLOD();
                for (lod = params.maxLOD + 1; lod <= maxLOD; lod++) {
                    if (this._getPath(lod) !== null) {
                        this._requestFile(lod);
                        return;
                    }
                }
            }
            application.showError("Could not find any files to load for model: '" + this._name + "'!");
        } else {
            // if no LOD was specified, request files to cover all available LODs
            this._requestFiles({maxLOD: this.getMaxLOD()});
        }
    };
    /**
     * @override
     * @param {Object} params
     * @returns {Boolean}
     */
    ModelResource.prototype._loadData = function (params) {
        this._model = new egomModel.Model();
        if (!params.text) {
            application.showError("Model file of max LOD level " + params.maxLOD + " could not be loaded for model '" + this.getName() + "'!");
            return false;
        }
        application.log_DEBUG("Model file of max LOD level " + params.maxLOD + " has been loaded for model '" + this.getName() + "'", 2);
        if (params.text[0] === "{") {
            this._model.loadFromJSON(this._getPath(params.maxLOD), JSON.parse(params.text), params.maxLOD);
        } else {
            application.showError("Cannot load Egom Model from file '" + this._getPath(params.maxLOD) + "' - the file needs to start with '{'!");
        }
        this._maxLoadedLOD = params.maxLOD;
        return true;
    };
    /**
     * @returns {Model}
     */
    ModelResource.prototype.getEgomModel = function () {
        if (this.isReadyToUse() === false) {
            application.showError("Cannot get model object for '" + this.getName() + "', as it has not been loaded from file yet!");
            return null;
        }
        return this._model;
    };
    // ############################################################################################
    /**
     * @class
     * @extends MediaResource
     * @param {Object} dataJSON
     */
    function SoundEffectResource(dataJSON) {
        MediaResource.call(this, dataJSON);
    }
    SoundEffectResource.prototype = new MediaResource();
    SoundEffectResource.prototype.constructor = SoundEffectResource;
    /**
     * @override
     * @param {Object} dataJSON
     */
    SoundEffectResource.prototype._loadConfig = function (dataJSON) {
        MediaResource.prototype._loadConfig.call(this, dataJSON);
        /**
         * The filenames (paths withing the sound effect folder) of the samples that correspond to this sound effect - when playing back
         * the effect, one of these samples is chosen randomly
         * @type String[]
         */
        this._samples = dataJSON.samples;
        /**
         * @type Number
         */
        this._loadedSamples = 0;
        /**
         * @type Number
         */
        this._samplesToLoad = 0;
    };
    /**
     * @override
     * @returns {Boolean}
     */
    SoundEffectResource.prototype.requiresReload = function () {
        return !this.isReadyToUse() && !this.isRequested();
    };
    /**
     * @param {Number} index
     */
    SoundEffectResource.prototype._requestFile = function (index) {
        this._samplesToLoad++;
        application.requestFile(SOUND_EFFECT_FOLDER, this._samples[index], function (request) {
            if (request) {
                audio.loadSample(this._samples[index], request, function () {
                    this._loadedSamples++;
                    this._onFilesLoad(this._samplesToLoad === this._loadedSamples, {path: this._samples[index]});
                }.bind(this));
            } else {
                application.showError("Could not load sound sample '" + this.getName() + "'!");
                this._samples[index] = null;
                this._loadedSamples++;
                this._onFilesLoad(this._samplesToLoad === this._loadedSamples, {path: this._samples[index], error: true});
            }
        }.bind(this), undefined, "arraybuffer");
    };
    /**
     * @override
     */
    SoundEffectResource.prototype._requestFiles = function () {
        var i;
        for (i = 0; i < this._samples.length; i++) {
            this._requestFile(i);
        }
    };
    /**
     * @override
     * @param {Object} params
     * @returns {Boolean}
     */
    SoundEffectResource.prototype._loadData = function (params) {
        if (!params.error) {
            application.log_DEBUG("Sound effect sample from file: " + params.path + " has been loaded.", 2);
            return true;
        }
        application.log_DEBUG("WARNING: Sound effect sample from file: " + params.path + " could not be loaded.", 1);
        return false;
    };
    /**
     * Plays back one of the samples (randomly chosen) corresponding to this effect, without saving a reference to it. The samples must be
     * loaded.
     * @param {Number} [volume=1]
     * @param {Number[3]} [position]
     * @param {Number} [rolloff]
     */
    SoundEffectResource.prototype.play = function (volume, position, rolloff) {
        var sample;
        if (this.isReadyToUse() === false) {
            application.showError("Cannot play sound effect '" + this.getName() + "', as it has not been loaded from file yet!");
            return;
        }
        sample = this._samples[Math.floor(Math.random() * this._samples.length)];
        if (sample) {
            audio.playSound(sample, volume, position, rolloff);
        } else {
            application.log_DEBUG("WARNING: cannot play sound sample '" + sample + "', as there was a problem while loading it.", 1);
        }
    };
    /**
     * Creates a sound source for a randomly chosen sample corresponding to this effect and returns the reference to it. The samples must be
     * loaded.
     * @param {Number} soundCategory (enum audio.SoundCategory) Use the SOUND_EFFECT or UI category
     * @param {Number} [volume=1]
     * @param {Boolean} [loop=false]
     * @param {Boolean} [shouldStack=false]
     * @param {Number} [stackTimeThreshold=0]
     * @param {Number} [stackVolumeFactor=1]
     * @param {SoundSource} [source]
     * @returns {SoundClip}
     */
    SoundEffectResource.prototype.createSoundClip = function (soundCategory, volume, loop, shouldStack, stackTimeThreshold, stackVolumeFactor, source) {
        var sample;
        if (this.isReadyToUse() === false) {
            application.showError("Cannot create sound source for sound effect '" + this.getName() + "', as it has not been loaded from file yet!");
            return null;
        }
        sample = this._samples[Math.floor(Math.random() * this._samples.length)];
        if (sample) {
            return new audio.SoundClip(soundCategory, sample, volume, loop, shouldStack, stackTimeThreshold, stackVolumeFactor, source);
        }
        application.log_DEBUG("WARNING: cannot create sound source for sample '" + sample + "', as there was a problem while loading it.", 1);
        return null;
    };
    // ############################################################################################
    /**
     * @class
     * @extends MediaResource
     * @param {Object} dataJSON
     */
    function MusicResource(dataJSON) {
        MediaResource.call(this, dataJSON);
    }
    MusicResource.prototype = new MediaResource();
    MusicResource.prototype.constructor = MusicResource;
    /**
     * @override
     * @param {Object} dataJSON
     */
    MusicResource.prototype._loadConfig = function (dataJSON) {
        MediaResource.prototype._loadConfig.call(this, dataJSON);
        /**
         * The filename (path withing the music folder) of the sample that correspond to this song
         * @type String
         */
        this._sample = dataJSON.sample;
    };
    /**
     * @override
     * @returns {Boolean}
     */
    MusicResource.prototype.requiresReload = function () {
        return !this.isReadyToUse() && !this.isRequested();
    };
    /**
     * @override
     */
    MusicResource.prototype._requestFiles = function () {
        application.requestFile(MUSIC_FOLDER, this._sample, function (request) {
            if (request) {
                audio.loadSample(this._sample, request, function () {
                    this._onFilesLoad(true, {path: this._sample});
                }.bind(this));
            } else {
                application.showError("Could not load music track '" + this.getName() + "'!");
                this._sample = null;
                this._onFilesLoad(true, {path: this._sample, error: true});
            }
        }.bind(this), undefined, "arraybuffer");
    };
    /**
     * @override
     * @param {Object} params
     * @returns {Boolean}
     */
    MusicResource.prototype._loadData = function (params) {
        if (!params.error) {
            application.log_DEBUG("Music song from file: " + params.path + " has been loaded.", 2);
            return true;
        }
        application.log_DEBUG("WARNING: Music song from file: " + params.path + " cound not be loaded.", 1);
        return false;
    };
    /**
     * Creates a sound source for the sample corresponding to this music and returns the reference to it. The sample must be loaded.
     * @param {Number} [volume=1]
     * @param {Boolean} [loop=false]
     * @returns {SoundClip}
     */
    MusicResource.prototype.createSoundClip = function (volume, loop) {
        if (this.isReadyToUse() === false) {
            application.showError("Cannot create sound source for music '" + this.getName() + "', as it has not been loaded from file yet!");
            return null;
        }
        if (this._sample) {
            return new audio.SoundClip(audio.SoundCategory.MUSIC, this._sample, volume, loop);
        }
        application.log_DEBUG("WARNING: cannot create sound source for music track '" + this._sample + "', as there was a problem while loading it.", 1);
        return null;
    };
    // ############################################################################################
    /**
     * @class
     * @augments ResourceManager
     */
    function MediaResourceManager() {
        resourceManager.ResourceManager.call(this);
    }
    MediaResourceManager.prototype = new resourceManager.ResourceManager();
    MediaResourceManager.prototype.constructor = MediaResourceManager;
    /**
     * @param {String} name
     * @param {TextureResource~RequestParams} params 
     * @returns {TextureResource}
     */
    MediaResourceManager.prototype.getTexture = function (name, params) {
        return this.getResource(TEXTURE_ARRAY_NAME, name, params);
    };
    /**
     * @param {String} name
     * @param {Object} params 
     * @returns {CubemapResource}
     */
    MediaResourceManager.prototype.getCubemap = function (name, params) {
        return this.getResource(CUBEMAP_ARRAY_NAME, name, params);
    };
    /**
     * @param {String} name
     * @returns {ShaderResource}
     */
    MediaResourceManager.prototype.getShader = function (name) {
        return this.getResource(SHADER_ARRAY_NAME, name);
    };
    /**
     * Returns the shader resource representing the given variant of the shader with the given name, if it exists, or the one representing
     * the original shader resource with the given name, if it does not.
     * @param {String} name
     * @param {String} variantName
     * @returns {ShaderResource}
     */
    MediaResourceManager.prototype.getVariantShader = function (name, variantName) {
        return this.getResource(SHADER_ARRAY_NAME, this.getResource(SHADER_ARRAY_NAME, name, {doNotLoad: true}).getVariantShaderName(variantName), {allowNullResult: true}) || this.getShader(name);
    };
    /**
     * @param {String} name
     * @param {Object} params
     * @returns {ModelResource}
     */
    MediaResourceManager.prototype.getModel = function (name, params) {
        return this.getResource(MODEL_ARRAY_NAME, name, params);
    };
    /**
     * @param {Model} model
     * @returns {ModelResource}
     */
    MediaResourceManager.prototype.getOrAddModel = function (model) {
        var result = this.getResource(MODEL_ARRAY_NAME, model.getName(), {allowNullResult: true});
        if (!result) {
            result = this.addResource(MODEL_ARRAY_NAME, new ModelResource({
                "name": model.getName(),
                "model": model
            }), true);
        }
        return result;
    };
    /**
     * @param {String} name
     * @returns {SoundEffectResource}
     */
    MediaResourceManager.prototype.getSoundEffect = function (name) {
        return this.getResource(SOUND_EFFECT_ARRAY_NAME, name);
    };
    /**
     * @param {String} name
     * @returns {MusicResource}
     */
    MediaResourceManager.prototype.getMusic = function (name) {
        return this.getResource(MUSIC_ARRAY_NAME, name);
    };
    // ------------------------------------------------------------------------------
    // Public functions
    /**
     * Sends an asynchronous request to grab the file containing the media
     * resource descriptions and sets a callback to load those descriptions as 
     * well as run a custom callback if given, as well, after the loading has 
     * been completed.
     * @param {{folder: String, filename: String}} mediaResourceFileDescriptor
     * @param {Function} callback
     */
    function requestConfigLoad(mediaResourceFileDescriptor, callback) {
        var resourceClassAssignment = {};
        resourceClassAssignment[TEXTURE_ARRAY_NAME] = TextureResource;
        resourceClassAssignment[CUBEMAP_ARRAY_NAME] = CubemapResource;
        resourceClassAssignment[SHADER_ARRAY_NAME] = ShaderResource;
        resourceClassAssignment[MODEL_ARRAY_NAME] = ModelResource;
        resourceClassAssignment[SOUND_EFFECT_ARRAY_NAME] = SoundEffectResource;
        resourceClassAssignment[MUSIC_ARRAY_NAME] = MusicResource;
        _resourceManager.requestConfigLoad(mediaResourceFileDescriptor.filename, mediaResourceFileDescriptor.folder, resourceClassAssignment, callback);
    }
    _resourceManager = new MediaResourceManager();
    return {
        SoundCategory: audio.SoundCategory, // propagated because a category can be chosen when creating sound clips for sound effects
        requestConfigLoad: requestConfigLoad,
        requestResourceLoad: _resourceManager.requestResourceLoad.bind(_resourceManager),
        getTexture: _resourceManager.getTexture.bind(_resourceManager),
        getCubemap: _resourceManager.getCubemap.bind(_resourceManager),
        getShader: _resourceManager.getShader.bind(_resourceManager),
        getVariantShader: _resourceManager.getVariantShader.bind(_resourceManager),
        getModel: _resourceManager.getModel.bind(_resourceManager),
        getOrAddModel: _resourceManager.getOrAddModel.bind(_resourceManager),
        getSoundEffect: _resourceManager.getSoundEffect.bind(_resourceManager),
        getMusic: _resourceManager.getMusic.bind(_resourceManager),
        getResourceTypes: _resourceManager.getResourceTypes.bind(_resourceManager),
        getResourceNames: _resourceManager.getResourceNames.bind(_resourceManager),
        getResource: _resourceManager.getResource.bind(_resourceManager),
        addResource: _resourceManager.addResource.bind(_resourceManager),
        createResource: _resourceManager.createResource.bind(_resourceManager),
        executeWhenReady: _resourceManager.executeWhenReady.bind(_resourceManager),
        executeOnResourceLoad: _resourceManager.executeOnResourceLoad.bind(_resourceManager),
        executeForAllResources: _resourceManager.executeForAllResources.bind(_resourceManager),
        renameResource: _resourceManager.renameResource.bind(_resourceManager),
        moveResourceAfter: _resourceManager.moveResourceAfter.bind(_resourceManager)
    };
});


/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides a set of functions to operate on Float32Arrays as matrices
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, Float32Array */

/**
 * @param utils Used for Pi related constants
 * @param vec Used for vector operations (such as calculating lengths or angles of vectors)
 */
define('utils/matrices',[
    "utils/utils",
    "utils/vectors"
], function (utils, vec) {
    "use strict";

    var mat = {},
            // ----------------------------------------------------------------------
            // constants
            /**
             * Used as error threshold - numbers larger than this can be exchanged for the number 1 in certain places
             * @type Number
             */
            CLOSE_TO_ONE_THRESHOLD = 0.99999,
            /**
             * The number of auxiliary matrices that should be created.
             * @type Number
             */
            AUX_MATRIX_COUNT = 20,
            // ----------------------------------------------------------------------
            // private variables
            /**
             * @typedef {object} TempMatrixObject
             * @property {Float32Array} matrix
             * @property {Boolean} used
             */
            /**
             * Stores matrices used for temporary values during matrix calculations so fewer new matrices need to be created.
             * These matrices are for internal use only, when a temporary matrix is required during one operation but can be disposed of
             * when the operation is complete.
             * @type TempMatrixObject[]
             */
            _tempMatrices = [],
            /**
             * Stores auxiliary matrices used for holding the results of temporary calculations. Operations returning a new matrix can have
             * an alternate version which uses one of the auxiliary matrices, thus avoiding creating a new matrix. This can
             * be utilized by the users of this library by using the auxiliary version where the result is not persistently needed.
             * There is a fixed amount of these matrices available and the operations cycle through them, so they can be used in (not too
             * deep) combined operations, but not for recursion.
             * @type Float32Array[]
             */
            _auxMatrices = [],
            /**
             * The index of the auxiliary matrix to be used for the next auxiliary matrix operation.
             * @type Number
             */
            _auxMatrixIndex = 0,
            /**
             * 3x3 auxiliary matrices.
             * @type Float32Array[]
             */
            _auxMatrices3 = [],
            /**
             * The index of the 3x3 auxiliary matrix to be used for the next 3x3 auxiliary matrix operation.
             * @type Number
             */
            _auxMatrix3Index = 0,
            /**
             * Stores how many new matrices have been created.
             * @type Number
             */
            _matrixCount = 0;
    // -----------------------------------------------------------------------------
    // Private functions with the matrix counterF
    /**
     * Clears the counter storing how many new matrices have been created.
     */
    mat.clearMatrixCount = function () {
        _matrixCount = 0;
    };
    /**
     * Returns how many matrices have been created using the functions of this module.
     * @returns {Number}
     */
    mat.getMatrixCount = function () {
        return _matrixCount;
    };
    // -----------------------------------------------------------------------------
    // Private functions with temporary matrices
    /**
     * Returns an index at which a free (currently not used) temporary matrix is available.
     * @returns {Number}
     */
    function _getFreeTempMatrixIndex() {
        var i;
        for (i = 0; i < _tempMatrices.length; i++) {
            if (!_tempMatrices[i].used) {
                return i;
            }
        }
        _tempMatrices.push({
            used: false,
            matrix: mat.identity4()
        });
        return _tempMatrices.length - 1;
    }
    /**
     * Returns the temporary matrix stored at the passed index as well as marks it as used.
     * @param {Number} index
     * @returns {Float32Array}
     */
    function _getTempMatrix(index) {
        _tempMatrices[index].used = true;
        return _tempMatrices[index].matrix;
    }
    /**
     * Marks the temporary matrix at the passed index as free.
     * @param {Number} index
     */
    function _releaseTempMatrix(index) {
        _tempMatrices[index].used = false;
    }
    // -----------------------------------------------------------------------------
    // Functions that create new matrices and constant matrices
    /**
     * Returns a 3x3 identity matrix.
     * @returns {Float32Array}
     */
    mat.identity3 = function () {
        _matrixCount++;
        return new Float32Array([
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
        ]);
    };
    /**
     * Returns a 3x3 identity matrix.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @returns {Float32Array}
     */
    mat.identity3Aux = function () {
        var aux = _auxMatrices3[_auxMatrix3Index];
        aux[0] = 1.0;
        aux[1] = 0.0;
        aux[2] = 0.0;
        aux[3] = 0.0;
        aux[4] = 1.0;
        aux[5] = 0.0;
        aux[6] = 0.0;
        aux[7] = 0.0;
        aux[8] = 1.0;
        _auxMatrix3Index = (_auxMatrix3Index + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * A constant 3x3 identity matrix.
     * @type Float32Array
     */
    mat.IDENTITY3 = mat.identity3();
    /**
     * Returns a 4x4 identity matrix.
     * @returns {Float32Array}
     */
    mat.identity4 = function () {
        _matrixCount++;
        return new Float32Array([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ]);
    };
    /**
     * Returns a 4x4 identity matrix.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @returns {Float32Array}
     */
    mat.identity4Aux = function () {
        var aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = 1.0;
        aux[1] = 0.0;
        aux[2] = 0.0;
        aux[3] = 0.0;
        aux[4] = 0.0;
        aux[5] = 1.0;
        aux[6] = 0.0;
        aux[7] = 0.0;
        aux[8] = 0.0;
        aux[9] = 0.0;
        aux[10] = 1.0;
        aux[11] = 0.0;
        aux[12] = 0.0;
        aux[13] = 0.0;
        aux[14] = 0.0;
        aux[15] = 1.0;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * A constant 4x4 identity matrix.
     * @type Float32Array
     */
    mat.IDENTITY4 = mat.identity4();
    /**
     * Returns a 3x3 null matrix.
     * @returns {Float32Array}
     */
    mat.null3 = function () {
        _matrixCount++;
        return new Float32Array([
            0.0, 0.0, 0.0,
            0.0, 0.0, 0.0,
            0.0, 0.0, 0.0
        ]);
    };
    /**
     * A constant 3x3 null matrix.
     * @type Float32Array
     */
    mat.NULL3 = mat.null3();
    /**
     * Returns a 4x4 null matrix.
     * @returns {Float32Array}
     */
    mat.null4 = function () {
        _matrixCount++;
        return new Float32Array([
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0
        ]);
    };
    /**
     * A constant 4x4 null matrix.
     * @type Float32Array
     */
    mat.NULL4 = mat.null4();
    /**
     * Return a 3x3 matrix comprised of the first 9 elements of the passed array.
     * @param {Float32Array|Number[9]} m
     * @returns {Float32Array}
     */
    mat.matrix3 = function (m) {
        _matrixCount++;
        return new Float32Array([
            m[0], m[1], m[2],
            m[3], m[4], m[5],
            m[6], m[7], m[8]
        ]);
    };
    /**
     * Return a 4x4 matrix comprised of the first 16 elements of the passed array.
     * @param {Float32Array|Number[16]} m
     * @returns {Float32Array}
     */
    mat.matrix4 = function (m) {
        _matrixCount++;
        return new Float32Array([
            m[0], m[1], m[2], m[3],
            m[4], m[5], m[6], m[7],
            m[8], m[9], m[10], m[11],
            m[12], m[13], m[14], m[15]
        ]);
    };
    /**
     * Return a 4x4 matrix comprised of the first 16 elements of the passed array.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array|Number[16]} m
     * @returns {Float32Array}
     */
    mat.matrix4Aux = function (m) {
        var aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = m[0];
        aux[1] = m[1];
        aux[2] = m[2];
        aux[3] = m[3];
        aux[4] = m[4];
        aux[5] = m[5];
        aux[6] = m[6];
        aux[7] = m[7];
        aux[8] = m[8];
        aux[9] = m[9];
        aux[10] = m[10];
        aux[11] = m[11];
        aux[12] = m[12];
        aux[13] = m[13];
        aux[14] = m[14];
        aux[15] = m[15];
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a 4x4 transformation matrix describing a translation.
     * @param {Number} x The x coordinate of the translation.
     * @param {Number} y The y coordinate of the translation.
     * @param {Number} z The z coordinate of the translation.
     * @returns {Float32Array}
     */
    mat.translation4 = function (x, y, z) {
        _matrixCount++;
        return new Float32Array([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            x, y, z, 1.0
        ]);
    };
    /**
     * Returns a 4x4 transformation matrix describing a translation.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number} x The x coordinate of the translation.
     * @param {Number} y The y coordinate of the translation.
     * @param {Number} z The z coordinate of the translation.
     * @returns {Float32Array}
     */
    mat.translation4Aux = function (x, y, z) {
        var aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = 1.0;
        aux[1] = 0.0;
        aux[2] = 0.0;
        aux[3] = 0.0;
        aux[4] = 0.0;
        aux[5] = 1.0;
        aux[6] = 0.0;
        aux[7] = 0.0;
        aux[8] = 0.0;
        aux[9] = 0.0;
        aux[10] = 1.0;
        aux[11] = 0.0;
        aux[12] = x;
        aux[13] = y;
        aux[14] = z;
        aux[15] = 1.0;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a 4x4 transformation matrix describing a translation.
     * @param {Number[3]} v The vector of the translation ([x,y,z]).
     * @returns {Float32Array}
     */
    mat.translation4v = function (v) {
        _matrixCount++;
        return new Float32Array([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            v[0], v[1], v[2], 1.0
        ]);
    };
    /**
     * Returns a 4x4 transformation matrix describing a translation.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[3]} v The vector of the translation ([x,y,z]).
     * @returns {Float32Array}
     */
    mat.translation4vAux = function (v) {
        var aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = 1.0;
        aux[1] = 0.0;
        aux[2] = 0.0;
        aux[3] = 0.0;
        aux[4] = 0.0;
        aux[5] = 1.0;
        aux[6] = 0.0;
        aux[7] = 0.0;
        aux[8] = 0.0;
        aux[9] = 0.0;
        aux[10] = 1.0;
        aux[11] = 0.0;
        aux[12] = v[0];
        aux[13] = v[1];
        aux[14] = v[2];
        aux[15] = 1.0;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a 4x4 transformation matrix describing a translation.
     * @param {Float32Array} m A generic 4x4 transformation matrix.
     * @returns {Float32Array}
     */
    mat.translation4m4 = function (m) {
        _matrixCount++;
        return new Float32Array([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            m[12], m[13], m[14], 1.0
        ]);
    };
    /**
     * Returns a 4x4 transformation matrix describing a translation.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m A generic 4x4 transformation matrix the translation of which will be extracted.
     * @returns {Float32Array}
     */
    mat.translation4m4Aux = function (m) {
        var aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = 1.0;
        aux[1] = 0.0;
        aux[2] = 0.0;
        aux[3] = 0.0;
        aux[4] = 0.0;
        aux[5] = 1.0;
        aux[6] = 0.0;
        aux[7] = 0.0;
        aux[8] = 0.0;
        aux[9] = 0.0;
        aux[10] = 1.0;
        aux[11] = 0.0;
        aux[12] = m[12];
        aux[13] = m[13];
        aux[14] = m[14];
        aux[15] = 1.0;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a new 2x2 transformation matrix describing a rotation.
     * @param {Number} angle The angle of rotation in radians
     */
    mat.rotation2 = function (angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle);
        _matrixCount++;
        return new Float32Array([
            cosAngle, -sinAngle,
            sinAngle, cosAngle
        ]);
    };
    /**
     * Returns a new 3x3 transformation matrix describing a rotation around an arbitrary axis.
     * @param {Number[]} axis A 3D unit vector describing the axis of the rotation
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotation3 = function (axis, angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle);
        _matrixCount++;
        return new Float32Array([
            cosAngle + (1 - cosAngle) * axis[0] * axis[0], (1 - cosAngle) * axis[0] * axis[1] - sinAngle * axis[2], (1 - cosAngle) * axis[0] * axis[2] + sinAngle * axis[1],
            (1 - cosAngle) * axis[0] * axis[1] + sinAngle * axis[2], cosAngle + (1 - cosAngle) * axis[1] * axis[1], (1 - cosAngle) * axis[1] * axis[2] - sinAngle * axis[0],
            (1 - cosAngle) * axis[0] * axis[2] - sinAngle * axis[1], (1 - cosAngle) * axis[1] * axis[2] + sinAngle * axis[0], cosAngle + (1 - cosAngle) * axis[2] * axis[2]
        ]);
    };
    /**
     * Returns a new 3x3 transformation matrix describing a rotation around an arbitrary axis.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[]} axis An array of 3 numbers describing the axis of the rotation
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotation3Aux = function (axis, angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle),
                aux = _auxMatrices3[_auxMatrix3Index];
        aux[0] = cosAngle + (1 - cosAngle) * axis[0] * axis[0];
        aux[1] = (1 - cosAngle) * axis[0] * axis[1] - sinAngle * axis[2];
        aux[2] = (1 - cosAngle) * axis[0] * axis[2] + sinAngle * axis[1];
        aux[3] = (1 - cosAngle) * axis[0] * axis[1] + sinAngle * axis[2];
        aux[4] = cosAngle + (1 - cosAngle) * axis[1] * axis[1];
        aux[5] = (1 - cosAngle) * axis[1] * axis[2] - sinAngle * axis[0];
        aux[6] = (1 - cosAngle) * axis[0] * axis[2] - sinAngle * axis[1];
        aux[7] = (1 - cosAngle) * axis[1] * axis[2] + sinAngle * axis[0];
        aux[8] = cosAngle + (1 - cosAngle) * axis[2] * axis[2];
        _auxMatrix3Index = (_auxMatrix3Index + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a new 4x4 transformation matrix describing a rotation around an arbitrary axis.
     * @param {Number[]} axis A 3D unit vector describing the axis of the rotation
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotation4 = function (axis, angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle);
        _matrixCount++;
        return new Float32Array([
            cosAngle + (1 - cosAngle) * axis[0] * axis[0], (1 - cosAngle) * axis[0] * axis[1] - sinAngle * axis[2], (1 - cosAngle) * axis[0] * axis[2] + sinAngle * axis[1], 0.0,
            (1 - cosAngle) * axis[0] * axis[1] + sinAngle * axis[2], cosAngle + (1 - cosAngle) * axis[1] * axis[1], (1 - cosAngle) * axis[1] * axis[2] - sinAngle * axis[0], 0.0,
            (1 - cosAngle) * axis[0] * axis[2] - sinAngle * axis[1], (1 - cosAngle) * axis[1] * axis[2] + sinAngle * axis[0], cosAngle + (1 - cosAngle) * axis[2] * axis[2], 0.0,
            0.0, 0.0, 0.0, 1.0
        ]);
    };
    /**
     * Returns a new 4x4 transformation matrix describing a rotation around the X axis.
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotationX4 = function (angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle);
        _matrixCount++;
        return new Float32Array([
            1, 0, 0, 0,
            0, cosAngle, -sinAngle, 0,
            0, sinAngle, cosAngle, 0,
            0, 0, 0, 1
        ]);
    };
    /**
     * A constant 4x4 rotation matrix, rotating +90 degrees around axis X.
     * @type Float32Array
     */
    mat.ROTATION_X_90 = mat.rotationX4(Math.PI * 0.5);
    /**
     * A constant 4x4 rotation matrix, rotating +180 degrees around axis X.
     * @type Float32Array
     */
    mat.ROTATION_X_180 = mat.rotationX4(Math.PI * 1.0);
    /**
     * A constant 4x4 rotation matrix, rotating +270 degrees around axis X.
     * @type Float32Array
     */
    mat.ROTATION_X_270 = mat.rotationX4(Math.PI * 1.5);
    /**
     * Returns a new 4x4 transformation matrix describing a rotation around the Y axis.
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotationY4 = function (angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle);
        _matrixCount++;
        return new Float32Array([
            cosAngle, 0, sinAngle, 0,
            0, 1, 0, 0,
            -sinAngle, 0, cosAngle, 0,
            0, 0, 0, 1
        ]);
    };
    /**
     * A constant 4x4 rotation matrix, rotating +90 degrees around axis Y.
     * @type Float32Array
     */
    mat.ROTATION_Y_90 = mat.rotationY4(Math.PI * 0.5);
    /**
     * A constant 4x4 rotation matrix, rotating +180 degrees around axis Y.
     * @type Float32Array
     */
    mat.ROTATION_Y_180 = mat.rotationY4(Math.PI * 1.0);
    /**
     * A constant 4x4 rotation matrix, rotating +270 degrees around axis Y.
     * @type Float32Array
     */
    mat.ROTATION_Y_270 = mat.rotationY4(Math.PI * 1.5);
    /**
     * Returns a new 4x4 transformation matrix describing a rotation around the Z axis.
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotationZ4 = function (angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle);
        _matrixCount++;
        return new Float32Array([
            cosAngle, -sinAngle, 0, 0,
            sinAngle, cosAngle, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
    };
    /**
     * A constant 4x4 rotation matrix, rotating +90 degrees around axis Z.
     * @type Float32Array
     */
    mat.ROTATION_Z_90 = mat.rotationZ4(Math.PI * 0.5);
    /**
     * A constant 4x4 rotation matrix, rotating +180 degrees around axis Z.
     * @type Float32Array
     */
    mat.ROTATION_Z_180 = mat.rotationZ4(Math.PI * 1.0);
    /**
     * A constant 4x4 rotation matrix, rotating +270 degrees around axis Z.
     * @type Float32Array
     */
    mat.ROTATION_Z_270 = mat.rotationZ4(Math.PI * 1.5);
    /**
     * Returns a new 4x4 transformation matrix describing a rotation around an arbitrary axis.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[]} axis A 3D unit vector describing the axis of the rotation
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotation4Aux = function (axis, angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle),
                aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = cosAngle + (1 - cosAngle) * axis[0] * axis[0];
        aux[1] = (1 - cosAngle) * axis[0] * axis[1] - sinAngle * axis[2];
        aux[2] = (1 - cosAngle) * axis[0] * axis[2] + sinAngle * axis[1];
        aux[3] = 0.0;
        aux[4] = (1 - cosAngle) * axis[0] * axis[1] + sinAngle * axis[2];
        aux[5] = cosAngle + (1 - cosAngle) * axis[1] * axis[1];
        aux[6] = (1 - cosAngle) * axis[1] * axis[2] - sinAngle * axis[0];
        aux[7] = 0.0;
        aux[8] = (1 - cosAngle) * axis[0] * axis[2] - sinAngle * axis[1];
        aux[9] = (1 - cosAngle) * axis[1] * axis[2] + sinAngle * axis[0];
        aux[10] = cosAngle + (1 - cosAngle) * axis[2] * axis[2];
        aux[11] = 0.0;
        aux[12] = 0.0;
        aux[13] = 0.0;
        aux[14] = 0.0;
        aux[15] = 1.0;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a new 4x4 transformation matrix describing a rotation around the X axis.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotationX4Aux = function (angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle),
                aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = 1;
        aux[1] = 0;
        aux[2] = 0;
        aux[3] = 0;
        aux[4] = 0;
        aux[5] = cosAngle;
        aux[6] = -sinAngle;
        aux[7] = 0;
        aux[8] = 0;
        aux[9] = sinAngle;
        aux[10] = cosAngle;
        aux[11] = 0;
        aux[12] = 0;
        aux[13] = 0;
        aux[14] = 0;
        aux[15] = 1;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a new 4x4 transformation matrix describing a rotation around the Y axis.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotationY4Aux = function (angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle),
                aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = cosAngle;
        aux[1] = 0;
        aux[2] = sinAngle;
        aux[3] = 0;
        aux[4] = 0;
        aux[5] = 1;
        aux[6] = 0;
        aux[7] = 0;
        aux[8] = -sinAngle;
        aux[9] = 0;
        aux[10] = cosAngle;
        aux[11] = 0;
        aux[12] = 0;
        aux[13] = 0;
        aux[14] = 0;
        aux[15] = 1;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a new 4x4 transformation matrix describing a rotation around the Z axis.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotationZ4Aux = function (angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle),
                aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = cosAngle;
        aux[1] = -sinAngle;
        aux[2] = 0;
        aux[3] = 0;
        aux[4] = sinAngle;
        aux[5] = cosAngle;
        aux[6] = 0;
        aux[7] = 0;
        aux[8] = 0;
        aux[9] = 0;
        aux[10] = 1;
        aux[11] = 0;
        aux[12] = 0;
        aux[13] = 0;
        aux[14] = 0;
        aux[15] = 1;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a new 4x4 transformation matrix describing a rotation around an arbitrary axis that goes through a given point.
     * @param {Number[3]} p The axis of rotation passes through this point.
     * @param {Number[]} axis A 3D unit vector describing the direction of the axis.
     * @param {Number} angle The angle of rotation in radians
     * @returns {Float32Array}
     */
    mat.rotationAroundPoint4 = function (p, axis, angle) {
        var
                m = mat.rotation4(axis, angle),
                p2 = vec.prodVec3Mat4Aux(p, m);
        m[12] = p[0] - p2[0];
        m[13] = p[1] - p2[1];
        m[14] = p[2] - p2[2];
        return m;
    };
    /**
     * Returns a 4x4 transformation matrix describing a rotation, using only the top left 3x3 submatrix
     * of a 4x4 matrix.
     * @param {Float32Array} m A generic 4x4 transformation matrix.
     * @returns {Float32Array}
     */
    mat.rotation4m4 = function (m) {
        _matrixCount++;
        return new Float32Array([
            m[0], m[1], m[2], 0.0,
            m[4], m[5], m[6], 0.0,
            m[8], m[9], m[10], 0.0,
            0.0, 0.0, 0.0, 1.0
        ]);
    };
    /**
     * Returns a 4x4 transformation matrix describing a rotation, using only the top left 3x3 submatrix
     * of a 4x4 matrix.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m A generic 4x4 transformation matrix.
     * @returns {Float32Array}
     */
    mat.rotation4m4Aux = function (m) {
        var aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = m[0];
        aux[1] = m[1];
        aux[2] = m[2];
        aux[3] = 0.0;
        aux[4] = m[4];
        aux[5] = m[5];
        aux[6] = m[6];
        aux[7] = 0.0;
        aux[8] = m[8];
        aux[9] = m[9];
        aux[10] = m[10];
        aux[11] = 0.0;
        aux[12] = 0.0;
        aux[13] = 0.0;
        aux[14] = 0.0;
        aux[15] = 1.0;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a 4x4 rotation matrix that has a Z axis pointing towards the given direction and a Y axis based on an optional second vector.
     * @param {Number[3]} direction A 3D unit vector.
     * @param {Number[3]} [up] A 3D unit vector.
     * @returns {Float32Array}
     */
    mat.lookTowards4 = function (direction, up) {
        var result;
        result = mat.identity4();
        mat.setLookTowards4(result, direction, up);
        return result;
    };
    /**
     * Returns a 4x4 rotation matrix that has a Z axis pointing towards the given direction and a Y axis based on an optional second vector.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number[3]} direction A 3D unit vector.
     * @param {Number[3]} [up] A 3D unit vector.
     * @returns {Float32Array}
     */
    mat.lookTowards4Aux = function (direction, up) {
        var aux = _auxMatrices[_auxMatrixIndex];
        mat.setLookTowards4(aux, direction, up);
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a 4x4 transformation matrix describing a scaling along the 3 axes.
     * @param {Number} x Scaling along axis X.
     * @param {Number} [y] Scaling along axis Y. If omitted, the same scaling will
     * be used for all 3 axes.
     * @param {Number} [z] Scaling along axis Z. If omitted, the same scaling will
     * be used for all 3 axes.
     * @returns {Float32Array}
     */
    mat.scaling4 = function (x, y, z) {
        if (y === undefined) {
            y = x;
        }
        if (z === undefined) {
            z = x;
        }
        _matrixCount++;
        return new Float32Array([
            x, 0.0, 0.0, 0.0,
            0.0, y, 0.0, 0.0,
            0.0, 0.0, z, 0.0,
            0.0, 0.0, 0.0, 1.0]
                );
    };
    /**
     * Returns a 4x4 transformation matrix describing a scaling along the 3 axes.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number} x Scaling along axis X.
     * @param {Number} [y] Scaling along axis Y. If omitted, the same scaling will
     * be used for all 3 axes.
     * @param {Number} [z] Scaling along axis Z. If omitted, the same scaling will
     * be used for all 3 axes.
     * @returns {Float32Array}
     */
    mat.scaling4Aux = function (x, y, z) {
        var aux = _auxMatrices[_auxMatrixIndex];
        if (y === undefined) {
            y = x;
        }
        if (z === undefined) {
            z = x;
        }
        aux[0] = x;
        aux[1] = 0;
        aux[2] = 0;
        aux[3] = 0;
        aux[4] = 0;
        aux[5] = y;
        aux[6] = 0;
        aux[7] = 0;
        aux[8] = 0;
        aux[9] = 0;
        aux[10] = z;
        aux[11] = 0;
        aux[12] = 0;
        aux[13] = 0;
        aux[14] = 0;
        aux[15] = 1;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Creates a 4x4 transformation matrix describing a translation and a rotation based on
     * two separate matrices, only the translation / rotation part of which are taken into
     * account and combined.
     * @param {Float32Array} translationMatrix A 4x4 matrix. Taken as a translation matrix,
     * irrelevant parts are not considered.
     * @param {Float32Array} rotationMatrix A 4x4 matrix. Taken as a roation matrix,
     * irrelevant parts are not considered.
     * @returns {Float32Array}
     */
    mat.translationRotation = function (translationMatrix, rotationMatrix) {
        _matrixCount++;
        return new Float32Array([
            rotationMatrix[0], rotationMatrix[1], rotationMatrix[2], 0.0,
            rotationMatrix[4], rotationMatrix[5], rotationMatrix[6], 0.0,
            rotationMatrix[8], rotationMatrix[9], rotationMatrix[10], 0.0,
            translationMatrix[12], translationMatrix[13], translationMatrix[14], 1.0
        ]);
    };
    /**
     * Returns a 4x4 transformation matrix describing a perspective projection.
     * @param {Number} right
     * @param {Number} top
     * @param {Number} near
     * @param {Number} far
     * @returns {Float32Array}
     */
    mat.perspective4 = function (right, top, near, far) {
        _matrixCount++;
        return new Float32Array([
            near / right, 0.0, 0.0, 0.0,
            0.0, near / top, 0.0, 0.0,
            0.0, 0.0, (near + far) / (near - far), -1.0,
            0.0, 0.0, 2 * near * far / (near - far), 0.0
        ]);
    };
    /**
     * Returns a 4x4 transformation matrix describing an orthographic projection.
     * @param {Number} right
     * @param {Number} top
     * @param {Number} near
     * @param {Number} far
     * @returns {Float32Array}
     */
    mat.orthographic4 = function (right, top, near, far) {
        _matrixCount++;
        return new Float32Array([
            1 / right, 0.0, 0.0, 0.0,
            0.0, 1 / top, 0.0, 0.0,
            0.0, 0.0, -2.0 / (far - near), 0.0,
            0.0, 0.0, -(near + far) / 2.0, 1.0
        ]);
    };
    /**
     * Returns a 4x4 transformation matrix describing an orthographic projection.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Number} right
     * @param {Number} top
     * @param {Number} near
     * @param {Number} far
     * @returns {Float32Array} One of the auxiliary matrices.
     */
    mat.orthographic4Aux = function (right, top, near, far) {
        var aux = _auxMatrices[_auxMatrixIndex];
        mat.setOrthographic4(aux, right, top, near, far);
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * @param {Object[]} jsonArray
     */
    mat.rotation4FromJSON = function (jsonArray) {
        var i, axis, rotation, result = mat.identity4();
        if (jsonArray) {
            for (i = 0; i < jsonArray.length; i++) {
                // handle (convert) short notation of rotations
                rotation = ((typeof jsonArray[i]) === "string") ? {
                    axis: jsonArray[i][0],
                    degrees: parseFloat(jsonArray[i].substring(1))
                } : jsonArray[i];
                // process rotation
                if (typeof rotation.axis === "string") {
                    switch (rotation.axis) {
                        case "x":
                        case "X":
                            axis = vec.UNIT3_X;
                            break;
                        case "y":
                        case "Y":
                            axis = vec.UNIT3_Y;
                            break;
                        case "z":
                        case "Z":
                            axis = vec.UNIT3_Z;
                            break;
                    }
                } else if (rotation.axis instanceof Array) {
                    axis = rotation.axis;
                }
                mat.mul4(
                        result,
                        mat.rotation4Aux(
                                axis,
                                rotation.degrees * utils.RAD
                                )
                        );
            }
        }
        return result;
    };
    /**
     * Returns a 3x3 vector the rows of which are made up of the vx,vy,vz vectors.
     * @param {Number[]} vx A 3D or 4D vector.
     * @param {Number[]} vy A 3D or 4D vector.
     * @param {Number[]} vz A 3D or 4D vector.
     * @returns {Float32Array}
     */
    mat.fromVectorsTo3 = function (vx, vy, vz) {
        _matrixCount++;
        return new Float32Array([
            vx[0], vx[1], vx[2],
            vy[0], vy[1], vy[2],
            vz[0], vz[1], vz[2]
        ]);
    };
    /**
     * Returns a 4x4 vector the rows of which are made up of the vx,vy,vz and if
     * given, vw (otherwise 0,0,0,1) vectors. The 4th elements are substituted by a
     * zero if the vectors are three dimensional.
     * @param {Number[]} vx A 3D or 4D vector.
     * @param {Number[]} vy A 3D or 4D vector.
     * @param {Number[]} vz A 3D or 4D vector.
     * @param {Number[]} vw A 3D or 4D vector.
     * @returns {Float32Array}
     */
    mat.fromVectorsTo4 = function (vx, vy, vz, vw) {
        vw = vw || [0.0, 0.0, 0.0, 1.0];
        _matrixCount++;
        return new Float32Array([
            vx[0], vx[1], vx[2], vx.length > 3 ? vx[3] : 0.0,
            vy[0], vy[1], vy[2], vy.length > 3 ? vy[3] : 0.0,
            vz[0], vz[1], vz[2], vz.length > 3 ? vz[3] : 0.0,
            vw[0], vw[1], vw[2], vw[3]
        ]);
    };
// -----------------------------------------------------------------------------
// Functions of a single matrix
    /**
     * Returns the first row vector of a 3x3 matrix.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Number[3]}
     */
    mat.getRowA3 = function (m) {
        return [m[0], m[1], m[2]];
    };
    /**
     * Returns the opposite of the first row vector of a 3x3 matrix.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Number[3]}
     */
    mat.getRowA3Neg = function (m) {
        return [-m[0], -m[1], -m[2]];
    };
    /**
     * Returns the first row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]}
     */
    mat.getRowA4 = function (m) {
        return [m[0], m[1], m[2], m[3]];
    };
    /**
     * Returns the opposite of the first row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]}
     */
    mat.getRowA4Neg = function (m) {
        return [-m[0], -m[1], -m[2], -m[3]];
    };
    /**
     * Returns the first row vector of a 4x4 matrix clipped to a 3D vector.
     * (same as getRowA3)
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[3]}
     */
    mat.getRowA43 = function (m) {
        return [m[0], m[1], m[2]];
    };
    /**
     * Returns the opposite of the first row vector of a 4x4 matrix clipped to a 3D vector.
     * (same as getRowA3Neg)
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[3]}
     */
    mat.getRowA43Neg = function (m) {
        return [-m[0], -m[1], -m[2]];
    };
    /**
     * Returns the second row vector of a 3x3 matrix.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Number[3]}
     */
    mat.getRowB3 = function (m) {
        return [m[3], m[4], m[5]];
    };
    /**
     * Returns the opposite of the second row vector of a 3x3 matrix.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Number[3]}
     */
    mat.getRowB3Neg = function (m) {
        return [-m[3], -m[4], -m[5]];
    };
    /**
     * Returns the second row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]}
     */
    mat.getRowB4 = function (m) {
        return [m[4], m[5], m[6], m[7]];
    };
    /**
     * Returns the opposite of the second row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]}
     */
    mat.getRowB4Neg = function (m) {
        return [-m[4], -m[5], -m[6], -m[7]];
    };
    /**
     * Returns the first 3 elements of the second row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[3]}
     */
    mat.getRowB43 = function (m) {
        return [m[4], m[5], m[6]];
    };
    /**
     * Returns the first 3 elements of the opposite of the second row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[3]}
     */
    mat.getRowB43Neg = function (m) {
        return [-m[4], -m[5], -m[6]];
    };
    /**
     * Returns the third row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]}
     */
    mat.getRowC4 = function (m) {
        return [m[8], m[9], m[10], m[11]];
    };
    /**
     * Returns the first 3 elements of the third row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[3]}
     */
    mat.getRowC43 = function (m) {
        return [m[8], m[9], m[10]];
    };
    /**
     * Returns the opposite of the first 3 elements of the third row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[3]}
     */
    mat.getRowC43Neg = function (m) {
        return [-m[8], -m[9], -m[10]];
    };
    /**
     * Returns the fourth row vector of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Number[4]}
     */
    mat.getRowD4 = function (m) {
        return [m[12], m[13], m[14], m[15]];
    };
    /**
     * Returns the determinant of the passed 3x3 matrix.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Number} The determinant of m.
     */
    mat.determinant3 = function (m) {
        return (
                m[0] * m[4] * m[8] + m[1] * m[5] * m[6] + m[2] * m[3] * m[7] -
                m[2] * m[4] * m[6] - m[1] * m[3] * m[8] - m[0] * m[5] * m[7]
                );
    };
    /**
     * Returns the 3D vector corresponding to the translation the passed 4x4 matrix
     * describes.
     * @param {Float32Array} m A 4x4 transformation matrix.
     * @returns {Number[3]}
     */
    mat.translationVector3 = function (m) {
        return [m[12], m[13], m[14]];
    };
    /**
     * Returns the 4D vector corresponding to the translation the passed 4x4 matrix
     * describes.
     * @param {Float32Array} m A 4x4 transformation matrix.
     * @returns {Number[4]}
     */
    mat.translationVector4 = function (m) {
        return [m[12], m[13], m[14], m[15]];
    };
    /**
     * Returns the length of the vector of the translation described by the passed
     * 4x4 transformation matrix.
     * @param {Float32Array} m A 4x4 transformation matrix.
     * @returns {Number}
     */
    mat.translationLength = function (m) {
        return vec.length3([m[12], m[13], m[14]]);
    };
    /**
     * Returns two angles, rotating by which would bring the axis Y unit vector in line with the passed unit vector.
     * @param {Number[3]} v A 3D unit vector.
     * @returns {Object} Has two fields, yaw is the angle of rotation around axis Z and pitch is the angle or rotation around axis X,
     * in radians.
     */
    mat.getVectorYawAndPitch = function (v) {
        var pitchVector, result = {};
        if (Math.abs(v[2]) > CLOSE_TO_ONE_THRESHOLD) {
            result.yaw = 0;
            result.pitch = (v[2] > 0) ? -utils.HALF_PI : utils.HALF_PI;
        } else {
            result.yaw = vec.angle2yCapped(v[0], v[1]);
            if (v[0] < 0) {
                result.yaw = -result.yaw;
            }
            pitchVector = vec.prodVec3Mat4Aux(v, mat.rotationZ4Aux(-result.yaw));
            result.pitch = vec.angle2xCapped(pitchVector[1], pitchVector[2]);
            if (pitchVector[2] > 0) {
                result.pitch = -result.pitch;
            }
        }
        return result;
    };
    /**
     * Takes a rotation matrix that was created as a product of two rotations, a first one around axis X and then one around axis Z, and 
     * returns the two angles corresponding to the two rotations. If the input matrix is not such a matrix (e.g. it was rotated around axis
     * Y as well), the result will not be accurate (and meaningful).
     * @param {Float32Array} m A 4x4 rotation matrix that is the combination (product) of a rotation first around axis X, then around axis Z.
     * @returns {Object} Has two fields, yaw is the angle of rotation around axis Z and pitch is the angle or rotation around axis X,
     * in radians.
     */
    mat.getYawAndPitch = function (m) {
        var pitchMatrix, result = {};
        if (Math.abs(m[6]) > CLOSE_TO_ONE_THRESHOLD) {
            result.yaw = 0;
            result.pitch = (m[6] > 0) ? -utils.HALF_PI : utils.HALF_PI;
        } else {
            result.yaw = (m[10] > 0) ? vec.angle2yCapped(m[4], m[5]) : vec.angle2yCapped(-m[4], -m[5]);
            if (m[4] * m[10] < 0) {
                result.yaw = -result.yaw;
            }
            pitchMatrix = mat.prod3x3SubOf4Aux(m, mat.rotationZ4Aux(-result.yaw));
            mat.correctOrthogonal4(pitchMatrix);
            result.pitch = vec.angle2xCapped(pitchMatrix[5], pitchMatrix[6]);
            if (pitchMatrix[6] > 0) {
                result.pitch = -result.pitch;
            }
        }
        return result;
    };
    /**
     * Returns the axes and angles (alpha and gamma) of two rotations that would transform the identity matrix into the passed rotation matrix.
     * @param {Float32Array} m A 4x4 rotation matrix.
     * @returns {Object} Has 4 fields: alpha and alphaAxis describe a rotation that would bring the Y axis of an identity matrix in line with
     * the Y axis of the passed matrix m, while gamma and gammaAxis describe a rotation that would afterwards bring the other axes in line.
     * The angles are in radian.
     */
    mat.getRotations = function (m) {
        var dot, halfMatrix, result = {};
        // calculate the rotation of axis Y needed
        dot = vec.dot3(vec.UNIT3_Y, mat.getRowB43(m));
        // if the angle of the two Y vectors is (around) 0 or 180 degrees, their cross product will be of zero length
        // and we cannot use it as a rotation axis, therefore fall back to axis Z in this case
        if (Math.abs(dot) > CLOSE_TO_ONE_THRESHOLD) {
            result.alphaAxis = [0, 0, 1];
            result.alpha = dot > 0 ? 0 : Math.PI;
        } else {
            result.alphaAxis = vec.normalize3(vec.cross3(mat.getRowB43(m), vec.UNIT3_Y));
            result.alpha = vec.angle3u(mat.getRowB43(m), vec.UNIT3_Y);
        }
        if (result.alpha > Math.PI) {
            result.alpha -= utils.DOUBLE_PI;
        }
        // calculate the matrix we would get if we rotated the Y vector into position
        halfMatrix = mat.prod3x3SubOf43Aux(m, mat.rotation3Aux(result.alphaAxis, -result.alpha));
        mat.correctOrthogonal4(halfMatrix);
        // X and Z vectors might still be out of place, therefore do the same calculations as before to 
        // get the second rotation needed, which will put all vectors in place
        dot = vec.dot3(vec.UNIT3_X, mat.getRowA43(halfMatrix));
        if (Math.abs(dot) > CLOSE_TO_ONE_THRESHOLD) {
            result.gammaAxis = [0, 1, 0];
            result.gamma = dot > 0 ? 0 : Math.PI;
        } else {
            result.gammaAxis = vec.normalize3(vec.cross3(mat.getRowA43(halfMatrix), vec.UNIT3_X));
            result.gamma = vec.angle3u(mat.getRowA43(halfMatrix), vec.UNIT3_X);
        }
        if (result.gamma > Math.PI) {
            result.gamma -= utils.DOUBLE_PI;
        }
        return result;
    };
    /**
     * Returns the string representation of a 3x3 matrix.
     * @param {Float32Array} m A 3x3 matrix.
     * @param {Number} [d=2] The number of decimals to include in the string for the 
     * matrix components.
     * @returns {String}
     */
    mat.toString3 = function (m, d) {
        d = d || 2;
        return m[0].toFixed(d) + " " + m[1].toFixed(d) + " " + m[2].toFixed(d) + "\n" +
                m[3].toFixed(d) + " " + m[4].toFixed(d) + " " + m[5].toFixed(d) + "\n" +
                m[6].toFixed(d) + " " + m[7].toFixed(d) + " " + m[8].toFixed(d);
    };
    /**
     * Returns the string representation of a 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @param {Number} [d=2] The number of decimals to include in the string for the 
     * matrix components.
     * @returns {String}
     */
    mat.toString4 = function (m, d) {
        d = d || 2;
        return m[0].toFixed(d) + " " + m[1].toFixed(d) + " " + m[2].toFixed(d) + " " + m[3].toFixed(d) + "\n" +
                m[4].toFixed(d) + " " + m[5].toFixed(d) + " " + m[6].toFixed(d) + " " + m[7].toFixed(d) + "\n" +
                m[8].toFixed(d) + " " + m[9].toFixed(d) + " " + m[10].toFixed(d) + " " + m[11].toFixed(d) + "\n" +
                m[12].toFixed(d) + " " + m[13].toFixed(d) + " " + m[14].toFixed(d) + " " + m[15].toFixed(d);
    };
    /**
     * Returns the string representation of a 4x4 matrix, with HTML markup to indicate
     * line breaks.
     * @param {Float32Array} m A 4x4 matrix.
     * @param {Number} [d=2] The number of decimals to include in the string for the 
     * matrix components.
     * @returns {String}
     */
    mat.toHTMLString4 = function (m, d) {
        d = d || 2;
        return m[0].toFixed(d) + " " + m[1].toFixed(d) + " " + m[2].toFixed(d) + " " + m[3].toFixed(d) + "<br/>" +
                m[4].toFixed(d) + " " + m[5].toFixed(d) + " " + m[6].toFixed(d) + " " + m[7].toFixed(d) + "<br/>" +
                m[8].toFixed(d) + " " + m[9].toFixed(d) + " " + m[10].toFixed(d) + " " + m[11].toFixed(d) + "<br/>" +
                m[12].toFixed(d) + " " + m[13].toFixed(d) + " " + m[14].toFixed(d) + " " + m[15].toFixed(d);
    };
// -----------------------------------------------------------------------------
// Functions that transform a matrix
    /**
     * Returns the 3x3 top-left submatrix of the passed 4x4 matrix.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Float32Array}
     */
    mat.matrix3from4 = function (m) {
        _matrixCount++;
        return new Float32Array([
            m[0], m[1], m[2],
            m[4], m[5], m[6],
            m[8], m[9], m[10]
        ]);
    };
    /**
     * Returns the 3x3 top-left submatrix of the passed 4x4 matrix.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Float32Array}
     */
    mat.matrix3from4Aux = function (m) {
        var aux = _auxMatrices3[_auxMatrix3Index];
        aux[0] = m[0];
        aux[1] = m[1];
        aux[2] = m[2];
        aux[3] = m[4];
        aux[4] = m[5];
        aux[5] = m[6];
        aux[6] = m[8];
        aux[7] = m[9];
        aux[8] = m[10];
        _auxMatrix3Index = (_auxMatrix3Index + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a 4x4 matrix by taking the 3x3 matrix m, and complementing it with
     * a last column and row of a 4x4 identity matrix.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Float32Array}
     */
    mat.matrix4from3 = function (m) {
        _matrixCount++;
        return new Float32Array([
            m[0], m[1], m[2], 0.0,
            m[3], m[4], m[5], 0.0,
            m[6], m[7], m[8], 0.0,
            0.0, 0.0, 0.0, 1.0
        ]);
    };
    /**
     * Returns the transposed of the passed 3x3 matrix m.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Float32Array} The transposed of m.
     */
    mat.transposed3 = function (m) {
        _matrixCount++;
        return new Float32Array([
            m[0], m[3], m[6],
            m[1], m[4], m[7],
            m[2], m[5], m[8]
        ]);
    };
    /**
     * Returns the transposed of the passed 3x3 matrix m.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Float32Array} The transposed of m.
     */
    mat.transposed3Aux = function (m) {
        var aux = _auxMatrices3[_auxMatrix3Index];
        mat.setTransposed3(aux, m);
        _auxMatrix3Index = (_auxMatrix3Index + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns the transposed of the top left 3x3 submatrix of the passed 4x4 matrix m.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Float32Array}
     */
    mat.transposed43 = function (m) {
        _matrixCount++;
        return new Float32Array([
            m[0], m[4], m[8],
            m[1], m[5], m[9],
            m[2], m[6], m[10]
        ]);
    };
    /**
     * Returns the transposed of the passed 4x4 matrix m.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Float32Array} The transposed of m.
     */
    mat.transposed4 = function (m) {
        _matrixCount++;
        return new Float32Array([
            m[0], m[4], m[8], m[12],
            m[1], m[5], m[9], m[13],
            m[2], m[6], m[10], m[14],
            m[3], m[7], m[11], m[15]
        ]);
    };
    /**
     * Returns the transposed of the passed 4x4 matrix m.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Float32Array} The transposed of m.
     */
    mat.transposed4Aux = function (m) {
        var aux = _auxMatrices[_auxMatrixIndex];
        mat.setTransposed4(aux, m);
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns the inverse of the passed 3x3 matrix m.
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Float32Array} The inverse of m.
     */
    mat.inverse3 = function (m) {
        var result;
        result = mat.identity3();
        mat.setInverse3(result, m);
        return result;
    };
    /**
     * Returns the inverse of the passed 3x3 matrix m.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m A 3x3 matrix.
     * @returns {Float32Array} The inverse of m.
     */
    mat.inverse3Aux = function (m) {
        var aux = _auxMatrices3[_auxMatrix3Index];
        mat.setInverse3(aux, m);
        _auxMatrix3Index = (_auxMatrix3Index + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns the inverse of the passed 4x4 matrix m.
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Float32Array} The inverse of m.
     */
    mat.inverse4 = function (m) {
        var result;
        result = mat.identity4();
        mat.setInverse4(result, m);
        return result;
    };
    /**
     * Returns the inverse of the passed 4x4 matrix m.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m A 4x4 matrix.
     * @returns {Float32Array} The inverse of m.
     */
    mat.inverse4Aux = function (m) {
        var aux = _auxMatrices[_auxMatrixIndex];
        mat.setInverse4(aux, m);
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * A computationally efficient function to return the inverse of a 4x4 translation
     * matrix. (a transformation matrix that only hold translation information)
     * @param {Float32Array} m The input 4x4 matrix.
     * @returns {Float32Array} The calculated inverse 4x4 matrix.
     */
    mat.inverseOfTranslation4 = function (m) {
        _matrixCount++;
        return new Float32Array([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            -m[12], -m[13], -m[14], 1.0
        ]);
    };
    /**
     * A computationally efficient function to return the inverse of a 4x4 translation
     * matrix. (a transformation matrix that only hold translation information)
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m The input 4x4 matrix.
     * @returns {Float32Array} The calculated inverse 4x4 matrix.
     */
    mat.inverseOfTranslation4Aux = function (m) {
        var aux = _auxMatrices[_auxMatrixIndex];
        mat.setInverseOfTranslation4(aux, m);
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Calculates and returns the inverse of a 4x4 rotation matrix, using the fact that
     * it coincides with its transpose. It is the same as transposed4, but the different
     * name of the function can clarify the role of it when it is used.
     * @param {Float32Array} m The input 4x4 rotation matrix.
     * @returns {Float32Array} The calculated inverse (transpose) rotation matrix.
     */
    mat.inverseOfRotation4 = mat.transposed4;
    /**
     * Calculates and returns the inverse of a 4x4 rotation matrix, using the fact that
     * it coincides with its transpose. It is the same as transposed4, but the different
     * name of the function can clarify the role of it when it is used.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m The input 4x4 rotation matrix.
     * @returns {Float32Array} The calculated inverse (transpose) rotation matrix.
     */
    mat.inverseOfRotation4Aux = mat.transposed4Aux;
    /**
     * A computationally efficient function to return the inverse of a 4x4 scaling
     * matrix. (a transformation matrix that only hold scaling information)
     * @param {Float32Array} m A 4x4 scaling matrix.
     * @returns {Float32Array} The calculated inverse 4x4 matrix.
     */
    mat.inverseOfScaling4 = function (m) {
        return mat.scaling4(1 / m[0], 1 / m[5], 1 / m[10]);
    };
    /**
     * Returns a 3x3 matrix multiplied by a scalar.
     * @param {Float32Array} m A 3x3 matrix.
     * @param {Number} s A scalar.
     * @returns {Float32Array} m multiplied by s.
     */
    mat.scaled3 = function (m, s) {
        _matrixCount++;
        return new Float32Array([
            m[0] * s, m[1] * s, m[2] * s,
            m[3] * s, m[4] * s, m[5] * s,
            m[6] * s, m[7] * s, m[8] * s
        ]);
    };
    /**
     * Returns a 4x4 matrix multiplied by a scalar.
     * @param {Float32Array} m A 4x4 matrix.
     * @param {Number} s A scalar.
     * @returns {Float32Array} m multiplied by s.
     */
    mat.scaled4 = function (m, s) {
        _matrixCount++;
        return new Float32Array([
            m[0] * s, m[1] * s, m[2] * s, m[3] * s,
            m[4] * s, m[5] * s, m[6] * s, m[7] * s,
            m[8] * s, m[9] * s, m[10] * s, m[11] * s,
            m[12] * s, m[13] * s, m[14] * s, m[15] * s
        ]);
    };
    /**
     * Returns a corrected matrix based on the passed one, which has orthogonal unit
     * vectors as its rows. Suitable for correcting minor distortions of originally
     * orthogonal matrices, which naturally occur after series of transformations
     * due to float inaccuracy .
     * @param {Float32Array} m The original (distorted) 4x4 matrix.
     * @returns {Float32Array} An orthogonal 4x4 matrix.
     */
    mat.correctedOrthogonal4 = function (m) {
        var
                vx = vec.normalize3([m[0], m[1], m[2]]),
                vy = vec.normalize3([m[4], m[5], m[6]]),
                vz = vec.cross3(vx, vy);
        vy = vec.cross3(vz, vx);
        _matrixCount++;
        return new Float32Array([
            vx[0], vx[1], vx[2], 0.0,
            vy[0], vy[1], vy[2], 0.0,
            vz[0], vz[1], vz[2], 0.0,
            0.0, 0.0, 0.0, 1.0]);
    };
    /**
     * Returns a "straigthened" version of the passed matrix, wich means every value
     * within the matrix that is at least epsilon-close to -1, 0 or 1 will be changed
     * to -1, 0 or 1 respectively. Works with both 3x3 and 4x4 matrices.
     * @param {Float32Array} m The input matrix.
     * @param {Number} epsilon The difference threshold within the matrix components
     * will be corrected.
     * @returns {Float32Array}
     */
    mat.straightened = function (m, epsilon) {
        _matrixCount++;
        var i, result = new Float32Array(m);
        for (i = 0; i < result.length; i++) {
            result[i] = (Math.abs(m[i]) < epsilon) ?
                    0.0 :
                    ((Math.abs(1 - m[i]) < epsilon) ?
                            1.0 :
                            ((Math.abs(-1 - m[i]) < epsilon) ?
                                    -1.0 : m[i]));
        }
        return result;
    };
// -----------------------------------------------------------------------------
// Functions and operations with two matrices
    /**
     * Returns whether the passed two 4x4 matrices are equal.
     * @param {Float32Array} m1 The first 4x4 matrix.
     * @param {Float32Array} m2 The second 4x4 matrix.
     * @returns {Boolean}
     */
    mat.equal4 = function (m1, m2) {
        return (
                m1[0] === m2[0] &&
                m1[1] === m2[1] &&
                m1[2] === m2[2] &&
                m1[3] === m2[3] &&
                m1[4] === m2[4] &&
                m1[5] === m2[5] &&
                m1[6] === m2[6] &&
                m1[7] === m2[7] &&
                m1[8] === m2[8] &&
                m1[9] === m2[9] &&
                m1[10] === m2[10] &&
                m1[11] === m2[11] &&
                m1[12] === m2[12] &&
                m1[13] === m2[13] &&
                m1[14] === m2[14] &&
                m1[15] === m2[15]
                );
    };
    /**
     * Returns the sum of two 4x4 matrices.
     * @param {Float32Array} m1 The first 4x4 matrix.
     * @param {Float32Array} m2 The second 4x4 matrix.
     * @returns {Float32Array} The result 4x4 matrix.
     */
    mat.sum4 = function (m1, m2) {
        _matrixCount++;
        return new Float32Array([
            m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3],
            m1[4] + m2[4], m1[5] + m2[5], m1[6] + m2[6], m1[7] + m2[7],
            m1[8] + m2[8], m1[9] + m2[9], m1[10] + m2[10], m1[11] + m2[11],
            m1[12] + m2[12], m1[13] + m2[13], m1[14] + m2[14], m1[15] + m2[15]
        ]);
    };
    /**
     * Multiplies two 3x3 matrices and returns the result.
     * @param {Float32Array} m1 The 3x3 matrix on the left of the multiplicaton.
     * @param {Float32Array} m2 The 3x3 matrix on the right of the multiplicaton.
     * @returns {Float32Array} The result 3x3 matrix.
     */
    mat.prod3 = function (m1, m2) {
        _matrixCount++;
        return new Float32Array([
            m1[0] * m2[0] + m1[1] * m2[3] + m1[2] * m2[6],
            m1[0] * m2[1] + m1[1] * m2[4] + m1[2] * m2[7],
            m1[0] * m2[2] + m1[1] * m2[5] + m1[2] * m2[8],
            m1[3] * m2[0] + m1[4] * m2[3] + m1[5] * m2[6],
            m1[3] * m2[1] + m1[4] * m2[4] + m1[5] * m2[7],
            m1[3] * m2[2] + m1[4] * m2[5] + m1[5] * m2[8],
            m1[6] * m2[0] + m1[7] * m2[3] + m1[8] * m2[6],
            m1[6] * m2[1] + m1[7] * m2[4] + m1[8] * m2[7],
            m1[6] * m2[2] + m1[7] * m2[5] + m1[8] * m2[8]
        ]);
    };
    /**
     * Multiplies two 4x4 matrices and returns the result.
     * @param {Float32Array} m1 The 4x4 matrix on the left of the multiplicaton.
     * @param {Float32Array} m2 The 4x4 matrix on the right of the multiplicaton.
     * @returns {Float32Array} The result 4x4 matrix.
     */
    mat.prod4 = function (m1, m2) {
        _matrixCount++;
        return new Float32Array([
            m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8] + m1[3] * m2[12],
            m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9] + m1[3] * m2[13],
            m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10] + m1[3] * m2[14],
            m1[0] * m2[3] + m1[1] * m2[7] + m1[2] * m2[11] + m1[3] * m2[15],
            m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8] + m1[7] * m2[12],
            m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9] + m1[7] * m2[13],
            m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10] + m1[7] * m2[14],
            m1[4] * m2[3] + m1[5] * m2[7] + m1[6] * m2[11] + m1[7] * m2[15],
            m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8] + m1[11] * m2[12],
            m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9] + m1[11] * m2[13],
            m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10] + m1[11] * m2[14],
            m1[8] * m2[3] + m1[9] * m2[7] + m1[10] * m2[11] + m1[11] * m2[15],
            m1[12] * m2[0] + m1[13] * m2[4] + m1[14] * m2[8] + m1[15] * m2[12],
            m1[12] * m2[1] + m1[13] * m2[5] + m1[14] * m2[9] + m1[15] * m2[13],
            m1[12] * m2[2] + m1[13] * m2[6] + m1[14] * m2[10] + m1[15] * m2[14],
            m1[12] * m2[3] + m1[13] * m2[7] + m1[14] * m2[11] + m1[15] * m2[15]
        ]);
    };
    /**
     * Multiplies two 4x4 matrices and returns the result.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m1 The left matrix.
     * @param {Float32Array} m2 The right matrix.
     * @returns {Float32Array} A 4x4 matrix. (one of the auxiliary matrices!)
     */
    mat.prod4Aux = function (m1, m2) {
        var aux = _auxMatrices[_auxMatrixIndex];
        mat.setProd4(aux, m1, m2);
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Multiplies the upper left 3x3 submatrices of two 4x4 matrices and returns the result.
     * @param {Float32Array} m1 The 4x4 matrix on the left of the multiplicaton.
     * @param {Float32Array} m2 The 4x4 matrix on the right of the multiplicaton.
     * @returns {Float32Array} A 3x3 matrix.
     */
    mat.prod3x3SubOf43 = function (m1, m2) {
        _matrixCount++;
        return new Float32Array([
            m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8],
            m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9],
            m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10],
            m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8],
            m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9],
            m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10],
            m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8],
            m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9],
            m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10]
        ]);
    };
    /**
     * Multiplies the upper left 3x3 submatrices of two 4x4 matrices and returns the result padded to a 4x4 matrix.
     * @param {Float32Array} m1 The 4x4 matrix on the left of the multiplicaton.
     * @param {Float32Array} m2 The 4x4 matrix on the right of the multiplicaton.
     * @returns {Float32Array} A 4x4 matrix.
     */
    mat.prod3x3SubOf4 = function (m1, m2) {
        _matrixCount++;
        return new Float32Array([
            m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8],
            m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9],
            m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10],
            0,
            m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8],
            m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9],
            m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10],
            0,
            m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8],
            m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9],
            m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10],
            0,
            0, 0, 0, 1
        ]);
    };
    /**
     * Multiplies the upper left 3x3 submatrices of two 4x4 matrices and returns the result padded to a 4x4 matrix.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m1 The 4x4 matrix on the left of the multiplicaton.
     * @param {Float32Array} m2 The 4x4 matrix on the right of the multiplicaton.
     * @returns {Float32Array} A 4x4 matrix. (one of the auxiliary matrices!)
     */
    mat.prod3x3SubOf4Aux = function (m1, m2) {
        var aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8];
        aux[1] = m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9];
        aux[2] = m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10];
        aux[3] = 0;
        aux[4] = m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8];
        aux[5] = m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9];
        aux[6] = m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10];
        aux[7] = 0;
        aux[8] = m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8];
        aux[9] = m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9];
        aux[10] = m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10];
        aux[11] = 0;
        aux[12] = 0;
        aux[13] = 0;
        aux[14] = 0;
        aux[15] = 1;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Multiplies a 4x4 scaling matrix with a 4x4 rotation matrix.
     * @param {Float32Array} sm The 4x4 scaling matrix on the left of the multiplicaton.
     * @param {Float32Array} rm The 4x4 rotation matrix on the right of the multiplicaton.
     * @returns {Float32Array} A 4x4 matrix.
     */
    mat.prodScalingRotation = function (sm, rm) {
        _matrixCount++;
        return new Float32Array([
            sm[0] * rm[0],
            sm[0] * rm[1],
            sm[0] * rm[2],
            0,
            sm[5] * rm[4],
            sm[5] * rm[5],
            sm[5] * rm[6],
            0,
            sm[10] * rm[8],
            sm[10] * rm[9],
            sm[10] * rm[10],
            0,
            0, 0, 0, 1
        ]);
    };
    /**
     * Multiplies a 4x4 scaling matrix with a 4x4 rotation matrix.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} sm The 4x4 scaling matrix on the left of the multiplicaton.
     * @param {Float32Array} rm The 4x4 rotation matrix on the right of the multiplicaton.
     * @returns {Float32Array} A 4x4 matrix. (one of the auxiliary matrices!)
     */
    mat.prodScalingRotationAux = function (sm, rm) {
        var aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = sm[0] * rm[0];
        aux[1] = sm[0] * rm[1];
        aux[2] = sm[0] * rm[2];
        aux[3] = 0;
        aux[4] = sm[5] * rm[4];
        aux[5] = sm[5] * rm[5];
        aux[6] = sm[5] * rm[6];
        aux[7] = 0;
        aux[8] = sm[10] * rm[8];
        aux[9] = sm[10] * rm[9];
        aux[10] = sm[10] * rm[10];
        aux[11] = 0;
        aux[12] = 0;
        aux[13] = 0;
        aux[14] = 0;
        aux[15] = 1;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Multiplies a 4x4 scaling matrix with a 4x4 rotation matrix and returns the upper left 3x3 submatrix of the result.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} sm The 4x4 scaling matrix on the left of the multiplicaton.
     * @param {Float32Array} rm The 4x4 rotation matrix on the right of the multiplicaton.
     * @returns {Float32Array} A 3x3 matrix. (one of the auxiliary matrices!)
     */
    mat.prodScalingRotation3Aux = function (sm, rm) {
        var aux = _auxMatrices3[_auxMatrix3Index];
        aux[0] = sm[0] * rm[0];
        aux[1] = sm[0] * rm[1];
        aux[2] = sm[0] * rm[2];
        aux[3] = sm[5] * rm[4];
        aux[4] = sm[5] * rm[5];
        aux[5] = sm[5] * rm[6];
        aux[6] = sm[10] * rm[8];
        aux[7] = sm[10] * rm[9];
        aux[8] = sm[10] * rm[10];
        _auxMatrix3Index = (_auxMatrix3Index + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Multiplies the upper left 3x3 submatrix of the 4x4 matrix with the 3x3 matrix and returns the result padded to a 4x4 matrix.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m4 The 4x4 matrix on the left of the multiplicaton.
     * @param {Float32Array} m3 The 3x3 matrix on the right of the multiplicaton.
     * @returns {Float32Array} A 4x4 matrix. (one of the auxiliary matrices!)
     */
    mat.prod3x3SubOf43Aux = function (m4, m3) {
        var aux = _auxMatrices[_auxMatrixIndex];
        aux[0] = m4[0] * m3[0] + m4[1] * m3[3] + m4[2] * m3[6];
        aux[1] = m4[0] * m3[1] + m4[1] * m3[4] + m4[2] * m3[7];
        aux[2] = m4[0] * m3[2] + m4[1] * m3[5] + m4[2] * m3[8];
        aux[3] = 0;
        aux[4] = m4[4] * m3[0] + m4[5] * m3[3] + m4[6] * m3[6];
        aux[5] = m4[4] * m3[1] + m4[5] * m3[4] + m4[6] * m3[7];
        aux[6] = m4[4] * m3[2] + m4[5] * m3[5] + m4[6] * m3[8];
        aux[7] = 0;
        aux[8] = m4[8] * m3[0] + m4[9] * m3[3] + m4[10] * m3[6];
        aux[9] = m4[8] * m3[1] + m4[9] * m3[4] + m4[10] * m3[7];
        aux[10] = m4[8] * m3[2] + m4[9] * m3[5] + m4[10] * m3[8];
        aux[11] = 0;
        aux[12] = 0;
        aux[13] = 0;
        aux[14] = 0;
        aux[15] = 1;
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Performs an optimized multiplication of two matrices using the assumption that the left matrix is a translation matrix and the right
     * matrix if a rotation (or scaled rotation, but without projection or translation) matrix.
     * @param {Float32Array} t A 4x4 translation matrix, without rotation, scaling or projection.
     * @param {Float32Array} r A 4x4 rotation or scaling and rotation matrix, without translation or projection.
     * @returns {Float32Array} The product of the two matrices.
     */
    mat.prodTranslationRotation4 = function (t, r) {
        _matrixCount++;
        return new Float32Array([
            r[0], r[1], r[2], 0,
            r[4], r[5], r[6], 0,
            r[8], r[9], r[10], 0,
            r[0] * t[12] + r[4] * t[13] + r[8] * t[14],
            r[1] * t[12] + r[5] * t[13] + r[9] * t[14],
            r[2] * t[12] + r[6] * t[13] + r[10] * t[14],
            1
        ]);
    };
    /**
     * Performs an optimized multiplication of two matrices using the assumption that the left matrix is a translation matrix and the right
     * matrix if a rotation (or scaled rotation, but without projection or translation) matrix.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} t A 4x4 translation matrix, without rotation, scaling or projection.
     * @param {Float32Array} r A 4x4 rotation or scaling and rotation matrix, without translation or projection.
     * @returns {Float32Array} The product of the two matrices.
     */
    mat.prodTranslationRotation4Aux = function (t, r) {
        var aux = _auxMatrices[_auxMatrixIndex];
        mat.setProdTranslationRotation4(aux, t, r);
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Multiplies three 4x4 matrices and returns the result.
     * @param {Float32Array} m1 The first (leftmost) 4x4 matrix
     * @param {Float32Array} m2 The second (middle) 4x4 matrix
     * @param {Float32Array} m3 The third (rightmost) 4x4 matrix
     * @returns {Float32Array}
     */
    mat.prod34 = function (m1, m2, m3) {
        var result = mat.prod4(m1, m2);
        mat.mul4(result, m3);
        return result;
    };
    /**
     * Multiplies three 4x4 matrices and returns the result.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m1 The first (leftmost) 4x4 matrix
     * @param {Float32Array} m2 The second (middle) 4x4 matrix
     * @param {Float32Array} m3 The third (rightmost) 4x4 matrix
     * @returns {Float32Array}
     */
    mat.prod34Aux = function (m1, m2, m3) {
        var result = mat.prod4Aux(m1, m2);
        mat.mul4(result, m3);
        return result;
    };
    /**
     * Returns a 4x4 transformation matrix, which is the result of translating m by the translation vector v.
     * @param {Float32Array} m A 4x4 transformation matrix.
     * @param {Float32Array} v A 3D vector
     * @returns {Float32Array}
     */
    mat.translatedByVector = function (m, v) {
        _matrixCount++;
        return new Float32Array([
            m[0], m[1], m[2], m[3],
            m[4], m[5], m[6], m[7],
            m[8], m[9], m[10], m[11],
            m[12] + v[0], m[13] + v[1], m[14] + v[2], m[15]
        ]);
    };
    /**
     * Returns a 4x4 transformation matrix, which is the result of translating m by the translation vector v.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m A 4x4 transformation matrix.
     * @param {Float32Array} v A 3D vector
     * @returns {Float32Array}
     */
    mat.translatedByVectorAux = function (m, v) {
        var aux = _auxMatrices[_auxMatrixIndex];
        mat.setTranslatedByVector(aux, m, v);
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns a 4x4 transformation matrix, which is the result of translating m1
     * by the translation described by m2.
     * @param {Float32Array} m1 A 4x4 transformation matrix.
     * @param {Float32Array} m2 A 4x4 transformation matrix. Only the translation
     * described in this matrix will be taken into account.
     * @returns {Float32Array}
     */
    mat.translatedByM4 = function (m1, m2) {
        _matrixCount++;
        return new Float32Array([
            m1[0], m1[1], m1[2], m1[3],
            m1[4], m1[5], m1[6], m1[7],
            m1[8], m1[9], m1[10], m1[11],
            m1[12] + m2[12], m1[13] + m2[13], m1[14] + m2[14], m1[15]
        ]);
    };
    /**
     * Returns a 4x4 transformation matrix, which is the result of translating m1 by the translation described by m2.
     * Uses one of the auxiliary matrices instead of creating a new one - use when the result is needed only temporarily!
     * @param {Float32Array} m1 A 4x4 transformation matrix.
     * @param {Float32Array} m2 A 4x4 transformation matrix. Only the translation described in this matrix will be taken into account.
     * @returns {Float32Array}
     */
    mat.translatedByM4Aux = function (m1, m2) {
        var aux = _auxMatrices[_auxMatrixIndex];
        mat.setTranslatedByM4(aux, m1, m2);
        _auxMatrixIndex = (_auxMatrixIndex + 1) % AUX_MATRIX_COUNT;
        return aux;
    };
    /**
     * Returns the square of the distance between the translations described by the
     * two given 4x4 transformation matrices. Transformations other than translations
     * are ignored.
     * @param {Float32Array} m1 A 4x4 transformation matrix.
     * @param {Float32Array} m2 Another 4x4 transformation matrix.
     * @returns {Number}
     */
    mat.distanceSquared = function (m1, m2) {
        return (
                (m1[12] - m2[12]) * (m1[12] - m2[12]) +
                (m1[13] - m2[13]) * (m1[13] - m2[13]) +
                (m1[14] - m2[14]) * (m1[14] - m2[14])
                );
    };
    // -----------------------------------------------------------------------------
    // Functions that modify existing matrices
    /**
     * Modifies the passed 3x3 matrix, setting it to a null matrix.
     * @param {Float32Array} m A 3x3 matrix
     */
    mat.setNull3 = function (m) {
        m[0] = 0;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = 0;
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
    };
    /**
     * Modifies the passed 3x3 matrix, setting it to an identity matrix.
     * @param {Float32Array} m A 3x3 matrix
     */
    mat.setIdentity3 = function (m) {
        m[0] = 1;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 1;
        m[5] = 0;
        m[6] = 0;
        m[7] = 0;
        m[8] = 1;
    };
    /**
     * Sets the passed 4x4 matrix m to a 4x4 identity matrix.
     * @param {Float32Array} m
     */
    mat.setIdentity4 = function (m) {
        m[0] = 1;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = 1;
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
        m[9] = 0;
        m[10] = 1;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
    };
    /**
     * Sets the value of a 3x3 matrix to that of another 3x3 matrix, without creating a new
     * matrix or modifying the reference itself. (copies the value over instead)
     * @param {Float32Array} left The leftvalue, a 3x3 matrix
     * @param {Float32Array} right The rightvalue, a 3x3 matrix
     */
    mat.setMatrix3 = function (left, right) {
        var i;
        for (i = 0; i < 9; i++) {
            left[i] = right[i];
        }
    };
    /**
     * Sets the value of a 4x4 matrix to that of another 4x4 matrix, without creating a new
     * matrix or modifying the reference itself. (copies the value over instead)
     * @param {Float32Array} left The leftvalue, a 4x4 matrix
     * @param {Float32Array} right The rightvalue, a 4x4 matrix
     */
    mat.setMatrix4 = function (left, right) {
        var i;
        for (i = 0; i < 16; i++) {
            left[i] = right[i];
        }
    };
    /**
     * Copies the value of the right 4x4 translation matrix into the left 4x4 translation matrix
     * @param {Float32Array} left The leftvalue, a 4x4 translation matrix
     * @param {Float32Array} right The rightvalue, a 4x4 translation matrix
     */
    mat.copyTranslation4 = function (left, right) {
        left[12] = right[12];
        left[13] = right[13];
        left[14] = right[14];
    };
    /**
     * Copies the value of the right 4x4 scaling matrix into the left 4x4 scaling matrix
     * @param {Float32Array} left The leftvalue, a 4x4 scaling matrix
     * @param {Float32Array} right The rightvalue, a 4x4 scaling matrix
     */
    mat.copyScaling4 = function (left, right) {
        left[0] = right[0];
        left[5] = right[5];
        left[10] = right[10];
    };
    /**
     * Sets the components of a 4x4 matrix to correspond to a translation defined by the passed vector.
     * @param {Float32Array} m
     * @param {Number[3]} v The vector of the translation ([x,y,z]).
     * @returns {Float32Array}
     */
    mat.setTranslation4v = function (m, v) {
        m[0] = 1.0;
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;
        m[4] = 0.0;
        m[5] = 1.0;
        m[6] = 0.0;
        m[7] = 0.0;
        m[8] = 0.0;
        m[9] = 0.0;
        m[10] = 1.0;
        m[11] = 0.0;
        m[12] = v[0];
        m[13] = v[1];
        m[14] = v[2];
        m[15] = 1.0;
    };
    /**
     * Sets the components of a 4x4 translation matrix to correspond to a translation defined by the passed vector.
     * @param {Float32Array} m
     * @param {Number[3]} v The vector of the translation ([x,y,z]).
     * @returns {Float32Array}
     */
    mat.updateTranslation4v = function (m, v) {
        m[12] = v[0];
        m[13] = v[1];
        m[14] = v[2];
    };
    /**
     * Modifies a 2x2 transformation matrix to describe a rotation.
     * @param {Float32Array} m The 2x2 matrix to modify
     * @param {Number} angle The angle of rotation in radians
     */
    mat.setRotation2 = function (m, angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle);
        m[0] = cosAngle;
        m[1] = -sinAngle;
        m[2] = sinAngle;
        m[3] = cosAngle;
    };
    /**
     * Modifies the 3x3 matrix m in-place, setting it to a 3x3 rotation matrix.
     * @param {Float32Array} m The 3x3 matrix to modify
     * @param {Number[]} axis An array of 3 numbers describing the axis of the rotation
     * @param {Number} angle The angle of rotation in radian
     */
    mat.setRotation3 = function (m, axis, angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle);
        m[0] = cosAngle + (1 - cosAngle) * axis[0] * axis[0];
        m[1] = (1 - cosAngle) * axis[0] * axis[1] - sinAngle * axis[2];
        m[2] = (1 - cosAngle) * axis[0] * axis[2] + sinAngle * axis[1];
        m[3] = (1 - cosAngle) * axis[0] * axis[1] + sinAngle * axis[2];
        m[4] = cosAngle + (1 - cosAngle) * axis[1] * axis[1];
        m[5] = (1 - cosAngle) * axis[1] * axis[2] - sinAngle * axis[0];
        m[6] = (1 - cosAngle) * axis[0] * axis[2] - sinAngle * axis[1];
        m[7] = (1 - cosAngle) * axis[1] * axis[2] + sinAngle * axis[0];
        m[8] = cosAngle + (1 - cosAngle) * axis[2] * axis[2];
    };
    /**
     * Modifies the 4x4 matrix m in-place, setting it to a 4x4 rotation matrix.
     * @param {Float32Array} m The 4x4 matrix to modify
     * @param {Number[]} axis An array of 3 numbers describing the axis of the rotation
     * @param {Number} angle The angle of rotation in radian
     */
    mat.setRotation4 = function (m, axis, angle) {
        var
                cosAngle = Math.cos(angle),
                sinAngle = Math.sin(angle);
        m[0] = cosAngle + (1 - cosAngle) * axis[0] * axis[0];
        m[1] = (1 - cosAngle) * axis[0] * axis[1] - sinAngle * axis[2];
        m[2] = (1 - cosAngle) * axis[0] * axis[2] + sinAngle * axis[1];
        m[3] = 0.0;
        m[4] = (1 - cosAngle) * axis[0] * axis[1] + sinAngle * axis[2];
        m[5] = cosAngle + (1 - cosAngle) * axis[1] * axis[1];
        m[6] = (1 - cosAngle) * axis[1] * axis[2] - sinAngle * axis[0];
        m[7] = 0.0;
        m[8] = (1 - cosAngle) * axis[0] * axis[2] - sinAngle * axis[1];
        m[9] = (1 - cosAngle) * axis[1] * axis[2] + sinAngle * axis[0];
        m[10] = cosAngle + (1 - cosAngle) * axis[2] * axis[2];
        m[11] = 0.0;
        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 0.0;
        m[15] = 1.0;
    };
    /**
     * Modifies the matrix m in-place, setting it to a 4x4 transformation matrix describing a rotation around an arbitrary axis that goes 
     * through a given point.
     * @param {Float32Array} m
     * @param {Number[3]} p The axis of rotation passes through this point.
     * @param {Number[]} axis A 3D unit vector describing the direction of the axis.
     * @param {Number} angle The angle of rotation in radians
     * @returns {Float32Array}
     */
    mat.setRotationAroundPoint4 = function (m, p, axis, angle) {
        var p2;
        mat.setRotation4(m, axis, angle);
        p2 = vec.prodVec3Mat4Aux(p, m);
        m[12] = p[0] - p2[0];
        m[13] = p[1] - p2[1];
        m[14] = p[2] - p2[2];
    };
    /**
     * Modifies a 4x4 matrix, setting it so that its Z axis points towards the given direction and the Y axis is based on an optional second vector.
     * @param {Float32Array} m The 4x4 matrix to modify
     * @param {Number[3]} direction A 3D unit vector.
     * @param {Number[3]} [up] A 3D unit vector.
     */
    mat.setLookTowards4 = function (m, direction, up) {
        var right;
        up = up || [0, 1, 0];
        if (Math.abs(vec.dot3(up, direction)) > CLOSE_TO_ONE_THRESHOLD) {
            up = vec.perpendicular3(direction);
        }
        right = vec.cross3(up, direction);
        m[0] = right[0];
        m[1] = right[1];
        m[2] = right[2];
        up = vec.cross3(direction, right);
        m[4] = up[0];
        m[5] = up[1];
        m[6] = up[2];
        mat.correctOrthogonal4(m);
    };
    /**
     * Applies a translation to the passed 4x4 transformation matrix described by the passed
     * 3D vector.
     * @param {Float32Array} m A 4x4 matrix
     * @param {Number[3]} v A 3D vector
     */
    mat.translateByVector = function (m, v) {
        m[12] += v[0];
        m[13] += v[1];
        m[14] += v[2];
    };
    /**
     * Applies a translation to the passed 4x4 transformation matrix described by the second
     * passed transformation matrix, which is treated like a translation matrix (other parts
     * of the matrix are not considered)
     * @param {Float32Array} m A 4x4 matrix
     * @param {Float32Array} n A 4x4 translation matrix
     */
    mat.translateByMatrix = function (m, n) {
        m[12] += n[12];
        m[13] += n[13];
        m[14] += n[14];
    };
    /**
     * Applies a translation to the passed 4x4 transformation matrix described by the second
     * passed transformation matrix, which is treated like a translation matrix (other parts
     * of the matrix are not considered), multiplied by a scalar.
     * @param {Float32Array} m A 4x4 matrix
     * @param {Float32Array} n A 4x4 translation matrix
     * @param {Number} s The scalar to multiply with
     */
    mat.translateByMatrixMul = function (m, n, s) {
        m[12] += n[12] * s;
        m[13] += n[13] * s;
        m[14] += n[14] * s;
    };
    /**
     * Modifies the passed 4x4 transformation matrix m in-place to be rotated around the given axis by the given angle.
     * @param {Float32Array} m The matrix to modify
     * @param {Number[]} axis An array of 3 numbers describing the axis of the rotation
     * @param {Number} angle The angle of rotation in radian
     */
    mat.rotate4 = function (m, axis, angle) {
        var
                index = _getFreeTempMatrixIndex(),
                rot = _getTempMatrix(index);
        mat.setRotation3(rot, axis, angle);
        mat.mul43(m, rot);
        _releaseTempMatrix(index);
    };
    /**
     * Modifies the passed 4x4 transformation matrix m in-place to be rotated by the given angle around the given axis that goes through the 
     * given point.
     * @param {Float32Array} m
     * @param {Number[3]} p The axis of rotation passes through this point.
     * @param {Number[]} axis A 3D unit vector describing the direction of the axis.
     * @param {Number} angle The angle of rotation in radians
     * @returns {Float32Array}
     */
    mat.rotateAroundPoint4 = function (m, p, axis, angle) {
        var
                index = _getFreeTempMatrixIndex(),
                rot = _getTempMatrix(index);
        mat.setRotationAroundPoint4(rot, p, axis, angle);
        mat.mul4(m, rot);
        _releaseTempMatrix(index);
    };
    /**
     * Modifies the passed 3x3 transformation matrix m in-place to be the inverse of the passed 3x3 matrix im.
     * @param {Float32Array} m The 3x3 matrix to modify
     * @param {Float32Array} im The 3x3 matrix the inverse of which is sought
     */
    mat.setInverse3 = function (m, im) {
        var i, j, k, t, u, m2, swap, index = _getFreeTempMatrixIndex();
        m2 = _getTempMatrix(index);
        mat.setMatrix3(m2, im);
        // check by the determinant, if the matrix is invertible
        if (mat.determinant3(m2) === 0) {
            mat.setNull3(m);
            return;
        }
        // we will use Gauss-Jordan elimination, so an identity matrix will be augmented to
        // the right of the original matrix
        mat.setIdentity3(m);
        // calculate the inverse by Gaussian-Jordan elimination
        // first part: forward elimination
        // for each row...
        for (i = 0; i < 3; i++) {
            // first swap the row to have a non-zero element at the diagonal
            // position, if needed
            if (Math.abs(m2[i * 4]) <= 0.0001) {
                // first, find a non-zero element in the same (i) column
                j = i + 1;
                while (Math.abs(m2[j * 3 + i]) <= 0.0001) {
                    j++;
                }
                // when found it in row 'j' swap the 'i'th and 'j'th rows
                for (k = 0; k < 3; k++) {
                    swap = m2[i * 3 + k];
                    m2[i * 3 + k] = m2[j * 3 + k];
                    m2[j * 3 + k] = swap;
                    swap = m[i * 3 + k];
                    m[i * 3 + k] = m[j * 3 + k];
                    m[j * 3 + k] = swap;
                }
            }
            // divide all elements of the row by the value of the element in the
            // main diagonal (within that row), to make it equal one
            t = m2[i * 4];
            for (j = 0; j < 3; j++) {
                m2[i * 3 + j] = m2[i * 3 + j] / t;
                m[i * 3 + j] = m[i * 3 + j] / t;
            }
            // subtract the row from all rows below it, multiplied accordingly
            // to null out the elements below the main diagonal element
            for (j = i + 1; j < 3; j++) {
                u = m2[j * 3 + i] / m2[i * 4];
                for (k = 0; k < 3; k++) {
                    m2[j * 3 + k] = m2[j * 3 + k] - u * m2[i * 3 + k];
                    m[j * 3 + k] = m[j * 3 + k] - u * m[i * 3 + k];
                }
            }
        }
        // back-substitution phase: eliminate the upper part of the original
        // matrix - however, these final values hold no additional information
        // for the calculations, so the operations are only done on the right
        // matrix, which will hold the inverse in the end
        for (i = 2; i >= 1; i--) {
            for (j = i - 1; j >= 0; j--) {
                for (k = 0; k < 3; k++) {
                    m[j * 3 + k] = m[j * 3 + k] - m2[j * 3 + i] * m[i * 3 + k];
                }
            }
        }
        _releaseTempMatrix(index);
    };
    /**
     * Modifies the passed 4x4 transformation matrix m in-place to be the inverse of the passed 4x4 matrix im.
     * @param {Float32Array} m The 4x4 matrix to modify
     * @param {Float32Array} im The 4x4 matrix the inverse of which is sought
     */
    mat.setInverse4 = function (m, im) {
        var i, j, k, t, u, m2, swap, index = _getFreeTempMatrixIndex();
        m2 = _getTempMatrix(index);
        mat.setMatrix4(m2, im);
        // we will use Gauss-Jordan elimination, so an identity matrix will be augmented to
        // the right of the original matrix
        mat.setIdentity4(m);
        // we assume that the matrix is invertible (for efficiency, and since in all
        // uses cases it should be)
        // calculate the inverse by Gaussian-Jordan elimination
        // first part: forward elimination
        // for each row...
        for (i = 0; i < 4; i++) {
            // first swap the row to have a non-zero element at the diagonal
            // position, if needed
            if (Math.abs(m2[i * 5]) <= 0.0001) {
                // first, find a non-zero element in the same (i) column
                j = i + 1;
                while (Math.abs(m2[j * 4 + i]) <= 0.0001) {
                    j++;
                }
                // when found it in row 'j' swap the 'i'th and 'j'th rows
                for (k = 0; k < 4; k++) {
                    swap = m2[i * 4 + k];
                    m2[i * 4 + k] = m2[j * 4 + k];
                    m2[j * 4 + k] = swap;
                    swap = m[i * 4 + k];
                    m[i * 4 + k] = m[j * 4 + k];
                    m[j * 4 + k] = swap;
                }
            }
            // divide all elements of the row by the value of the element in the
            // main diagonal (within that row), to make it equal one
            t = m2[i * 5];
            for (j = 0; j < 4; j++) {
                m2[i * 4 + j] = m2[i * 4 + j] / t;
                m[i * 4 + j] = m[i * 4 + j] / t;
            }
            // subtract the row from all rows below it, multiplied accordingly
            // to null out the elements below the main diagonal element
            for (j = i + 1; j < 4; j++) {
                u = m2[j * 4 + i] / m2[i * 5];
                for (k = 0; k < 4; k++) {
                    m2[j * 4 + k] = m2[j * 4 + k] - u * m2[i * 4 + k];
                    m[j * 4 + k] = m[j * 4 + k] - u * m[i * 4 + k];
                }
            }
        }
        // back-substitution phase: eliminate the upper part of the original
        // matrix - however, these final values hold no additional information
        // for the calculations, so the operations are only done on the right
        // matrix, which will hold the inverse in the end
        for (i = 3; i >= 1; i--) {
            for (j = i - 1; j >= 0; j--) {
                for (k = 0; k < 4; k++) {
                    m[j * 4 + k] = m[j * 4 + k] - m2[j * 4 + i] * m[i * 4 + k];
                }
            }
        }
        _releaseTempMatrix(index);
    };
    /**
     * A computationally efficient function to set a 4x4 matrix to be the inverse of a 4x4 translation
     * matrix. (a transformation matrix that only holds translation information)
     * @param {Float32Array} m The 4x4 matrix to set
     * @param {Float32Array} tm The input 4x4 matrix.
     */
    mat.setInverseOfTranslation4 = function (m, tm) {
        m[0] = 1.0;
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;
        m[4] = 0.0;
        m[5] = 1.0;
        m[6] = 0.0;
        m[7] = 0.0;
        m[8] = 0.0;
        m[9] = 0.0;
        m[10] = 1.0;
        m[11] = 0.0;
        m[12] = -tm[12];
        m[13] = -tm[13];
        m[14] = -tm[14];
        m[15] = 1.0;
    };
    /**
     * Modifies the passed matrix in-place to be the transposed of the other passed 3x3 matrix
     * @param {Float32Array} m The 3x3 matrix to modify
     * @param {Float32Array} tm The 3x3 matrix to transpose
     */
    mat.setTransposed3 = function (m, tm) {
        m[0] = tm[0];
        m[1] = tm[3];
        m[2] = tm[6];
        m[3] = tm[1];
        m[4] = tm[4];
        m[5] = tm[7];
        m[6] = tm[2];
        m[7] = tm[5];
        m[8] = tm[8];
    };
    /**
     * Modifies the passed matrix in-place to be the transposed of the other passed 4x4 matrix
     * @param {Float32Array} m The 4x4 matrix to modify
     * @param {Float32Array} tm The 4x4 matrix to transpose
     */
    mat.setTransposed4 = function (m, tm) {
        m[0] = tm[0];
        m[1] = tm[4];
        m[2] = tm[8];
        m[3] = tm[12];
        m[4] = tm[1];
        m[5] = tm[5];
        m[6] = tm[9];
        m[7] = tm[13];
        m[8] = tm[2];
        m[9] = tm[6];
        m[10] = tm[10];
        m[11] = tm[14];
        m[12] = tm[3];
        m[13] = tm[7];
        m[14] = tm[11];
        m[15] = tm[15];
    };
    /**
     * Modifies the passed matrix in-place to be the the inverse of a 4x4 rotation matrix, using the fact that
     * it coincides with its transpose. It is the same as setTransposed4, but the different
     * name of the function can clarify the role of it when it is used.
     * @param {Float32Array} m The 4x4 matrix to modify
     * @param {Float32Array} tm The 4x4 matrix to invert
     */
    mat.setInverseOfRotation4 = mat.setTransposed4;
    /**
     * Modifies the passed matrix in-place to be the inverse of the other passed 4x4 scaling matrix
     * @param {Float32Array} m The 4x4 matrix to modify
     * @param {Float32Array} im The 4x4 matrix to invert, must be a scaling matrix
     */
    mat.setInverseOfScaling4 = function (m, im) {
        m[0] = 1 / im[0];
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = 1 / im[5];
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
        m[9] = 0;
        m[10] = 1 / im[10];
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
    };
    /**
     * Multiples the given 3x3 matrix m1 in place by the 3x3 matrix m2 from the right.
     * @param {Float32Array} m1
     * @param {Float32Array} m2
     */
    mat.mul3 = function (m1, m2) {
        var
                index = _getFreeTempMatrixIndex(),
                mt = _getTempMatrix(index);
        mat.setMatrix3(mt, m1);
        m1[0] = mt[0] * m2[0] + mt[1] * m2[3] + mt[2] * m2[6];
        m1[1] = mt[0] * m2[1] + mt[1] * m2[4] + mt[2] * m2[7];
        m1[2] = mt[0] * m2[2] + mt[1] * m2[5] + mt[2] * m2[8];
        m1[3] = mt[3] * m2[0] + mt[4] * m2[3] + mt[5] * m2[6];
        m1[4] = mt[3] * m2[1] + mt[4] * m2[4] + mt[5] * m2[7];
        m1[5] = mt[3] * m2[2] + mt[4] * m2[5] + mt[5] * m2[8];
        m1[6] = mt[6] * m2[0] + mt[7] * m2[3] + mt[8] * m2[6];
        m1[7] = mt[6] * m2[1] + mt[7] * m2[4] + mt[8] * m2[7];
        m1[8] = mt[6] * m2[2] + mt[7] * m2[5] + mt[8] * m2[8];
        _releaseTempMatrix(index);
    };
    /**
     * Multiples the given 4x4 matrix m1 in place by the 4x4 matrix m2 from the right.
     * @param {Float32Array} m1
     * @param {Float32Array} m2
     */
    mat.mul4 = function (m1, m2) {
        var
                index = _getFreeTempMatrixIndex(),
                m3 = _getTempMatrix(index);
        mat.setMatrix4(m3, m1);
        m1[0] = m3[0] * m2[0] + m3[1] * m2[4] + m3[2] * m2[8] + m3[3] * m2[12];
        m1[1] = m3[0] * m2[1] + m3[1] * m2[5] + m3[2] * m2[9] + m3[3] * m2[13];
        m1[2] = m3[0] * m2[2] + m3[1] * m2[6] + m3[2] * m2[10] + m3[3] * m2[14];
        m1[3] = m3[0] * m2[3] + m3[1] * m2[7] + m3[2] * m2[11] + m3[3] * m2[15];
        m1[4] = m3[4] * m2[0] + m3[5] * m2[4] + m3[6] * m2[8] + m3[7] * m2[12];
        m1[5] = m3[4] * m2[1] + m3[5] * m2[5] + m3[6] * m2[9] + m3[7] * m2[13];
        m1[6] = m3[4] * m2[2] + m3[5] * m2[6] + m3[6] * m2[10] + m3[7] * m2[14];
        m1[7] = m3[4] * m2[3] + m3[5] * m2[7] + m3[6] * m2[11] + m3[7] * m2[15];
        m1[8] = m3[8] * m2[0] + m3[9] * m2[4] + m3[10] * m2[8] + m3[11] * m2[12];
        m1[9] = m3[8] * m2[1] + m3[9] * m2[5] + m3[10] * m2[9] + m3[11] * m2[13];
        m1[10] = m3[8] * m2[2] + m3[9] * m2[6] + m3[10] * m2[10] + m3[11] * m2[14];
        m1[11] = m3[8] * m2[3] + m3[9] * m2[7] + m3[10] * m2[11] + m3[11] * m2[15];
        m1[12] = m3[12] * m2[0] + m3[13] * m2[4] + m3[14] * m2[8] + m3[15] * m2[12];
        m1[13] = m3[12] * m2[1] + m3[13] * m2[5] + m3[14] * m2[9] + m3[15] * m2[13];
        m1[14] = m3[12] * m2[2] + m3[13] * m2[6] + m3[14] * m2[10] + m3[15] * m2[14];
        m1[15] = m3[12] * m2[3] + m3[13] * m2[7] + m3[14] * m2[11] + m3[15] * m2[15];
        _releaseTempMatrix(index);
    };
    /**
     * Multiples the given 4x4 matrix mm in place by the 4x4 perspective 
     * projection matrix pm from the right.
     * @param {Float32Array} m Any 4x4 transformation matrix
     * @param {Float32Array} pm A 4x4 perspective projection matrix (perspective along Z)
     */
    mat.mul4Proj = function (m, pm) {
        var
                index = _getFreeTempMatrixIndex(),
                tm = _getTempMatrix(index);
        mat.setMatrix4(tm, m);
        m[0] = tm[0] * pm[0];
        m[1] = tm[1] * pm[5];
        m[2] = tm[2] * pm[10] + tm[3] * pm[14];
        m[3] = -tm[2];
        m[4] = tm[4] * pm[0];
        m[5] = tm[5] * pm[5];
        m[6] = tm[6] * pm[10] + tm[7] * pm[14];
        m[7] = -tm[6];
        m[8] = tm[8] * pm[0];
        m[9] = tm[9] * pm[5];
        m[10] = tm[10] * pm[10] + tm[11] * pm[14];
        m[11] = -tm[10];
        m[12] = tm[12] * pm[0];
        m[13] = tm[13] * pm[5];
        m[14] = tm[14] * pm[10] + tm[15] * pm[14];
        m[15] = -tm[14];
        _releaseTempMatrix(index);
    };
    /**
     * Modifies the passed 4x4 matrix is place, multiplying it with the passed 3x3 matrix
     * padded to a 4x4 matrix (complemented as an identity matrix, with a 0,0,0,1 last row/column)
     * @param {Float32Array} m4 A 4x4 matrix
     * @param {Float32Array} m3 A 3x3 matrix
     */
    mat.mul43 = function (m4, m3) {
        var
                index = _getFreeTempMatrixIndex(),
                mt = _getTempMatrix(index);
        mat.setMatrix4(mt, m4);
        m4[0] = mt[0] * m3[0] + mt[1] * m3[3] + mt[2] * m3[6];
        m4[1] = mt[0] * m3[1] + mt[1] * m3[4] + mt[2] * m3[7];
        m4[2] = mt[0] * m3[2] + mt[1] * m3[5] + mt[2] * m3[8];
        m4[4] = mt[4] * m3[0] + mt[5] * m3[3] + mt[6] * m3[6];
        m4[5] = mt[4] * m3[1] + mt[5] * m3[4] + mt[6] * m3[7];
        m4[6] = mt[4] * m3[2] + mt[5] * m3[5] + mt[6] * m3[8];
        m4[8] = mt[8] * m3[0] + mt[9] * m3[3] + mt[10] * m3[6];
        m4[9] = mt[8] * m3[1] + mt[9] * m3[4] + mt[10] * m3[7];
        m4[10] = mt[8] * m3[2] + mt[9] * m3[5] + mt[10] * m3[8];
        m4[12] = mt[12] * m3[0] + mt[13] * m3[3] + mt[14] * m3[6];
        m4[13] = mt[12] * m3[1] + mt[13] * m3[4] + mt[14] * m3[7];
        m4[14] = mt[12] * m3[2] + mt[13] * m3[5] + mt[14] * m3[8];
        _releaseTempMatrix(index);
    };
    /**
     * Modifies the passed 4x4 rotation matrix is place, multiplying it with the passed 3x3 matrix
     * padded to a 4x4 matrix (complemented as an identity matrix, with a 0,0,0,1 last row/column)
     * @param {Float32Array} m4 A 4x4 rotation matrix
     * @param {Float32Array} m3 A 3x3 matrix
     */
    mat.mulRotation43 = function (m4, m3) {
        var
                index = _getFreeTempMatrixIndex(),
                mt = _getTempMatrix(index);
        mat.setMatrix4(mt, m4);
        m4[0] = mt[0] * m3[0] + mt[1] * m3[3] + mt[2] * m3[6];
        m4[1] = mt[0] * m3[1] + mt[1] * m3[4] + mt[2] * m3[7];
        m4[2] = mt[0] * m3[2] + mt[1] * m3[5] + mt[2] * m3[8];
        m4[4] = mt[4] * m3[0] + mt[5] * m3[3] + mt[6] * m3[6];
        m4[5] = mt[4] * m3[1] + mt[5] * m3[4] + mt[6] * m3[7];
        m4[6] = mt[4] * m3[2] + mt[5] * m3[5] + mt[6] * m3[8];
        m4[8] = mt[8] * m3[0] + mt[9] * m3[3] + mt[10] * m3[6];
        m4[9] = mt[8] * m3[1] + mt[9] * m3[4] + mt[10] * m3[7];
        m4[10] = mt[8] * m3[2] + mt[9] * m3[5] + mt[10] * m3[8];
        _releaseTempMatrix(index);
    };
    /**
     * Multiples the given 4x4 rotation matrix m1 in place by the 4x4 rotation matrix m2 from the right.
     * @param {Float32Array} m1
     * @param {Float32Array} m2
     */
    mat.mulRotationRotation4 = function (m1, m2) {
        var
                index = _getFreeTempMatrixIndex(),
                m3 = _getTempMatrix(index);
        mat.setMatrix4(m3, m1);
        m1[0] = m3[0] * m2[0] + m3[1] * m2[4] + m3[2] * m2[8];
        m1[1] = m3[0] * m2[1] + m3[1] * m2[5] + m3[2] * m2[9];
        m1[2] = m3[0] * m2[2] + m3[1] * m2[6] + m3[2] * m2[10];
        m1[4] = m3[4] * m2[0] + m3[5] * m2[4] + m3[6] * m2[8];
        m1[5] = m3[4] * m2[1] + m3[5] * m2[5] + m3[6] * m2[9];
        m1[6] = m3[4] * m2[2] + m3[5] * m2[6] + m3[6] * m2[10];
        m1[8] = m3[8] * m2[0] + m3[9] * m2[4] + m3[10] * m2[8];
        m1[9] = m3[8] * m2[1] + m3[9] * m2[5] + m3[10] * m2[9];
        m1[10] = m3[8] * m2[2] + m3[9] * m2[6] + m3[10] * m2[10];
        _releaseTempMatrix(index);
    };
    /**
     * Sets a passed 4x4 matrix to be equal with the product of two other 4x4 matrices
     * @param {Float32Array} m The 4x4 matrix to modify.
     * @param {Float32Array} m1 The 4x4 matrix on the left of the multiplicaton.
     * @param {Float32Array} m2 The 4x4 matrix on the right of the multiplicaton.
     */
    mat.setProd4 = function (m, m1, m2) {
        m[0] = m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8] + m1[3] * m2[12];
        m[1] = m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9] + m1[3] * m2[13];
        m[2] = m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10] + m1[3] * m2[14];
        m[3] = m1[0] * m2[3] + m1[1] * m2[7] + m1[2] * m2[11] + m1[3] * m2[15];
        m[4] = m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8] + m1[7] * m2[12];
        m[5] = m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9] + m1[7] * m2[13];
        m[6] = m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10] + m1[7] * m2[14];
        m[7] = m1[4] * m2[3] + m1[5] * m2[7] + m1[6] * m2[11] + m1[7] * m2[15];
        m[8] = m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8] + m1[11] * m2[12];
        m[9] = m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9] + m1[11] * m2[13];
        m[10] = m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10] + m1[11] * m2[14];
        m[11] = m1[8] * m2[3] + m1[9] * m2[7] + m1[10] * m2[11] + m1[11] * m2[15];
        m[12] = m1[12] * m2[0] + m1[13] * m2[4] + m1[14] * m2[8] + m1[15] * m2[12];
        m[13] = m1[12] * m2[1] + m1[13] * m2[5] + m1[14] * m2[9] + m1[15] * m2[13];
        m[14] = m1[12] * m2[2] + m1[13] * m2[6] + m1[14] * m2[10] + m1[15] * m2[14];
        m[15] = m1[12] * m2[3] + m1[13] * m2[7] + m1[14] * m2[11] + m1[15] * m2[15];
    };
    /**
     * Sets a passed 4x4 matrix to be equal with the product of two other 4x4 matrices, assuming
     * that the 4th rows and columns are all (0, 0, 0, 1)
     * @param {Float32Array} m The 4x4 matrix to modify.
     * @param {Float32Array} m1 The 4x4 matrix on the left of the multiplicaton.
     * @param {Float32Array} m2 The 4x4 matrix on the right of the multiplicaton.
     */
    mat.setProd4NoProj = function (m, m1, m2) {
        m[0] = m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8];
        m[1] = m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9];
        m[2] = m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10];
        m[4] = m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8];
        m[5] = m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9];
        m[6] = m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10];
        m[8] = m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8];
        m[9] = m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9];
        m[10] = m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10];
        m[12] = m1[12] * m2[0] + m1[13] * m2[4] + m1[14] * m2[8] + m2[12];
        m[13] = m1[12] * m2[1] + m1[13] * m2[5] + m1[14] * m2[9] + m2[13];
        m[14] = m1[12] * m2[2] + m1[13] * m2[6] + m1[14] * m2[10] + m2[14];
    };
    /**
     * Modifies a 4x4 matrix in-place to be equal to the product of the upper left 3x3 submatrices of two 4x4 matrices padded to a 4x4 matrix.
     * @param {Float32Array} m The 4x4 matrix to modify
     * @param {Float32Array} m1 The 4x4 matrix on the left of the multiplicaton.
     * @param {Float32Array} m2 The 4x4 matrix on the right of the multiplicaton.
     */
    mat.setProd3x3SubOf4 = function (m, m1, m2) {
        m[0] = m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8];
        m[1] = m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9];
        m[2] = m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10];
        m[3] = 0;
        m[4] = m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8];
        m[5] = m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9];
        m[6] = m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10];
        m[7] = 0;
        m[8] = m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8];
        m[9] = m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9];
        m[10] = m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10];
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
    };
    /**
     * Modifies a 4x4 scaling matrix in-place to be equal to the product of two 4x4 sacling matrices.
     * @param {Float32Array} m The 4x4 scaling matrix to modify
     * @param {Float32Array} m1 The 4x4 scaling matrix on the left of the multiplicaton.
     * @param {Float32Array} m2 The 4x4 scaling matrix on the right of the multiplicaton.
     */
    mat.setScalingToProdScalingScaling4 = function (m, m1, m2) {
        m[0] = m1[0] * m2[0];
        m[5] = m1[5] * m2[5];
        m[10] = m1[10] * m2[10];
    };
    /**
     * Performs an optimized multiplication of two matrices using the assumption that the left matrix is a translation matrix and the right
     * matrix if a rotation (or scaled rotation, but without projection or translation) matrix and sets a passed matrix to be equal to the
     * result.
     * @param {Float32Array} m The 4x4 matrix to set
     * @param {Float32Array} t A 4x4 translation matrix, without rotation, scaling or projection.
     * @param {Float32Array} r A 4x4 rotation or scaling and rotation matrix, without translation or projection.
     */
    mat.setProdTranslationRotation4 = function (m, t, r) {
        m[0] = r[0];
        m[1] = r[1];
        m[2] = r[2];
        m[3] = 0;
        m[4] = r[4];
        m[5] = r[5];
        m[6] = r[6];
        m[7] = 0;
        m[8] = r[8];
        m[9] = r[9];
        m[10] = r[10];
        m[11] = 0;
        m[12] = r[0] * t[12] + r[4] * t[13] + r[8] * t[14];
        m[13] = r[1] * t[12] + r[5] * t[13] + r[9] * t[14];
        m[14] = r[2] * t[12] + r[6] * t[13] + r[10] * t[14];
        m[15] = 1;
    };
    /**
     * Sets (updates) a model matrix based on the passed translation, rotation 
     * and scaling matrices.
     * @param {Float32Array} m The 4x4 model matrix to update
     * @param {Float32Array} t A 4x4 translation matrix
     * @param {Float32Array} r A 4x4 rotation matrix
     * @param {Float32Array} s A 4x4 scaling matrix
     */
    mat.setModelMatrix = function (m, t, r, s) {
        m[0] = s[0] * r[0];
        m[1] = s[0] * r[1];
        m[2] = s[0] * r[2];
        m[4] = s[5] * r[4];
        m[5] = s[5] * r[5];
        m[6] = s[5] * r[6];
        m[8] = s[10] * r[8];
        m[9] = s[10] * r[9];
        m[10] = s[10] * r[10];
        m[12] = t[12];
        m[13] = t[13];
        m[14] = t[14];
    };
    /**
     * Modifies a 4x4 transformation matrix, setting it to be equal to the result of translating m1 by the translation vector v
     * @param {Float32Array} m The 4x4 transformation matrix to modify
     * @param {Float32Array} m1 A 4x4 transformation matrix.
     * @param {Float32Array} v A 3D vector.
     */
    mat.setTranslatedByVector = function (m, m1, v) {
        m[0] = m1[0];
        m[1] = m1[1];
        m[2] = m1[2];
        m[3] = m1[3];
        m[4] = m1[4];
        m[5] = m1[5];
        m[6] = m1[6];
        m[7] = m1[7];
        m[8] = m1[8];
        m[9] = m1[9];
        m[10] = m1[10];
        m[11] = m1[11];
        m[12] = m1[12] + v[0];
        m[13] = m1[13] + v[1];
        m[14] = m1[14] + v[2];
        m[15] = m1[15];
    };
    /**
     * Modifies a 4x4 transformation matrix, setting it to be equal to the result of translating m1 by the translation described by m2.
     * @param {Float32Array} m The 4x4 transformation matrix to modify
     * @param {Float32Array} m1 A 4x4 transformation matrix.
     * @param {Float32Array} m2 A 4x4 transformation matrix. Only the translation described in this matrix will be taken into account.
     */
    mat.setTranslatedByM4 = function (m, m1, m2) {
        m[0] = m1[0];
        m[1] = m1[1];
        m[2] = m1[2];
        m[3] = m1[3];
        m[4] = m1[4];
        m[5] = m1[5];
        m[6] = m1[6];
        m[7] = m1[7];
        m[8] = m1[8];
        m[9] = m1[9];
        m[10] = m1[10];
        m[11] = m1[11];
        m[12] = m1[12] + m2[12];
        m[13] = m1[13] + m2[13];
        m[14] = m1[14] + m2[14];
        m[15] = m1[15];
    };
    /**
     * Modifies a 4x4 transformation matrix, setting it to describe perspective projection.
     * @param {Float32Array} m The matrix to modify
     * @param {Number} right
     * @param {Number} top
     * @param {Number} near
     * @param {Number} far
     */
    mat.setPerspective4 = function (m, right, top, near, far) {
        m[0] = near / right;
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;
        m[4] = 0.0;
        m[5] = near / top;
        m[6] = 0.0;
        m[7] = 0.0;
        m[8] = 0.0;
        m[9] = 0.0;
        m[10] = (near + far) / (near - far);
        m[11] = -1.0;
        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 2 * near * far / (near - far);
        m[15] = 0.0;
    };
    /**
     * Modifies a 4x4 transformation matrix, setting it to describe an orthographic projection.
     * @param {Float32Array} m The matrix to modify
     * @param {Number} right
     * @param {Number} top
     * @param {Number} near
     * @param {Number} far
     */
    mat.setOrthographic4 = function (m, right, top, near, far) {
        m[0] = 1 / right;
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;
        m[4] = 0.0;
        m[5] = 1 / top;
        m[6] = 0.0;
        m[7] = 0.0;
        m[8] = 0.0;
        m[9] = 0.0;
        m[10] = -2.0 / (far - near);
        m[11] = 0.0;
        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = -(near + far) / 2.0;
        m[15] = 1.0;
    };
    /**
     * Modifies the passed matrix m in-place to ensure its orthogonality.
     * @param {Float32Array} m
     */
    mat.correctOrthogonal4 = function (m) {
        var
                vx = vec.normalize3([m[0], m[1], m[2]]),
                vy = vec.normalize3([m[4], m[5], m[6]]),
                vz = vec.cross3(vx, vy);
        vy = vec.cross3(vz, vx);
        m[0] = vx[0];
        m[1] = vx[1];
        m[2] = vx[2];
        m[3] = 0.0;
        m[4] = vy[0];
        m[5] = vy[1];
        m[6] = vy[2];
        m[7] = 0.0;
        m[8] = vz[0];
        m[9] = vz[1];
        m[10] = vz[2];
        m[11] = 0.0;
        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 0.0;
        m[15] = 1.0;
    };
    /**
     * Modifies the passed matrix m to a "straigthened" version, which means every value
     * within the matrix that is at least epsilon-close to -1, 0 or 1 will be changed
     * to -1, 0 or 1 respectively. Works with both 3x3 and 4x4 matrices.
     * @param {Float32Array} m The input matrix.
     * @param {Number} epsilon The difference threshold within the matrix components
     * will be corrected.
     */
    mat.straighten = function (m, epsilon) {
        var i;
        for (i = 0; i < m.length; i++) {
            m[i] = (Math.abs(m[i]) < epsilon) ?
                    0.0 :
                    ((Math.abs(1 - m[i]) < epsilon) ?
                            1.0 :
                            ((Math.abs(-1 - m[i]) < epsilon) ?
                                    -1.0 : m[i]));
        }
    };
    /**
     * Modifies the passed 4x4 translation matrix m to a "straigthened" version, 
     * which means that the translation coordinates which are at least epsilon-close 
     * to -1, 0 or 1 will be changed to -1, 0 or 1 respectively.
     * @param {Float32Array} m The input 4x4 translation matrix.
     * @param {Number} epsilon The difference threshold within the matrix components
     * will be corrected.
     */
    mat.straightenTranslation = function (m, epsilon) {
        var i;
        for (i = 12; i < 14; i++) {
            m[i] = (Math.abs(m[i]) < epsilon) ?
                    0.0 :
                    ((Math.abs(1 - m[i]) < epsilon) ?
                            1.0 :
                            ((Math.abs(-1 - m[i]) < epsilon) ?
                                    -1.0 : m[i]));
        }
    };
    /**
     * Modifies the passed 4x4 rotation matrix m to a "straigthened" version, 
     * which means that the rotation coordinates which are at least epsilon-close 
     * to -1, 0 or 1 will be changed to -1, 0 or 1 respectively.
     * @param {Float32Array} m The input 4x4 translation matrix.
     * @param {Number} epsilon The difference threshold within the matrix components
     * will be corrected.
     */
    mat.straightenRotation4 = function (m, epsilon) {
        var i;
        for (i = 0; i < 10; i++) {
            m[i] = (Math.abs(m[i]) < epsilon) ?
                    0.0 :
                    ((Math.abs(1 - m[i]) < epsilon) ?
                            1.0 :
                            ((Math.abs(-1 - m[i]) < epsilon) ?
                                    -1.0 : m[i]));
        }
    };
    // ----------------------------------------------------------------------
    // Initialization
    (function () {
        var i;
        for (i = 0; i < AUX_MATRIX_COUNT; i++) {
            _auxMatrices.push(mat.identity4());
        }
        for (i = 0; i < AUX_MATRIX_COUNT; i++) {
            _auxMatrices3.push(mat.identity3());
        }
    }());
    // ----------------------------------------------------------------------
    // Returning the public interface
    return mat;
});
/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides different types of light source classes to add to scenes.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Float32Array, Int32Array */

/**
 * @param vec Used for 3D (and 4D) vector operations.
 * @param mat Used for 3D (and 4D) matrix operations.
 * @param managedGL Used for handling managed framebuffers, creating uniform names, feature checking
 */
define('modules/scene/lights',[
    "utils/vectors",
    "utils/matrices",
    "modules/managed-gl"
], function (vec, mat, managedGL) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // constants
            // the names of uniforms that light sources provide values for (these names will be pre/suffixed by ManagedGL)
            /**
             * When rendering a shadow map, the light matrix data will be loaded to the uniform with this name.
             * @type String
             */
            UNIFORM_LIGHT_MATRIX_NAME = "lightMatrix",
            /**
             * When rendering a shadow map, the shadow map parameters will be loaded to the uniform with this name.
             * @type String
             */
            UNIFORM_SHADOW_MAP_PARAMS_NAME = "shadowMapParams",
            /**
             * The near value to use for light space perspective shadow mapping, when the view is fully perpendicular to the light direction
             * @type Number
             */
            _lispsmMinimumNear = 10,
            /**
             * In light space perspective shadow mapping, when the view is not perpendicular to the light direction, the near value should be 
             * increased for weaker perspective effect. The increase is multiplied by this factor.
             * @type Number
             */
            _lispsmNearFactor = 100;
    // #########################################################################
    /**
     * Set up the general parameters to use for light space perspective shadow mapping from now on
     * @param {Number} minimumNear
     * @param {Number} nearFactor
     */
    function setupLiSPSM(minimumNear, nearFactor) {
        _lispsmMinimumNear = minimumNear;
        _lispsmNearFactor = nearFactor;
    }
    // #########################################################################
    /**
     * @typedef {Object} SceneGraph~DirectionalLightUniformData
     * @property {Number[3]} color
     * @property {Number[3]} direction
     * @property {Float32Array} matrix
     * @property {Float32Array} translationVector
     */
    /**
     * @class A simple directional light source that all objects in the scene will have access to and can cast shadows using a set of
     * shadow maps that have increasing spans around the camera position to provide higher resolution for objects close to the camera.
     * @param {Number[3]} color The color of the light the source emits.
     * @param {Number[3]} direction The direction this light source emits light FROM (the opposite of the direction of the light rays
     * themselves)
     */
    function DirectionalLightSource(color, direction) {
        /**
         * The color of the light the source emits.
         * @type Number[3]
         */
        this._color = color;
        /**
         * A unit vector indicating the direction this light source emits light FROM (the opposite of the direction of the light rays
         * themselves)
         * @type Number[3]
         */
        this._direction = vec.normal3(direction);
        /**
         * The inverse of the rotation matrix pointing towards this light source.
         * @type Float32Array
         */
        this._orientationMatrix = mat.inverseOfRotation4(mat.lookTowards4(this._direction));
        /**
         * The matrix that transforms a world coordinate into a shadow map coordinate for this light source. Depends on the camera position,
         * but does not take into account that the actual center of the shadow map is in front of the camera, at different positions for
         * each range, so the resulting coordinates will have to be translated using a stored translation unit vector and the size of the
         * ranges.
         * @type Float32Array
         */
        this._baseMatrix = mat.identity4();
        /**
         * Whether the currently stored base matrix value is up-to-date.
         * @type Boolean
         */
        this._baseMatrixValid = false;
        /**
         * A cached value of the near value of the latest calculated LiSP transformation matrix
         * @type Number
         */
        this._near = 0;
        /**
         * A cached value of the far value of the latest calculated LiSP transformation matrix
         * @type Number
         */
        this._far = 0;
        /**
         * Stores the latest calculated LiSP transformation matrix
         * @type Float32Array
         */
        this._lispMatrix = mat.matrix4([
            1, 0, 0, 0,
            0, 1, 0, -1,
            0, 0, 1, 0,
            0, 0, 0, 0
        ]);
        /**
         * The prefix to use for creating frambuffer names for the shadow maps of different ranges for this light source.
         * @type String
         */
        this._shadowMapBufferNamePrefix = null;
        /**
         * The functions returning the values for the shader uniforms used for shadow mapping for this light source.
         * @type Object.<String, Function>
         */
        this._uniformValueFunctions = {};
        /**
         * Holds the data to be passed to the corresponding uniform struct.
         * @type SceneGraph~DirectionalLightUniformData
         */
        this._uniformData = {
            color: this._color,
            direction: [this._direction[0], this._direction[1], this._direction[2], 1], // fourth coordinate is parallelism
            matrix: this._baseMatrix
        };
        /**
         * Stores the values to be passed to the shadow mapping shader. Parallelism is how much is the view direction parallel to the light direction
         * (the cosine of their angle)
         * [range, depth, parallelism]
         * @type Number[3]
         */
        this._shadowMapParams = [0, 0, 1];
        // set uniform value functions
        this._uniformValueFunctions[managedGL.getUniformName(UNIFORM_LIGHT_MATRIX_NAME)] = function () {
            return this._baseMatrix;
        }.bind(this);
        this._uniformValueFunctions[managedGL.getUniformName(UNIFORM_SHADOW_MAP_PARAMS_NAME)] = function () {
            return this._shadowMapParams;
        }.bind(this);
    }
    /**
     * Returns the name of the shadow map framebuffer to use for rendering the shadow map of the range with the given index for this light source.
     * @param {Number} rangeIndex
     * @returns {String}
     */
    DirectionalLightSource.prototype.getShadowMapBufferName = function (rangeIndex) {
        return this._shadowMapBufferNamePrefix + rangeIndex.toString();
    };
    /**
     * Performs all necessary actions to prepare for rendering shadow maps for this light source using the passed context with the passed
     * parameters.
     * @param {ManagedGLContext} context The context to use for rendering shadow maps.
     * @param {Boolean} shadowMappingEnabled Whether shadow mapping is enabled for rendering.
     * @param {String} shadowMapBufferNamePrefix The prefix to use for creating frambuffer names for the shadow maps of different ranges for this light source.
     * @param {Number} numRanges The number of shadow map( range)s that will have to be rendered.
     * @param {Number} shadowMapTextureSize The size (width and height, in texels) that the shadow map framebuffers should have
     */
    DirectionalLightSource.prototype.addToContext = function (context, shadowMappingEnabled, shadowMapBufferNamePrefix, numRanges, shadowMapTextureSize) {
        var i, name, existingBuffer;
        this._shadowMapBufferNamePrefix = shadowMapBufferNamePrefix;
        if (shadowMappingEnabled) {
            for (i = 0; i < numRanges; i++) {
                name = this.getShadowMapBufferName(i);
                existingBuffer = context.getFrameBuffer(name);
                context.addFrameBuffer(
                        new managedGL.FrameBuffer(name, shadowMapTextureSize, shadowMapTextureSize, true),
                        existingBuffer && (existingBuffer.getWidth() !== shadowMapTextureSize));
            }
        }
    };
    /**
     * Call at the beginning of each render to clear stored values that refer to the state of the previous render.
     */
    DirectionalLightSource.prototype.reset = function () {
        this._baseMatrixValid = false;
    };
    /**
     * Updates the stored Light-Space Perspective transformation matrix according to the latest started shadow map
     * @returns {Float32Array}
     */
    DirectionalLightSource.prototype._updateLiSPMatrix = function () {
        var
                range = this._shadowMapParams[0],
                depth = this._shadowMapParams[1];
        this._near = (_lispsmNearFactor + range) * this._shadowMapParams[2] + _lispsmMinimumNear;
        this._far = 2.0 * range + this._near;
        this._lispMatrix[0] = this._far / range;
        this._lispMatrix[5] = (this._far + this._near) / (this._far - this._near);
        this._lispMatrix[10] = this._far / depth;
        this._lispMatrix[13] = 2.0 * this._far * this._near / (this._far - this._near);
    };
    /**
     * Returns whether an object specified by the passed transformation matrix and size should be rendered onto
     * the current (latest started) shadow map for this light
     * @param {Float32Array} modelMatrix
     * @param {Number} size
     * @returns {Boolean}
     */
    DirectionalLightSource.prototype.isInsideCurrentMap = function (modelMatrix, size) {
        var
                positionInLightSpace, x, y1, y2, z, w, wp,
                range = this._shadowMapParams[0],
                parallelism = this._shadowMapParams[2];
        size *= 0.5;
        // position / orientation transformation
        positionInLightSpace = vec.prodTranslationModel3Aux(modelMatrix, this._baseMatrix);
        // additional position transformation
        positionInLightSpace[1] -= parallelism * range + this._near;
        positionInLightSpace[2] = -positionInLightSpace[2] + parallelism * range;
        // perspective transformation (multiplying with the list matrix manually, only considering the non-zero elements)
        x = positionInLightSpace[0] * this._lispMatrix[0]; // left-right plane
        y1 = (positionInLightSpace[1] + size) * this._lispMatrix[5] + this._lispMatrix[13]; // far plane
        y2 = (positionInLightSpace[1] - size) * this._lispMatrix[5] + this._lispMatrix[13]; // near plane
        z = positionInLightSpace[2] * this._lispMatrix[10]; // top-bottom plane
        w = -positionInLightSpace[1];
        wp = Math.max(w, 0); // w-positive - for objects behind the projection point, w would be negative, indicating a negative (mirrored) frustum,
        // possibly resulting in false negative result when checking side planes, if part of the object is still in front of the
        // projection point:
        //
        // top down view on XY plane, field of view above 'p' projection point:
        //
        //   \     /
        //    \   /
        //     \^/   _
        //      p    |
        //     / \   |
        //    / |----o
        //   /     \
        //
        // object 'o' is behind projection point 'p', but it is still visible, yet it would fail the X coordinate check as at the
        // o point, the w will be even more negative (w will follow the frustum, the bottom-left / top-right diagonal line here)

        return (Math.abs(x) - size * this._lispMatrix[0] < wp) && // left-right plane
                ((y1 > 0) || (y1 > -(w - size))) &&               // far plane (w is calculated for y1 by also negating the added size)
                ((y2 < 0) || (y2 < (w + size))) &&                // near plane (w is calculated for y2 by also negating the subtracted size)
                (Math.abs(z) - size * this._lispMatrix[10] < wp); // top-bottom plane
    };
    /**
     * Performs all actions necesary to set up the passed context for rendering the shadow map of the given range for this light source.
     * Assumes that an appropriate shadow mapping shader is already bound (since that would be the same for the different ranges and light
     * sources)
     * @param {ManagedGLContext} context The context to set up for shadow map rendering.
     * @param {Camera} camera The camera used for the rendering (since the positions of the shadow maps in the world depend on it)
     * @param {Number} rangeIndex The index of the shadow map range that is to be rendered
     * @param {Number} range The range of this shadow map (the size of the shadow map area on axes X and Y)
     * @param {Number} depth The depth of this shadow map (the size of the shadow map area on axis Z)
     */
    DirectionalLightSource.prototype.startShadowMap = function (context, camera, rangeIndex, range, depth) {
        var viewDir, cos;
        context.setCurrentFrameBuffer(this.getShadowMapBufferName(rangeIndex));
        viewDir = mat.getRowC43(camera.getCameraOrientationMatrix());
        cos = Math.abs(vec.dot3(viewDir, this._direction)); // parallelism, which will determine the amount of perspective transformation
        this._shadowMapParams[0] = range;
        this._shadowMapParams[1] = depth;
        this._shadowMapParams[2] = cos;
        // this will be the matrix that transforms a world-space coordinate into shadow-space coordinate for this particular shadow map
        // (not counting the light-space perspective transform)
        if (!this._baseMatrixValid) {
            // up vector on shadow map is aligned with camera view direction, so as a result with the perspective transform
            mat.setInverseOfRotation4(this._orientationMatrix, mat.lookTowards4Aux(this._direction, viewDir));
            mat.setProdTranslationRotation4(this._baseMatrix, camera.getInversePositionMatrix(), this._orientationMatrix);
            this._baseMatrixValid = true;
        }
        this._uniformData.direction[3] = cos;
        this._updateLiSPMatrix();
        context.getCurrentShader().assignUniforms(context, this._uniformValueFunctions);
    };
    /**
     * Returns an object that can be used to set the uniform object representing this light source in a shader using it.
     * @returns {SceneGraph~DirectionalLightUniformData}
     */
    DirectionalLightSource.prototype.getUniformData = function () {
        return this._uniformData;
    };
    // #########################################################################
    /**
     * @typedef {Object} PointLightSource~LightState
     * @property {Number[3]} color
     * @property {Number} intensity
     * @property {Number} timeToReach
     */
    /**
     * @typedef {Object} SceneGraph~PointLightUniformData
     * @property {Number[4]} color The RGB color and the intensity of the light.
     * @property {Number[3]} position
     */
    /**
     * @class Represents a point-like light source that can be bound to one or more object in a scene, following their position.
     * @param {Number[3]} color The color of the light emitted by this source.
     * @param {Number} intensity The intensity of the light - the level of lighting for point light sources depends on the distance
     * from the illuminated object, and it will be multiplied by this factor. This value corresponds by the intensity emitted by one of the
     * objects, the total intensity will be multiplied by the total number of objects participating in this light source.
     * @param {Number[3]} positionVector The position of the light source - if there is no specific object emitting it, then relative to the
     * scene origo, if there is one specific object, then relative to that object, and if there are multiple object, this value is not 
     * considered.
     * @param {RenderableObject3D[]} [emittingObjects] The list of objects that together act as this light source. If none specified, the 
     * light source will act as a static, global light source in the scene, and if multiple objects are specified, it will be positioned
     * at the average position of those objects. In this case, all objects will be considered to contribute the same amount of intensity
     * of the same color.
     * @param {PointLightSource~LightState[]} [states] The list of states this light source should go through, if a dynamic behavior is
     * desired.
     * @param {Boolean} [looping] If states are given, this parameter tells whether to loop through them, starting over once the last
     * state is reached, or just stay in it.
     */
    function PointLightSource(color, intensity, positionVector, emittingObjects, states, looping) {
        /**
         * The color of the light emitted by this source.
         * @type Number[3]
         */
        this._color = color;
        /**
         * The intensity of light emitted by one object
         * @type Number
         */
        this._objectIntensity = intensity;
        /**
         * The position vector of this light source relative to the scene, if there are no emitting objects, and relative to the emitting 
         * object, if there is one. If there are multiple objects, this value is not considered.
         * @type Number[3]
         */
        this._relativePositionVector = positionVector;
        /**
         * Stores the calculated value of whether this point light has a non-zero relative position set, because position calculation can
         * be much simpler then.
         * @type Boolean
         */
        this._hasRelativePosition = (positionVector && ((positionVector[0] !== 0) || (positionVector[1] !== 0) || (positionVector[2] !== 0)));
        /**
         * The list of all objects acting together as this light source. If null / undefined, then the light source is considered static.
         * @type RenderableObject3D[]
         */
        this._emittingObjects = emittingObjects;
        /**
         * Stores the calculated value of whether this light has exactly one emitting object set, because some calculations can be simpler if so.
         * @type Boolean
         */
        this._singleEmittingObject = (!!emittingObjects && (emittingObjects.length === 1));
        /**
         * Storing the calculated total intensity of this light source emitted by all of its emitting objects.
         * @type Number
         */
        this._totalIntensity = intensity * (emittingObjects ? emittingObjects.length : 1);
        /**
         * While set to false, isVisible() and shouldBeRendered() returns false, intensity is set to 0 and position is not updated, but state
         * intensity / color still is
         * @type Boolean
         */
        this._visible = true;
        /**
         * The calculated position vector of this light source in world-space.
         * @type Number[3]
         */
        this._positionVector = [0, 0, 0];
        /**
         * The list of states (storing the values for attributes like color and intensity) this light source will go through.
         * If it is not given, the light source will have a static state.
         * @type PointLightSource~LightState[]
         */
        this._states = states;
        /**
         * The time elapsed since transitioning to the current state, in milliseconds.
         * @type Number
         */
        this._timeSinceLastTransition = 0;
        /**
         * The index of the current state the light source is in - it might be transitioning already to the next state, in which case its
         * actual attributes will be determined as a combination of the ones defined in these two states.
         * @type Number
         */
        this._currentStateIndex = 0;
        /**
         * If this light source has states, whether to start over after reaching the last one.
         * @type Boolean
         */
        this._looping = looping;
        /**
         * A cached value of the color vector to be assigned to uniforms (containing the RGB color and the intensity)
         * @type Number[4]
         */
        this._uniformColor = [0, 0, 0, this._totalIntensity];
        /**
         * Holds the data to be passed to the corresponding uniform struct.
         * @type SceneGraph~PointLightUniformData
         */
        this._uniformData = {
            color: this._uniformColor,
            position: this._positionVector
        };
        if (color) {
            this._updateUniformColor();
        }
    }
    /**
     * Updates the cached color vector to be used when assigning uniforms.
     */
    PointLightSource.prototype._updateUniformColor = function () {
        this._uniformColor[0] = this._color[0];
        this._uniformColor[1] = this._color[1];
        this._uniformColor[2] = this._color[2];
    };
    /**
     * Returns whether the light is currently visible in the scene (it has at least one visible emitting object)
     * @returns {Boolean}
     */
    PointLightSource.prototype.isVisible = function () {
        var i;
        if (!this._visible) {
            return false;
        }
        if (!this._emittingObjects) {
            return true;
        }
        if (this._singleEmittingObject) {
            return this._emittingObjects[0].isVisible();
        }
        for (i = 0; i < this._emittingObjects.length; i++) {
            if (this._emittingObjects[i] && !this._emittingObjects[i].canBeReused() && this._emittingObjects[i].isVisible()) {
                return true;
            }
        }
        return false;
    };
    /**
     * Updates the properties of the light source that are defined in the state list.
     * @param {Number} dt The elapsed time since the last update, in milliseconds.
     */
    PointLightSource.prototype.updateState = function (dt) {
        var nextStateIndex, stateProgress;
        // only animating through states if there is more than one of them
        if (this._states && (this._states.length > 1) && (dt > 0)) {
            this._timeSinceLastTransition += dt;
            // find out which state did we arrive to and which is next
            nextStateIndex = (this._currentStateIndex + 1) % this._states.length;
            while (this._timeSinceLastTransition > this._states[nextStateIndex].timeToReach) {
                if ((nextStateIndex === 0) && (!this._looping)) {
                    nextStateIndex = this._states.length - 1;
                    this._timeSinceLastTransition = this._states[nextStateIndex].timeToReach;
                    break;
                }
                this._timeSinceLastTransition -= this._states[nextStateIndex].timeToReach;
                nextStateIndex = (nextStateIndex + 1) % this._states.length;
            }
            this._currentStateIndex = (nextStateIndex === 0) ? (this._states.length - 1) : (nextStateIndex - 1);
            // calculate the relative progress
            stateProgress = this._timeSinceLastTransition / this._states[nextStateIndex].timeToReach;
            this.setObjectIntensity(this._states[this._currentStateIndex].intensity * (1.0 - stateProgress) + this._states[nextStateIndex].intensity * stateProgress);
            this.setColor(vec.sum3(
                    vec.scaled3(this._states[this._currentStateIndex].color, 1.0 - stateProgress),
                    vec.scaled3(this._states[nextStateIndex].color, stateProgress)));
        }
    };
    /**
     * Updates the properties of the light source based on the status of the emitting objects and the current state of the light source.
     * @param {Number} dt The time elapsed since the last update, in milliseconds
     */
    PointLightSource.prototype.update = function (dt) {
        var i, count, previousIntensity = this._totalIntensity;
        this.updateState(dt);
        if (!this._visible) {
            this._totalIntensity = 0;
        } else {
            // calculate attributes that depend on the emitting objects
            if (!this._emittingObjects) {
                this._totalIntensity = this._objectIntensity;
                vec.setVector3(this._positionVector, this._relativePositionVector);
            } else if (this._singleEmittingObject) {
                this._totalIntensity = this._objectIntensity;
                this._emittingObjects[0].copyPositionToVector(this._positionVector);
                if (this._hasRelativePosition) {
                    vec.add3(this._positionVector, vec.prodVec3Mat4Aux(this._relativePositionVector, mat.prod3x3SubOf4Aux(this._emittingObjects[0].getCascadeScalingMatrix(), this._emittingObjects[0].getOrientationMatrix())));
                }
            } else {
                vec.setNull3(this._positionVector);
                count = 0;
                for (i = 0; i < this._emittingObjects.length; i++) {
                    if (this._emittingObjects[i] && !this._emittingObjects[i].canBeReused() && this._emittingObjects[i].isVisible()) {
                        this._emittingObjects[i].addPositionToVector(this._positionVector);
                        count++;
                    }
                }
                if (count > 0) {
                    this._positionVector[0] /= count;
                    this._positionVector[1] /= count;
                    this._positionVector[2] /= count;
                }
                this._totalIntensity = this._objectIntensity * count;
            }
        }
        if (this._totalIntensity !== previousIntensity) {
            this._uniformColor[3] = this._totalIntensity;
        }
    };
    /**
     * Returns an object that can be used to set the uniform object representing this light source in a shader using it.
     * @returns {SceneGraph~PointLightUniformData}
     */
    PointLightSource.prototype.getUniformData = function () {
        return this._uniformData;
    };
    /**
     * Returns whether this light source object can be reused as the light source it represents is not needed anymore (all its emitting
     * objects have been deleted)
     * @returns {Boolean}
     */
    PointLightSource.prototype.canBeReused = function () {
        var i;
        if (!this._emittingObjects) {
            return false;
        }
        if (this._singleEmittingObject) {
            return this._emittingObjects[0].canBeReused();
        }
        for (i = 0; i < this._emittingObjects.length; i++) {
            if (this._emittingObjects[i] && !this._emittingObjects[i].canBeReused()) {
                return false;
            }
        }
        return true;
    };
    /**
     * Sets a new color for the light emitted by this source.
     * @param {Number[3]} value
     */
    PointLightSource.prototype.setColor = function (value) {
        this._color = value;
        this._updateUniformColor();
    };
    /**
     * Sets a new intensity for the light emitted by the objects contributing to this light source.
     * @param {Number} value
     */
    PointLightSource.prototype.setObjectIntensity = function (value) {
        this._objectIntensity = value;
    };
    /**
     * Adds a new emitting object to the ones contributing to this light source. All objects should be of the same type (color and intensity)
     * @param {RenderableObject3D} emittingObject
     */
    PointLightSource.prototype.addEmittingObject = function (emittingObject) {
        this._emittingObjects.push(emittingObject);
        this._singleEmittingObject = (this._emittingObjects.length === 1);
    };
    /**
     * Returns whether the light source should be considered for rendering if the passed camera is used.
     * @param {Camera} camera
     * @returns {Boolean}
     */
    PointLightSource.prototype.shouldBeRendered = function (camera) {
        var viewMatrix = camera.getViewMatrix();
        // calculating the Z position in camera space by multiplying the world space position vector with the view matrix (only the applicable parts)
        return (this._totalIntensity > 0) && ((this._positionVector[0] * viewMatrix[2] + this._positionVector[1] * viewMatrix[6] + this._positionVector[2] * viewMatrix[10] + viewMatrix[14]) < this._totalIntensity);
    };
    /**
     * Sets the animation state of the light source to be the one occuring after the passed amount of time from the start
     * @param {Number} elapsedTime In milliseconds
     */
    PointLightSource.prototype.setAnimationTime = function (elapsedTime) {
        this._timeSinceLastTransition = 0;
        this._currentStateIndex = 0;
        this.updateState(elapsedTime);
    };
    /**
     * Causes the light source to not be rendered (isVisible() and shouldBeRendered() to be false) and its position not be updated
     */
    PointLightSource.prototype.hide = function () {
        this._visible = false;
    };
    /**
     * Restores the default visibility state of the light source (where rendering depends on camera frustum and current intensity)
     */
    PointLightSource.prototype.show = function () {
        this._visible = true;
    };
    // #########################################################################
    /**
     * @typedef {SceneGraph~PointLightUniformData} SceneGraph~SpotLightUniformData
     * @property {Number[4]} color The RGB color and the intensity of the light.
     * @property {Number[4]} spot The spot direction (XYZ) and the cutoff angle cosine
     * @property {Number[4]} position The position in world-space (XYZ) and the full intensity angle cosine (or zero)
     */
    /**
     * @class A directed point-like light source.
     * @extends PointLightSource
     * @param {Number[3]} color See PointLightSource.
     * @param {Number} intensity See PointLightSource.
     * @param {Number[3]} positionVector See PointLightSource.
     * @param {Number[3]} spotDirection The (relative) direction in which the light cone of this light source is pointed. If there is one
     * emitting object, the direction will be relative to the orientation of that object, otherwise it will be taken as absolute.
     * @param {Number} spotCutoffAngle Light will not be emitted in directions with angles larger than this to the primary spot direction.
     * In degrees.
     * @param {Number} spotFullIntensityAngle Light will be emitted at full intensity only in direction with angles smaller than this to the
     * primary direction. Between this and the cutoff angle, the intensity will transition to zero. If this is larger than the cutoff angle,
     * light will be emitted with full intensity everywhere within the cutoff angle. In degrees.
     * @param {RenderableObject3D[]} emittingObjects See PointLightSource.
     * @param {PointLightSource~LightState[]} [states] See PointLightSource.
     * @param {Boolean} [looping] See PointLightSource.
     */
    function SpotLightSource(color, intensity, positionVector, spotDirection, spotCutoffAngle, spotFullIntensityAngle, emittingObjects, states, looping) {
        PointLightSource.call(this, color, intensity, positionVector, emittingObjects, states, looping);
        /**
         * The (relative) direction in which the light cone of this light source is pointed. If there is one
         * emitting object, the direction will be relative to the orientation of that object, otherwise it will be taken as absolute.
         * @type Numberf[3]
         */
        this._relativeSpotDirection = spotDirection;
        /**
         * The cosine of the cutoff angle.
         * @type Number
         */
        this._spotCutoffCosine = Math.cos(Math.radians(spotCutoffAngle));
        /**
         * The cosine of th full intensity angle (zero if there if full intensity needs to be applied everywhere)
         * @type Number
         */
        this._spotFullIntensityCosine = (spotFullIntensityAngle < spotCutoffAngle) ? Math.cos(Math.radians(spotFullIntensityAngle)) : 0;
        /**
         * The direction of the light cone in world-space.
         * @type Numberf[3]
         */
        this._spotDirection = [0, 0, 0];
        /**
         * Holds the data to be passed to the corresponding uniform struct.
         * @type SceneGraph~StopLightUniformData
         */
        this._uniformData = {
            color: this._uniformColor,
            spot: [0, 0, 0, 0],
            position: [0, 0, 0, 0]
        };
    }
    SpotLightSource.prototype = new PointLightSource();
    SpotLightSource.prototype.constructor = SpotLightSource;
    /**
     * @param {Number[3]} value
     */
    SpotLightSource.prototype.setSpotDirection = function (value) {
        this._relativeSpotDirection = value;
    };
    /**
     * @param {Number} value
     */
    SpotLightSource.prototype.setSpotCutoffAngle = function (value) {
        this._spotCutoffCosine = Math.cos(Math.radians(value));
    };
    /**
     * @override
     * @param {Number} dt
     */
    SpotLightSource.prototype.update = function (dt) {
        PointLightSource.prototype.update.call(this, dt);
        if (this._visible) {
            // calculate attributes that depend on the emitting objects
            if (!this._emittingObjects || (this._emittingObjects.length !== 1)) {
                vec.setVector3(this._spotDirection, this._relativeSpotDirection);
            } else {
                vec.setProdVec3Mat4(this._spotDirection, this._relativeSpotDirection, this._emittingObjects[0].getOrientationMatrix());
            }
        }
    };
    /**
     * @override
     * @returns {SceneGraph~SpotLightUniformData}
     */
    SpotLightSource.prototype.getUniformData = function () {
        this._uniformData.spot[0] = this._spotDirection[0];
        this._uniformData.spot[1] = this._spotDirection[1];
        this._uniformData.spot[2] = this._spotDirection[2];
        this._uniformData.spot[3] = this._spotCutoffCosine;
        this._uniformData.position[0] = this._positionVector[0];
        this._uniformData.position[1] = this._positionVector[1];
        this._uniformData.position[2] = this._positionVector[2];
        this._uniformData.position[3] = this._spotFullIntensityCosine;
        return this._uniformData;
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        setupLiSPSM: setupLiSPSM,
        DirectionalLightSource: DirectionalLightSource,
        PointLightSource: PointLightSource,
        SpotLightSource: SpotLightSource
    };
});
/**
 * Copyright 2016, 2020 Krisztián Nagy
 * @file Contains the constants accessible to all modules of the Interstellar Armada game.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define */

define('armada/constants',[],function () {
    "use strict";
    var
            GAME_NAME = "Interstellar Armada",
            LOCAL_STORAGE_PREFIX = "armada_",
            LANGUAGE_LOCAL_STORAGE_ID = LOCAL_STORAGE_PREFIX + "language",
            VERSION_LOCAL_STORAGE_ID = LOCAL_STORAGE_PREFIX + "version";
    // constants to be accessable for all game modules
    return {
        GAME_NAME: GAME_NAME,
        LOCAL_STORAGE_PREFIX: LOCAL_STORAGE_PREFIX,
        LANGUAGE_LOCAL_STORAGE_ID: LANGUAGE_LOCAL_STORAGE_ID,
        VERSION_LOCAL_STORAGE_ID: VERSION_LOCAL_STORAGE_ID
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides a basic class to use as a mixin or base class for 3 dimensional objects.
 * be rendered on them.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Float32Array, Int32Array */

/**
 * @param vec Used for 3D (and 4D) vector operations.
 * @param mat Used for 3D (and 4D) matrix operations.
 */
define('modules/scene/object-3d',[
    "utils/vectors",
    "utils/matrices"
], function (vec, mat) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // public functions
            makeObject3DMixinClassFunction, makeObject3DMixinClass;
    // #########################################################################
    /**
     * @class Represents a three dimensional object situated in a virtual space. 
     * This is used as a mixin class, adding its functionality to classes that 
     * have otherwise a different superclass.
     * @constructor
     * @param {Float32Array} [positionMatrix] Initial position.
     * @param {Float32Array} [orientationMatrix] Initial orientation.
     * @param {Float32Array} [scalingMatrix] Initial scaling.
     * @param {Number} [size=1]
     * @param {Boolean} [childrenAlwaysInside=false] When true, children of this object are always considered to be inside it, without 
     * performing an actual position check. Useful for container objects.
     * @param {Boolean} [ignoreTransform=false] If true, the transforms of this object are ignored when calculating its children's model
     * matrix - useful for objects with permanent identity transforms (such as root nodes)
     * @returns {Object3D}
     */
    function Object3D(positionMatrix, orientationMatrix, scalingMatrix, size, childrenAlwaysInside, ignoreTransform) {
        /**
         * Optional parent, relative to which the position, orientation and
         * scaling of this object is interpreted.
         * @type Object3D
         */
        this._parent = null;
        /**
         * @type Float32Array
         */
        this._positionMatrix = positionMatrix || mat.identity4();
        /**
         * @type Float32Array
         */
        this._orientationMatrix = orientationMatrix || mat.identity4();
        /**
         * @type Float32Array
         */
        this._scalingMatrix = scalingMatrix || mat.identity4();
        /**
         * The cached calculated value of the cascaded scaling matrix (with the scaling of the parent nodes applied).
         * @type Float32Array
         */
        this._cascadeScalingMatrix = mat.identity4();
        /**
         * Whether the cached cascaded scaling matrix value is up-to-date for the current frame
         * @type Boolean
         */
        this._cascadeScalingMatrixValid = false;
        /**
         * Cache variable to store the calculated value of the combined model matrix.
         * @type Float32Array
         */
        this._modelMatrix = mat.identity4();
        /**
         * Whether the cached model matrix value is currently valid
         * @type Boolean
         */
        this._modelMatrixValid = false;
        /**
         * The cached calculated value of the cascaded model matrix (with the transformations of the parents applied) for the current frame.
         * @type Float32Array
         */
        this._cascadedModelMatrix = mat.identity4();
        /**
         * The matrix to be used as the model matrix for the current frame (points to the calculated cascaded matrix, if there is a parent, 
         * and to the simple local model matrix if there isn't)
         * @type Float32Array
         */
        this._modelMatrixForFrame = this._modelMatrix;
        /**
         * Whether the cached cascaded model matrix value is currently valid
         * @type Boolean
         */
        this._modelMatrixForFrameValid = false;
        /**
         * Cache variable to store the calculated value of the inverse of the combined model matrix.
         * @type Float32Array
         */
        this._modelMatrixInverse = mat.identity4();
        /**
         * Whether the cached inverse model matrix value is currently valid
         * @type Boolean
         */
        this._modelMatrixInverseValid = false;
        /**
         * The cached calculated value of the cascaded inverse model matrix (with the transformations of the parents applied) for the 
         * current frame.
         * @type Float32Array
         */
        this._cascadedModelMatrixInverse = mat.identity4();
        /**
         * The matrix to be used as the inverse model matrix for the current frame (points to the calculated cascaded inverse model matrix, if there is a parent, 
         * and to the simple local inverse model matrix if there isn't)
         * @type Float32Array
         */
        this._modelMatrixInverseForFrame = this._modelMatrixInverse;
        /**
         * Whether the cached cascaded inverse model matrix value is currently valid
         * @type Boolean
         */
        this._modelMatrixInverseForFrameValid = false;
        /**
         * @type Number
         */
        this._size = (size !== undefined) ? size : 1;
        /**
         * Cache value to store whether the object is situated within its 
         * parent's boundaries, as the parent's values can be used for certain 
         * calculations in this case.
         * @type ?Boolean
         */
        this._insideParent = null;
        /**
         * When true, children of this object are always considered to be inside it, without 
         * performing an actual position check. Useful for container objects.
         * @type Boolean
         */
        this._childrenAlwaysInside = childrenAlwaysInside || false;
        /**
         * Stored value of the last frustum calculation result. Not used for
         * caching but to avoid creating a new object to store this every time.
         * @type Object
         */
        this._lastSizeInsideViewFrustum = {width: -1, height: -1};
        /**
         * Stores a cached value of the (4x4 translation matrix describing the) position of this 
         * 3D object transformed into camera space. The object needs to be reset to clear this cache, 
         * so a reset needs to be called before the object is used with new or updated camera.
         * @type Float32Array
         */
        this._positionMatrixInCameraSpace = mat.identity4();
        /**
         * Whether the cached camera space position matrix value is currently valid
         * @type Boolean
         */
        this._positionMatrixInCameraSpaceValid = false;
        /**
         * If true, the transforms of this object are ignored when calculating its children's model matrix.
         * Useful for objects with permanent identity transforms (such as root nodes).
         * @type Boolean
         */
        this._ignoreTransform = ignoreTransform || false;
    }
    /**
     * Adds the methods of an Object3D class to the prototype of the class 
     * passed as the 'this' variable (so usage: 
     * makeObject3DMixinClass.call(ClassName)), so subsequently created 
     * instances of it can be used as Object3D instances.
     * It is an IIFE to create the methods themselves only once and cache them
     * in a closure, and only add the references when it is used.
     * @type Function(this:Object3D)
     */
    makeObject3DMixinClassFunction = function () {
        /**
         * Reinitializes the 3D object with new properties
         * @param {Float32Array} [positionMatrix] Initial position.
         * @param {Float32Array} [orientationMatrix] Initial orientation.
         * @param {Float32Array} [scalingMatrix] Initial scaling.
         * @param {Number} [size=1]
         * @param {Boolean} [childrenAlwaysInside=false]
         * @param {Boolean} [ignoreTransform=false]
         * @returns {Object3D}
         */
        function init(positionMatrix, orientationMatrix, scalingMatrix, size, childrenAlwaysInside, ignoreTransform) {
            this._parent = null;
            mat.copyTranslation4(this._positionMatrix, positionMatrix || mat.IDENTITY4);
            mat.setMatrix4(this._orientationMatrix, orientationMatrix || mat.IDENTITY4);
            mat.copyScaling4(this._scalingMatrix, scalingMatrix || mat.IDENTITY4);
            this._modelMatrixForFrame = this._modelMatrix;
            this._modelMatrixInverseForFrame = this._modelMatrixInverse;
            this._cascadeScalingMatrixValid = false;
            this._modelMatrixValid = false;
            this._modelMatrixForFrameValid = false;
            this._modelMatrixInverseValid = false;
            this._modelMatrixInverseForFrameValid = false;
            this._size = (size !== undefined) ? size : 1;
            this._insideParent = null;
            this._childrenAlwaysInside = childrenAlwaysInside || false;
            this._ignoreTransform = ignoreTransform || false;
            this._lastSizeInsideViewFrustum = {width: -1, height: -1};
            this._positionMatrixInCameraSpaceValid = false;
        }
        /**
         * Clears cache variables that store calculated values which are only valid for one frame.
         */
        function resetCachedValues() {
            this._positionMatrixInCameraSpaceValid = false;
            this._modelMatrixForFrameValid = false;
            this._modelMatrixInverseForFrameValid = false;
        }
        /**
         * Sets a new parent.
         * @param {Object3D} parent
         */
        function setParent(parent) {
            this._parent = parent;
            this._modelMatrixForFrame = (parent && !parent.shouldIgnoreTransform()) ? this._cascadedModelMatrix : this._modelMatrix;
            this._modelMatrixInverseForFrame = (parent && !parent.shouldIgnoreTransform()) ? this._cascadedModelMatrixInverse : this._modelMatrixInverse;
        }
        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        /**
         * Returns the translation matrix describing the position of the object
         * in world space.
         * @returns {Float32Array}
         */
        function getPositionMatrix() {
            return this._positionMatrix;
        }
        /**
         * Sets a new position matrix.
         * @param {Float32Array} value
         */
        function setPositionMatrix(value) {
            this._positionMatrix = value;
            this._modelMatrix[12] = this._positionMatrix[12];
            this._modelMatrix[13] = this._positionMatrix[13];
            this._modelMatrix[14] = this._positionMatrix[14];
            this._modelMatrixInverseValid = false;
            if (!this._parent || !this._parent.childrenAlwaysInside()) {
                this._insideParent = null;
            }
            this._positionMatrixInCameraSpaceValid = false;
        }
        /**
         * Returns a 3D vector describing the position.
         * @returns {Number[3]}
         */
        function getPositionVector() {
            return [
                this._positionMatrix[12],
                this._positionMatrix[13],
                this._positionMatrix[14]
            ];
        }
        /**
         * Copies the value of a 3D vector describing the position of this object to the passed vector
         * @param {Number[3]} destination 
         * @returns {Number[3]}
         */
        function copyPositionToVector(destination) {
            destination[0] = this._positionMatrix[12];
            destination[1] = this._positionMatrix[13];
            destination[2] = this._positionMatrix[14];
        }
        /**
         * Adds the value of a 3D vector describing the position of this object to the passed vector
         * @param {Number[3]} destination 
         * @returns {Number[3]}
         */
        function addPositionToVector(destination) {
            destination[0] += this._positionMatrix[12];
            destination[1] += this._positionMatrix[13];
            destination[2] += this._positionMatrix[14];
        }
        /**
         * Sets the passed vector as the new position.
         * @param {Number[3]} v
         */
        function setPositionv(v) {
            this._positionMatrix[12] = v[0];
            this._positionMatrix[13] = v[1];
            this._positionMatrix[14] = v[2];
            this._modelMatrix[12] = v[0];
            this._modelMatrix[13] = v[1];
            this._modelMatrix[14] = v[2];
            this._modelMatrixInverseValid = false;
            if (!this._parent || !this._parent.childrenAlwaysInside()) {
                this._insideParent = null;
            }
            this._positionMatrixInCameraSpaceValid = false;
        }
        /**
         * Modifies the position, setting it to the translation described by the passed matrix.
         * @param {Float32Array} m
         */
        function setPositionM4(m) {
            this._positionMatrix[12] = m[12];
            this._positionMatrix[13] = m[13];
            this._positionMatrix[14] = m[14];
            this._modelMatrix[12] = m[12];
            this._modelMatrix[13] = m[13];
            this._modelMatrix[14] = m[14];
            this._modelMatrixInverseValid = false;
            if (!this._parent || !this._parent.childrenAlwaysInside()) {
                this._insideParent = null;
            }
            this._positionMatrixInCameraSpaceValid = false;
        }
        /**
         * Translates the current position by (x;y;z).
         * @param {Number} x
         * @param {Number} y
         * @param {Number} z
         */
        function translate(x, y, z) {
            this._positionMatrix[12] += x;
            this._positionMatrix[13] += y;
            this._positionMatrix[14] += z;
            this._modelMatrix[12] += x;
            this._modelMatrix[13] += y;
            this._modelMatrix[14] += z;
            this._modelMatrixInverseValid = false;
            if (!this._parent || !this._parent.childrenAlwaysInside()) {
                this._insideParent = null;
            }
            this._positionMatrixInCameraSpaceValid = false;
        }
        /**
         * Translates the current position by the given 3D vector.
         * @param {Number[3]} v [x,y,z]
         */
        function translatev(v) {
            this._positionMatrix[12] += v[0];
            this._positionMatrix[13] += v[1];
            this._positionMatrix[14] += v[2];
            this._modelMatrix[12] += v[0];
            this._modelMatrix[13] += v[1];
            this._modelMatrix[14] += v[2];
            this._modelMatrixInverseValid = false;
            if (!this._parent || !this._parent.childrenAlwaysInside()) {
                this._insideParent = null;
            }
            this._positionMatrixInCameraSpaceValid = false;
        }
        /**
         * Translates the current position by mutliplying it by the given 
         * matrix.
         * @param {Float32Array} matrix
         */
        function translateByMatrix(matrix) {
            this._positionMatrix[12] += matrix[12];
            this._positionMatrix[13] += matrix[13];
            this._positionMatrix[14] += matrix[14];
            this._modelMatrix[12] += matrix[12];
            this._modelMatrix[13] += matrix[13];
            this._modelMatrix[14] += matrix[14];
            this._modelMatrixInverseValid = false;
            if (!this._parent || !this._parent.childrenAlwaysInside()) {
                this._insideParent = null;
            }
            this._positionMatrixInCameraSpaceValid = false;
        }
        /**
         * Translates the position to be the linear combination of the current
         * position and the one define by the passed matrix.
         * @param {Float32Array} matrix A 4x4 matrix
         * @param {Number} ratio The ratio for the linear interpolation: 0 
         * corresponds to the current, 1 to the given position
         */
        function translateTowardsM4(matrix, ratio) {
            var delta = (ratio * matrix[12]) + ((1 - ratio) * this._positionMatrix[12]) - this._positionMatrix[12];
            this._positionMatrix[12] += delta;
            this._modelMatrix[12] += delta;
            delta = (ratio * matrix[13]) + ((1 - ratio) * this._positionMatrix[13]) - this._positionMatrix[13];
            this._positionMatrix[13] += delta;
            this._modelMatrix[13] += delta;
            delta = (ratio * matrix[14]) + ((1 - ratio) * this._positionMatrix[14]) - this._positionMatrix[14];
            this._positionMatrix[14] += delta;
            this._modelMatrix[14] += delta;
            this._modelMatrixInverseValid = false;
            if (!this._parent || !this._parent.childrenAlwaysInside()) {
                this._insideParent = null;
            }
            this._positionMatrixInCameraSpaceValid = false;
        }
        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        /**
         * Returns the rotation matrix describing the orientation of the object.
         * * @returns {Float32Array}
         */
        function getOrientationMatrix() {
            return this._orientationMatrix;
        }
        /**
         * Sets a new orientation matrix.
         * @param {Float32Array} value
         */
        function setOrientationMatrix(value) {
            if (value) {
                this._orientationMatrix = value;
            }
            this._modelMatrixValid = false;
            this._modelMatrixInverseValid = false;
            if (this._handleOrientationChanged) {
                this._handleOrientationChanged();
            }
        }
        /**
         * Sets the orientation to be the one described by the passed 4x4 matrix.
         * @param {Float32Array} m
         */
        function setOrientationM4(m) {
            mat.setMatrix4(this._orientationMatrix, m);
            this._modelMatrixValid = false;
            this._modelMatrixInverseValid = false;
            if (this._handleOrientationChanged) {
                this._handleOrientationChanged();
            }
        }
        /**
         * Returns the 3D vector corresponding to the X axis of the current
         * orientation.
         * @returns {Number[3]}
         */
        function getXDirectionVector() {
            return [
                this._orientationMatrix[0],
                this._orientationMatrix[1],
                this._orientationMatrix[2]
            ];
        }
        /**
         * Returns the 3D vector corresponding to the Y axis of the current
         * orientation.
         * @returns {Number[3]}
         */
        function getYDirectionVector() {
            return [
                this._orientationMatrix[4],
                this._orientationMatrix[5],
                this._orientationMatrix[6]
            ];
        }
        /**
         * Returns the 3D vector corresponding to the Z axis of the current
         * orientation.
         * @returns {Number[3]}
         */
        function getZDirectionVector() {
            return [
                this._orientationMatrix[8],
                this._orientationMatrix[9],
                this._orientationMatrix[10]
            ];
        }
        /**
         * Rotates the current orientation around the given axis by the given
         * angle.
         * @param {Number[3]} axis The 3D vector of the axis.
         * @param {Number} angle Angle in radians.
         */
        function rotate(axis, angle) {
            if (angle !== 0) {
                mat.rotate4(this._orientationMatrix, axis, angle);
                this.setOrientationMatrix();
            }
        }
        /**
         * Rotates the current orientation by multiplying it by the given 
         * 4x4 rotation matrix.
         * @param {Float32Array} matrix
         */
        function rotateByMatrix(matrix) {
            mat.mulRotationRotation4(this._orientationMatrix, matrix);
            this.setOrientationMatrix();
        }
        /**
         * Rotates the current orientation by multiplying it by the given 
         * 3x3 rotation matrix.
         * @param {Float32Array} matrix
         */
        function rotateByMatrix3(matrix) {
            mat.mulRotation43(this._orientationMatrix, matrix);
            this.setOrientationMatrix();
        }
        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        /**
         * Returns the scaling matrix describing the size of the object. 
         * * @returns {Float32Array}
         */
        function getScalingMatrix() {
            return this._scalingMatrix;
        }
        /**
         * Sets a new scaling matrix.
         * @param {Float32Array} value
         */
        function setScalingMatrix(value) {
            if (value) {
                this._scalingMatrix = value;
            }
            this._modelMatrixValid = false;
            this._modelMatrixInverseValid = false;
            this._cascadeScalingMatrixValid = false;
        }
        /**
         * A convenience method to set uniform scaling
         * @param {Number} scale The scaling to apply to all 3 axes
         */
        function setScale(scale) {
            this._scalingMatrix[0] = scale;
            this._scalingMatrix[5] = scale;
            this._scalingMatrix[10] = scale;
            this.setScalingMatrix();
        }
        /**
         * Returns a scaling matrix corresponding to the stacked scaling applied
         * on this object originating both from its parents' and own scaling.
         * @returns {Float32Array}
         */
        function getCascadeScalingMatrix() {
            if (!this._cascadeScalingMatrixValid) {
                if (this._parent && !this._parent.shouldIgnoreTransform()) {
                    mat.setScalingToProdScalingScaling4(this._cascadeScalingMatrix, this._parent.getCascadeScalingMatrix(), this._scalingMatrix);
                } else {
                    mat.copyScaling4(this._cascadeScalingMatrix, this._scalingMatrix);
                }
                this._cascadeScalingMatrixValid = true;
            }
            return this._cascadeScalingMatrix;
        }
        //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        /**
         * Returns the calculated combined model matrix of this object (and its parents). Uses cache.
         * @returns {Float32Array}
         */
        function getModelMatrix() {
            if (!this._modelMatrixForFrameValid) {
                if (!this._modelMatrixValid) {
                    mat.setModelMatrix(this._modelMatrix, this._positionMatrix, this._orientationMatrix, this._scalingMatrix);
                    this._modelMatrixValid = true;
                }
                if (this._parent && !this._parent.shouldIgnoreTransform()) {
                    mat.setProd4NoProj(this._cascadedModelMatrix, this._modelMatrix, this._parent.getModelMatrix());
                }
                this._modelMatrixForFrameValid = true;
            }
            return this._modelMatrixForFrame;
        }
        /**
         * Returns the calculated inverse of the combined model matrix of this object (and its parents). Uses cache.
         * @returns {Float32Array}
         */
        function getModelMatrixInverse() {
            if (!this._modelMatrixInverseForFrameValid) {
                if (!this._modelMatrixInverseValid) {
                    mat.setInverse4(this._modelMatrixInverse, this.getModelMatrix());
                    this._modelMatrixInverseValid = true;
                }
                if (this._parent && !this._parent.shouldIgnoreTransform()) {
                    mat.setProd4NoProj(this._cascadedModelMatrixInverse, this._parent.getModelMatrixInverse(), this._modelMatrixInverse);
                }
                this._modelMatrixInverseForFrameValid = true;
            }
            return this._modelMatrixInverseForFrame;
        }
        /**
         * Returns the size of this object.
         * @returns {Number}
         */
        function getSize() {
            return this._size;
        }
        /**
         * Sets a new explicit size for this object
         * @param {Number} value
         */
        function setSize(value) {
            this._size = value;
        }
        /**
         * Returns the size of this object in world space, accounting for all 
         * the scaling.
         * @returns {Number}
         */
        function getScaledSize() {
            return this.getSize() * this.getCascadeScalingMatrix()[0];
        }
        /**
         * Returns whether the object is situated within the boundaries of its
         * parent. Uses cache.
         * @returns {Boolean}
         */
        function isInsideParent() {
            if (this._insideParent === null) {
                this._insideParent = this._parent ?
                        (this._parent.childrenAlwaysInside() || (
                                (Math.abs(this.getPositionMatrix()[12]) < this._parent.getSize()) &&
                                (Math.abs(this.getPositionMatrix()[13]) < this._parent.getSize()) &&
                                (Math.abs(this.getPositionMatrix()[14]) < this._parent.getSize())))
                        : false;
            }
            return this._insideParent;
        }
        /**
         * Returns whether children of this object should always be considered as being inside of it (within its bounds)
         * @returns {Boolean}
         */
        function childrenAlwaysInside() {
            return this._childrenAlwaysInside;
        }
        /**
         * Returns position matrix transformed into camera space using the passed camera.
         * Within one frame, the value is cached to avoid calculating it multiple times
         * for the same camera.
         * @param {Camera} camera
         * @returns {Float32Array}
         */
        function getPositionMatrixInCameraSpace(camera) {
            if (!this._positionMatrixInCameraSpaceValid) {
                mat.updateTranslation4v(this._positionMatrixInCameraSpace, vec.prodTranslationModel3Aux(this.getModelMatrix(), camera.getViewMatrix()));
                this._positionMatrixInCameraSpaceValid = true;
            }
            return this._positionMatrixInCameraSpace;
        }
        /**
         * Checks if the object is inside the viewing frustum of the passed camera, taking into account the parents of the object as well. 
         * Also sets the view width and height members of the object to cache them for the current frame.
         * @param {Camera} camera The camera the frustum of which is to be checked
         * @param {Boolean} [checkNearAndFarPlanes=false] Whether to check if the object is between the near and far cutting planes of the 
         * frustum - this is disabled by default as this easier check is normally done separately in advance to organize the objects into
         * rendering queues by distance.
         * @returns {Object} 
         */
        function getSizeInsideViewFrustum(camera, checkNearAndFarPlanes) {
            var size, scalingMatrix, baseMatrix, projMatrix, positionX, positionY, xOffset, yOffset, factor;
            // scaling and orientation is lost here, since we create a new translation matrix based on the original transformation
            baseMatrix = this.getPositionMatrixInCameraSpace(camera);
            if (baseMatrix[14] !== 0) {
                scalingMatrix = this.getCascadeScalingMatrix();
                // frustum culling: back and front
                if (checkNearAndFarPlanes) {
                    size = this.getSize() * scalingMatrix[0];
                    if ((baseMatrix[14] - size >= -camera.getNearDistance()) || ((baseMatrix[14] + size) < -camera.getViewDistance())) {
                        this._lastSizeInsideViewFrustum.width = 0;
                        this._lastSizeInsideViewFrustum.height = 0;
                        return this._lastSizeInsideViewFrustum;
                    }
                }
                // we reintroduce appropriate scaling, but not the orientation, so 
                // we can check border points of the properly scaled model, but translated
                // along the axes of the camera space
                projMatrix = camera.getProjectionMatrix();
                size = this.getSize();
                factor = -1 / baseMatrix[14];
                positionX = baseMatrix[12] * projMatrix[0] * factor;
                positionY = baseMatrix[13] * projMatrix[5] * factor;
                // Z coordinate is not needed
                // frustum culling: sides
                xOffset = Math.abs(scalingMatrix[0] * projMatrix[0] * size * factor);
                yOffset = Math.abs(scalingMatrix[5] * projMatrix[5] * size * factor);
                if (!((positionX + xOffset < -1) || (positionX - xOffset > 1)) &&
                        !((positionY + yOffset < -1) || (positionY - yOffset > 1))) {
                    this._lastSizeInsideViewFrustum.width = xOffset;
                    this._lastSizeInsideViewFrustum.height = yOffset;
                    return this._lastSizeInsideViewFrustum;
                }
            }
            this._lastSizeInsideViewFrustum.width = 0;
            this._lastSizeInsideViewFrustum.height = 0;
            return this._lastSizeInsideViewFrustum;
        }
        /**
         * Returns whether the object (or at least a part of it) lies within a specific shadow map region.
         * @param {DirectionalLight} light The currently rendered shadow map of this light will be considered
         * @returns {Boolean}
         */
        function isInsideShadowRegion(light) {
            return light.isInsideCurrentMap(this.getModelMatrix(), this.getScaledSize());
        }
        /**
         * If returns true, the transforms of this object should be ignored when calculating its children's model matrix.
         * @returns {Boolean}
         */
        function shouldIgnoreTransform() {
            return this._ignoreTransform;
        }
        // interface of an Object3D mixin
        return function () {
            this.prototype.init = init;
            this.prototype.resetCachedValues = resetCachedValues;
            this.prototype.setParent = setParent;
            this.prototype.getPositionMatrix = getPositionMatrix;
            this.prototype.setPositionMatrix = setPositionMatrix;
            this.prototype.setPositionv = setPositionv;
            this.prototype.setPositionM4 = setPositionM4;
            this.prototype.getOrientationMatrix = getOrientationMatrix;
            this.prototype.setOrientationMatrix = setOrientationMatrix;
            this.prototype.setOrientationM4 = setOrientationM4;
            this.prototype.getScalingMatrix = getScalingMatrix;
            this.prototype.setScalingMatrix = setScalingMatrix;
            this.prototype.setScale = setScale;
            this.prototype.getPositionVector = getPositionVector;
            this.prototype.copyPositionToVector = copyPositionToVector;
            this.prototype.addPositionToVector = addPositionToVector;
            this.prototype.translate = translate;
            this.prototype.translatev = translatev;
            this.prototype.translateByMatrix = translateByMatrix;
            this.prototype.translateTowardsM4 = translateTowardsM4;
            this.prototype.getXDirectionVector = getXDirectionVector;
            this.prototype.getYDirectionVector = getYDirectionVector;
            this.prototype.getZDirectionVector = getZDirectionVector;
            this.prototype.rotate = rotate;
            this.prototype.rotateByMatrix = rotateByMatrix;
            this.prototype.rotateByMatrix3 = rotateByMatrix3;
            this.prototype.getCascadeScalingMatrix = getCascadeScalingMatrix;
            this.prototype.getModelMatrix = getModelMatrix;
            this.prototype.getModelMatrixInverse = getModelMatrixInverse;
            this.prototype.getSize = getSize;
            this.prototype.setSize = setSize;
            this.prototype.getScaledSize = getScaledSize;
            this.prototype.isInsideParent = isInsideParent;
            this.prototype.childrenAlwaysInside = childrenAlwaysInside;
            this.prototype.getPositionMatrixInCameraSpace = getPositionMatrixInCameraSpace;
            this.prototype.getSizeInsideViewFrustum = getSizeInsideViewFrustum;
            this.prototype.isInsideShadowRegion = isInsideShadowRegion;
            this.prototype.shouldIgnoreTransform = shouldIgnoreTransform;
        };
    };
    makeObject3DMixinClass = makeObject3DMixinClassFunction();
    makeObject3DMixinClass.call(Object3D);
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        Object3D: Object3D,
        makeObject3DMixinClass: makeObject3DMixinClass
    };
});
/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides a capable camera class to use with scenes.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Float32Array, Int32Array */

/**
 * @param utils Used for array equality check.
 * @param vec Used for 3D (and 4D) vector operations.
 * @param mat Used for 3D (and 4D) matrix operations.
 * @param application Used for displaying errors and logging (and intentional crashing)
 * @param object3D The Camera is an Object3D mixin class
 */
define('modules/scene/camera',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/scene/object-3d"
], function (utils, vec, mat, application, object3D) {
    "use strict";
    // ----------------------------------------------------------------------
    // constants
    var
            /**
             * The minimum alpha angle for FPS-mode camera configurations that were created without specifying it
             * @type Number
             */
            DEFAULT_MIN_ALPHA = -360,
            /**
             * The maximum alpha angle for FPS-mode camera configurations that were created without specifying it
             * @type Number
             */
            DEFAULT_MAX_ALPHA = 360,
            /**
             * The minimum beta angle for FPS-mode camera configurations that were created without specifying it
             * @type Number
             */
            DEFAULT_MIN_BETA = -90,
            /**
             * The maximum beta angle for FPS-mode camera configurations that were created without specifying it
             * @type Number
             */
            DEFAULT_MAX_BETA = 90,
            /**
             * When decreased by one step, the field of view of a camera will be multiplied by this factor
             * @type Number
             */
            FOV_DECREASE_FACTOR = 0.95,
            /**
             * When increased by one step, the field of view of a camera will be multiplied by this factor
             * @type Number
             */
            FOV_INCREASE_FACTOR = 1.05,
            /**
             * The camera used for rendering the distance render queues will have a view distance that is the view distance of the regular
             * camera multiplied by this factor.
             * @type Number
             */
            CAMERA_EXTENSION_FACTOR = 5,
            /**
             * Half of the default interocular distance for stereoscopic cameras, in meters.
             * @type Number
             */
            DEFAULT_INTEROCULAR_HALF_DISTANCE = 0.0635 / 1.5,
            /**
             * Default distance of the convergence point from the camera position for stereoscopic cameras, in meters.
             * @type Number
             */
            DEFAULT_STEREOSCOPIC_CONVERGENCE_DISTANCE = 20;
    // #########################################################################
    /**
     * @class This class can update and compute the world position of a camera based on the related configuration settings, which it stores.
     * @param {Boolean} fixed Whether the camera position should be locked and not be movable by the user
     * @param {Boolean} turnsAroundObjects If true, the camera position can be changed by rotating it, as it will be calculated relative to
     * the followed object(s) and the orientation of the camera. If not fixed, "zooming" on a straight line towards/away from the object(s)
     * is possible as well
     * @param {Boolean} movesRelativeToObject If true, the movement of the camera will happen along the axes of the orientation of the first
     * followed object (if any)
     * @param {Object3D[]} followedObjects The list of objects the camera's position should follow. Setting no objects means the set 
     * position is absolute, setting multiple objects means the average of their positions will be followed.
     * @param {Boolean} startsWithRelativePosition Whether only at the start and at default resets should the position be calculated as
     * relative (and not follow the followed objects continuously)
     * @param {Float32Array} positionMatrix The set position. Might mean the absolute (world) or relative position depending on other settings.
     * The final world position is always calculated and not set.
     * @param {Number[2]} distanceRange If the camera turns around the followed objects and it is not fixed, this is the range in which the
     * distance from the objects is allowed to change
     * @param {Number[3][2]} [confines] If given, the movement of the camera will be limited to the specified ranges on the 3 axes, 
     * respectively. It is possible to specify confinement on select axes only, in which case null should be passed as range for the other
     * axes.
     * @param {Boolean} resetsWhenLeavingConfines Whether a reset to defaults should automatically be called whenever the camera position 
     * leaves the area determined by its confines (distance, X, Y or Z)
     * @param {Boolean} [isTransitionConfiguration=false] If true, the configuration will serve as a suitable starting point for 
     * transitions, as it will not perform major updates (resets, changes) and the checks necessary for them (confine checks, object 
     * cleanup). Such a copy can be made from a configuration and then use it to transition to the regular configuration which gets properly
     * updated to provide a smooth transition between the non-updated and updated state
     */
    function CameraPositionConfiguration(fixed, turnsAroundObjects, movesRelativeToObject, followedObjects, startsWithRelativePosition, positionMatrix, distanceRange, confines, resetsWhenLeavingConfines, isTransitionConfiguration) {
        /**
         * If true, the camera position can't be controlled by the player, but is automatically
         * calculated. The absolute position might still change e.g. if it is relative to objects
         * in the scene.
         * @type Boolean
         */
        this._fixed = fixed;
        /**
         * If true, the position is relative not just to the position of the followed point, but also
         * to the direction that the camera points towards - if the orientation of the camera changes,
         * the position is recalculated, turning around the followed point.
         * @type Boolean
         */
        this._turnsAroundObjects = turnsAroundObjects;
        /**
         * If true, the movement of the camera will happen along the axes of the orientation of the first
         * followed object (if any)
         */
        this._movesRelativeToObject = movesRelativeToObject;
        /**
         * The list of objects the camera is following. If empty, the camera is free to move around
         * or has a constant absolute position if fixed. If more than one object is in the list, the camera
         * follows the point in space which is the average of the positions of the objects.
         * @type Object3D[]
         */
        this._followedObjects = followedObjects || [];
        /**
         * If true, the given position is taken as relative to the followed object(s), but only at the first step after setting this 
         * configuration for a new camera or resetting the configuration. After that, instead of following the objects using a relative
         * position, it will switch to world-position (absolute) mode, and stay at the same place (or can be moved from it)
         * @type Boolean
         */
        this._startsWithRelativePosition = startsWithRelativePosition;
        /**
         * Stores a copy of the starting relative position matrix so it can be reset to it later.
         * @type Float32Array
         */
        this._defaultRelativePositionMatrix = mat.matrix4(positionMatrix);
        /**
         * Describes the relative position stored in this configuration. Not the same as the world position of the camera
         * itself, as it can be relative to followed objects and the camera direction.
         * @type Float32Array
         */
        this._relativePositionMatrix = positionMatrix;
        /**
         * Describes the position of the camera in the world. This is calculated based on the other
         * properties and cannot be set directly.
         * @type Float32Array
         */
        this._worldPositionMatrix = mat.identity4();
        /**
         * Whether the currently stored world position matrix is up-to-date for the current frame.
         * @type Boolean
         */
        this._worldPositionMatrixValid = false;
        /**
         * Whether the distance from the followed objects is confined to certain limits
         * @type Boolean
         */
        this._distanceIsConfined = distanceRange ? true : false;
        /**
         * If objects are followed and turnsAroundObjects is true, movement of the camera is possible by "zooming", bringing it closer
         * or farther to the followed objects on a straight line (the direction of which is based on the position matrix).
         * This value marks the closest distance.
         * @type Number
         */
        this._minimumDistance = distanceRange ? distanceRange[0] : 0;
        /**
         * See minimum distance for detailed explanation. This value marks the maximum distance. 
         * @type Number
         */
        this._maximumDistance = distanceRange ? distanceRange[1] : 0;
        /**
         * Whether the movement of the camera is limited to a certain range on axis X
         * @type Boolean
         */
        this._xIsConfined = (confines && confines[0]) ? true : false;
        /**
         * The minimum value of the X coordinate of the camera, if confined on axis X
         * @type Number
         */
        this._minimumX = (confines && confines[0]) ? confines[0][0] : 0;
        /**
         * The maximum value of the X coordinate of the camera, if confined on axis X
         * @type Number
         */
        this._maximumX = (confines && confines[0]) ? confines[0][1] : 0;
        /**
         * Whether the movement of the camera is limited to a certain range on axis Y
         * @type Boolean
         */
        this._yIsConfined = (confines && confines[1]) ? true : false;
        /**
         * The minimum value of the Y coordinate of the camera, if confined on axis Y
         * @type Number
         */
        this._minimumY = (confines && confines[1]) ? confines[1][0] : 0;
        /**
         * The maximum value of the Y coordinate of the camera, if confined on axis Y
         * @type Number
         */
        this._maximumY = (confines && confines[1]) ? confines[1][1] : 0;
        /**
         * Whether the movement of the camera is limited to a certain range on axis Z
         * @type Boolean
         */
        this._zIsConfined = (confines && confines[2]) ? true : false;
        /**
         * The minimum value of the Z coordinate of the camera, if confined on axis Z
         * @type Number
         */
        this._minimumZ = (confines && confines[2]) ? confines[2][0] : 0;
        /**
         * The maximum value of the Z coordinate of the camera, if confined on axis Z
         * @type Number
         */
        this._maximumZ = (confines && confines[2]) ? confines[2][1] : 0;
        /**
         * Whether a reset to defaults should automatically be called whenever the camera position leaves the area determined by its 
         * confines (distance, X, Y or Z)
         * @type Boolean
         */
        this._resetsWhenLeavingConfines = resetsWhenLeavingConfines;
        /**
         * If true, the configuration serves as a suitable starting point for transitions, as it will not perform major updates (resets, 
         * changes) and the checks necessary for them (confine checks, object cleanup). 
         */
        this._isTransitionConfiguration = isTransitionConfiguration;
        /**
         * Whether the current (next) simulation step is a starting step
         * @type Boolean
         */
        this._isStarting = true;
        /**
         * A reference to the camera that currently uses this position configuration
         * @type Camera
         */
        this._camera = null;
    }
    /**
     * Initializes all properties of this camera position configuration
     * @param {Boolean} fixed Whether the camera position should be locked and not be movable by the user
     * @param {Boolean} turnsAroundObjects If true, the camera position can be changed by rotating it, as it will be calculated relative to
     * the followed object(s) and the orientation of the camera. If not fixed, "zooming" on a straight line towards/away from the object(s)
     * is possible as well
     * @param {Boolean} movesRelativeToObject If true, the movement of the camera will happen along the axes of the orientation of the first
     * followed object (if any)
     * @param {Object3D[]} followedObjects The list of objects the camera's position should follow. Setting no objects means the set 
     * position is absolute, setting multiple objects means the average of their positions will be followed.
     * @param {Boolean} startsWithRelativePosition Whether only at the start and at default resets should the position be calculated as
     * relative (and not follow the followed objects continuously)
     * @param {Float32Array} positionMatrix The set position. Might mean the absolute (world) or relative position depending on other settings.
     * The final world position is always calculated and not set.
     * @param {Number[2]} distanceRange If the camera turns around the followed objects and it is not fixed, this is the range in which the
     * distance from the objects is allowed to change
     * @param {Number[3][2]} [confines] If given, the movement of the camera will be limited to the specified ranges on the 3 axes, 
     * respectively. It is possible to specify confinement on select axes only, in which case null should be passed as range for the other
     * axes.
     * @param {Boolean} resetsWhenLeavingConfines Whether a reset to defaults should automatically be called whenever the camera position 
     * leaves the area determined by its confines (distance, X, Y or Z)
     * @param {Boolean} [isTransitionConfiguration=false] If true, the configuration will serve as a suitable starting point for 
     * transitions, as it will not perform major updates (resets, changes) and the checks necessary for them (confine checks, object 
     * cleanup). Such a copy can be made from a configuration and then use it to transition to the regular configuration which gets properly
     * updated to provide a smooth transition between the non-updated and updated state
     */
    CameraPositionConfiguration.prototype.init = function (fixed, turnsAroundObjects, movesRelativeToObject, followedObjects, startsWithRelativePosition, positionMatrix, distanceRange, confines, resetsWhenLeavingConfines, isTransitionConfiguration) {
        this._fixed = fixed;
        this._turnsAroundObjects = turnsAroundObjects;
        this._movesRelativeToObject = movesRelativeToObject;
        this._followedObjects = followedObjects || [];
        this._startsWithRelativePosition = startsWithRelativePosition;
        mat.setMatrix4(this._defaultRelativePositionMatrix, positionMatrix);
        mat.setMatrix4(this._relativePositionMatrix, positionMatrix);
        mat.setIdentity4(this._worldPositionMatrix);
        this._worldPositionMatrixValid = false;
        this._distanceIsConfined = distanceRange ? true : false;
        this._minimumDistance = distanceRange ? distanceRange[0] : 0;
        this._maximumDistance = distanceRange ? distanceRange[1] : 0;
        this._xIsConfined = (confines && confines[0]) ? true : false;
        this._minimumX = (confines && confines[0]) ? confines[0][0] : 0;
        this._maximumX = (confines && confines[0]) ? confines[0][1] : 0;
        this._yIsConfined = (confines && confines[1]) ? true : false;
        this._minimumY = (confines && confines[1]) ? confines[1][0] : 0;
        this._maximumY = (confines && confines[1]) ? confines[1][1] : 0;
        this._zIsConfined = (confines && confines[2]) ? true : false;
        this._minimumZ = (confines && confines[2]) ? confines[2][0] : 0;
        this._maximumZ = (confines && confines[2]) ? confines[2][1] : 0;
        this._resetsWhenLeavingConfines = resetsWhenLeavingConfines;
        this._isTransitionConfiguration = isTransitionConfiguration;
        this._isStarting = true;
        this._camera = null;
    };
    /**
     * Returns a camera position configuration with the same settings as this one, cloning referenced values to make sure changes to this
     * configuration do not affect the created copy.
     * @param {Boolean} [transitionCopy=false] Create a copy that serves as a transition configuration (not doing object cleanup, confine
     * checks, only regular following of position)
     * @returns {CameraPositionConfiguration}
     */
    CameraPositionConfiguration.prototype.copy = function (transitionCopy) {
        var result = new CameraPositionConfiguration(
                this._fixed,
                this._turnsAroundObjects,
                this._movesRelativeToObject,
                this._followedObjects.slice(),
                this._startsWithRelativePosition,
                mat.matrix4(this._defaultRelativePositionMatrix),
                this._distanceIsConfined ? [this._minimumDistance, this._maximumDistance] : null,
                [
                    this._xIsConfined ? [this._minimumX, this._maximumX] : null,
                    this._yIsConfined ? [this._minimumY, this._maximumY] : null,
                    this._zIsConfined ? [this._minimumZ, this._maximumZ] : null
                ],
                this._resetsWhenLeavingConfines,
                transitionCopy);
        result._relativePositionMatrix = mat.matrix4(this._relativePositionMatrix);
        result._worldPositionMatrix = mat.matrix4(this._worldPositionMatrix);
        result._isStarting = this._isStarting;
        return result;
    };
    /**
     * Sets the reference to the camera currently using this position configuration. Configurations with relative starting position are 
     * automatically reset when a new camera is assigned to them, so that they start from a refreshed relative position
     * @param {Camera} value
     * @param {Boolean} [doNotReset=false] If true, the automatic configuration reset will be suppressed 
     */
    CameraPositionConfiguration.prototype.setCamera = function (value, doNotReset) {
        if (value && (this._camera !== value) && this._startsWithRelativePosition && !doNotReset) {
            this.resetToDefaults(true);
        }
        this._camera = value;
    };
    /**
     * Resets the configuration to its initial state.
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this reset
     */
    CameraPositionConfiguration.prototype.resetToDefaults = function (doNotNotifyCamera) {
        if (this._camera && !doNotNotifyCamera) {
            this._camera.positionConfigurationWillChange();
        }
        mat.setMatrix4(this._relativePositionMatrix, this._defaultRelativePositionMatrix);
        this._worldPositionMatrixValid = false;
        this._isStarting = true;
    };
    /**
     * Directly sets a new relative position matrix for this configuration.
     * @param {Float32Array} value A 4x4 translation matrix.
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraPositionConfiguration.prototype.setRelativePositionMatrix = function (value, doNotNotifyCamera) {
        if (this._camera && !doNotNotifyCamera) {
            this._camera.positionConfigurationWillChange();
        }
        this._relativePositionMatrix = value;
    };
    /**
     * Moves the relative position of the configuration by the passed 3D vector.
     * @param {Number[3]} vector
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraPositionConfiguration.prototype.moveByVector = function (vector, doNotNotifyCamera) {
        if (this._camera && !doNotNotifyCamera) {
            this._camera.positionConfigurationWillChange();
        }
        mat.translateByVector(this._relativePositionMatrix, vector);
    };
    /**
     * If no parameter is given, returns whether the configuration is set to follow any objects. If a list of objects is given, returns 
     * whether this conifugation is set to follow the same list of objects.
     * @param {Object3D[]} [objects]
     * @returns {Boolean}
     */
    CameraPositionConfiguration.prototype.followsObjects = function (objects) {
        return objects ?
                utils.arraysEqual(this._followedObjects.sort(), objects.sort()) :
                ((this._followedObjects.length > 0) && !this._startsWithRelativePosition);
    };
    /**
     * Returns the 3D vector describing the current location in space that is tracked by this camera configuration.
     * The result is not a reference to any actually tracked vector, but a copy describing the current location.
     * @returns {Number[3]}
     */
    CameraPositionConfiguration.prototype.getFollowedPositionVector = function () {
        var i, positionVector = [0, 0, 0];
        if (this._followedObjects.length === 0) {
            application.crash();
        } else {
            for (i = 0; i < this._followedObjects.length; i++) {
                this._followedObjects[i].addPositionToVector(positionVector);
            }
            positionVector = [
                positionVector[0] / this._followedObjects.length,
                positionVector[1] / this._followedObjects.length,
                positionVector[2] / this._followedObjects.length
            ];
        }
        return positionVector;
    };
    /**
     * Returns the 4x4 translation matrix describing the current location in space that is tracked by this camera configuration.
     * The result is not a reference to any actually tracked matrix, but a copy describing the current location.
     * @returns {Float32Array}
     */
    CameraPositionConfiguration.prototype.getFollowedPositionMatrix = function () {
        var i, positionMatrix = mat.identity4Aux();
        if (this._followedObjects.length === 0) {
            application.crash();
        } else {
            for (i = 0; i < this._followedObjects.length; i++) {
                mat.translateByMatrix(positionMatrix, this._followedObjects[i].getPositionMatrix());
            }
            positionMatrix = mat.translation4Aux(
                    positionMatrix[12] / this._followedObjects.length,
                    positionMatrix[13] / this._followedObjects.length,
                    positionMatrix[14] / this._followedObjects.length);
        }
        return positionMatrix;
    };
    /**
     * Returns the orientation matrix of the first followed object. This is necessary for calculating the relative portion of the position
     * as well as if the orientation following is set to FPS-mode with a coordinate system relative to the position-followed object.
     * @returns {Float32Array}
     */
    CameraPositionConfiguration.prototype.getFollowedObjectOrientationMatrix = function () {
        if (this._followedObjects.length === 0) {
            application.crash();
            return null;
        }
        return this._followedObjects[0].getOrientationMatrix();
    };
    /**
     * Removes the destroyed objects from the list of followed objects.
     */
    CameraPositionConfiguration.prototype._cleanupFollowedObjects = function () {
        var i, j, k;
        for (i = 0; i < this._followedObjects.length; i++) {
            j = i;
            k = 0;
            while ((j < this._followedObjects.length) && ((!this._followedObjects[j]) || (this._followedObjects[j].canBeReused() === true))) {
                j++;
                k++;
            }
            if (k > 0) {
                this._followedObjects.splice(i, k);
                if (this._followedObjects.length === 0) {
                    mat.setMatrix4(this._relativePositionMatrix, (this._worldPositionMatrixValid && this._worldPositionMatrix) || this._relativePositionMatrix || this._defaultRelativePositionMatrix);
                }
            }
        }
    };
    /**
     * Calculates and updates the internally stored world position matrix (which is nulled out automatically whenever one of the values it 
     * depends on changes, therefore serving as a cache variable)
     * @param {Float32Array} worldOrientationMatrix The current orientation of the camera in world coordinates - needed for configurations
     * that turn around the followed object, as in those cases the relative portion of the position is calculated based on it
     */
    CameraPositionConfiguration.prototype._calculateWorldPositionMatrix = function (worldOrientationMatrix) {
        if ((this._followedObjects.length > 0) && (!this._startsWithRelativePosition || this._isStarting)) {
            this._isStarting = false;
            if (!this._turnsAroundObjects) {
                mat.setTranslatedByM4(this._worldPositionMatrix,
                        mat.translation4m4Aux(mat.prodTranslationRotation4Aux(
                                this._relativePositionMatrix,
                                this.getFollowedObjectOrientationMatrix())),
                        this.getFollowedPositionMatrix());
            } else {
                if (!worldOrientationMatrix) {
                    application.crash();
                } else {
                    mat.setTranslatedByM4(this._worldPositionMatrix,
                            mat.translation4m4Aux(mat.prodTranslationRotation4Aux(
                                    this._relativePositionMatrix,
                                    mat.prod3x3SubOf4Aux(mat.ROTATION_X_90, worldOrientationMatrix))),
                            this.getFollowedPositionMatrix());
                }
            }
            if (this._startsWithRelativePosition) {
                mat.setMatrix4(this._relativePositionMatrix, this._worldPositionMatrix);
            }
        } else {
            mat.setMatrix4(this._worldPositionMatrix, this._relativePositionMatrix);
        }
        this._worldPositionMatrixValid = true;
    };
    /**
     * If not cached, calculates, and returns the translation matrix describing the current location of the camera in world coordinates.
     * @param {Float32Array} worldOrientationMatrix The current orientation of the camera in world coordinates - needed for configurations
     * that turn around the followed object, as in those cases the relative portion of the position is calculated based on it
     * @returns {Float32Array}
     */
    CameraPositionConfiguration.prototype.getWorldPositionMatrix = function (worldOrientationMatrix) {
        if (!this._worldPositionMatrixValid) {
            this._calculateWorldPositionMatrix(worldOrientationMatrix);
        }
        return this._worldPositionMatrix;
    };
    /**
     * Checks whether the configuration's position is outside the set confines, and if it is, either constraints them or resets the defaults
     * (if that option is set)
     * @param {Number[3]} [orientationFollowedObjectsPositionVector] The position vector of the object(s) followed by orientation.
     * If there is no object followed by position, then distance confines will be applied to the object(s) followed by orientation (if any)
     * @return {Boolean} Whether the position has passed all the confine checks.
     */
    CameraPositionConfiguration.prototype._checkConfines = function (orientationFollowedObjectsPositionVector) {
        var translationVector, distance, relativePositionMatrix;
        // if the position is only taken as relative at the start, then the stored relative position will actually be the world position,
        // so we need to transform it back to the actual relative position, before checking the limits
        if (this._startsWithRelativePosition && (!this._isStarting) && (this._followedObjects.length > 0)) {
            relativePositionMatrix = mat.translation4m4Aux(mat.prodTranslationRotation4Aux(
                    mat.translatedByM4Aux(
                            this._relativePositionMatrix,
                            mat.inverseOfTranslation4Aux(this.getFollowedPositionMatrix())),
                    mat.inverseOfRotation4Aux(this.getFollowedObjectOrientationMatrix())));
        } else {
            relativePositionMatrix = this._relativePositionMatrix;
        }
        // the checks start here
        if (this._distanceIsConfined) {
            if (this._followedObjects.length > 0) {
                translationVector = mat.translationVector3(relativePositionMatrix);
                distance = vec.extractLength3(translationVector);
                if ((distance < this._minimumDistance) || (distance > this._maximumDistance)) {
                    if ((distance > this._maximumDistance) && (this._resetsWhenLeavingConfines)) {
                        this.resetToDefaults();
                        return false;
                    }
                    distance = Math.min(Math.max(distance, this._minimumDistance), this._maximumDistance);
                    relativePositionMatrix = mat.translation4vAux(vec.scale3(translationVector, distance));
                }
                // if the position is absolute, we will do the distance range check from the orientation followed object (if any)
            } else if (orientationFollowedObjectsPositionVector) {
                translationVector = vec.diff3Aux(mat.translationVector3(relativePositionMatrix), orientationFollowedObjectsPositionVector);
                distance = vec.extractLength3(translationVector);
                if ((distance < this._minimumDistance) || (distance > this._maximumDistance)) {
                    if ((distance > this._maximumDistance) && (this._resetsWhenLeavingConfines)) {
                        // if we have absolute position and a distance confined for the orientation followed object, a reset is not possible
                        // as it would set an absolute position again which might be out of confines since it does not depend on the position
                        // of the orientation followed object
                        application.crash();
                        return false;
                    }
                    distance = Math.min(Math.max(distance, this._minimumDistance), this._maximumDistance);
                    relativePositionMatrix = mat.translation4vAux(vec.sum3(orientationFollowedObjectsPositionVector, vec.scale3(translationVector, distance)));
                }
            }
        }
        if (this._xIsConfined) {
            if ((relativePositionMatrix[12] < this._minimumX) || (relativePositionMatrix[12] > this._maximumX)) {
                if (this._resetsWhenLeavingConfines) {
                    this.resetToDefaults();
                    return false;
                }
                relativePositionMatrix[12] = Math.min(Math.max(relativePositionMatrix[12], this._minimumX), this._maximumX);
            }
        }
        if (this._yIsConfined) {
            if ((relativePositionMatrix[13] < this._minimumY) || (relativePositionMatrix[13] > this._maximumY)) {
                if (this._resetsWhenLeavingConfines) {
                    this.resetToDefaults();
                    return false;
                }
                relativePositionMatrix[13] = Math.min(Math.max(relativePositionMatrix[13], this._minimumY), this._maximumY);
            }
        }
        if (this._zIsConfined) {
            if ((relativePositionMatrix[14] < this._minimumZ) || (relativePositionMatrix[14] > this._maximumZ)) {
                if (this._resetsWhenLeavingConfines) {
                    this.resetToDefaults();
                    return false;
                }
                relativePositionMatrix[14] = Math.min(Math.max(relativePositionMatrix[14], this._minimumZ), this._maximumZ);
            }
        }
        // if the position is only taken as relative at the start, then calculate and store the world position
        if (this._startsWithRelativePosition && (!this._isStarting) && (this._followedObjects.length > 0)) {
            mat.setTranslatedByM4(this._relativePositionMatrix,
                    mat.translation4m4Aux(mat.prodTranslationRotation4Aux(
                            relativePositionMatrix,
                            this.getFollowedObjectOrientationMatrix())),
                    this.getFollowedPositionMatrix());
        } else {
            mat.setMatrix4(this._relativePositionMatrix, relativePositionMatrix);
        }
        return true;
    };
    /**
     * Updates the position of the configuration based on the movement of the camera and the objects it follows
     * @param {Float32Array} worldOrientationMatrix The orientation of the camera in world coordinates - a free camera moves along its own
     * axes
     * @param {Number[3]} [orientationFollowedObjectsPositionVector] The position vector of the object(s) followed by orientation.
     * If there is no object followed by position, then distance confines will be applied to the object(s) followed by orientation (if any)
     * @param {Number[3]} velocityVector The vector describing the current velocity of the camera (not taking into account the movement
     * of the objects it follows and the orientation, as those are calculated in within this functions)
     * This method might update the velocity vector.
     * @param {Number} dt The time passed since the last update, to calculate the distance travelled
     * @returns {Boolean} Whether the update has been successfully completed (or a reset has been happened instead)
     */
    CameraPositionConfiguration.prototype.update = function (worldOrientationMatrix, orientationFollowedObjectsPositionVector, velocityVector, dt) {
        var translationVector, distance;
        if (!this._fixed) {
            if ((this._followedObjects.length === 0) || this._startsWithRelativePosition) {
                mat.translateByVector(this._relativePositionMatrix, vec.scale3(vec.prodVec3Mat4Aux(velocityVector, worldOrientationMatrix), dt / 1000));
            } else {
                if (this._turnsAroundObjects) {
                    if (this._distanceIsConfined) {
                        translationVector = mat.translationVector3(this._relativePositionMatrix);
                        distance = vec.extractLength3(translationVector) + (velocityVector[2] * dt / 1000);
                        if ((distance < this._minimumDistance) || (distance > this._maximumDistance)) {
                            if (this._resetsWhenLeavingConfines) {
                                this.resetToDefaults();
                                return false;
                            }
                            velocityVector[2] = 0;
                            distance = Math.min(Math.max(distance, this._minimumDistance), this._maximumDistance);
                        }
                        mat.setTranslation4v(this._relativePositionMatrix, vec.scale3(translationVector, distance));
                    }
                } else {
                    if (this._movesRelativeToObject) {
                        mat.translateByVector(this._relativePositionMatrix, vec.scaled3(vec.prodVec3Mat4Aux(velocityVector, mat.ROTATION_X_270), dt * 0.001));
                    } else {
                        mat.translateByVector(this._relativePositionMatrix, vec.scaled3(vec.prodVec3Mat4Aux(
                                velocityVector,
                                mat.prod3x3SubOf4Aux(
                                        worldOrientationMatrix,
                                        mat.inverseOfRotation4Aux(this.getFollowedObjectOrientationMatrix()))), dt * 0.001));
                    }
                }
            }
        }
        if (!this._isTransitionConfiguration) {
            if (!this._checkConfines(orientationFollowedObjectsPositionVector)) {
                return false;
            }
            this._cleanupFollowedObjects();
        }
        this._worldPositionMatrixValid = false;
        return true;
    };
    // #########################################################################
    /**
     * @class This class can update and compute the orientation of a camera in world coordinates, based on the related configuration 
     * settings, which it stores.
     * @param {Boolean} fixed Whether the camera orientation should be locked and not be turnable by the user
     * @param {Boolean} pointsTowardsObjects Whether the camera orientation should be calculated so that it always faces the followed objects
     * @param {Boolean} fps Whether the camera should work in "FPS-mode", by being turnable along 2 axes (of a base coordinate system, that
     * can be specified at the time of calculation)
     * @param {Object3D[]} followedObjects The list of objects the camera's orientation should follow. Setting no objects means the set 
     * orientation is absolute, setting multiple objects means the orientation of the first one will be followed. (as of now, can be changed
     * later to utilize all orientations)
     * @param {Float32Array} orientationMatrix The starting relative (if objects are followed) or world (if not) orientation of the camera.
     * @param {Number} [alpha=0] In FPS-mode, the starting alpha angle (around the Z axis)
     * @param {Number} [beta=0] In FPS-mode, the starting beta angle (around X axis)
     * @param {Number[2]} [alphaRange=[DEFAULT_MIN_ALPHA, DEFAULT_MAX_ALPHA]] In FPS-mode, the lowest and highest possible values for the alpha angle.
     * @param {Number[2]} [betaRange=[DEFAULT_MIN_BETA, DEFAULT_MAX_BETA]] In FPS-mode, the lowest and highest possible values for the beta angle.
     * @param {String} [baseOrientation] (enum CameraOrientationConfiguration.BaseOrientation) What coordinate system should be 
     * taken as base when calculating the orientation in FPS-mode.
     * @param {String} [pointToFallback] (enum CameraOrientationConfiguration.PointToFallback) In point-to mode, what orientation 
     * calculation to use if no objects are specified to point towards to
     * @param {Boolean} [isTransitionConfiguration=false] If true, the configuration will serve as a suitable starting point for 
     * transitions, as it will not perform major updates (resets, changes) and the checks necessary for them (object cleanup and fallback). 
     * Such a copy can be made from a configuration and then use it to transition to the regular configuration which gets properly updated 
     * to provide a smooth transition between the non-updated and updated state
     */
    function CameraOrientationConfiguration(fixed, pointsTowardsObjects, fps, followedObjects, orientationMatrix, alpha, beta, alphaRange, betaRange, baseOrientation, pointToFallback, isTransitionConfiguration) {
        /**
         * If true, the camera orientation can't be controlled by the player, but is automatically
         * calculated. The absolute orientation might still change e.g. if it is relative to objects
         * in the scene.
         * @type Boolean
         */
        this._fixed = fixed;
        /**
         * If objects are followed, the true value means the orientation needs to be calculated so
         * that the camera faces the followed point, while false means that the orientation is to
         * be set to the same as (the first of) the followed objects, and the transformation described
         * in this configuration is applied subsequently.
         * @type Boolean
         */
        this._pointsTowardsObjects = pointsTowardsObjects;
        /**
         * "FPS camera mode": True means that rather than applying the matrix transformation stored
         * in the orientation matrix, the orientation is calculated by applying two rotations relative
         * to the axes of the (average) orientation of followed objects, or the world, if no objects
         * are followed. The two degrees of the rotations are stored in alpha and beta.
         * @type Boolean
         */
        this._fps = fps;
        /**
         * The list of objects the camera orientation is following. If empty, the camera is free to 
         * turn around or has a constant absolute orientation if fixed. If more than one object is in the 
         * list, the camera orientation is relative to the average orientatio of the objects (or points
         * towards their average position).
         * @type Object3D[]
         */
        this._followedObjects = followedObjects || [];
        /**
         * Stores a copy of the starting relative orientation matrix so it can be reset to it later.
         * @type Float32Array
         */
        this._defaultRelativeOrientationMatrix = mat.matrix4(orientationMatrix);
        /**
         * If FPS mode is off, this matrix describes the orientation stored in this configuration. Not the same 
         * as the world orientation of the camera itself, as it can be relative to followed objects. (or their position)
         * @type Float32Array
         */
        this._relativeOrientationMatrix = orientationMatrix;
        /**
         * Describes the orientation of the camera in the world. This is calculated based on the other
         * properties and cannot be set directly.
         * @type Float32Array
         */
        this._worldOrientationMatrix = mat.identity4();
        /**
         * Whether the currently stored world orientation matrix value is up-to-date.
         * @type Boolean
         */
        this._worldOrientationMatrixValid = false;
        /**
         * Stores a copy of the starting alpha angle so it can be reset to it later.
         * @type Number
         */
        this._defaultAlpha = alpha || 0;
        /**
         * If FPS mode is on, this number describes the angle by which the orientation needs to be rotated around the
         * Y axis, in degrees.
         * @type Number
         */
        this._alpha = alpha || 0;
        /**
         * Stores a copy of the starting beta angle so it can be reset to it later.
         * @type Number
         */
        this._defaultBeta = beta || 0;
        /**
         * If FPS mode is on, this number describes the angle by which the orientation needs to be rotated around the
         * X axis, in degrees.
         * @type Number
         */
        this._beta = beta || 0;
        /**
         * If the camera is in FPS mode and not fixed, this value constraints turning it around, as the alpha angle
         * cannot be set below it. Can be a negative number. In degrees.
         * @type Number
         */
        this._minAlpha = (alphaRange && (alphaRange[0] !== undefined)) ? alphaRange[0] : DEFAULT_MIN_ALPHA;
        /**
         * If the camera is in FPS mode and not fixed, this value constraints turning it around, as the alpha angle
         * cannot be set above it. In degrees.
         * @type Number
         */
        this._maxAlpha = (alphaRange && (alphaRange[1] !== undefined)) ? alphaRange[1] : DEFAULT_MAX_ALPHA;
        /**
         * See min alpha for explanation. The minimum for the beta angle. In degrees.
         * @type Number
         */
        this._minBeta = (betaRange && (betaRange[0] !== undefined)) ? betaRange[0] : DEFAULT_MIN_BETA;
        /**
         * See max alpha for explanation. The maximum for the beta angle. In degrees.
         * @type Number
         */
        this._maxBeta = (betaRange && (betaRange[1] !== undefined)) ? betaRange[1] : DEFAULT_MAX_BETA;
        /**
         * (enum CameraOrientationConfiguration.BaseOrientation) What coordinate system should be taken as base when calculating 
         * the orientation in FPS-mode.
         * @type String
         */
        this._baseOrientation = baseOrientation;
        /**
         * (enum CameraOrientationConfiguration.PointToFallback) In point-to mode, what orientation calculation to use if no 
         * objects are specified to point towards to
         * @type String
         */
        this._pointToFallback = pointToFallback;
        /**
         * If true, the configuration serves as a suitable starting point for transitions, as it will not perform major updates (resets, 
         * changes) and the checks necessary for them (object cleanup, fallback). 
         */
        this._isTransitionConfiguration = isTransitionConfiguration;
        /**
         * A reference to the camera that currently uses this orientation configuration
         * @type Camera
         */
        this._camera = null;
    }
    /**
     * @enum {String}
     * Options about what coordinate sytem should be taken as base when calculating the orientation in FPS-mode.
     */
    CameraOrientationConfiguration.BaseOrientation = {
        /**
         * The FPS-mode angles should be relative to the world coordinate system
         */
        WORLD: "world",
        /**
         * The FPS-mode angles should be relative to the orientation of the object(s) followed by position
         */
        POSITION_FOLLOWED_OBJECTS: "positionFollowedObjects",
        /**
         * The FPS-mode angles should be relative to the orientation of the (first) object followed by orientation
         */
        ORIENTATION_FOLLOWED_OBJECT: "orientationFollowedObject"
    };
    Object.freeze(CameraOrientationConfiguration.BaseOrientation);
    /**
     * @enum {String}
     * Options on what orientation calculation to fall back to in case a "point-to" configuration was set (which always faces the followed
     * objects), but no followed objects are specified.
     */
    CameraOrientationConfiguration.PointToFallback = {
        /**
         * Treat the relative orientation matrix as world orientation matrix
         */
        WORLD: "world",
        /**
         * Let the orientation stay as it is (as it was before)
         */
        STATIONARY: "stationary",
        /**
         * Calculate the orientation relative to the object that is followed by position. If no object is followed by position, use the
         * world setting
         */
        POSITION_FOLLOWED_OBJECT_OR_WORLD: "positionFollowedObjectOrWorld"
    };
    Object.freeze(CameraOrientationConfiguration.PointToFallback);
    /**
     * Initializes all properties of this camera orientation configuration
     * @param {Boolean} fixed Whether the camera orientation should be locked and not be turnable by the user
     * @param {Boolean} pointsTowardsObjects Whether the camera orientation should be calculated so that it always faces the followed objects
     * @param {Boolean} fps Whether the camera should work in "FPS-mode", by being turnable along 2 axes (of a base coordinate system, that
     * can be specified at the time of calculation)
     * @param {Object3D[]} followedObjects The list of objects the camera's orientation should follow. Setting no objects means the set 
     * orientation is absolute, setting multiple objects means the orientation of the first one will be followed. (as of now, can be changed
     * later to utilize all orientations)
     * @param {Float32Array} orientationMatrix The starting relative (if objects are followed) or world (if not) orientation of the camera.
     * @param {Number} [alpha=0] In FPS-mode, the starting alpha angle (around the Z axis)
     * @param {Number} [beta=0] In FPS-mode, the starting beta angle (around X axis)
     * @param {Number[2]} [alphaRange=[DEFAULT_MIN_ALPHA, DEFAULT_MAX_ALPHA]] In FPS-mode, the lowest and highest possible values for the alpha angle.
     * @param {Number[2]} [betaRange=[DEFAULT_MIN_BETA, DEFAULT_MAX_BETA]] In FPS-mode, the lowest and highest possible values for the beta angle.
     * @param {String} [baseOrientation] (enum CameraOrientationConfiguration.BaseOrientation) What coordinate system should be 
     * taken as base when calculating the orientation in FPS-mode.
     * @param {String} [pointToFallback] (enum CameraOrientationConfiguration.PointToFallback) In point-to mode, what orientation 
     * calculation to use if no objects are specified to point towards to
     * @param {Boolean} [isTransitionConfiguration=false] If true, the configuration will serve as a suitable starting point for 
     * transitions, as it will not perform major updates (resets, changes) and the checks necessary for them (object cleanup and fallback). 
     * Such a copy can be made from a configuration and then use it to transition to the regular configuration which gets properly updated 
     * to provide a smooth transition between the non-updated and updated state
     */
    CameraOrientationConfiguration.prototype.init = function (fixed, pointsTowardsObjects, fps, followedObjects, orientationMatrix, alpha, beta, alphaRange, betaRange, baseOrientation, pointToFallback, isTransitionConfiguration) {
        this._fixed = fixed;
        this._pointsTowardsObjects = pointsTowardsObjects;
        this._fps = fps;
        this._followedObjects = followedObjects || [];
        mat.setMatrix4(this._defaultRelativeOrientationMatrix, orientationMatrix);
        mat.setMatrix4(this._relativeOrientationMatrix, orientationMatrix);
        mat.setIdentity4(this._worldOrientationMatrix);
        this._worldOrientationMatrixValid = false;
        this._defaultAlpha = alpha || 0;
        this._alpha = alpha || 0;
        this._defaultBeta = beta || 0;
        this._beta = beta || 0;
        this._minAlpha = (alphaRange && (alphaRange[0] !== undefined)) ? alphaRange[0] : DEFAULT_MIN_ALPHA;
        this._maxAlpha = (alphaRange && (alphaRange[1] !== undefined)) ? alphaRange[1] : DEFAULT_MAX_ALPHA;
        this._minBeta = (betaRange && (betaRange[0] !== undefined)) ? betaRange[0] : DEFAULT_MIN_BETA;
        this._maxBeta = (betaRange && (betaRange[1] !== undefined)) ? betaRange[1] : DEFAULT_MAX_BETA;
        this._baseOrientation = baseOrientation;
        this._pointToFallback = pointToFallback;
        this._isTransitionConfiguration = isTransitionConfiguration;
        this._camera = null;
    };
    /**
     * Returns a camera orientation configuration with the same settings as this one, cloning referenced values to make sure changes to this
     * configuration do not affect the created copy.
     * @param {Boolean} [transitionCopy=false] Create a copy that serves as a transition configuration (not doing object cleanup, fallback
     * checking, only regular following of orientation)
     * @returns {CameraOrientationConfiguration}
     */
    CameraOrientationConfiguration.prototype.copy = function (transitionCopy) {
        var result = new CameraOrientationConfiguration(
                this._fixed,
                this._pointsTowardsObjects,
                this._fps,
                this._followedObjects.slice(),
                mat.matrix4(this._defaultRelativeOrientationMatrix),
                this._alpha,
                this._beta,
                [this._minAlpha, this._maxAlpha],
                [this._minBeta, this._maxBeta],
                this._baseOrientation,
                this._pointToFallback,
                transitionCopy);
        result._relativeOrientationMatrix = mat.matrix4(this._relativeOrientationMatrix);
        result._worldOrientationMatrix = mat.matrix4(this._worldOrientationMatrix);
        return result;
    };
    /**
     * Sets the reference to the camera currently using this orientation configuration
     * @param {Camera} value
     */
    CameraOrientationConfiguration.prototype.setCamera = function (value) {
        this._camera = value;
    };
    /**
     * Resets the configuration to its initial state.
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraOrientationConfiguration.prototype.resetToDefaults = function (doNotNotifyCamera) {
        if (this._camera && !doNotNotifyCamera) {
            this._camera.orientationConfigurationWillChange();
        }
        mat.setMatrix4(this._relativeOrientationMatrix, this._defaultRelativeOrientationMatrix);
        this._alpha = this._defaultAlpha;
        this._beta = this._defaultBeta;
        this._worldOrientationMatrixValid = false;
    };
    /**
     * Directly sets a new relative orientation matrix for this configuration.
     * @param {Float32Array} value A 4x4 rotation matrix.
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraOrientationConfiguration.prototype.setRelativeOrientationMatrix = function (value, doNotNotifyCamera) {
        if (this._camera && !doNotNotifyCamera) {
            this._camera.orientationConfigurationWillChange();
        }
        this._relativeOrientationMatrix = value;
    };
    /**
     * Returns whether this configuration is in FPS-mode.
     * @returns {Boolean}
     */
    CameraOrientationConfiguration.prototype.isFPS = function () {
        return this._fps;
    };
    /**
     * If no parameter is given, returns whether the configuration is set to follow any objects. If a list of objects is given, returns 
     * whether this conifugation is set to follow the same list of objects.
     * @param {Object3D[]} [objects]
     * @returns {Boolean}
     */
    CameraOrientationConfiguration.prototype.followsObjects = function (objects) {
        return objects ?
                utils.arraysEqual(this._followedObjects.sort(), objects.sort()) :
                (this._followedObjects.length > 0);
    };
    /**
     * Sets the list of followed object to the passed one.
     * @param {Object3D[]} followedObjects
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraOrientationConfiguration.prototype.setFollowedObjects = function (followedObjects, doNotNotifyCamera) {
        if ((this._followedObjects.length === 0) && (followedObjects.length === 0)) {
            return;
        }
        if (this._camera && !doNotNotifyCamera) {
            this._camera.orientationConfigurationWillChange();
        }
        this._followedObjects = followedObjects;
    };
    /**
     * Sets the list of followed object to the single passed 3D object.
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     * @param {Object3D} followedObject
     */
    CameraOrientationConfiguration.prototype.setFollowedObject = function (followedObject, doNotNotifyCamera) {
        if ((this._followedObjects.length === 1) && (this._followedObjects[0] === followedObject)) {
            return;
        }
        this.setFollowedObjects([followedObject], doNotNotifyCamera);
    };
    /**
     * Returns a 3D vector describing the current (average) location in space of the followed objects.
     * @returns {Number[3]}
     */
    CameraOrientationConfiguration.prototype.getFollowedObjectsPositionVector = function () {
        var i, positionVector = [0, 0, 0];
        if (this._followedObjects.length === 0) {
            application.crash();
        } else {
            for (i = 0; i < this._followedObjects.length; i++) {
                this._followedObjects[i].addPositionToVector(positionVector);
            }
            positionVector = [
                positionVector[0] / this._followedObjects.length,
                positionVector[1] / this._followedObjects.length,
                positionVector[2] / this._followedObjects.length
            ];
        }
        return positionVector;
    };
    /**
     * Returns the orientation matrix of the first followed object. Can be later changed to calculate an orientation based on all objects
     * in the list.
     * @returns {Float32Array}
     */
    CameraOrientationConfiguration.prototype.getFollowedOrientationMatrix = function () {
        if (this._followedObjects.length === 0) {
            application.crash();
            return null;
        } else {
            return this._followedObjects[0].getOrientationMatrix();
        }
    };
    /**
     * Removes the destroyed objects from the list of followed objects.
     * @returns {Boolean} Whether the cleanup finished in order (true) or there was a change in the settings (false)
     */
    CameraOrientationConfiguration.prototype._cleanupFollowedObjects = function () {
        var i, j, k;
        for (i = 0; i < this._followedObjects.length; i++) {
            j = i;
            k = 0;
            while ((j < this._followedObjects.length) && ((!this._followedObjects[j]) || (this._followedObjects[j].canBeReused() === true))) {
                j++;
                k++;
            }
            if (k > 0) {
                // if all followed objects have been eliminated, adapt
                if (this._followedObjects.length === k) {
                    // notify the camera before any changes are made to the configuration, so it can make a copy of the original settings
                    if (this._camera) {
                        this._camera.orientationConfigurationWillChange();
                    }
                    // point-to modes have an explicitly set fallback option, but for other modes switch to absolute orientation
                    if (!this._pointsTowardsObjects) {
                        mat.setMatrix4(this._relativeOrientationMatrix, (this._worldOrientationMatrixValid && this._worldOrientationMatrix) || this._relativeOrientationMatrix || this._defaultRelativeOrientationMatrix);
                        this._fps = false;
                    }
                    this._followedObjects.splice(i, k);
                    return false;
                }
                this._followedObjects.splice(i, k);
            }
        }
        return true;
    };
    /**
     * Calculates and updates the internally stored world orientation matrix (which is nulled out automatically whenever one of the values it 
     * depends on changes, therefore serving as a cache variable)
     * @param {Float32Array} worldPositionMatrix The current position of the camera in world coordinates - needed for configurations
     * that always face the followed object, so that the orientation can be set according to the direction from the camera towards the objects
     * @param {Float32Array} positionFollowedObjectOrientationMatrix The orientation matrix of the object(s) that are followed by position
     * (by the camera that uses this orientation configuration) Needed as in FPS-mode, this can be taken as a base coordinate system, and
     * in point-to mode, as a fallback base orientation
     */
    CameraOrientationConfiguration.prototype._calculateWorldOrientationMatrix = function (worldPositionMatrix, positionFollowedObjectOrientationMatrix) {
        var baseOrientationMatrix, dirTowardsObject, axis,
                calculateRelative = function (followedOrientationMatrix) {
                    // look in direction y instead of z:
                    mat.setProd3x3SubOf4(this._worldOrientationMatrix,
                            mat.prod3x3SubOf4Aux(
                                    mat.ROTATION_X_270,
                                    this._relativeOrientationMatrix),
                            followedOrientationMatrix);
                }.bind(this),
                calculateAbsolute = function () {
                    if (this._fps) {
                        mat.setProd3x3SubOf4(this._worldOrientationMatrix, mat.ROTATION_X_270, this._relativeOrientationMatrix);
                    } else {
                        mat.setMatrix4(this._worldOrientationMatrix, this._relativeOrientationMatrix);
                    }
                }.bind(this);
        if (this._followedObjects.length > 0) {
            if (!this._pointsTowardsObjects) {
                calculateRelative(this.getFollowedOrientationMatrix());
            } else {
                if (!worldPositionMatrix) {
                    application.crash();
                } else {
                    dirTowardsObject = vec.normalize3(vec.diff3(this.getFollowedObjectsPositionVector(), mat.translationVector3(worldPositionMatrix)));
                    if (!this._fps) {
                        this._worldOrientationMatrix[8] = dirTowardsObject[0];
                        this._worldOrientationMatrix[9] = dirTowardsObject[1];
                        this._worldOrientationMatrix[10] = dirTowardsObject[2];
                        this._worldOrientationMatrix[11] = 0;
                        axis = vec.cross3(vec.UNIT3_X, dirTowardsObject);
                        this._worldOrientationMatrix[4] = axis[0];
                        this._worldOrientationMatrix[5] = axis[1];
                        this._worldOrientationMatrix[6] = axis[2];
                        this._worldOrientationMatrix[7] = 0;
                        axis = vec.cross3(dirTowardsObject, axis);
                        this._worldOrientationMatrix[0] = axis[0];
                        this._worldOrientationMatrix[1] = axis[1];
                        this._worldOrientationMatrix[2] = axis[2];
                        this._worldOrientationMatrix[3] = 0;
                        this._worldOrientationMatrix[12] = 0;
                        this._worldOrientationMatrix[13] = 0;
                        this._worldOrientationMatrix[14] = 0;
                        this._worldOrientationMatrix[15] = 1;
                        mat.correctOrthogonal4(this._worldOrientationMatrix);
                    } else {
                        switch (this._baseOrientation) {
                            case CameraOrientationConfiguration.BaseOrientation.WORLD:
                                baseOrientationMatrix = null;
                                break;
                            case CameraOrientationConfiguration.BaseOrientation.POSITION_FOLLOWED_OBJECTS:
                                baseOrientationMatrix = positionFollowedObjectOrientationMatrix || null;
                                break;
                            case CameraOrientationConfiguration.BaseOrientation.ORIENTATION_FOLLOWED_OBJECT:
                                baseOrientationMatrix = this.followsObjects() ? this.getFollowedOrientationMatrix() : null;
                                break;
                            default:
                                application.crash();
                        }
                        if (baseOrientationMatrix) {
                            dirTowardsObject = vec.prodVec3Mat4Aux(dirTowardsObject, mat.inverseOfRotation4Aux(baseOrientationMatrix));
                        } else {
                            baseOrientationMatrix = mat.IDENTITY4;
                        }
                        this._alpha = ((dirTowardsObject[0] !== 0) || (dirTowardsObject[1] !== 0)) ?
                                vec.angle2yCapped(dirTowardsObject[0], dirTowardsObject[1]) :
                                0;
                        if (dirTowardsObject[0] < 0) {
                            this._alpha = -this._alpha;
                        }
                        mat.setProd3x3SubOf4(this._worldOrientationMatrix, mat.ROTATION_X_270, mat.rotationZ4Aux(this._alpha));
                        this._beta = vec.angle3uCapped(mat.getRowC43Neg(this._worldOrientationMatrix), dirTowardsObject);
                        if (dirTowardsObject[2] > 0) {
                            this._beta = -this._beta;
                        }
                        mat.setProd3x3SubOf4(this._worldOrientationMatrix,
                                mat.prod3x3SubOf4Aux(
                                        mat.ROTATION_X_270,
                                        mat.rotationX4Aux(this._beta)),
                                mat.rotationZ4Aux(this._alpha));
                        mat.mul4(this._worldOrientationMatrix, baseOrientationMatrix);
                    }
                }
            }
        } else {
            if (this._pointsTowardsObjects) {
                switch (this._pointToFallback) {
                    case CameraOrientationConfiguration.PointToFallback.WORLD:
                        calculateAbsolute();
                        break;
                    case CameraOrientationConfiguration.PointToFallback.STATIONARY:
                        mat.setIdentity4(this._worldOrientationMatrix);
                        break;
                    case CameraOrientationConfiguration.PointToFallback.POSITION_FOLLOWED_OBJECT_OR_WORLD:
                        if (positionFollowedObjectOrientationMatrix) {
                            calculateRelative(positionFollowedObjectOrientationMatrix);
                        } else {
                            calculateAbsolute();
                        }
                        break;
                    default:
                        application.crash();
                }
            } else {
                calculateAbsolute();
            }
        }
        this._worldOrientationMatrixValid = true;
    };
    /**
     * If not cached, calculates, and returns the rotation matrix describing the current orientation of the camera in world coordinates.
     * @param {Float32Array} worldPositionMatrix The current position of the camera in world coordinates - needed for configurations
     * that always face the followed object, so that the orientation can be set according to the direction from the camera towards the objects
     * @param {Float32Array} positionFollowedObjectOrientationMatrix The orientation matrix of the object(s) that are followed by position
     * (by the camera that uses this orientation configuration) Needed as in FPS-mode, this can be taken as a base coordinate system, and
     * in point-to mode, as a fallback base orientation
     * @returns {Float32Array}
     */
    CameraOrientationConfiguration.prototype.getWorldOrientationMatrix = function (worldPositionMatrix, positionFollowedObjectOrientationMatrix) {
        if (!this._worldOrientationMatrixValid) {
            this._calculateWorldOrientationMatrix(worldPositionMatrix, positionFollowedObjectOrientationMatrix);
        }
        return this._worldOrientationMatrix;
    };
    /**
     * Updates the orientation of the configuration based on the spin of the camera and the position / orientation of the objects it follows
     * @param {Number[3]} angularVelocityVector The vector describing the current angular velocity (spin) of the camera (not taking into account the spin
     * of the objects it follows and the current orientation, as those are calculated in within this functions) degrees / second, around axes [X, Y, Z]
     * @param {Number} dt The time passed since the last update, to calculate the angles by which the camera rotated since 
     * @returns {Boolean} Whether the update finished successfully (true) or there was a change in the settings (false)
     */
    CameraOrientationConfiguration.prototype.update = function (angularVelocityVector, dt) {
        var factor;
        if (this._pointsTowardsObjects && !this.followsObjects() && (this._pointToFallback === CameraOrientationConfiguration.PointToFallback.STATIONARY)) {
            return;
        }
        if (!this._fixed) {
            if (this._fps) {
                this._alpha += angularVelocityVector[1] * dt / 1000;
                this._beta += angularVelocityVector[0] * dt / 1000;
                if (this._alpha >= 360) {
                    this._alpha -= 360;
                }
                if (this._alpha <= -360) {
                    this._alpha += 360;
                }
                if (this._beta >= 360) {
                    this._beta -= 360;
                }
                if (this._beta <= -360) {
                    this._beta += 360;
                }
                this._alpha = Math.min(Math.max(this._minAlpha, this._alpha), this._maxAlpha);
                this._beta = Math.min(Math.max(this._minBeta, this._beta), this._maxBeta);
                mat.setProd3x3SubOf4(this._relativeOrientationMatrix, mat.rotationX4Aux(this._beta * utils.RAD), mat.rotationZ4Aux(this._alpha * utils.RAD));
            } else {
                factor = utils.RAD * dt / 1000;
                if (this._followedObjects.length > 0) {
                    mat.mul4(this._relativeOrientationMatrix, mat.prod34Aux(
                            mat.rotation4Aux(vec.normalize3(mat.getRowB43(this._relativeOrientationMatrix)), angularVelocityVector[2] * factor),
                            mat.rotation4Aux(vec.normalize3(mat.getRowA43(this._relativeOrientationMatrix)), angularVelocityVector[0] * factor),
                            mat.rotation4Aux(vec.normalize3(mat.getRowC43(this._relativeOrientationMatrix)), angularVelocityVector[1] * factor)));
                } else {
                    mat.mul4(this._relativeOrientationMatrix, mat.prod34Aux(
                            mat.rotation4Aux(vec.normalize3(mat.getRowC43(this._relativeOrientationMatrix)), angularVelocityVector[2] * factor),
                            mat.rotation4Aux(vec.normalize3(mat.getRowA43(this._relativeOrientationMatrix)), angularVelocityVector[0] * factor),
                            mat.rotation4Aux(vec.normalize3(mat.getRowB43(this._relativeOrientationMatrix)), angularVelocityVector[1] * factor)));
                }
            }
        }
        if (!this._isTransitionConfiguration) {
            if (!this._cleanupFollowedObjects()) {
                return false;
            }
        }
        this._worldOrientationMatrixValid = false;
        return true;
    };
    // #########################################################################
    /**
     * @class Stores a specific configuration of camera settings such as how the position and orientation should be calculated (in two 
     * separate contained objects) or what is the current, maximum, minimum field of view. Based on the information stored in this 
     * object, the state of the camera at one point in time can be calculated. This class therefore only stores information about a static 
     * state and the constraints it has. The actual camera object can store two of these configurations and transition its state between 
     * them and stores all the dynamic information such as velocity.
     * @extends Object3D
     * @param {String} [name] An optional, descriptive name of this configuration by which it can be found and referred to later.
     * @param {CameraPositionConfiguration} positionConfiguration All the settings necessary to calculate the world position.
     * @param {CameraOrientationConfiguration} orientationConfiguration All the settings necessary to calculate the world orientation.
     * @param {Number} fov The starting field of view, in degrees.
     * @param {Number} fovRange The minimum and maximum field of view value that can be set for a camera using this configuration.
     * @param {Number} span The starting span of the camera. This is the world-space distance that the camera sees
     * horizontally or vertically at depth 0, depending on camera setting. The other value will be calculated basen on the aspect of the 
     * camera. In meters.
     * @param {Boolean} resetsOnFocusChange An indicator whether this configuration should automatically reset to default state when the camera 
     * switches to it or when the camera controls go out of focus (after being in focus)
     * @param {Boolean} shouldExcludeFromCycle When true, this configuration should be skipped when switching using cycling (switching to 
     * next / previous configuration), and should only be possible to invoke it by switching to it explicitly 
     */
    function CameraConfiguration(name, positionConfiguration, orientationConfiguration, fov, fovRange, span, resetsOnFocusChange, shouldExcludeFromCycle) {
        object3D.Object3D.call(this, positionConfiguration._positionMatrix, orientationConfiguration._orientationMatrix);
        /**
         * An optional, descriptive name of this configuration by which it can be found and referred to.
         * @type String
         */
        this._name = name;
        /**
         * Stores all the settings necessary to calculate the world position and can carry out the calculations as well.
         * @type CameraPositionConfiguration
         */
        this._positionConfiguration = positionConfiguration;
        /**
         * Stores all the settings necessary to calculate the world orientation and can carry out the calculations as well.
         * @type CameraOrientationConfiguration
         */
        this._orientationConfiguration = orientationConfiguration;
        /**
         * The starting field of view, in degrees is stored so the configuration can be reset to defaults later.
         * @type Number
         */
        this._defaultFOV = fov;
        /**
         * The current field of view, in degrees. Refers to the field of view, the vertical will depend on the aspect of the camera.
         * @type Number
         */
        this._fov = fov;
        /**
         * The minimum value to which the field of view can be set in this configuration, in degrees.
         * @type Number
         */
        this._minFOV = fovRange ? fovRange[0] : fov;
        /**
         * The maximum value to which the field of view can be set in this configuration, in degrees.
         * @type Number
         */
        this._maxFOV = fovRange ? fovRange[1] : fov;
        /**
         * The current span, in meters. This is the world-space distance that the camera sees
         * horizontally or vertically at depth 0, depending on camera setting. The other value
         * will be calculated basen on the aspect of the camera.
         * @type Number
         */
        this._span = span;
        /**
         * An indicator whether this configuration should automatically reset to default state when the camera switches to it or when the 
         * camera controls go out of focus (after being in focus)
         * @type Boolean
         */
        this._resetsOnFocusChange = resetsOnFocusChange;
        /**
         * When true, this configuration should be skipped when switching using cycling (switching to next / previous configuration), 
         * and should only be possible to invoke it by switching to it explicitly 
         * @type Boolean
         */
        this._excludeFromCycle = shouldExcludeFromCycle;
        /**
         * A reference to the camera that currently uses this configuration
         * @type Camera
         */
        this._camera = null;
    }
    object3D.makeObject3DMixinClass.call(CameraConfiguration);
    /**
     * Initializes the properties of this camera configuration.
     * @param {String} [name] An optional, descriptive name of this configuration by which it can be found and referred to later.
     * @param {CameraPositionConfiguration} positionConfiguration All the settings necessary to calculate the world position.
     * @param {CameraOrientationConfiguration} orientationConfiguration All the settings necessary to calculate the world orientation.
     * @param {Number} fov The starting field of view, in degrees.
     * @param {Number} fovRange The minimum and maximum field of view value that can be set for a camera using this configuration.
     * @param {Number} span The starting span of the camera. This is the world-space distance that the camera sees
     * horizontally or vertically at depth 0, depending on camera setting. The other value will be calculated basen on the aspect of the 
     * camera. In meters.
     * @param {Boolean} resetsOnFocusChange An indicator whether this configuration should automatically reset to default state when the camera 
     * switches to it or when the camera controls go out of focus (after being in focus)
     * @param {Boolean} shouldExcludeFromCycle When true, this configuration should be skipped when switching using cycling (switching to 
     * next / previous configuration), and should only be possible to invoke it by switching to it explicitly 
     */
    CameraConfiguration.prototype.init = function (name, positionConfiguration, orientationConfiguration, fov, fovRange, span, resetsOnFocusChange, shouldExcludeFromCycle) {
        object3D.Object3D.prototype.init.call(this, positionConfiguration._positionMatrix, orientationConfiguration._orientationMatrix);
        this._name = name;
        this._positionConfiguration = positionConfiguration;
        this._orientationConfiguration = orientationConfiguration;
        this._defaultFOV = fov;
        this._fov = fov;
        this._minFOV = fovRange ? fovRange[0] : fov;
        this._maxFOV = fovRange ? fovRange[1] : fov;
        this._span = span;
        this._resetsOnFocusChange = resetsOnFocusChange;
        this._excludeFromCycle = shouldExcludeFromCycle;
        this._camera = null;
    };
    /**
     * Creates and returns copy with the same configuration settings as this one, but with new references to avoid any change made to the
     * original configuration to affect the new one or vice versa.
     * @param {String} [name=""] An optional name for the created copy.
     * @param {Boolean} [transitionCopy=false] Create a copy that serves as a transition configuration (not doing object cleanup, confine
     * checks, fallback, only regular following of position and orientation)
     * @returns {CameraConfiguration}
     */
    CameraConfiguration.prototype.copy = function (name, transitionCopy) {
        var result = new CameraConfiguration(
                name || utils.EMPTY_STRING,
                this._positionConfiguration.copy(transitionCopy),
                this._orientationConfiguration.copy(transitionCopy),
                this._fov,
                [this._minFOV, this._maxFOV],
                this._span);
        result.setPositionMatrix(mat.matrix4(this.getPositionMatrix()));
        result.setOrientationMatrix(mat.matrix4(this.getOrientationMatrix()));
        return result;
    };
    /**
     * Sets the reference to the camera currently using this configuration
     * @param {Camera} value
     * @param {Boolean} [doNotReset=false] If true, the automatic configuration reset will be suppressed 
     */
    CameraConfiguration.prototype.setCamera = function (value, doNotReset) {
        this._camera = value;
        this._positionConfiguration.setCamera(value, doNotReset);
        this._orientationConfiguration.setCamera(value);
        if (this._camera && this._resetsOnFocusChange && !doNotReset) {
            this.resetToDefaults(true);
        }
    };
    /**
     * Sets a new relative (or absolute, depending on the configuration properties) position matrix for this configuration.
     * @param {Float32Array} value A 4x4 translation matrix.
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraConfiguration.prototype.setRelativePositionMatrix = function (value, doNotNotifyCamera) {
        this._positionConfiguration.setRelativePositionMatrix(value, doNotNotifyCamera);
    };
    /**
     * Moves the relative (or absolute, depending on the configuration properties) position of the configuration by the passed 3D vector.
     * @param {Number[3]} vector
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraConfiguration.prototype.moveByVector = function (vector, doNotNotifyCamera) {
        this._positionConfiguration.moveByVector(vector, doNotNotifyCamera);
    };
    /**
     * Sets a new relative (or absolute, depending on the configuration properties) orientation matrix for this configuration.
     * @param {Float32Array} value A 4x4 rotation matrix.
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraConfiguration.prototype.setRelativeOrientationMatrix = function (value, doNotNotifyCamera) {
        this._orientationConfiguration.setRelativeOrientationMatrix(value, doNotNotifyCamera);
    };
    /**
     * Returns the descriptive name of this configuration so it can be identified.
     * @returns {String}
     */
    CameraConfiguration.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns whether this configuration is in FPS-mode.
     * @returns {Boolean}
     */
    CameraConfiguration.prototype.isFPS = function () {
        return this._orientationConfiguration.isFPS();
    };
    /**
     * Sets the configuration's field of view 
     * @param {Number} fov The new desired FOV in degrees.
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraConfiguration.prototype.setFOV = function (fov, doNotNotifyCamera) {
        if (this._camera && !doNotNotifyCamera) {
            this._camera.configurationWillChange();
        }
        this._fov = Math.min(Math.max(fov, this._minFOV), this._maxFOV);
    };
    /**
     * Returns the currently set field of view, in degrees.
     * @returns {Number}
     */
    CameraConfiguration.prototype.getFOV = function () {
        return this._fov;
    };
    /**
     * Returns the minimum field of view that can be set, in degrees.
     * @returns {Number}
     */
    CameraConfiguration.prototype.getMinFOV = function () {
        return this._minFOV;
    };
    /**
     * Returns the maximum field of view that can be set, in degrees.
     * @returns {Number}
     */
    CameraConfiguration.prototype.getMaxFOV = function () {
        return this._maxFOV;
    };
    /**
     * Decreases the field of view of the configuration by a small amount (but not below the set minimum).
     * @returns {Number} The resulting new value of the field of view. (in degrees)
     */
    CameraConfiguration.prototype.decreaseFOV = function () {
        this.setFOV(this._fov * FOV_DECREASE_FACTOR, true);
        return this._fov;
    };
    /**
     * Increases the field of view of the configuration by a small amount (but not above the set maximum).
     * @returns {Number} The resulting new value of the field of view. (in degrees)
     */
    CameraConfiguration.prototype.increaseFOV = function () {
        this.setFOV(this._fov * FOV_INCREASE_FACTOR, true);
        return this._fov;
    };
    /**
     * Returns the currently set span, in meters.
     * @returns {Number}
     */
    CameraConfiguration.prototype.getSpan = function () {
        return this._span;
    };
    /**
     * Returns whether this configuration should automatically reset to default state when the camera switches to it or when the camera 
     * controls go out of focus (after being in focus)
     * @returns {Boolean}
     */
    CameraConfiguration.prototype.resetsOnFocusChange = function () {
        return this._resetsOnFocusChange;
    };
    /**
     * Returns whether this configuration should be skipped when switching using cycling (switching to next / previous configuration)
     * @returns {Boolean}
     */
    CameraConfiguration.prototype.shouldExcludeFromCycle = function () {
        return this._excludeFromCycle;
    };
    /**
     * Resets all configuration values to their initial state (including position, orientation, field of view and span configuration)
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraConfiguration.prototype.resetToDefaults = function (doNotNotifyCamera) {
        if (this._camera && !doNotNotifyCamera) {
            this._camera.configurationWillChange();
        }
        this.setFOV(this._defaultFOV, true);
        this._positionConfiguration.resetToDefaults(true);
        this._orientationConfiguration.resetToDefaults(true);
    };
    /**
     * Updates the position and orientation of the camera based on the current configuration values and the given velocity and spin vectors.
     * The passed vectors should represent a velocity set by the user who is controlling the camera, and how they are interpreted in world 
     * coordinates depends on the actual configuration settings (such as a fixed position camera will ignore the velocityVector, a free
     * position configuration will move the camera along its own axes etc). The update might change the position or the orientation of the
     * camera even if the passed vectors are null vectors, the camera can be set to follow moving objects in the scene!
     * @param {Number[3]} velocityVector The velocity of the camera set by the controlling user: [X,Y,Z] (not in world coordinates)
     * @param {Number[3]} angularVelocityVector The spin of the camera set by the controlling user, around axes: [X,Y,Z], degrees / second
     * @param {Number} dt The passed time since the last update, to calculate the actual path travelled / angles rotated since then
     * @returns {Boolean} Whether the update has been successfully completed (or a change has happened during it)
     */
    CameraConfiguration.prototype.update = function (velocityVector, angularVelocityVector, dt) {
        var result = true;
        result = this._orientationConfiguration.update(angularVelocityVector, dt);
        this.setOrientationMatrix(this._orientationConfiguration.getWorldOrientationMatrix(this.getPositionMatrix(), this._positionConfiguration.followsObjects() ? this._positionConfiguration.getFollowedObjectOrientationMatrix() : null));
        result = this._positionConfiguration.update(this.getOrientationMatrix(), this._orientationConfiguration.followsObjects() ? this._orientationConfiguration.getFollowedObjectsPositionVector() : null, velocityVector, dt) && result;
        this.setPositionMatrix(this._positionConfiguration.getWorldPositionMatrix(this.getOrientationMatrix()));
        return result;
    };
    /**
     * Returns whether the camera position is set to follow any objects in this configuration.
     * @returns {Boolean}
     */
    CameraConfiguration.prototype.positionFollowsObjects = function () {
        return this._positionConfiguration.followsObjects();
    };
    /**
     * Returns whether the camera orientation is set to follow any objects in this configuration.
     * @returns {Boolean}
     */
    CameraConfiguration.prototype.orientationFollowsObjects = function () {
        return this._orientationConfiguration.followsObjects();
    };
    /**
     * Returns a 3D vector that represents the current position in the world which is being followed by this configuration.
     * The vector contains copies of the current coordinates and does not change as the followed position changes.
     * @returns {Number[3]}
     */
    CameraConfiguration.prototype.getFollowedPositionVector = function () {
        return this._positionConfiguration.getFollowedPositionVector();
    };
    /**
     * Sets the list of objects which should be followed with the orientation of the camera (either by setting a relative orientation or
     * in "point-to" mode, depending on the orientation configuration)
     * @param {Object3D[]} targetObjects Should not be null, but an empty list, if no objects are to be specified
     * @param {Boolean} [doNotNotifyCamera=false] Do not call the method of the camera using this configuration that alerts it about this change
     */
    CameraConfiguration.prototype.setOrientationFollowedObjects = function (targetObjects, doNotNotifyCamera) {
        this._orientationConfiguration.setFollowedObjects(targetObjects, doNotNotifyCamera);
    };
    /**
     * Sets up the properties of this camera configuration to correspond to a free camera with the passed parameters.
     * @param {Boolean} fps Whether the orientation of the camera should be controlled in FPS mode.
     * @param {Float32Array} positionMatrix The initial position. (4x4 translation matrix)
     * @param {Float32Array} orientationMatrix The initial orientation. (4x4 rotation matrix)
     * @param {Number} fov The initial field of view, in degrees.
     * @param {Number} minFOV The minimum field of view that can be set for this configuration, in degrees.
     * @param {Number} maxFOV The maximum field of view that can be set for this configuration, in degrees.
     * @param {Number} span The initial span, in meters.
     * @returns {CameraConfiguration}
     */
    CameraConfiguration.prototype.setToFree = function (fps, positionMatrix, orientationMatrix, fov, minFOV, maxFOV, span) {
        var angles = mat.getYawAndPitch(orientationMatrix);
        this._positionConfiguration.init(false, false, false, [], false, positionMatrix, null, null, false);
        this._orientationConfiguration.init(false, false, fps, [], orientationMatrix, Math.degrees(angles.yaw), Math.degrees(angles.pitch), undefined, undefined,
                CameraOrientationConfiguration.BaseOrientation.WORLD,
                CameraOrientationConfiguration.PointToFallback.POSITION_FOLLOWED_OBJECT_OR_WORLD);
        this.init(
                utils.EMPTY_STRING,
                this._positionConfiguration,
                this._orientationConfiguration,
                fov, [minFOV, maxFOV],
                span);
    };
    /**
     * Removes all references stored by this object
     */
    CameraConfiguration.prototype.destroy = function () {
        this._positionConfiguration = null;
        this._orientationConfiguration = null;
        this._camera = null;
    };
    // -------------------------------------------------------------------------
    /**
     * Returns a new camera configuration which does not follow any objects but can be moved and turned freely and has the specified position, 
     * orientation and field of view.
     * @param {Boolean} fps Whether the orientation of the camera should be controlled in FPS mode.
     * @param {Float32Array} positionMatrix The initial position. (4x4 translation matrix)
     * @param {Float32Array} orientationMatrix The initial orientation. (4x4 rotation matrix)
     * @param {Number} fov The initial field of view, in degrees.
     * @param {Number} minFOV The minimum field of view that can be set for this configuration, in degrees.
     * @param {Number} maxFOV The maximum field of view that can be set for this configuration, in degrees.
     * @param {Number} span The initial span, in meters.
     * @returns {CameraConfiguration}
     */
    function getFreeCameraConfiguration(fps, positionMatrix, orientationMatrix, fov, minFOV, maxFOV, span) {
        var angles = mat.getYawAndPitch(orientationMatrix);
        return new CameraConfiguration(
                utils.EMPTY_STRING,
                new CameraPositionConfiguration(false, false, false, [], false, mat.matrix4(positionMatrix), null, null, false),
                new CameraOrientationConfiguration(false, false, fps, [], mat.matrix4(orientationMatrix), Math.degrees(angles.yaw), Math.degrees(angles.pitch), undefined, undefined,
                        CameraOrientationConfiguration.BaseOrientation.WORLD,
                        CameraOrientationConfiguration.PointToFallback.POSITION_FOLLOWED_OBJECT_OR_WORLD),
                fov, [minFOV, maxFOV],
                span);
    }
    // #########################################################################
    /**
     * @class A virtual camera that can be used to render a scene from a specific viewpoint. The position, orientation and field of view
     * of the camera is calculated by separate configuration classes, and this camera class refers those classes. It also supports 
     * transitioning smoothly from one configuration to another.
     * @param {Scene} scene A reference to the scene this camera is used to render. The camera can follow objects in this scene. (with its
     * position or orientation)
     * @param {Number} aspect The ratio of the horizontal and the vertical size of the image that should be rendered with this camera.
     * @param {Boolean} usesVerticalValues Whether to consider the set FOV and span values as vertical (true) or horizontal (false)
     * @param {Number} viewDistance Objects are visible up to this distance when rendered using this camera. (in meters)
     * @param {CameraConfiguration} configuration The starting configuration of the camera. There is no default, should not be null!
     * @param {Number} [transitionDuration=0] The time the camera should take to transition from one configuration to another by default, in 
     * milliseconds.
     * @param {String} [transitionStyle=NONE] (enum Camera.TransitionStyle) The style to use for transitions by default.
     */
    function Camera(scene, aspect, usesVerticalValues, viewDistance, configuration, transitionDuration, transitionStyle) {
        /**
         * An internal 3D object representing the position and orientation of the camera.
         * @type Object3D
         */
        this._object3D = new object3D.Object3D(mat.identity4(), mat.identity4(), mat.identity4());
        /**
         * A reference to the scene this camera is used to render.
         * @type Scene
         */
        this._scene = scene;
        /**
         * The ratio of the horizontal and the vertical size of the image that should be rendered with this camera.
         * @type Number
         */
        this._aspect = aspect;
        /**
         * Whether to consider the set FOV and span values as vertical (true) or horizontal (false)
         * @type Boolean
         */
        this._usesVerticalValues = usesVerticalValues;
        /**
         * Objects are visible up to this distance when rendered using this camera. In meters.
         * @type Number
         */
        this._viewDistance = viewDistance;
        /**
         * The configuration the camera is currently transitioning from to a new one. If no transition is in progress, its value is null.
         * @type CameraConfiguration
         */
        this._previousConfiguration = null;
        /**
         * The camera configuration that is used currently to calculate the camera position, orientation and field of view. Should never be
         * null.
         * @type CameraConfiguration
         */
        this._currentConfiguration = configuration;
        this._currentConfiguration.setCamera(this);
        /**
         * (enum Camera.TransitionStyle) The style used for the current configuration transition.
         * @type String
         */
        this._transitionStyle = Camera.TransitionStyle.NONE;
        /**
         * (enum Camera.TransitionStyle) The style to use for transitions by default.
         * @type String
         */
        this._defaultTransitionStyle = transitionStyle || Camera.TransitionStyle.NONE;
        /**
         * The duration of the transition currently in progress, in milliseconds.
         * @type Number
         */
        this._transitionDuration = 0;
        /**
         * The time the camera should take to transition from one configuration to another by default (when none is specified), in 
         * milliseconds.
         * @type Number
         */
        this._defaultTransitionDuration = transitionDuration || 0;
        /**
         * The amount of time that has already passed during the current transition. The current state of properties of the camera between
         * the two configurations is calculated based on this and the transition style.
         * @type Number
         */
        this._transitionElapsedTime = 0;
        /**
         * The vector describing the current relative velocity of the camera. This can be used to draw trails for particles that visualize
         * the camera's movement. When an object is followed, the velocity is considered to be that of the object (not counting relative
         * camera movements)
         * @type Number[3]
         */
        this._velocityVector = [0, 0, 0];
        /**
         * The relative velocity vector that is the result of acceleration induced by the user controlling the camera.
         * @type Number[3]
         */
        this._controlledVelocityVector = [0, 0, 0];
        /**
         * The current relative angular velocity of the camera, around axes: [X,Y,Z], in degrees / second
         * This is the result of angular acceleration induced by the player. (followed objects not considered)
         * @type Number[3]
         */
        this._angularVelocityVector = [0, 0, 0];
        /**
         * A stored value of the previous world position of the followed object(s), so that the camera velocity can be calculated if the 
         * camera is following objects.
         * @type Number[3]
         */
        this._previousFollowedPositionVector = null;
        /**
         * The stored value of the 4x4 perspective matrix calculated from the properties of the camera. 
         * @type Float32Array
         */
        this._projectionMatrix = mat.identity4();
        /**
         * Whether the currently stored projection matrix value is up-to-date.
         * @type Boolean
         */
        this._projectionMatrixValid = false;
        /**
         * A reference to the rendereble node that the current configuration of this camera is associated with (typically because it follows 
         * the object stored at it). Thanks to this reference, the camera can cycle through the configurations associated with the same node,
         * or pick the next node from the scene to follow.
         * @type RenderableNode
         */
        this._followedNode = null;
        /**
         * A cache variable storing the calculated value of the camera matrix. This depends on the position and orientation matrices and
         * thus is reset to null when those are changed.
         * @type Float32Array
         */
        this._viewMatrix = mat.identity4();
        /**
         * Whether the currently stored view matrix value is up-to-date.
         * @type Boolean
         */
        this._viewMatrixValid = false;
        /**
         * A cache variable storing the calculated inverse of the position matrix. It is reset to null whenever the position changes.
         * @type Float32Array
         */
        this._inversePositionMatrix = mat.identity4();
        /**
         * Whether the currently stored inverse position matrix value is up-to-date.
         * @type Boolean
         */
        this._inversePositionMatrixValid = false;
        /**
         * A cache variable storing the calculated inverse of the orientation matrix. It is reset to null whenever the orientation changes.
         * @type Float32Array
         */
        this._inverseOrientationMatrix = mat.identity4();
        /**
         * Whether the currently stored inverse orientation matrix value is up-to-date.
         * @type Boolean
         */
        this._inverseOrientationMatrixValid = false;
        /**
         * The cached value of the current field of view. (in degrees)
         * @type Number
         */
        this._fov = 0;
        /**
         * The cached value of the current span of the camera.
         * @type Number
         */
        this._span = 0;
        /**
         * The cached value of the distance of the near cutting plane of the camera's view frustum from the focal point.
         * @type Number
         */
        this._near = 0;
        /**
         * A cached reference to a camera with the same position, orientation and overall parameters, but with a frustum that starts from
         * the far cutting plane of this camera and extends beyond it.
         * @type Camera
         */
        this._extendedCamera = null;
        /**
         * Whether the stored extended camera is set up appropriately for the current proprties of the camera.
         * @type Boolean
         */
        this._extendedCameraValid = false;
        /**
         * A cached reference to a camera with the same overall parameters, but with a view frustum that combines that of this camera and
         * its extended camera.
         * @type Camera
         */
        this._combinedExtendedCamera = null;
        /**
         * Whether the stored combined extended camera is set up appropriately for the current proprties of the camera.
         * @type Boolean
         */
        this._combinedExtendedCameraValid = false;
        /**
         * Holds the calculated camera position matrix based on the position of the camera and the stereoscopic settings.
         * @type Float32Array
         */
        this._posMatrix = mat.identity4();
        /**
         * Holds the calculated camera orientation matrix based on the orientation of the camera and the stereoscopic settings.
         * @type Float32Array
         */
        this._oriMatrix = mat.identity4();
        // fields for stereoscopic rendering
        /**
         * Half of the interocular distance for stereoscopic rendering, in meters.
         * @type Number
         */
        this._interocularHalfDistance = DEFAULT_INTEROCULAR_HALF_DISTANCE;
        /**
         * The distance between the convergence point and the camera position for stereoscopic rendering, in meters.
         * @type Number
         */
        this._stereoscopicConvergenceDistance = DEFAULT_STEREOSCOPIC_CONVERGENCE_DISTANCE;
        /**
         * The calculated value of the angle the stereoscopic cameras need to be rotated, based on the interocular distance and 
         * the distance to the convergence point. Do not modify directly. In radians.
         * @type Number
         */
        this._stereoAngle = 0;
        /**
         * The current stereoscopic mode of the camera. Influences the position and orientation matrices returned using the
         * getter methods.
         * (enum Camera.Stereoscopy)
         * @type Number
         */
        this._stereoscopy = Camera.Stereoscopy.NONE;
        /**
         * Whether the camera currently corresponds to the left eye in a stereoscopic setting.
         * @type Boolean
         */
        this._leftEye = false;
        /**
         * Whether the camera currently corresponds to the right eye in a stereoscopic setting.
         * @type Boolean
         */
        this._rightEye = false;
        // update to have appropriate starting values
        this._updateFOV();
        this._updateSpan();
        this._updateStereoAngle();
    }
    /**
     * Each camera can be (is) in one of these states, corresponding to what role they are used in currently for stereoscopic rendering.
     * @enum {Number}
     */
    Camera.Stereoscopy = {
        /** Non-stereoscopic camera */
        NONE: 0,
        /** Camera currently used to render the image corresponding to the left eye in a stereoscopic setting */
        LEFT: 1,
        /** Camera currently used to render the image corresponding to the right eye in a stereoscopic setting */
        RIGHT: 2
    };
    /**
     * @enum {Number}
     * Options about how should the combination of the two configurations be calculated when the camera is transitioning from one
     * to the another.
     */
    Camera.TransitionStyle = {
        /**
         * No valid value given, a transition with this value will result in an error. This way accidentally not setting a value
         * can be noticed. (for instantly jumping to the new configuration, use a duration of 0)
         */
        NONE: "none",
        /**
         * Use a simple linear transition from one configuration to another. The position will move, and the direction will turn
         * in a linear manner.
         */
        LINEAR: "linear",
        /**
         * Use a calculation resulting in an accelerating change in the first half, and a decelerating change during the second
         * half of the transition.
         */
        SMOOTH: "smooth"
    };
    Object.freeze(Camera.TransitionStyle);
    /**
     * Initializes the values of all properties of the camera
     * @param {Scene} scene A reference to the scene this camera is used to render. The camera can follow objects in this scene. (with its
     * position or orientation)
     * @param {Number} aspect The ratio of the horizontal and the vertical size of the image that should be rendered with this camera.
     * @param {Boolean} usesVerticalValues Whether to consider the set FOV and span values as vertical (true) or horizontal (false)
     * @param {Number} viewDistance Objects are visible up to this distance when rendered using this camera. (in meters)
     * @param {CameraConfiguration} configuration The starting configuration of the camera. There is no default, should not be null!
     * @param {Number} [transitionDuration=0] The time the camera should take to transition from one configuration to another by default, in 
     * milliseconds.
     * @param {String} [transitionStyle=NONE] (enum Camera.TransitionStyle) The style to use for transitions by default.
     */
    Camera.prototype.init = function (scene, aspect, usesVerticalValues, viewDistance, configuration, transitionDuration, transitionStyle) {
        this._object3D.init(mat.IDENTITY4, mat.IDENTITY4, mat.IDENTITY4);
        this._scene = scene;
        this._aspect = aspect;
        this._usesVerticalValues = usesVerticalValues;
        this._viewDistance = viewDistance;
        this._previousConfiguration = null;
        this._currentConfiguration = configuration;
        this._currentConfiguration.setCamera(this);
        this._transitionStyle = Camera.TransitionStyle.NONE;
        this._defaultTransitionStyle = transitionStyle || Camera.TransitionStyle.NONE;
        this._transitionDuration = 0;
        this._defaultTransitionDuration = transitionDuration || 0;
        this._transitionElapsedTime = 0;
        this._velocityVector = [0, 0, 0];
        this._controlledVelocityVector = [0, 0, 0];
        this._angularVelocityVector = [0, 0, 0];
        this._previousFollowedPositionVector = null;
        mat.setIdentity4(this._projectionMatrix);
        this._projectionMatrixValid = false;
        this._followedNode = null;
        mat.setIdentity4(this._viewMatrix);
        this._viewMatrixValid = false;
        mat.setIdentity4(this._inversePositionMatrix);
        this._inversePositionMatrixValid = false;
        mat.setIdentity4(this._inverseOrientationMatrix);
        this._inverseOrientationMatrixValid = false;
        this._fov = 0;
        this._span = 0;
        this._near = 0;
        this._extendedCamera = null;
        this._extendedCameraValid = false;
        this._combinedExtendedCamera = null;
        this._combinedExtendedCameraValid = false;
        this._updateFOV();
        this._updateSpan();
    };
    /**
     * Returns the view distance of the camera (the distance of the far cutting plane of the camera's view frustum from its focal point)
     * @returns {Number}
     */
    Camera.prototype.getViewDistance = function () {
        return this._viewDistance;
    };
    /**
     * Sets a new view distance for the camera (the distance of the far cutting plane of the camera's view frustum from its focal point)
     * @param {Number} value
     */
    Camera.prototype.setViewDistance = function (value) {
        this._viewDistance = value;
        this._updateProjectionMatrix(this._fov, this._span);
    };
    /**
     * Returns the distance of the near cutting plane of the camera's view frustum from its focal point
     * @returns {Number}
     */
    Camera.prototype.getNearDistance = function () {
        return this._near;
    };
    /**
     * Returns the 4x4 translation matrix describing the current position of the camera in world space.
     * Considers the stereoscopic state of the camera.
     * @returns {Float32Array}
     */
    Camera.prototype.getCameraPositionMatrix = function () {
        var ori;
        mat.setMatrix4(this._posMatrix, this._object3D.getPositionMatrix());
        if (this._leftEye) {
            ori = this._object3D.getOrientationMatrix();
            this._posMatrix[12] -= this._interocularHalfDistance * ori[0];
            this._posMatrix[13] -= this._interocularHalfDistance * ori[1];
            this._posMatrix[14] -= this._interocularHalfDistance * ori[2];
        } else if (this._rightEye) {
            ori = this._object3D.getOrientationMatrix();
            this._posMatrix[12] += this._interocularHalfDistance * ori[0];
            this._posMatrix[13] += this._interocularHalfDistance * ori[1];
            this._posMatrix[14] += this._interocularHalfDistance * ori[2];
        }
        return this._posMatrix;
    };
    /**
     * Returns the 3D vector describing the current position of the camera in world space.
     * Does not consider the stereoscopic state of the camera.
     * @returns {Number[3]}
     */
    Camera.prototype.getCameraPositionVector = function () {
        return this._object3D.getPositionVector();
    };
    /**
     * Returns the 4x4 rotation matrix describing the current orientaton of the camera in world space.
     * Considers the stereoscopic state of the camera.
     * @returns {Float32Array}
     */
    Camera.prototype.getCameraOrientationMatrix = function () {
        mat.setMatrix4(this._oriMatrix, this._object3D.getOrientationMatrix());
        if (this._leftEye) {
            mat.rotate4(this._oriMatrix, mat.getRowB43(this._oriMatrix), this._stereoAngle);
        } else if (this._rightEye) {
            mat.rotate4(this._oriMatrix, mat.getRowB43(this._oriMatrix), -this._stereoAngle);
        }
        return this._oriMatrix;
    };
    /**
     * Sets a new position matrix for the camera. The update() method calculates the position and this should not be called from outside.
     * @param {Float32Array} value
     */
    Camera.prototype._setPositionMatrix = function (value) {
        this._object3D.setPositionMatrix(value);
        this._viewMatrixValid = false;
        this._inversePositionMatrixValid = false;
    };
    /**
     * Modifies the position matrix of the camera. The update() method calculates the position and this should not be called from outside.
     * @param {Number[3]} v
     */
    Camera.prototype._setPositionv = function (v) {
        this._object3D.setPositionv(v);
        this._viewMatrixValid = false;
        this._inversePositionMatrixValid = false;
    };
    /**
     * Modifies the position matrix of the camera. The update() method calculates the position and this should not be called from outside.
     * @param {Float32Array} m
     */
    Camera.prototype._setPositionM4 = function (m) {
        this._object3D.setPositionM4(m);
        this._viewMatrixValid = false;
        this._inversePositionMatrixValid = false;
    };
    /**
     * Sets a new orientation matrix for the camera. The update() method calculates the orientation and this should not be called from outside.
     * @param {Float32Array} value
     */
    Camera.prototype._setOrientationMatrix = function (value) {
        this._object3D.setOrientationMatrix(value);
        this._viewMatrixValid = false;
        this._inverseOrientationMatrixValid = false;
    };
    /**
     * Modifies the orientation matrix of the camera. The update() method calculates the orientation and this should not be called from outside.
     * @param {Float32Array} m
     */
    Camera.prototype._setOrientationM4 = function (m) {
        this._object3D.setOrientationM4(m);
        this._viewMatrixValid = false;
        this._inverseOrientationMatrixValid = false;
    };
    /**
     * Rotates the current orientation around the given axis by the given angle. This directly manipulates the orientation of the camera
     * and thus should not be used from outside! Use setAngularVelocityVector() (and update()) instead!
     * @param {Number[3]} axis The 3D vector of the axis.
     * @param {Number} angle Angle in radians.
     */
    Camera.prototype._rotate = function (axis, angle) {
        this._object3D.rotate(axis, angle);
        this._setOrientationMatrix();
    };
    /**
     * Moves the camera to the specified (absolute or relative, depending on the configuration of the camera) position.
     * @param {Number[3]} positionVector
     * @param {Number} [duration] The duration of the new transition in milliseconds. If not given, the camera default will be used. If zero
     * is given, the new configuration will be applied instantly.
     * @param {String} [style] (enum Camera.TransitionStyle) The style of the new transition to use. If not given, the camera 
     * default will be used.
     */
    Camera.prototype.moveToPosition = function (positionVector, duration, style) {
        duration = (duration === undefined) ? this._defaultTransitionDuration : duration;
        if (duration > 0) {
            this.transitionToSameConfiguration(duration, style);
        }
        this._currentConfiguration.setRelativePositionMatrix(mat.translation4v(positionVector), true);
    };
    /**
     * Returns the current view matrix based on the position and orientation. This will be the inverse transformation
     * that is to be applied to objects to transform them from world space into camera space.
     * Considers the stereoscopic state of the camera.
     * @returns {Float32Array}
     */
    Camera.prototype.getViewMatrix = function () {
        if (!this._viewMatrixValid) {
            mat.setProdTranslationRotation4(this._viewMatrix, this.getInversePositionMatrix(), this.getInverseOrientationMatrix());
            this._viewMatrixValid = true;
        }
        return this._viewMatrix;
    };
    /**
     * Returns the inverse of the position matrix of the camera. Uses caching to eliminate unnecessary calculations.
     * Considers the stereoscopic state of the camera.
     * @returns {Float32Array}
     */
    Camera.prototype.getInversePositionMatrix = function () {
        if (!this._inversePositionMatrixValid) {
            mat.setInverseOfTranslation4(this._inversePositionMatrix, this.getCameraPositionMatrix());
            this._inversePositionMatrixValid = true;
        }
        return this._inversePositionMatrix;
    };
    /**
     * Returns the inverse of the orientation matrix of the camera. Uses caching to eliminate unnecessary calculations.
     * Considers the stereoscopic state of the camera.
     * @returns {Float32Array}
     */
    Camera.prototype.getInverseOrientationMatrix = function () {
        if (!this._inverseOrientationMatrixValid) {
            mat.setInverseOfRotation4(this._inverseOrientationMatrix, this.getCameraOrientationMatrix());
            this._inverseOrientationMatrixValid = true;
        }
        return this._inverseOrientationMatrix;
    };
    /**
     * Returns the currently set configuration of the camera. If the camera is in transition between two configurations,
     * this will return the configuration it is transitioning into.
     * @returns {CameraConfiguration}
     */
    Camera.prototype.getConfiguration = function () {
        return this._currentConfiguration;
    };
    /**
     * Returns a vector representing the current relative velocity of the camera. If the camera is freely movable by the
     * user, this will be the velocity that is the result of the user controls. If the camera position is following some
     * objects, this will be the relative velocity of the followed point in space (regardless of additional camera
     * movements). While transitioning, this will be the relative velocity of the camera position as it moves from
     * the position of the first configuration towards the second.
     * This velocity vector can be used to draw trails for objects to visualise the movement of the camera.
     * @returns {Number[3]}
     */
    Camera.prototype.getVelocityVector = function () {
        return this._velocityVector;
    };
    /**
     * Returns the current projection matrix of the camera. Currently only perspective projection is supported.
     * Calculates the matrix from the current camera properties if necessary, and caches the result.
     * @returns {Float32Array}
     */
    Camera.prototype.getProjectionMatrix = function () {
        if (!this._projectionMatrixValid) {
            this._updateProjectionMatrix(this.getFOV(), this.getSpan());
        }
        return this._projectionMatrix;
    };
    /**
     * Updates the stored cache value of the projection matrix of the camera based on its current properties.
     * Currently only perspective projection is supported.
     * @param {Number} fov The field of view for the perspective projection, in degrees.
     * @param {Number} span The span of the viewing rectangle at depth 0, in meters.
     */
    Camera.prototype._updateProjectionMatrix = function (fov, span) {
        // update the near cutting plane
        this._near = span * 0.5 / Math.tan(fov * utils.RAD * 0.5);
        if (this._usesVerticalValues) {
            mat.setPerspective4(this._projectionMatrix, span * this._aspect * 0.5, span * 0.5, this._near, this._viewDistance);
        } else {
            mat.setPerspective4(this._projectionMatrix, span * 0.5, span / this._aspect * 0.5, this._near, this._viewDistance);
        }
        this._projectionMatrixValid = true;
    };
    /**
     * Returns the current width / height aspect ratio of the camera.
     * @returns {Number}
     */
    Camera.prototype.getAspect = function () {
        return this._aspect;
    };
    /**
     * Sets the camera's aspect ratio. (width / height)
     * @param {Number} aspect The new desired aspect ratio.
     */
    Camera.prototype.setAspect = function (aspect) {
        if (this._aspect !== aspect) {
            this._aspect = aspect;
            this._projectionMatrixValid = false;
        }
    };
    /**
     * Returns the current field of view (the correct current value during transitions as well), in degrees
     * @returns {Number}
     */
    Camera.prototype.getFOV = function () {
        if (!this._fov) {
            this._updateFOV(this._getTransitionProgress());
        }
        return this._fov;
    };
    /**
     * Sets the camera's field of view.
     * @param {Number} fov The new desired field of view in degrees.
     * @param {Number} [duration] The duration of the new transition in milliseconds. If not given, the camera default will be used. If zero
     * is given, the new configuration will be applied instantly.
     * @param {String} [style] (enum Camera.TransitionStyle) The style of the new transition to use. If not given, the camera 
     * default will be used.
     */
    Camera.prototype.setFOV = function (fov, duration, style) {
        duration = (duration === undefined) ? this._defaultTransitionDuration : duration;
        if (duration > 0) {
            this.transitionToSameConfiguration(duration, style);
        } else {
            this._fov = fov;
        }
        this._currentConfiguration.setFOV(fov, true);
        this._projectionMatrixValid = false;
    };
    /**
     * Decreases the camera's field of view by a small step, but not below the minimum allowed by the current configuration.
     */
    Camera.prototype.decreaseFOV = function () {
        this._fov = this._currentConfiguration.decreaseFOV();
        this._projectionMatrixValid = false;
    };
    /**
     * Increases the camera's field of view by a small step, but not above the maximum allowed by the current configuration.
     */
    Camera.prototype.increaseFOV = function () {
        this._fov = this._currentConfiguration.increaseFOV();
        this._projectionMatrixValid = false;
    };
    /**
     * Returns the current span (the correct current value during transitions as well), in meters
     * @returns {Number}
     */
    Camera.prototype.getSpan = function () {
        if (!this._span) {
            this._updateSpan(this._getTransitionProgress());
        }
        return this._span;
    };
    /**
     * Sets a new controlled velocity vector for the camera. Typically a camera controller would call this.
     * @param {Number[3]} value
     */
    Camera.prototype.setControlledVelocityVector = function (value) {
        this._controlledVelocityVector = value;
    };
    /**
     * Sets a new (controlled) angular velocity vector for the camera. Typically a camera controller would call this.
     * @param {Number[3]} value
     */
    Camera.prototype.setAngularVelocityVector = function (value) {
        this._angularVelocityVector = value;
    };
    /**
     * Creates and returns a camera configuration based on the one currently set for this camera, with absolute position and orientation and
     * free movement setting. The starting position and orientation will either be the passed ones (if any), or the current position / orientation
     * of the camera.
     * @param {Boolean} [fps] Whether to set the created configuration to FPS-mode. if not specified, the current configuration setting will be used.
     * @param {Float32Array} [positionMatrix] If none given, the current world position will be used.
     * @param {Float32Array} [orientationMatrix] If none given, the current world orientation will be used.
     * @returns {CameraConfiguration}
     */
    Camera.prototype._getFreeCameraConfiguration = function (fps, positionMatrix, orientationMatrix) {
        if (fps === undefined) {
            fps = this._currentConfiguration.isFPS();
        }
        positionMatrix = positionMatrix || this.getCameraPositionMatrix();
        orientationMatrix = orientationMatrix || this.getCameraOrientationMatrix();
        if (fps) {
            orientationMatrix = mat.prod3x3SubOf4Aux(mat.ROTATION_X_90, orientationMatrix);
        }
        return getFreeCameraConfiguration(
                fps,
                positionMatrix,
                orientationMatrix,
                this.getFOV(),
                this._currentConfiguration.getMinFOV(),
                this._currentConfiguration.getMaxFOV(),
                this.getSpan());
    };
    /**
     * Directly sets a new configuration to use for this camera. The new configuration is applied instantly, without transition.
     * @param {CameraConfiguration} configuration 
     * @param {Boolean} [doNotResetConfiguration=false] If true, the automatic configuration reset will be suppressed 
     */
    Camera.prototype.setConfiguration = function (configuration, doNotResetConfiguration) {
        if (this._currentConfiguration) {
            this._currentConfiguration.setCamera(null);
        }
        this._currentConfiguration = configuration;
        this._previousConfiguration = null;
        this._updateFOV();
        this._updateSpan();
        this._updateProjectionMatrix(this._fov, this._span);
        this._currentConfiguration.setCamera(this, doNotResetConfiguration);
    };
    /**
     * Initiates a new transition from the current configuration to the given one. If a transition already is in progress, the new 
     * transition will start from a new, free camera configuration set to the current position and orientation of the camera.
     * @param {CameraConfiguration} configuration
     * @param {Number} [duration] The duration of the new transition in milliseconds. If not given, the camera default will be used. If zero
     * is given, the new configuration will be applied instantly.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the new transition to use. If not given, the camera 
     * default will be used.
     */
    Camera.prototype.startTransitionToConfiguration = function (configuration, duration, style) {
        if (this._currentConfiguration === configuration) {
            return;
        }
        if (duration === 0) {
            this.setConfiguration(configuration);
        } else {
            if (this._previousConfiguration && this._currentConfiguration) {
                this._previousConfiguration = this._getFreeCameraConfiguration(false);
            } else {
                this._previousConfiguration = this._currentConfiguration;
            }
            if (this._currentConfiguration) {
                this._currentConfiguration.setCamera(null);
            }
            this._currentConfiguration = configuration;
            this._currentConfiguration.setCamera(this);
            this._transitionDuration = duration === undefined ? this._defaultTransitionDuration : duration;
            this._transitionElapsedTime = 0;
            this._transitionStyle = style === undefined ? this._defaultTransitionStyle : style;
        }
    };
    /**
     * Starts a transition to a free camera configuration (with absolute position and orientation both controllable) with the given
     * parameters.
     * @param {Boolean} [fps] Whether the new camera configuration should be set to FPS-mode. If not given, the current configuration 
     * setting will be used.
     * @param {Float32Array} [positionMatrix] The position matrix of the new configuration. If not given, the current world position will be
     * used.
     * @param {Float32Array} [orientationMatrix] The orientation matrix of the new configuration. If not given, the current world 
     * orientation will be used.
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     */
    Camera.prototype.transitionToFreeCamera = function (fps, positionMatrix, orientationMatrix, duration, style) {
        this._followedNode = null;
        this.startTransitionToConfiguration(this._getFreeCameraConfiguration(fps, positionMatrix, orientationMatrix), duration, style);
    };
    /**
     * Instantly sets a new, free camera configuration (with absolute position and orientation both controllable) with the given parameters
     * for this camera.
     * @param {Boolean} [fps] Whether the new camera configuration should be set to FPS-mode. If not given, the current configuration 
     * setting will be used.
     * @param {Float32Array} [positionMatrix] The position matrix of the new configuration. If not given, the current world position will be
     * used.
     * @param {Float32Array} [orientationMatrix] The orientation matrix of the new configuration. If not given, the current world 
     * orientation will be used.
     */
    Camera.prototype.setToFreeCamera = function (fps, positionMatrix, orientationMatrix) {
        this.transitionToFreeCamera(fps, positionMatrix, orientationMatrix, 0);
    };
    /**
     * Start a new transition from a free camera at the current position and orientation towards the configuration that was already active.
     * This is useful when some property of the current configuration changes, as with this method a smoother transition to the recalculated
     * position / orientation can be displayed.
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     */
    Camera.prototype.transitionToSameConfiguration = function (duration, style) {
        var configuration = this._currentConfiguration;
        this.setConfiguration(this._previousConfiguration ? this._getFreeCameraConfiguration(false) : this._currentConfiguration.copy(utils.EMPTY_STRING, true), true);
        this.startTransitionToConfiguration(configuration, duration, style);
    };
    /**
     * Start a transition to the same configuration, but with its default settings reset. This preserves the reference to the configuration
     * and does not create a copy.
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     */
    Camera.prototype.transitionToConfigurationDefaults = function (duration, style) {
        this.transitionToSameConfiguration(duration, style);
        this._currentConfiguration.resetToDefaults(true);
    };
    /**
     * When a change happens in the settings from the position configuration's side, this method will be called which will apply a default 
     * transition.
     */
    Camera.prototype.positionConfigurationWillChange = function () {
        this.transitionToSameConfiguration();
    };
    /**
     * When a change happens in the settings from the orientation configuration's side, this method will be called which will apply a default 
     * transition.
     */
    Camera.prototype.orientationConfigurationWillChange = function () {
        this.transitionToSameConfiguration();
    };
    /**
     * When a change happens in the settings from the configuration's side, this method will be called which will apply a default transition.
     */
    Camera.prototype.configurationWillChange = function () {
        this.transitionToSameConfiguration();
    };
    Camera.prototype.getFollowedNode = function () {
        return this._followedNode;
    };
    /**
     * If the current position of the camera exceeds plus/minus the given limit on any axis, moves the camera back to the origo and returns
     * the vector by which the objects in the scene need to be moved to stay in sync with the new camera position, otherwise returns null.
     * @param {Number} limit
     * @returns {Number[3]|null}
     */
    Camera.prototype.moveToOrigoIfNeeded = function (limit) {
        var m = this.getCameraPositionMatrix(), result = null;
        if ((m[12] > limit) || (m[12] < -limit) || (m[13] > limit) || (m[13] < -limit) || (m[14] > limit) || (m[14] < -limit)) {
            result = [-m[12], -m[13], -m[14]];
            if (!this._currentConfiguration.positionFollowsObjects()) {
                this._currentConfiguration.setRelativePositionMatrix(mat.identity4(), true);
            }
            if (this._previousConfiguration && !this._previousConfiguration.positionFollowsObjects()) {
                this._previousConfiguration.moveByVector(result, true);
            }
        }
        return result;
    };
    /**
     * Start a transition to the first (or given) camera configuration associated with the passed renderable node, if any.
     * @param {RenderableNode} [node] If no node is given, the method will start a transition to the first camera configuration associated
     * with the scene itself.
     * @param {Boolean} forceFirstView If true, then even if the given node is already the followed one, the method will switch to its first
     * camera configuration. Otherwise it will leave the current camera configuration in this case.
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     * @param {String} [configurationName] If given, the camera will transition to the (first) configuration with this name instead of the first configuration
     * @returns {Boolean} Whether as a result of this call, the camera is now following the specified node. If the node has no associated
     * configurations to switch to, this will be false.
     */
    Camera.prototype.followNode = function (node, forceFirstView, duration, style, configurationName) {
        var configurations, configuration;
        if (!forceFirstView && (this._followedNode === node)) {
            return true;
        }
        this._followedNode = node;
        if (this._followedNode) {
            if (configurationName) {
                configurations = this._followedNode.getCameraConfigurationsWithName(configurationName);
                if (configurations.length > 0) {
                    configuration = configurations[0];
                }
            }
            configuration = configuration || this._followedNode.getNextCameraConfiguration();
            if (configuration) {
                this.startTransitionToConfiguration(configuration, duration, style);
                return true;
            }
            return false;
        }
        // if no node was given
        if (configurationName) {
            configurations = this._scene.getCameraConfigurationsWithName(configurationName);
            if (configurations.length > 0) {
                configuration = configurations[0];
            }
        }
        configuration = configuration || this._scene.getNextCameraConfiguration();
        if (configuration) {
            this.startTransitionToConfiguration(configuration, duration, style);
            return true;
        }
        return false;
    };
    /**
     * A convenience methods so that instead of the renderable node, one can specify the renderable object to follow. This will just get
     * the node of the object and follow that.
     * @param {RenderableObject3D} objectToFollow The renderable object the node of which to follow.
     * @param {Boolean} forceFirstView If true, then even if the given object's node is already the followed one, the method will switch to 
     * its first camera configuration. Otherwise it will leave the current camera configuration in this case.
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     * @param {String} [configurationName] If given, the camera will transition to the (first) configuration with this name instead of the first configuration
     * @returns {Boolean} Whether as a result of this call, the camera is now following the specified object's node. If the node has no 
     * associated configurations to switch to, this will be false.
     */
    Camera.prototype.followObject = function (objectToFollow, forceFirstView, duration, style, configurationName) {
        return this.followNode(objectToFollow.getNode(), forceFirstView, duration, style, configurationName);
    };
    /**
     * Start a transition to the next camera configuration associated with the currently followed node, or the scene, in case no node is
     * followed. If the currently followed configuration is the last one, the first one will be chosen.
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     */
    Camera.prototype.changeToNextView = function (duration, style) {
        if (this._followedNode) {
            // if there is a followed node, that means the current configuration is among its associated configurations, we can safely proceed
            this.startTransitionToConfiguration(this._followedNode.getNextCameraConfiguration(this._currentConfiguration), duration, style);
        } else {
            // if there is no followed node, we need to be more careful, first need to check if the scene has any associated configurations at all
            if (this._scene.getNextCameraConfiguration()) {
                // then we need to check if the current configuration is among the associated ones (it can be a generic free configuration)
                this.startTransitionToConfiguration(this._scene.getNextCameraConfiguration(this._scene.hasCameraConfiguration(this._currentConfiguration) ? this._currentConfiguration : null), duration, style);
            }
        }
    };
    /**
     * Start a transition to the previous camera configuration associated with the currently followed node, or the scene, in case no node is
     * followed. If the currently followed configuration is the first one, the last one will be chosen.
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     */
    Camera.prototype.changeToPreviousView = function (duration, style) {
        if (this._followedNode) {
            // if there is a followed node, that means the current configuration is among its associated configurations, we can safely proceed
            this.startTransitionToConfiguration(this._followedNode.getPreviousCameraConfiguration(this._currentConfiguration), duration, style);
        } else {
            // if there is no followed node, we need to be more careful, first need to check if the scene has any associated configurations at all
            if (this._scene.getNextCameraConfiguration()) {
                // then we need to check if the current configuration is among the associated ones (it can be a generic free configuration)
                this.startTransitionToConfiguration(this._scene.getPreviousCameraConfiguration(this._scene.hasCameraConfiguration(this._currentConfiguration) ? this._currentConfiguration : null), duration, style);
            }
        }
    };
    /**
     * Start a transition to the first associated camera configuration of the next renderable node.
     * @param {Boolean} [considerScene=false] Whether to also consider the scene "as a node". If true, than after the last node, this 
     * method will set the fist configuration associated with the scene rather than jumping right to the first node again.
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     * @returns {Boolean} Whether a node has been successfully followed (will be false if considerScene is false and there are no nodes in the
     * scene which can be followed)
     */
    Camera.prototype.followNextNode = function (considerScene, duration, style) {
        var node = this._scene.getNextNode(this._followedNode), originalNode = this._followedNode;
        while ((node !== originalNode) && node && (!node.getNextCameraConfiguration() || !node.isVisible())) {
            if (!originalNode) {
                originalNode = node;
            }
            node = this._scene.getNextNode(node);
            if (considerScene && this._followedNode && (node === this._scene.getFirstNode())) {
                if (this.followNode(null, true, duration, style)) {
                    return true;
                }
            }
        }
        if (node && node.getNextCameraConfiguration() && node.isVisible()) {
            return this.followNode(node, true, duration, style);
        }
        return false;
    };
    /**
     * Start a transition to the first associated camera configuration of the previous renderable node.
     * @param {Boolean} [considerScene=false] Whether to also consider the scene "as a node". If true, than after the first node, this 
     * method will set the fist configuration associated with the scene rather than jumping right to the last node again.
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     */
    Camera.prototype.followPreviousNode = function (considerScene, duration, style) {
        var firstNode = this._scene.getFirstNode(), node = this._scene.getPreviousNode(this._followedNode), originalNode = this._followedNode;
        while ((node !== originalNode) && node && (!node.getNextCameraConfiguration() || !node.isVisible())) {
            if (!originalNode) {
                originalNode = node;
            }
            if (considerScene && (node === firstNode)) {
                if (this.followNode(null, true, duration, style)) {
                    return;
                }
            }
            node = this._scene.getPreviousNode(node);
        }
        if (node && node.getNextCameraConfiguration()) {
            this.followNode(node, true, duration, style);
        }
    };
    /**
     * Changes the list of objects that the active configuration's orientation is set to follow.
     * @param {Object3D[]} targetObjects Should not be null, but an empty list, if no objects are to be specified
     * @param {Number} [duration] The duration of the transition, in milliseconds. If not given, the camera default will be used.
     * @param {Number} [style] (enum Camera.TransitionStyle) The style of the transition to use. If not given, the camera default 
     * will be used.
     */
    Camera.prototype.followOrientationOfObjects = function (targetObjects, duration, style) {
        duration = (duration === undefined) ? this._defaultTransitionDuration : duration;
        if (duration > 0) {
            this.transitionToSameConfiguration(duration, style);
        }
        this._currentConfiguration.setOrientationFollowedObjects(targetObjects, true);
    };
    /**
     * Returns the current progress of the transition, which is a number between 0 and 1 based on which the attributes of the camera can
     * be calculated as a linear combination of the previous and current configurations
     * @returns {Number}
     */
    Camera.prototype._getTransitionProgress = function () {
        var result;
        if (this._transitionDuration === 0) {
            return 0;
        }
        switch (this._transitionStyle) {
            case Camera.TransitionStyle.LINEAR:
                return this._transitionElapsedTime / this._transitionDuration;
            case Camera.TransitionStyle.SMOOTH:
                result = this._transitionElapsedTime / this._transitionDuration;
                result = 3 * result * result - 2 * result * result * result;
                return result;
            default:
                application.crash();
        }
        return -1;
    };
    /**
     * Updates the cached value of the current field of view based on the current configuration(s) and transition.
     * @param {Number} transitionProgress The progress value of the current transition.
     */
    Camera.prototype._updateFOV = function (transitionProgress) {
        this._fov = this._previousConfiguration ?
                this._previousConfiguration.getFOV() + (this._currentConfiguration.getFOV() - this._previousConfiguration.getFOV()) * transitionProgress :
                this._currentConfiguration.getFOV();
    };
    /**
     * Updates the cached value of the current span based on the current configuration(s) and transition.
     * @param {Number} transitionProgress The progress value of the current transition.
     */
    Camera.prototype._updateSpan = function (transitionProgress) {
        this._span = this._previousConfiguration ?
                this._previousConfiguration.getSpan() + (this._currentConfiguration.getSpan() - this._previousConfiguration.getSpan()) * transitionProgress :
                this._currentConfiguration.getSpan();
    };
    /**
     * Updates the cached value of the angle the camera needs to be rotated for stereoscopic rendering.
     */
    Camera.prototype._updateStereoAngle = function () {
        this._stereoAngle = Math.atan(this._interocularHalfDistance / this._stereoscopicConvergenceDistance);
    };
    /**
     * Calculates and sets the world position and orientation and the relative velocity vector of the camera based on the configuration 
     * settings, the transition (if one is in progress) and the commands that were issued by the controller in this simulation step.
     * @param {Number} dt The time that has passed since the last simulation step (in milliseconds)
     */
    Camera.prototype.update = function (dt) {
        var startPositionVector, endPositionVector, previousPositionVector,
                relativeTransitionRotationMatrix, rotations,
                transitionProgress, m;
        this._extendedCameraValid = false;
        this._combinedExtendedCameraValid = false;
        if (this._previousConfiguration) {
            // if a transition is in progress...
            // during transitions, movement and turning commands are not taken into account, therefore updating the configurations without
            // considering those
            if (!this._currentConfiguration.update([0, 0, 0], [0, 0, 0], dt)) {
                this.update(dt);
                return;
            }
            // calculating transition progress based on the elapsed time and the transition style
            this._transitionElapsedTime += dt;
            if (this._transitionElapsedTime > this._transitionDuration) {
                this._transitionElapsedTime = this._transitionDuration;
            }
            transitionProgress = this._getTransitionProgress();
            if (!this._previousConfiguration.update([0, 0, 0], [0, 0, 0], dt)) {
                this.update(dt);
                return;
            }
            // calculate position
            // we can simply interpolate the position on a straight linear path
            startPositionVector = this._previousConfiguration.getPositionVector();
            endPositionVector = this._currentConfiguration.getPositionVector();
            previousPositionVector = this.getCameraPositionVector();
            this._setPositionv(vec.sum3(vec.scaled3(startPositionVector, 1 - transitionProgress), vec.scaled3(endPositionVector, transitionProgress)));
            // calculate the velocity vector
            this._velocityVector = vec.scaled3(vec.prodMat4Vec3(this.getCameraOrientationMatrix(), vec.diff3(this.getCameraPositionVector(), previousPositionVector)), 1000 / dt);
            // calculate orientation
            // calculate the rotation matrix that describes the transformation that needs to be applied on the
            // starting orientation matrix to get the new oritentation matrix (relative to the original matrix)
            relativeTransitionRotationMatrix = mat.prod3x3SubOf4Aux(mat.inverseOfRotation4Aux(this._previousConfiguration.getOrientationMatrix()), this._currentConfiguration.getOrientationMatrix());
            rotations = mat.getRotations(relativeTransitionRotationMatrix);
            // now that the two rotations are calculated, we can interpolate the transformation using the angles
            this._setOrientationM4(mat.IDENTITY4);
            this._rotate(rotations.gammaAxis, rotations.gamma * transitionProgress);
            this._rotate(rotations.alphaAxis, rotations.alpha * transitionProgress);
            m = mat.prod3x3SubOf4Aux(this._previousConfiguration.getOrientationMatrix(), this.getCameraOrientationMatrix());
            mat.correctOrthogonal4(m);
            this._setOrientationM4(m);
            // calculate FOV
            this._updateFOV(transitionProgress);
            this._updateSpan(transitionProgress);
            this._updateProjectionMatrix(this._fov, this._span);
            // if the transition has finished, drop the previous configuration
            if (this._transitionElapsedTime === this._transitionDuration) {
                this._previousConfiguration = null;
            }
        } else {
            // make sure that even if the position / orientation are dependent on each other, both are fully updated for the configuration
            if (!this._currentConfiguration.update(this._controlledVelocityVector, this._angularVelocityVector, dt)) {
                this.update(dt);
                return;
            }
            if (!this._currentConfiguration.update([0, 0, 0], [0, 0, 0], dt)) {
                this.update(dt);
                return;
            }
            // update the position and orientation
            previousPositionVector = this.getCameraPositionVector();
            this._setPositionM4(this._currentConfiguration.getPositionMatrix());
            this._setOrientationM4(this._currentConfiguration.getOrientationMatrix());
            // update the relative velocity vector
            if (this._currentConfiguration.positionFollowsObjects()) {
                if (this._previousFollowedPositionVector) {
                    this._velocityVector = vec.scaled3(
                            vec.prodMat4Vec3(
                                    this.getCameraOrientationMatrix(),
                                    vec.diff3(
                                            this._currentConfiguration.getFollowedPositionVector(),
                                            this._previousFollowedPositionVector)),
                            1000 / dt);
                } else {
                    this._velocityVector = [0, 0, 0];
                }
                this._previousFollowedPositionVector = this._currentConfiguration.getFollowedPositionVector();
            } else {
                this._velocityVector = vec.scaled3(vec.prodMat4Vec3(this.getCameraOrientationMatrix(), vec.diff3(this.getCameraPositionVector(), previousPositionVector)), 1000 / dt);
            }
        }
    };
    /**
     * Puts the camera in the passed stereoscopic state.
     * @param {Number} mode (enum Camera.Stereoscopy)
     */
    Camera.prototype.setStereoscopy = function (mode) {
        if (this._stereoscopy !== mode) {
            this._stereoscopy = mode;
            this._leftEye = (mode === Camera.Stereoscopy.LEFT);
            this._rightEye = (mode === Camera.Stereoscopy.RIGHT);
            this._viewMatrixValid = false;
            this._inversePositionMatrixValid = false;
            this._inverseOrientationMatrixValid = false;
        }
    };
    /**
     * Puts the camera in the stereoscopic state corresponding to the left eye.
     */
    Camera.prototype.setLeftEye = function () {
        this.setStereoscopy(Camera.Stereoscopy.LEFT);
    };
    /**
     * Puts the camera in the stereoscopic state corresponding to the right eye.
     */
    Camera.prototype.setRightEye = function () {
        this.setStereoscopy(Camera.Stereoscopy.RIGHT);
    };
    /**
     * Sets a new interocular distance used for stereoscopic rendering.
     * @param {Number} value In meters.
     */
    Camera.prototype.setInterocularDistance = function (value) {
        this._interocularHalfDistance = value * 0.5;
        this._updateStereoAngle();
    };
    /**
     * Sets a new convergence distance (distance between convergence point and camera position) used for stereoscopic rendering.
     * @param {Number} value In meters.
     */
    Camera.prototype.setStereoscopicConvergenceDistance = function (value) {
        this._stereoscopicConvergenceDistance = value;
        this._updateStereoAngle();
    };
    /**
     * Copies the passed values to be the stereoscopic settings of this camera.
     * @param {Number} mode (enum Camera.Stereoscopy)
     * @param {Number} interocularHalfDistance
     * @param {Number} convergenceDistance
     */
    Camera.prototype.copyStereoscopy = function (mode, interocularHalfDistance, convergenceDistance) {
        this.setStereoscopy(mode);
        if (mode !== Camera.Stereoscopy.NONE) {
            this._interocularHalfDistance = interocularHalfDistance;
            this._stereoscopicConvergenceDistance = convergenceDistance;
            this._updateStereoAngle();
        }
    };
    /**
     * Returns (and caches) a camera that has the same overall parameters as this one (with a free configuration), but its view frustum
     * starts where this one's ends and extends beyond it with a total view distance determined by the CAMERA_EXTENSION_FACTOR.
     * @param {Boolean} [includeOriginalFrustum=false] If true, the created extended camera will have the same near plane as the original,
     * and the same far plane as a regular extended camera.
     * @returns {Camera}
     */
    Camera.prototype.getExtendedCamera = function (includeOriginalFrustum) {
        var /**@type Number*/ span, /**@type Camera*/ result;
        if (!includeOriginalFrustum && this._extendedCameraValid) {
            result = this._extendedCamera;
        } else if (includeOriginalFrustum && this._combinedExtendedCameraValid) {
            result = this._combinedExtendedCamera;
        } else {
            if (this._fov === 0) {
                this._updateFOV();
                this._updateSpan();
            }
            span = includeOriginalFrustum ? this._span : this._span / this._near * this._viewDistance;
            result = includeOriginalFrustum ? this._combinedExtendedCamera : this._extendedCamera;
            if (!result) {
                result = new Camera(
                        this._scene,
                        this._aspect,
                        this._usesVerticalValues,
                        this._viewDistance * CAMERA_EXTENSION_FACTOR,
                        getFreeCameraConfiguration(
                                false,
                                this._object3D.getPositionMatrix(),
                                this._object3D.getOrientationMatrix(),
                                this._fov,
                                this._fov, this._fov,
                                span,
                                span, span));
            } else {
                result.getConfiguration().setToFree(
                        false,
                        this._object3D.getPositionMatrix(),
                        this._object3D.getOrientationMatrix(),
                        this._fov,
                        this._fov, this._fov,
                        span,
                        span, span);
                result.init(this._scene,
                        this._aspect,
                        this._usesVerticalValues,
                        this._viewDistance * CAMERA_EXTENSION_FACTOR,
                        result.getConfiguration());
            }
            result.update(0);
            if (!includeOriginalFrustum) {
                this._extendedCameraValid = true;
                this._extendedCamera = result;
            } else {
                this._combinedExtendedCameraValid = true;
                this._combinedExtendedCamera = result;
            }
        }
        result.copyStereoscopy(this._stereoscopy, this._interocularHalfDistance, this._stereoscopicConvergenceDistance);
        return result;
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        CameraPositionConfiguration: CameraPositionConfiguration,
        CameraOrientationConfiguration: CameraOrientationConfiguration,
        CameraConfiguration: CameraConfiguration,
        Camera: Camera,
        getFreeCameraConfiguration: getFreeCameraConfiguration
    };
});
/**
 * Copyright 2017, 2020 Krisztián Nagy
 * @file Provides container classes for general use.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, Element, Float32Array, performance */

define('modules/containers',[],function () {
    "use strict";
    /**
     * @typedef {Object} DirectDoubleLinkedList~Element
     * @property {DirectDoubleLinkedList~Element} next A reference to the next list element.
     * @property {DirectDoubleLinkedList~Element} previous A reference to the previous list element.
     * @property {DirectDoubleLinkedList} list A reference to the linked list which this element is part of.
     */
    /**
     * @class A linked list class that is
     * - direct: to be used with elements that directly hold the linked list-related properties. One element can only be part of one linked
     * list. Element properties must not clash with the linked list properties.
     * - double-linked: links to both next and previous elements are available
     */
    function DirectDoubleLinkedList() {
        /**
         * The first element of the list.
         * @type DirectDoubleLinkedList~Element
         */
        this._first = null;
        /**
         * The last element of the list.
         * @type DirectDoubleLinkedList~Element
         */
        this._last = null;
        /**
         * The number of elements the list currently holds.
         * @type Number
         */
        this._length = 0;
    }
    /**
     * Appends the passed element to the end of the list.
     * @param {DirectDoubleLinkedList~Element} element
     */
    DirectDoubleLinkedList.prototype.add = function (element) {
        if (!this._first) {
            this._first = element;
            element.previous = null;
        } else {
            this._last.next = element;
            element.previous = this._last;
        }
        element.next = null;
        element.list = this;
        this._last = element;
        this._length++;
    };
    /**
     * Removes the passed element if it is contained in the list.
     * @param {DirectDoubleLinkedList~Element} element
     */
    DirectDoubleLinkedList.prototype.remove = function (element) {
        if (element.list === this) {
            if (element.previous) {
                element.previous.next = element.next;
            } else {
                this._first = element.next;
            }
            if (element.next) {
                element.next.previous = element.previous;
            } else {
                this._last = element.previous;
            }
            element.list = null;
            this._length--;
        }
    };
    /**
     * Removes all elements from the list.
     * @param {Boolean} [hard=false] If true, also removes the reference to this list stored in the elements.
     */
    DirectDoubleLinkedList.prototype.clear = function (hard) {
        var element;
        if (hard) {
            for (element = this._first; element; element = element.next) {
                element.list = null;
            }
        }
        this._first = null;
        this._last = null;
        this._length = 0;
    };
    /**
     * Returns the number of elements that are currently in the list.
     * @returns {Number}
     */
    DirectDoubleLinkedList.prototype.getLength = function () {
        return this._length;
    };
    /**
     * Returns the first element of the list.
     * @returns {DirectDoubleLinkedList~Element}
     */
    DirectDoubleLinkedList.prototype.getFirst = function () {
        return this._first;
    };
    /**
     * Returns the last element of the list.
     * @returns {DirectDoubleLinkedList~Element}
     */
    DirectDoubleLinkedList.prototype.getLast = function () {
        return this._last;
    };
    /**
     * Returns the element coming after the passed element in the list, or the first element, if the passed element is the last element in
     * the list, it is not in the list or it is not given.
     * @param {DirectDoubleLinkedList~Element} [element]
     */
    DirectDoubleLinkedList.prototype.getNext = function (element) {
        if (element && (element.list === this)) {
            return element.next || this._first;
        }
        return this._first;
    };
    /**
     * Returns the element coming before the passed element in the list, or the last element, if the passed element is the first element in
     * the list, it is not in the list or it is not given.
     * @param {DirectDoubleLinkedList~Element} [element]
     */
    DirectDoubleLinkedList.prototype.getPrevious = function (element) {
        if (element && (element.list === this)) {
            return element.previous || this._last;
        }
        return this._last;
    };
    /**
     * Appends the elements of this linked list to the end of the passed regular JS array.
     * @param {Array} array
     */
    DirectDoubleLinkedList.prototype.appendToArray = function (array) {
        var element, i;
        i = array.length;
        array.length = i + this._length;
        for (element = this._first; element; element = element.next, i++) {
            array[i] = element;
        }
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        DirectDoubleLinkedList: DirectDoubleLinkedList
    };
});
/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides a basic physics engine with Newtonian mechanics
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define */

/**
 * @param utils Used for point in rectangle checks
 * @param vec Used for vector operations
 * @param mat Used for matrix operations
 * @param containers Used for linked lists
 */
define('modules/physics',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/containers"
], function (utils, vec, mat, containers) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // constants
            /**
             * The angular velocity matrix of a physical object stores the rotation that happens during this duration at the current angular
             * velocity of the object. In milliseconds.
             * @type Number
             */
            ANGULAR_VELOCITY_MATRIX_DURATION = 5,
            /**
             * Values closer to zero or plus/minus one than this will be reset to zero or plus/minus one in the velocity matrix.
             * @type Number
             */
            VELOCITY_MATRIX_ERROR_THRESHOLD = 0.0001,
            /**
             * Values closer to zero or plus/minus one than this will be reset to zero or plus/minus one in the angular velocity matrix.
             * @type Number
             */
            ANGULAR_VELOCITY_MATRIX_ERROR_THRESHOLD = 0.00001,
            /**
             * The minimum amount of time required for the effect of a force or torque to be taken into account, in milliseconds.
             * @type Number
             */
            MINIMUM_EFFECT_DURATION = 0.1,
            /**
             * The drag force will affect objects with a velocity higher than this, meters / second
             * @type Number
             */
            MINIMUM_DRAG_VELOCITY = 0.1,
            /**
             * The angular drag torque will affect objects with an angular velocity higher than this, radians / ANGULAR_VELOCITY_MATRIX_DURATION milliseconds
             * @type Number
             */
            MINIMUM_DRAG_ANGLE = 0.001,
            // ----------------------------------------------------------------------
            // module variables
            /**
             * The global drag coefficient
             * @type Number
             */
            _drag = 0,
            /**
             * The global angular drag coefficient
             * @type Number
             */
            _angularDrag = 0;
    // #########################################################################
    /**
     * The global drag coefficient
     * @returns {Number}
     */
    function getDrag() {
        return _drag;
    }
    /**
     * Sets the global drag and angular drag coefficients
     * @param {Number} drag
     * @param {Number} angularDrag
     */
    function setDrag(drag, angularDrag) {
        _drag = drag;
        _angularDrag = angularDrag;
    }
    // #########################################################################
    /**
     * @class Represents a force affecting a physical object, causing it to 
     * accelerate at a constant rate in the direction of the force.
     * @param {Number} strength The strength of the force in newtons.
     * @param {Number[3]} direction The vector describing the direction in which
     * the force creates the acceleration. Needs to be a unit vector. 
     * #persistent, #read-write
     * @param {Number} [duration] The duration while the force is still in effect, 
     * given in milliseconds. If omitted, the force will be created as continuous.
     */
    function Force(strength, direction, duration) {
        /**
         * Magnitude of the force, in newtons.
         * @type Number
         */
        this._strength = strength;
        /**
         * Attack direction vector of the force. Unit vector.
         * @type Number[3]
         */
        this._direction = direction;
        /**
         * For how much more time is this force in effect, in milliseconds. For continuous forces, 0 means the force is in effect and a negative
         * value means it is currently not in effect.
         * @type Number
         */
        this._duration = duration || 0;
        /**
         * Whether this force is continuous - it is exerted for (the entire duration of) every simulation step when it is renewed, and ignored when not.
         * @type Boolean
         */
        this._continuous = (duration === undefined);
        // direct linked list element properties
        this.next = null;
        this.previous = null;
        this.list = null;
    }
    // methods
    /**
     * Updates the properties of a continuous force, placing it back into effect for the current simulation step
     * @param {Number} strength In newtowns
     * @param {Number[3]} direction A unit vector.
     * #temporary, #ready-only
     */
    Force.prototype.renew = function (strength, direction) {
        this._strength = strength;
        vec.setVector3(this._direction, direction);
        this._duration = 0;
    };
    /**
     * Decreases the remaining exertion duration of the force by maxmimum the passed amount,
     * and returns for how long the force was really exerted (which might be smaller if there
     * is less duration left than the passed amount)
     * @param {Number} dt Elapsed time in milliseconds.
     * @returns {Number} The duration of the exertion of this force in milliseconds.
     */
    Force.prototype.exert = function (dt) {
        if (this._continuous) {
            if (this._duration < 0) {
                return 0;
            }
            this._duration = -1;
            return dt;
        }
        if (this._duration >= MINIMUM_EFFECT_DURATION) {
            var t = Math.min(this._duration, dt);
            this._duration -= dt;
            return t;
        }
        return 0;
    };
    /**
     * Returns the vector corresponding to the acceleration this force causes on 
     * an object that has the passed mass.
     * @param {Number} inverseMass The reciprocal of the mass of the object to accelerate, in kg.
     * @returns {Number[3]} The acceleration vector, in m/s^2.
     */
    Force.prototype.getAccelerationVector = function (inverseMass) {
        return vec.scaled3(this._direction, this._strength * inverseMass);
    };
    /**
     * Returns whether this force object can be reused as the force represented is no longer in effect.
     * @returns {Boolean}
     */
    Force.prototype.canBeReused = function () {
        return (this._duration < MINIMUM_EFFECT_DURATION) && !this._continuous;
    };
    // #########################################################################
    /**
     * @class Represents a torque affecting a physical object, causing it to 
     * accelerate its spinning around the axis of the torque at a constant rate.
     * @param {Number} strength The strength of the torque in kg*rad/s^2.
     * @param {Number[3]} axis The vector describing the axis of spinning. Needs to be a unit vector.
     * #persistent, #read-write
     * @param {Number} [duration] The duration while the torque is still in effect,
     * given in milliseconds. If omitted, the torque will be created as continuous.
     */
    function Torque(strength, axis, duration) {
        /**
         * Magnitude of the torque, in kg*rad/s^2.
         * @type Number
         */
        this._strength = strength;
        /**
         * Axis of the spinning which this torque accelerates. Unit vector.
         * @type Number[3]
         */
        this._axis = axis;
        /**
         * For how much more time is this torque in effect, in milliseconds. For continuous torques, 0 means the torque is in effect and a negative
         * value means it is currently not in effect.
         * @type Number
         */
        this._duration = duration || 0;
        /**
         * Whether this torque is continuous - it is exerted for (the entire duration of) every simulation step when it is renewed, and ignored when not.
         * @type Boolean
         */
        this._continuous = (duration === undefined);
        // direct linked list element properties
        this.next = null;
        this.previous = null;
        this.list = null;
    }
    // methods
    /**
     * Updates the properties of a continuous torque.
     * @param {Number} strength
     * @param {Number[3]} axis #temporary, #read-only
     */
    Torque.prototype.renew = function (strength, axis) {
        this._strength = strength;
        vec.setVector3(this._axis, axis);
        this._duration = 0;
    };
    /**
     * Decreases the remaining exertion duration of the torque by maxmimum the passed amount,
     * and returns for how long the torque was really exerted (which might be smaller if there
     * is less duration left than the passed amount)
     * @param {Number} dt Elapsed time in milliseconds.
     * @returns {Number} The duration of the exertion of this torque in 
     * milliseconds.
     */
    Torque.prototype.exert = function (dt) {
        if (this._continuous) {
            if (this._duration < 0) {
                return 0;
            }
            this._duration = -1;
            return dt;
        }
        if (this._duration >= MINIMUM_EFFECT_DURATION) {
            var t = Math.min(this._duration, dt);
            this._duration -= dt;
            return t;
        }
        return 0;
    };
    /**
     * Returns the rotation matrix corresponding to the angular acceleration 
     * this torque causes on an object that has the passed mass if exerted for
     * the given time.
     * Uses an auxiliary matrix, only use when the result is needed temporarily!
     * @param {Number} inverseMass The reciprocal of the mass of the object to accelerate, in kg.
     * @param {Number} t The time of exertion, in seconds.
     * @returns {Float32Array} A 3x3 rotation matrix.
     */
    Torque.prototype.getAngularAccelerationMatrixOverTime = function (inverseMass, t) {
        // in reality, the shape of the object should be taken into account,
        // for simplicity, the mass is taken as the only coefficient
        return mat.rotation3Aux(this._axis, this._strength * inverseMass * t);
    };
    /**
     * Returns whether this torque object can be reused as the torque represented is no longer in effect.
     * @returns {Boolean}
     */
    Torque.prototype.canBeReused = function () {
        return (this._duration < MINIMUM_EFFECT_DURATION) && !this._continuous;
    };
    // #########################################################################
    /**
     * @class Represents a physical body with a box shape in space.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix describing
     * the initial position of the body (relative to its parent).
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix describing
     * the initial orientation of the body (relative to its parent).
     * @param {Number[3]} dimensions The size of the box this body represents
     * along the 3 axes, in relative (unoriented) space.
     * @returns {Body}
     */
    function Body(positionMatrix, orientationMatrix, dimensions) {
        /**
         * The 4x4 translation matrix describing the position of the body 
         * (relative to its parent).
         * @type Float32Array
         */
        this._positionMatrix = positionMatrix;
        /**
         * A 3D vector describing the position of the body (relative to its parent).
         * @type Number[3]
         */
        this._positionVector = mat.translationVector3(positionMatrix);
        /**
         * The 4x4 rotation matrix describing the orientation of the body 
         * (relative to its parent).
         * @type Float32Array
         */
        this._orientationMatrix = orientationMatrix;
        /**
         * A boolean flag indicating whether this body has a non-identity orientation.
         * @type Boolean
         */
        this._rotated = !mat.equal4(orientationMatrix, mat.IDENTITY4);
        /**
         * The cached inverse of the model matrix of the body.
         * @type Float32Array
         */
        this._modelMatrixInverse = null;
        /**
         * Half of the size of the box this body represents along the X axis, in relative 
         * (unoriented) space.
         * @type Number
         */
        this._halfWidth = dimensions[0] * 0.5;
        /**
         * Half of the size of the box this body represents along the Y axis, in relative 
         * (unoriented) space.
         * @type Number
         */
        this._halfHeight = dimensions[1] * 0.5;
        /**
         * Half of the size of the box this body represents along the Z axis, in relative 
         * (unoriented) space.
         * @type Number
         */
        this._halfDepth = dimensions[2] * 0.5;
        /**
         * Reusable variable to temporarity store the result of the last model transform call
         * @type Number
         */
        this._modelTransformResult = [0, 0, 0, 1];
    }
    // direct getters and setters
    /**
     * Return the 4x4 translation matrix describing the position of the body 
     * (relative to its parent).
     * @returns {Float32Array}
     */
    Body.prototype.getPositionMatrix = function () {
        return this._positionMatrix;
    };
    /**
     * Return the 4x4 rotation matrix describing the orientation of the body 
     * (relative to its parent).
     * @returns {Float32Array}
     */
    Body.prototype.getOrientationMatrix = function () {
        return this._orientationMatrix;
    };
    /**
     * Returns the size of the box this body represents along the X axis, in 
     * relative (unoriented) space.
     * @returns {Number}
     */
    Body.prototype.getWidth = function () {
        return this._halfWidth * 2;
    };
    /**
     * Returns the size of the box this body represents along the Y axis, in 
     * relative (unoriented) space.
     * @returns {Number}
     */
    Body.prototype.getHeight = function () {
        return this._halfHeight * 2;
    };
    /**
     * Returns the size of the box this body represents along the Z axis, in 
     * relative (unoriented) space.
     * @returns {Number}
     */
    Body.prototype.getDepth = function () {
        return this._halfDepth * 2;
    };
    // indirect getters and setters
    /**
     * Transforms and returns the given 3D vector according to the position and orientation of this body. Returns a 4D vector.
     * @param {Number[3]} vector
     * @returns {Number[4]}
     */
    Body.prototype._modelTransform = function (vector) {
        if (this._rotated) {
            vec.setSum3(this._modelTransformResult, vec.prodVec3Mat4Aux(vector, this._orientationMatrix), this._positionVector);
        } else {
            vec.setSum3(this._modelTransformResult, vector, this._positionVector);
        }
        return this._modelTransformResult;
    };
    /**
     * Returns the inverse of the model matrix (the matrix representing both the
     * position and orientation of the body)
     * @returns {Float32Array} A 4x4 transformation matrix.
     */
    Body.prototype.getModelMatrixInverse = function () {
        this._modelMatrixInverse = this._modelMatrixInverse || mat.prodTranslationRotation4(mat.inverseOfTranslation4Aux(this._positionMatrix), mat.inverseOfRotation4Aux(this._orientationMatrix));
        return this._modelMatrixInverse;
    };
    /**
     * Returns the half of the width, height and depth of the body in an array.
     * @returns {Number[3]}
     */
    Body.prototype.getHalfDimensions = function () {
        return [this._halfWidth, this._halfHeight, this._halfDepth];
    };
    // methods
    /**
     * Checks whether a point-like body moving along a given vector has hit this body.
     * @param {Number[4]} relativePositionVector A 4D vector describing the current position of the point-like body in model space.
     * @param {Number[3]} relativeDirectionVector A 3D unit (one meter long) vector describing the direction the body is moving towards
     * in model space.
     * @param {Number} range The distance from the current position within which the hit point is to be located in order to count it as a
     * hit, in meters. E.g. to check whether an object moving at 10 m/s has hit this body within the past 5 seconds, this should be 50.
     * @param {Number} offset The boundaries of the box of the body are offset (the size increased) by this much (in model space)
     * @returns {Number[4]|null} The point of intersection where the object has hit or null if it did not.
     */
    Body.prototype.checkHit = function (relativePositionVector, relativeDirectionVector, range, offset) {
        var d, ipx, ipy, halfWidth = this._halfWidth + offset, halfHeight = this._halfHeight + offset, halfDepth = this._halfDepth + offset;
        // first transform the coordinates from model-space (physical object space) to body-space
        if (this._rotated) {
            // we should not modify relativePositionVector, so creating a new one instead of multiplying in-place
            relativePositionVector = vec.prodVec4Mat4Aux(relativePositionVector, this.getModelMatrixInverse());
            relativeDirectionVector = vec.prodVec3Mat3Aux(relativeDirectionVector, mat.matrix3from4Aux(mat.inverseOfRotation4Aux(this._orientationMatrix)));
        } else {
            // we should not modify relativePositionVector, so creating a new one instead of subtracting in-place
            relativePositionVector = vec.diff3Aux(relativePositionVector, this._positionVector);
        }
        // if the object has a velocity along X, it is possible it has hit at the left or right planes
        if (relativeDirectionVector[0] !== 0) {
            // if the object has a positive velocity, it could have hit the left plane (or a plane at other axes, but not the right plane)
            if (relativeDirectionVector[0] > 0) {
                // calculate the distance from the given point at which the object reached / will reach the left plane
                // we are actually calculating the fraction (ratio) of the relative direction vector at which the plane is reached, but
                // since the length on the direction vector is one meter, this will equal the distance
                // a positive number will indicate impact with the plane in the future and a negative one will indicate impact in the past
                d = (-halfWidth - relativePositionVector[0]) / relativeDirectionVector[0];
                // calculate the coordinates of the intersection point with the left plane (Y and Z coordinates)
                ipx = relativePositionVector[1] + relativeDirectionVector[1] * d;
                ipy = relativePositionVector[2] + relativeDirectionVector[2] * d;
                // check if the intersection point is within the left face of this box, which means the object entered or will enter the
                // box through the left face
                if (utils.pointInRect(ipx, ipy, -halfHeight, -halfDepth, halfHeight, halfDepth)) {
                    // if the impact already happened and it happened within the given range then we can return the intersection point
                    // (transformed back into model (physical object) space)
                    if ((d <= 0) && (d >= -range)) {
                        return this._modelTransform([-halfWidth, ipx, ipy]);
                    }
                    // if the entry point is on the left face but the impact did not happen yet or happened too far in the past (which means 
                    // it is possible it did not even happen as this is just an extrapolation of the path to a whole infinite line, while 
                    // the object only was created at a certain point and it could have changed direction), then it means there is no hit
                    // (yet) and no need to check the other faces, since we found the one where the entry happens
                    return null;
                }
            } else {
                // if the object has a negative velocity along X, check for the right face of the box the same way
                d = (halfWidth - relativePositionVector[0]) / relativeDirectionVector[0];
                ipx = relativePositionVector[1] + relativeDirectionVector[1] * d;
                ipy = relativePositionVector[2] + relativeDirectionVector[2] * d;
                if (utils.pointInRect(ipx, ipy, -halfHeight, -halfDepth, halfHeight, halfDepth)) {
                    if ((d <= 0) && (d >= -range)) {
                        return this._modelTransform([halfWidth, ipx, ipy]);
                    }
                    return null;
                }
            }
        }
        // if the entry point of the object's path in not on the left or right faces of the box, check for the faces along the other 2 axes
        // exactly the same way
        if (relativeDirectionVector[1] !== 0) {
            if (relativeDirectionVector[1] > 0) {
                d = (-halfHeight - relativePositionVector[1]) / relativeDirectionVector[1];
                ipx = relativePositionVector[0] + relativeDirectionVector[0] * d;
                ipy = relativePositionVector[2] + relativeDirectionVector[2] * d;
                if (utils.pointInRect(ipx, ipy, -halfWidth, -halfDepth, halfWidth, halfDepth)) {
                    if ((d <= 0) && (d >= -range)) {
                        return this._modelTransform([ipx, -halfHeight, ipy]);
                    }
                    return null;
                }
            } else {
                d = (halfHeight - relativePositionVector[1]) / relativeDirectionVector[1];
                ipx = relativePositionVector[0] + relativeDirectionVector[0] * d;
                ipy = relativePositionVector[2] + relativeDirectionVector[2] * d;
                if (utils.pointInRect(ipx, ipy, -halfWidth, -halfDepth, halfWidth, halfDepth)) {
                    if ((d <= 0) && (d >= -range)) {
                        return this._modelTransform([ipx, halfHeight, ipy]);
                    }
                    return null;
                }
            }
        }
        if (relativeDirectionVector[2] !== 0) {
            if (relativeDirectionVector[2] > 0) {
                d = (-halfDepth - relativePositionVector[2]) / relativeDirectionVector[2];
                ipx = relativePositionVector[0] + relativeDirectionVector[0] * d;
                ipy = relativePositionVector[1] + relativeDirectionVector[1] * d;
                if (utils.pointInRect(ipx, ipy, -halfWidth, -halfHeight, halfWidth, halfHeight)) {
                    if ((d <= 0) && (d >= -range)) {
                        return this._modelTransform([ipx, ipy, -halfDepth]);
                    }
                    return null;
                }
            } else {
                d = (halfDepth - relativePositionVector[2]) / relativeDirectionVector[2];
                ipx = relativePositionVector[0] + relativeDirectionVector[0] * d;
                ipy = relativePositionVector[1] + relativeDirectionVector[1] * d;
                if (utils.pointInRect(ipx, ipy, -halfWidth, -halfHeight, halfWidth, halfHeight)) {
                    if ((d <= 0) && (d >= -range)) {
                        return this._modelTransform([ipx, ipy, halfDepth]);
                    }
                    return null;
                }
            }
        }
        return null;
    };
    // #########################################################################
    /**
     * @class The basic entity for all physical simulations. Can have physical properties and interact with other objects.
     * @param {Number} mass The mass of the physical object in kg.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix describing the initial position of the object. (in meters)
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix describing the initial orientation of the object.
     * @param {Float32Array} scalingMatrix The 4x4 scaling matrix describing the initial scaling of the object.
     * @param {Float32Array} initialVelocityMatrix The 4x4 translation matrix  describing the initial velocity of the object. (in m/s)
     * @param {Body[]} [bodies] The array of bodies this object is comprised of.
     * @param {Boolean} [fixedOrientation=false] When true, the orientation of the object cannot change during simulation steps as the 
     * related calculations are not performed (for optimization)
     * @param {Boolean} [fixedVelocity=false] When true, the velocity of the object is not changed by any added forces (can still be 
     * changed by directly applying forces)
     * @param {Number} [dragFactor=1] If there is a global drag coefficient set, the drag experienced by this object will be multiplied by this factor
     */
    function PhysicalObject(mass, positionMatrix, orientationMatrix, scalingMatrix, initialVelocityMatrix, bodies, fixedOrientation, fixedVelocity, dragFactor) {
        /**
         * The mass in kilograms.
         * @type Number
         */
        this._mass = 0;
        /**
         * The 4x4 translation matrix describing the position of the object. (meters, world space)
         * @type Float32Array
         */
        this._positionMatrix = mat.identity4();
        /**
         * The 4x4 rotation matrix describing the orientation of the object.
         * @type Float32Array
         */
        this._orientationMatrix = mat.identity4();
        /**
         * The 4x4 scaling matrix describing the scale of the object.
         * @type Float32Array
         */
        this._scalingMatrix = mat.identity4();
        /**
         * The cached inverse of the orientation matrix.
         * @type Float32Array
         */
        this._rotationMatrixInverse = mat.identity4();
        /**
         * Whether the cached value of the inverse orientation matrix is currently valid
         * @type Boolean
         */
        this._rotationMatrixInverseValid = false;
        /**
         * The cached inverse of the scaling matrix.
         * @type Float32Array
         */
        this._scalingMatrixInverse = mat.identity4();
        /**
         * Whether the cached value of the inverse scaling matrix is currently valid
         * @type Boolean
         */
        this._scalingMatrixInverseValid = false;
        /**
         * The cached inverse of the model (position + orientation + scaling) matrix.
         * @type Float32Array
         */
        this._modelMatrixInverse = mat.identity4();
        /**
         * Whether the cached value of the inverse model matrix is currently valid
         * @type Boolean
         */
        this._modelMatrixInverseValid = false;
        /**
         * The 4x4 translation matrix describing the velocity of the object. (m/s)
         * @type Float32Array
         */
        this._velocityMatrix = mat.identity4();
        /**
         * The acceleration caused by the directly applied and the added forces is
         * accumulated for the current simulation step in this vector.
         * @type Number[3]
         */
        this._acceleration = [0, 0, 0];
        /**
         * The movement caused by the directly applied forces during the current
         * simulation step (a/2*t^2) is accumulated in this vector.
         * @type Number[3]
         */
        this._offset = [0, 0, 0];
        /**
         * The 4x4 rotation matrix describing the rotation the current angular velocity of the object causes over 
         * ANGULAR_VELOCITY_MATRIX_DURATION milliseconds. (because rotation is performed in steps as matrix rotation cannot be interpolated)
         * @type Float32Array
         */
        this._angularVelocityMatrix = mat.identity4();
        /**
         * The angular acceleration caused by the directly applied and the added 
         * torques is accumulated for the current simulation step in this 3x3 rotation matrix.
         * @type Float32Array
         */
        this._angularAccelerationMatrix = mat.identity3();
        /**
         * The rotation caused by the directly applied torques during the current
         * simulation step (a/2*t^2) is accumulated in this 3x3 rotation matrix.
         * @type Float32Array
         */
        this._orientationOffset = mat.identity3();
        /**
         * Whether the object has angular acceleration in the current simulation step.
         * @type Boolean
         */
        this._hasAngularAcceleration = false;
        /**
         * The list of forces affecting this object.
         * @type DirectDoubleLinkedList
         */
        this._forces = new containers.DirectDoubleLinkedList();
        /**
         * The list of torques affecting this object.
         * @type DirectDoubleLinkedList
         */
        this._torques = new containers.DirectDoubleLinkedList();
        /**
         * The list of bodies the structure of this object is comprised of. (for hit/collision check)
         * @type Body[]
         */
        this._bodies = null;
        // optimization variables:
        /**
         * The cached size of the whole structure (the distance between the center of the object and the farthest point of its bodies)
         * @type Number
         */
        this._bodySize = -1;
        /**
         * When true, the velocity of the object is not changed by any added forces (can still be changed by directly applying forces)
         * Makes the simulate() call faster by omitting the related calculations
         * @type Boolean
         */
        this._fixedVelocity = false;
        /**
         * When true, the orientation of the object cannot change during simulation steps as the related calculations are not performed 
         * (for optimization)
         * @type Boolean
         */
        this._fixedOrientation = false;
        /**
         * If there is a global drag coefficient set, the drag experienced by this object will be multiplied by this factor
         * @type Number
         */
        this._dragFactor = 0;
        /**
         * Cached value of the reciprocal of the current X scaling
         * @type Number
         */
        this._inverseScalingFactor = 1;
        /**
         * Cached value of the reciprocal of the mass of this object
         * @type Number
         */
        this._inverseMass = 0;
        if (positionMatrix) {
            this.init(mass, positionMatrix, orientationMatrix, scalingMatrix, initialVelocityMatrix, bodies, fixedOrientation, fixedVelocity, dragFactor);
        }
    }
    /**
     * @param {Number} mass The mass of the physical object in kg.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix describing the initial position of the object. (in meters)
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix describing the initial orientation of the object.
     * @param {Float32Array} scalingMatrix The 4x4 scaling matrix describing the initial scaling of the object.
     * @param {Float32Array} initialVelocityMatrix The 4x4 translation matrix  describing the initial velocity of the object. (in m/s)
     * @param {Body[]} [bodies] The array of bodies this object is comprised of.
     * @param {Boolean} [fixedOrientation=false] When true, the orientation of the object cannot change during simulation steps as the 
     * related calculations are not performed (for optimization)
     * @param {Boolean} [fixedVelocity=false] When true, the velocity of the object is not changed by any added forces (can still be 
     * changed by directly applying forces)
     * @param {Number} [dragFactor=1] If there is a global drag coefficient set, the drag experienced by this object will be multiplied by this factor
     */
    PhysicalObject.prototype.init = function (mass, positionMatrix, orientationMatrix, scalingMatrix, initialVelocityMatrix, bodies, fixedOrientation, fixedVelocity, dragFactor) {
        this._mass = mass;
        this._inverseMass = 1 / mass;
        mat.copyTranslation4(this._positionMatrix, positionMatrix);
        mat.setMatrix4(this._orientationMatrix, orientationMatrix);
        mat.copyScaling4(this._scalingMatrix, scalingMatrix);
        this._rotationMatrixInverseValid = false;
        this._scalingMatrixInverseValid = false;
        this._modelMatrixInverseValid = false;
        mat.copyTranslation4(this._velocityMatrix, initialVelocityMatrix);
        vec.setNull3(this._acceleration);
        vec.setNull3(this._offset);
        mat.setIdentity4(this._angularVelocityMatrix);
        mat.setIdentity3(this._angularAccelerationMatrix);
        mat.setIdentity3(this._orientationOffset);
        this._hasAngularAcceleration = false;
        this._inverseScalingFactor = 1 / this._scalingMatrix[0];
        this._forces.clear();
        this._torques.clear();
        this._bodies = bodies || utils.EMPTY_ARRAY;
        this._bodySize = -1;
        this._calculateBodySize();
        this._fixedOrientation = !!fixedOrientation;
        this._fixedVelocity = !!fixedVelocity;
        this._dragFactor = (dragFactor !== undefined) ? dragFactor : 1;
    };
    /**
     * Removes all forces, torques, velocity and angular velocity from the object.
     */
    PhysicalObject.prototype.reset = function () {
        mat.setIdentity4(this._velocityMatrix);
        mat.setIdentity4(this._angularVelocityMatrix);
        this._forces.clear();
        this._torques.clear();
    };
    // direct getters and setters
    /**
     * The mass of the physical object in kilograms.
     * @returns {Number}
     */
    PhysicalObject.prototype.getMass = function () {
        return this._mass;
    };
    /**
     * If there is a global drag coefficient set, the drag experienced by this object will be multiplied by this factor
     * @param {Number} value
     */
    PhysicalObject.prototype.setDragFactor = function (value) {
        this._dragFactor = value;
    };
    /**
     * Returns the 4x4 translation matrix describing the position of the object.
     * (meters, world space)
     * @returns {Float32Array}
     */
    PhysicalObject.prototype.getPositionMatrix = function () {
        return this._positionMatrix;
    };
    /**
     * Copies the value of a 3D vector describing the position of this object to the passed vector
     * @param {Number[3]} destination 
     */
    PhysicalObject.prototype.copyPositionToVector = function (destination) {
        destination[0] = this._positionMatrix[12];
        destination[1] = this._positionMatrix[13];
        destination[2] = this._positionMatrix[14];
    };
    /**
     * Returns the 4x4 rotation matrix describing the orientation of the object.
     * @returns {Float32Array}
     */
    PhysicalObject.prototype.getOrientationMatrix = function () {
        return this._orientationMatrix;
    };
    /**
     * Returns the 4x4 scaling matrix describing the scale of the object.
     * @returns {Float32Array}
     */
    PhysicalObject.prototype.getScalingMatrix = function () {
        return this._scalingMatrix;
    };
    /**
     * Returns the distance between the center of the object and the farthest point of its bodies (in object-space)
     * @returns {Number}
     */
    PhysicalObject.prototype.getBodySize = function () {
        return this._bodySize;
    };
    /**
     * Returns the distance between the center of the object and the farthest point of its bodies in world coordinates, baded on the
     * scaling of the object along axis X.
     * @returns {Number}
     */
    PhysicalObject.prototype.getSize = function () {
        return this._bodySize * this._scalingMatrix[0];
    };
    /**
     * Returns the 4x4 translation matrix describing the velocity of the object.
     * (in m/s)
     * @returns {Float32Array}
     */
    PhysicalObject.prototype.getVelocityMatrix = function () {
        return this._velocityMatrix;
    };
    /**
     * Directly (by reference) sets the 4x4 translation matrix describing the velocity of the object.
     * (in m/s)
     * @param{Float32Array} value
     */
    PhysicalObject.prototype.setVelocityMatrix = function (value) {
        this._velocityMatrix = value;
    };
    /**
     * Returns the 4x4 rotation matrix describing the rotation the current angular
     * velocity of the object causes over ANGULAR_VELOCITY_MATRIX_DURATION milliseconds.
     * @returns {Float32Array}
     */
    PhysicalObject.prototype.getAngularVelocityMatrix = function () {
        return this._angularVelocityMatrix;
    };
    /**
     * Adds a force that will affect this object from now on.
     * @param {Force} force
     * @returns {Force} The added force
     */
    PhysicalObject.prototype.addForce = function (force) {
        this._forces.add(force);
        return force;
    };
    /**
     * Directly applies the force described by the parameters, without adding it to the 
     * list of active forces.
     * @param {Number} strength In newtons (kg*m/s^2)
     * @param {Number} x X coordinate of the direction of the force
     * @param {Number} y Y coordinate of the direction of the force
     * @param {Number} z Z coordinate of the direction of the force
     * @param {Number} duration In ms
     */
    PhysicalObject.prototype.applyForce = function (strength, x, y, z, duration) {
        var
                t = duration * 0.001, // t is in seconds
                factor = strength * this._inverseMass * 0.5 * t * t;
        this._offset[0] += x * factor;
        this._offset[1] += y * factor;
        this._offset[2] += z * factor;
        factor = strength * this._inverseMass * t;
        this._acceleration[0] += x * factor;
        this._acceleration[1] += y * factor;
        this._acceleration[2] += z * factor;
    };
    /**
     * Adds a torque that will affect this object from now on.
     * @param {Torque} torque
     * @returns {Torque} The added torque
     */
    PhysicalObject.prototype.addTorque = function (torque) {
        this._torques.add(torque);
        return torque;
    };
    /**
     * Directly applies the torque described by the parameters, without adding it to the 
     * list of active torques.
     * @param {Number} strength In kg*rad/s^2
     * @param {Number[3]} axis Needs to be a unit vector
     * @param {Number} duration In ms
     */
    PhysicalObject.prototype.applyTorque = function (strength, axis, duration) {
        var
                t = duration * 0.001, // t is in seconds
                factor = strength * this._inverseMass * t;
        this._hasAngularAcceleration = true;
        mat.mul3(
                this._orientationOffset,
                mat.rotation3Aux(axis, factor * 0.5 * t));
        // angular acceleration matrix stores angular acceleration for ANGULAR_VELOCITY_MATRIX_DURATION ms
        mat.mul3(
                this._angularAccelerationMatrix,
                mat.rotation3Aux(axis, factor * ANGULAR_VELOCITY_MATRIX_DURATION * 0.001));
    };
    // indirect getters and setters
    /**
     * Sets the position for this object to the passed matrix.
     * @param {Float32Array} value A 4x4 translation matrix.
     */
    PhysicalObject.prototype.setPositionMatrix = function (value) {
        if (value) {
            this._positionMatrix = value;
        }
        this._modelMatrixInverseValid = false;
    };
    /**
     * Sets the orientation for this object to the passed matrix.
     * @param {Float32Array} value A 4x4 rotation matrix.
     */
    PhysicalObject.prototype.setOrientationMatrix = function (value) {
        if (value) {
            this._orientationMatrix = value;
        }
        this._rotationMatrixInverseValid = false;
        this._modelMatrixInverseValid = false;
    };
    /**
     * Sets the scaling for this object to the passed matrix.
     * @param {Float32Array} value
     */
    PhysicalObject.prototype.setScalingMatrix = function (value) {
        this._scalingMatrix = value;
        this._scalingMatrixInverseValid = false;
        this._modelMatrixInverseValid = false;
        this._inverseScalingFactor = 1 / this._scalingMatrix[0];
    };
    /**
     * Returns the inverse of the rotation matrix and stores it in a cache to
     * make sure it is only calculated again if the rotation matrix changes.
     * @returns {Float32Array}
     */
    PhysicalObject.prototype.getRotationMatrixInverse = function () {
        if (!this._rotationMatrixInverseValid) {
            mat.setInverseOfRotation4(this._rotationMatrixInverse, this._orientationMatrix);
            this._rotationMatrixInverseValid = true;
        }
        return this._rotationMatrixInverse;
    };
    /**
     * Returns the inverse of the scaling matrix and stores it in a cache to
     * make sure it is only calculated again if the scaling matrix changes.
     * @returns {Float32Array}
     */
    PhysicalObject.prototype.getScalingMatrixInverse = function () {
        if (!this._scalingMatrixInverseValid) {
            mat.setInverseOfScaling4(this._scalingMatrixInverse, this._scalingMatrix);
            this._scalingMatrixInverseValid = true;
        }
        return this._scalingMatrixInverse;
    };
    /**
     * Returns the inverse of the model matrix and stores it in a cache to
     * make sure it is only calculated again if the model matrix changes.
     * @returns {Float32Array}
     */
    PhysicalObject.prototype.getModelMatrixInverse = function () {
        if (!this._modelMatrixInverseValid) {
            mat.setProdTranslationRotation4(this._modelMatrixInverse,
                    mat.inverseOfTranslation4Aux(this._positionMatrix),
                    mat.prod3x3SubOf4Aux(
                            this.getRotationMatrixInverse(),
                            this.getScalingMatrixInverse()));
            this._modelMatrixInverseValid = true;
        }
        return this._modelMatrixInverse;
    };
    // methods
    /**
     * If a (continuous) force is passed, renews its properties, if not, adds a new force with the given parameters.
     * Warning! Does not readd the force when renewing if it has been removed with PhysicalObject.reset()! Delete cached
     * forces after calling that.
     * @param {Force} [force] The force to renew, if it already exists. Should be a continuous force!
     * @param {Number} strength The new strength of the force in newtons.
     * @param {Number[3]} direction The vector describing the new direction of the force. Needs to be a unit vector.
     * #persistent, #read-write
     * @returns {Force} The passed or created force
     */
    PhysicalObject.prototype.addOrRenewForce = function (force, strength, direction) {
        if (force) {
            force.renew(strength, direction);
        } else {
            force = this.addForce(new Force(strength, direction));
        }
        return force;
    };
    /**
     * If a (continuous) torque is passed, renews its properties, if not, adds a new torque with the given parameters.
     * Warning! Does not readd the torque when renewing if it has been removed with PhysicalObject.reset()! Delete cached
     * torques after calling that.
     * @param {Torque} [torque] The torque to renew, if it already exists. Should be a continuous torque!
     * @param {Number} strength The strength of the torque.
     * @param {Number[3]} axis The vector describing the axis of the torque. Needs to be a unit vector.
     * #persistent, #ready-write
     * @returns {Torque} The passed of created torque
     */
    PhysicalObject.prototype.addOrRenewTorque = function (torque, strength, axis) {
        if (torque) {
            torque.renew(strength, axis);
        } else {
            torque = this.addTorque(new Torque(strength, axis));
        }
        return torque;
    };
    /**
     * Simulates a force affecting the object that has an arbitrary point and direction
     * of attack, potentially affecting both the linear and angular momentum of the object.
     * @param {Number[3]} position Point of attack relative to this object (meters)
     * @param {Number[3]} direction Unit vector of the direction of the force to apply
     * #persistent, #read-write
     * @param {Number} strength Overall strength of the force in newtons
     * @param {Number} [duration] The force and torque will be exterted for this duration (milliseconds)
     * If omitted, they will be created as continuous.
     */
    PhysicalObject.prototype.addForceAndTorque = function (position, direction, strength, duration) {
        var
                lever = vec.length3(position),
                leverDir = vec.scaled3(position, 1 / lever),
                parallelForce = vec.scaled3(leverDir, vec.dot3(direction, leverDir)),
                perpendicularForce = vec.diff3Aux(direction, parallelForce);
        this.addForce(new Force(
                strength,
                direction,
                duration));
        this.addTorque(new Torque(
                strength * vec.length3(perpendicularForce) * lever,
                vec.normalize3(vec.cross3(perpendicularForce, leverDir)),
                duration));
    };
    /**
     * Simulates a force affecting the object that has an arbitrary point and direction
     * of attack, potentially affecting both the linear and angular momentum of the object.
     * Directly applies the force and the torque, without adding them to the list of 
     * active forces / torques
     * @param {Number[3]} position Point of attack relative to this object (meters)
     * @param {Number[3]} direction Unit vector of the direction of the force to apply
     * #temporary, #read-only
     * @param {Number} strength Overall strength of the force in newtons
     * @param {Number} duration The force and torque will be exterted for this duration (milliseconds)
     */
    PhysicalObject.prototype.applyForceAndTorque = function (position, direction, strength, duration) {
        var
                lever = vec.length3(position),
                leverDir = vec.scaled3(position, 1 / lever),
                parallelForce = vec.scaled3(leverDir, vec.dot3(direction, leverDir)),
                perpendicularForce = vec.diff3Aux(direction, parallelForce);
        this.applyForce(
                strength,
                direction[0],
                direction[1],
                direction[2],
                duration);
        this.applyTorque(
                strength * vec.length3(perpendicularForce) * lever,
                vec.normalize3(vec.cross3(perpendicularForce, leverDir)),
                duration);
    };
    /**
     * Calculates the size of the structure of this physical object and stores 
     * it in a cache to speed up hit checks.
     */
    PhysicalObject.prototype._calculateBodySize = function () {
        var i, bodyPos = [0, 0, 0], halfDim;
        this._bodySize = 0;
        for (i = 0; i < this._bodies.length; i++) {
            vec.setTranslationVector3(bodyPos, this._bodies[i].getPositionMatrix());
            halfDim = vec.prodVec3Mat3Aux(this._bodies[i].getHalfDimensions(), mat.prod3x3SubOf43(
                    this._orientationMatrix,
                    this._bodies[i].getOrientationMatrix()));
            this._bodySize = Math.max(this._bodySize, vec.length3(vec.sum3(bodyPos, halfDim)));
            this._bodySize = Math.max(this._bodySize, vec.length3(vec.sum3(bodyPos, [halfDim[0], halfDim[1], -halfDim[2]])));
            this._bodySize = Math.max(this._bodySize, vec.length3(vec.sum3(bodyPos, [halfDim[0], -halfDim[1], halfDim[2]])));
            this._bodySize = Math.max(this._bodySize, vec.length3(vec.sum3(bodyPos, [halfDim[0], -halfDim[1], -halfDim[2]])));
            this._bodySize = Math.max(this._bodySize, vec.length3(vec.sum3(bodyPos, [-halfDim[0], halfDim[1], halfDim[2]])));
            this._bodySize = Math.max(this._bodySize, vec.length3(vec.sum3(bodyPos, [-halfDim[0], halfDim[1], -halfDim[2]])));
            this._bodySize = Math.max(this._bodySize, vec.length3(vec.sum3(bodyPos, [-halfDim[0], -halfDim[1], halfDim[2]])));
            this._bodySize = Math.max(this._bodySize, vec.length3(vec.sum3(bodyPos, [-halfDim[0], -halfDim[1], -halfDim[2]])));
        }
    };
    /**
     * Checks whether a point-like object travelling along a straight path with a given speed has hit this pyhical object recently and
     * if so, returns the intersection point where it did.
     * @param {Number[3]} positionVector A 3D vector describing the position of the point in world space. (in meters)
     * @param {Number[3]} velocityVector The vector in world space that describes the velocity of the travelling object in m/s.
     * @param {Number} dt The time interval in milliseconds within which to check for the hit.
     * @param {Number} [offset=0] If given, the bounderies of (all the bodies of) the object are offset (the size increased) by this amount
     * (meters in world space)
     * @returns {Number[4]|null} If the object has hit, the intersection point where the hit happened in object space, otherwise null.
     */
    PhysicalObject.prototype.checkHit = function (positionVector, velocityVector, dt, offset) {
        var relativePos, relativeVelocityVector, i, range, result = null;
        offset = offset || 0;
        offset *= this._inverseScalingFactor;
        // transforms the position to object-space for preliminary check
        relativePos = vec.prodVec4Mat4Aux(vec.vector4From3Aux(positionVector), this.getModelMatrixInverse());
        // calculate the relative velocity of the two objects in world space
        relativeVelocityVector = vec.diffVec3Mat4(velocityVector, this.getVelocityMatrix());
        i = vec.extractLength3(relativeVelocityVector);
        range = i * dt * 0.001 * this._inverseScalingFactor;
        // first, preliminary check based on position relative to the whole object
        if ((Math.abs(relativePos[0]) - range < this._bodySize + offset) && (Math.abs(relativePos[1]) - range < this._bodySize + offset) && (Math.abs(relativePos[2]) - range < this._bodySize + offset)) {
            // if it is close enough to be hitting one of the bodies, check them
            vec.mulVec3Mat3(relativeVelocityVector, mat.matrix3from4Aux(this.getRotationMatrixInverse()));
            for (i = 0; (result === null) && (i < this._bodies.length); i++) {
                result = this._bodies[i].checkHit(relativePos, relativeVelocityVector, range, offset);
            }
        }
        return result;
    };
    /**
     * Checks whether a point-like object travelling along a straight path with a given speed has hit this pyhical object recently and
     * if so, returns the intersection point where it did.
     * @param {Number[4]} relativePosition A 4D vector describing current the position of the point in model space. (in meters)
     * @param {Number[3]} relativeDirection The direction the object is travelling in (the hitcheck will be performed backwards!)
     * @param {Number} range The distance the object has traversed recently when it could have hit the body
     * @param {Number} [offset=0] If given, the bounderies of (all the bodies of) the object are offset (the size increased) by this amount
     * (meters in world space)
     * @returns {Number[4]|null} If the object has hit, the intersection point where the hit happened in object space, otherwise null.
     */
    PhysicalObject.prototype.checkHitRelative = function (relativePosition, relativeDirection, range, offset) {
        var i, result = null;
        for (i = 0; (result === null) && (i < this._bodies.length); i++) {
            result = this._bodies[i].checkHit(relativePosition, relativeDirection, range, offset);
        }
        return result;
    };
    /**
     * Ensures that the orientation and angular velocity matrices are orthogonal,
     * compensating for floating point inaccuracies.
     */
    PhysicalObject.prototype._correctMatrices = function () {
        mat.correctOrthogonal4(this._orientationMatrix);
        this.setOrientationMatrix();
        mat.correctOrthogonal4(this._angularVelocityMatrix);
    };
    /**
     * Performs the physics calculations for the object based on the forces and 
     * torques that are affecting it, updating its position and orientation.
     * @param {Number} dt The elapsed time since the last simulation step, in
     * milliseconds.
     */
    PhysicalObject.prototype.simulate = function (dt) {
        var i, a, s, t, force, nextForce, torque, nextTorque, matrix;
        if (dt > 0) {
            if ((_drag > 0) && (this._dragFactor > 0)) {
                s = (this._velocityMatrix[12] * this._velocityMatrix[12] + this._velocityMatrix[13] * this._velocityMatrix[13] + this._velocityMatrix[14] * this._velocityMatrix[14]);
                if (s > MINIMUM_DRAG_VELOCITY) {
                    a = _drag * this._dragFactor * s;
                    s = 1 / Math.sqrt(s);
                    a = -s * a * dt * 0.001;
                    this._velocityMatrix[12] += a * this._velocityMatrix[12];
                    this._velocityMatrix[13] += a * this._velocityMatrix[13];
                    this._velocityMatrix[14] += a * this._velocityMatrix[14];
                }
            }
            // first calculate the movement that happened in the past dt
            // milliseconds as a result of the velocity sampled in the previous step
            // the velocity matrix is in m/s
            mat.translateByMatrixMul(this._positionMatrix, this._velocityMatrix, dt * 0.001);
            if (this._fixedVelocity) {
                this.setPositionMatrix();
            } else {
                mat.translateByVector(this._positionMatrix, this._offset);
                this.setPositionMatrix();
                // calculate the movement that happened as a result of the acceleration
                // the affecting forces caused since the previous step
                // (s=1/2*a*t^2)
                if (this._forces.getLength() > 0) {
                    for (force = this._forces.getFirst(); force; force = nextForce) {
                        nextForce = force.next;
                        if (force.canBeReused()) {
                            this._forces.remove(force);
                        } else {
                            t = force.exert(dt) * 0.001; // t is in seconds
                            if (t > 0) {
                                a = force.getAccelerationVector(this._inverseMass);
                                mat.translateByVector(
                                        this._positionMatrix,
                                        vec.scaled3Aux(a, 0.5 * t * t));
                                // calculate the caused acceleration to update the velocity matrix
                                vec.add3(
                                        this._acceleration,
                                        vec.scaled3Aux(a, t));
                            }
                        }
                    }
                }
                // update velocity matrix
                mat.translateByVector(this._velocityMatrix, this._acceleration);
                vec.setNull3(this._acceleration);
                vec.setNull3(this._offset);
                // correct matrix inaccuracies and close to zero values resulting from
                // floating point operations
                mat.straightenTranslation(this._velocityMatrix, VELOCITY_MATRIX_ERROR_THRESHOLD);
            }
            if (!this._fixedOrientation) {
                if ((_drag > 0) && (this._dragFactor > 0)) {
                    matrix = mat.identity3Aux();
                    s = _angularDrag * this._dragFactor * dt * 0.001;
                    if (vec.angle2y(this._angularVelocityMatrix[4], this._angularVelocityMatrix[5]) > MINIMUM_DRAG_ANGLE) {
                        mat.mul3(matrix, mat.rotation3Aux(vec.UNIT3_Z, (this._angularVelocityMatrix[4] > 0) ? -s : s));
                    }
                    if (vec.angle2x(this._angularVelocityMatrix[5], this._angularVelocityMatrix[6]) > MINIMUM_DRAG_ANGLE) {
                        mat.mul3(matrix, mat.rotation3Aux(vec.UNIT3_X, (this._angularVelocityMatrix[6] > 0) ? s : -s));
                    }
                    if (vec.angle2x(this._angularVelocityMatrix[0], this._angularVelocityMatrix[2]) > MINIMUM_DRAG_ANGLE) {
                        mat.mul3(matrix, mat.rotation3Aux(vec.UNIT3_Y, (this._angularVelocityMatrix[2] > 0) ? -s : s));
                    }
                    mat.mulRotation43(this._angularVelocityMatrix, matrix);
                }
                // the same process with rotation and torques
                // the angular velocity matrix represents the rotation that happens
                // during the course of ANGULAR_VELOCITY_MATRIX_DURATION milliseconds (since rotation cannot be
                // interpolated easily, for that quaternions should be used)
                for (i = 0; (i + ANGULAR_VELOCITY_MATRIX_DURATION * 0.5) < dt; i += ANGULAR_VELOCITY_MATRIX_DURATION) {
                    mat.mulRotationRotation4(this._orientationMatrix, this._angularVelocityMatrix);
                }
                if (this._hasAngularAcceleration) {
                    mat.mulRotation43(
                            this._orientationMatrix,
                            this._orientationOffset);
                    mat.setIdentity3(this._orientationOffset);
                }
                this.setOrientationMatrix();
                // calculate the rotation that happened as a result of the angular
                // acceleration the affecting torques caused since the previous step
                if (this._torques.getLength() > 0) {
                    this._hasAngularAcceleration = true;
                    for (torque = this._torques.getFirst(); torque; torque = nextTorque) {
                        nextTorque = torque.next;
                        if (torque.canBeReused()) {
                            this._torques.remove(torque);
                        } else {
                            t = torque.exert(dt) * 0.001; // t is in seconds
                            if (t > 0) {
                                mat.mulRotation43(
                                        this._orientationMatrix,
                                        torque.getAngularAccelerationMatrixOverTime(this._inverseMass, 0.5 * t * t));
                                // angular acceleration matrix stores angular acceleration for ANGULAR_VELOCITY_MATRIX_DURATION ms
                                mat.mul3(
                                        this._angularAccelerationMatrix,
                                        torque.getAngularAccelerationMatrixOverTime(this._inverseMass, ANGULAR_VELOCITY_MATRIX_DURATION * t * 0.001));
                            }
                        }
                    }
                }
                if (this._hasAngularAcceleration) {
                    // update angular velocity matrix
                    mat.mulRotation43(this._angularVelocityMatrix, this._angularAccelerationMatrix);
                    mat.setIdentity3(this._angularAccelerationMatrix);
                    this._hasAngularAcceleration = false;
                    // correct matrix inaccuracies and close to zero values resulting from
                    // floating point operations
                    mat.straightenRotation4(this._angularVelocityMatrix, ANGULAR_VELOCITY_MATRIX_ERROR_THRESHOLD);
                }
                this._correctMatrices();
            }
        }
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        getDrag: getDrag,
        setDrag: setDrag,
        Body: Body,
        Force: Force,
        Torque: Torque,
        PhysicalObject: PhysicalObject,
        // constants
        ANGULAR_VELOCITY_MATRIX_DURATION: ANGULAR_VELOCITY_MATRIX_DURATION,
        ANGULAR_VELOCITY_MATRIX_DURATION_S: ANGULAR_VELOCITY_MATRIX_DURATION / 1000,
        VELOCITY_MATRIX_ERROR_THRESHOLD: VELOCITY_MATRIX_ERROR_THRESHOLD,
        ANGULAR_VELOCITY_MATRIX_ERROR_THRESHOLD: ANGULAR_VELOCITY_MATRIX_ERROR_THRESHOLD
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides various basic renderable object classes that can be added to scenes inside renderable nodes.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Float32Array, Int32Array */

/**
 * @param utils Used for the ScaleMode enum
 * @param vec Used for 3D (and 4D) vector operations.
 * @param mat Used for 3D (and 4D) matrix operations.
 * @param application Used for displaying errors and logging (and intentional crashing)
 * @param managedGL Used for managing texture and uniform names
 * @param object3D Used for RenderableObject3D (mixin)
 */
define('modules/scene/renderable-objects',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/managed-gl",
    "modules/scene/object-3d"
], function (utils, vec, mat, application, managedGL, object3D) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // enums
            /**
             * The bits that can be combined to define which render queues should a renderable object('s node) be added to.
             * @type Object
             */
            RenderQueueBits = {
                NONE: 0,
                FRONT_QUEUE_BIT: 1,
                DISTANCE_QUEUE_BIT: 2
            },
            // ----------------------------------------------------------------------
            // constants
            /**
             * @type String
             */
            UNIFORM_VIEW_PROJECTION_INVERSE_MATRIX_NAME = "viewDirectionProjectionInverse",
            UNIFORM_MODEL_MATRIX_NAME = "modelMatrix",
            UNIFORM_NORMAL_MATRIX_NAME = "normalMatrix",
            UNIFORM_BILLBOARD_SIZE_NAME = "billboardSize",
            UNIFORM_COLOR_NAME = "color",
            UNIFORM_POINT_CLOUD_SHIFT_NAME = "shift",
            UNIFORM_POINT_CLOUD_FARTHEST_Z_NAME = "farthestZ",
            UNIFORM_POSITION_NAME = "position",
            UNIFORM_DIRECTION_NAME = "direction",
            UNIFORM_SIZE_NAME = "size",
            UNIFORM_START_POSITION_NAME = "startPosition",
            UNIFORM_END_POSITION_NAME = "endPosition",
            UNIFORM_START_DIRECTION_NAME = "startDirection",
            UNIFORM_END_DIRECTION_NAME = "endDirection",
            UNIFORM_SCALE_MODE_NAME = "scaleMode",
            UNIFORM_ROTATION_MATRIX_NAME = "rotationMatrix",
            UNIFORM_CLIP_COORDINATES_NAME = "clipCoords",
            UNIFORM_CLIP_COLOR_NAME = "clipColor",
            /**
             * If no suitable LOD is available for a model when querying it for the current frame and there is no previously set LOD cached, 
             * this LOD will be chosen.
             * @type Number
             */
            DEFAULT_LOD = 0,
            /**
             * Particles will only be rendered if their size factor reaches at least this value.
             * @type Number
             */
            PARTICLE_MINIMUM_VISIBLE_SIZE = 0.01,
            /**
             * Meshes will only be rendered if their visible size reaches at least this value.
             * @type Number
             */
            DEFAULT_SMALLEST_MESH_SIZE_WHEN_DRAWN = 5,
            /**
             * Using these as clip coordinates specifies a clip zone that includes the whole element.
             * @type Number[4]
             */
            CLIP_COORDINATES_NO_CLIP = [0, 1, 0, 1],
            /**
             * @type Number[4]
             */
            DEFAULT_PARTICLE_STATE_COLOR = [1, 1, 1, 1];
    // -------------------------------------------------------------------------
    // Private functions
    /**
     * Converts a scale mode variable of the enum type defined in utils to a number that can be passed to shaders.
     * @param {String} scaleMode (enum ScaleMode)
     * @returns {Number}
     */
    function _getScaleModeInt(scaleMode) {
        switch (scaleMode) {
            case utils.ScaleMode.WIDTH:
                return 0;
            case utils.ScaleMode.HEIGHT:
                return 1;
            case utils.ScaleMode.ASPECT:
                return 2;
            case utils.ScaleMode.MINIMUM:
                return 3;
            case utils.ScaleMode.MAXIMUM:
                return 4;
            default:
                application.crash();
        }
    }
    // #########################################################################
    /**
     * @class The superclass of all objects that can be rendered on the screen.
     * @param {ManagedShader} shader The shader that should be active while rendering this object
     * @param {Boolean} [renderedWithDepthMask=true] Tells whether this object should be rendered when the depth mask is on (= it contains 
     * non-transparent triangles)
     * @param {Boolean} [renderedWithoutDepthMask=true] Tells whether this object should be rendered when the depth mask is off (= it contains 
     * transparent triangles)
     * @param {ManagedShader} [instancedShader]
     * @param {Boolean} [castsShadows=true] If true, this object will be rendered to shadow maps.
     */
    function RenderableObject(shader, renderedWithDepthMask, renderedWithoutDepthMask, instancedShader, castsShadows) {
        /**
         * A reference to the node holding this object.
         * @type RenderableNode
         */
        this._node = null;
        /**
         * The shader to use while rendering this object.
         * @type ManagedShader
         */
        this._shader = shader;
        /**
         * The textures this object uses, ordered by their roles/types.
         * @type Object.<String, Texture|Cubemap>
         */
        this._textures = {};
        /**
         * Cached list of the roles of the currently set textures.
         * @type String[]
         */
        this._textureRoles = [];
        /**
         * The functions to call when calculating the values of uniform variables before assigning them, ordered by the names of the variables.
         * @type Object.<String, Function>
         */
        this._uniformValueFunctions = {};
        /**
         * Flag, whether this object should be rendered when the depth mask is on.
         * @type Boolean
         */
        this._isRenderedWithDepthMask = renderedWithDepthMask === undefined ? true : renderedWithDepthMask;
        /**
         * Flag, whether this object should be rendered when the depth mask is off.
         * @type Boolean
         */
        this._isRenderedWithoutDepthMask = renderedWithoutDepthMask === undefined ? true : renderedWithoutDepthMask;
        /**
         * The shader to use when rendering this object in instanced mode.
         * @type ManagedShader
         */
        this._instancedShader = instancedShader || null;
        /**
         * Flag, whether this object is no longer valid and can be used to store a new object.
         * @type Boolean
         */
        this._canBeReused = false;
        /**
         * Whether this object is currently visible (should be rendered)
         * @type Boolean
         */
        this._visible = true;
        /**
         * If true, this object is rendered to shadow maps.
         * @type Boolean
         */
        this._castsShadows = (castsShadows !== undefined) ? castsShadows : true;
        /**
         * Whether the object has been rendered to the last shadow map. Can be used by children objects when rendering them to the same 
         * shadow map - if they go together with their parent, so no additional tests need to be performed for them.
         * @type Boolean
         */
        this._wasRenderedToShadowMap = false;
        /**
         * An optional string ID by which a particular renderable object can be identified.
         * @type String
         */
        this._name = null;
    }
    /**
     * Reinitializes the renderable object with new properties. Does not clear uniform value functions and node reference (so the same node
     * can be reused with the object)
     * @param {ManagedShader} shader The shader that should be active while rendering this object
     * @param {Boolean} [renderedWithDepthMask=true] Tells whether this object should be rendered when the depth mask is on (= it contains 
     * non-transparent triangles)
     * @param {Boolean} [renderedWithoutDepthMask=true] Tells whether this object should be rendered when the depth mask is off (= it contains 
     * transparent triangles)
     * @param {ManagedShader} [instancedShader]
     * @param {Boolean} [castsShadows=true] If true, this object will be rendered to shadow maps.
     */
    RenderableObject.prototype.init = function (shader, renderedWithDepthMask, renderedWithoutDepthMask, instancedShader, castsShadows) {
        this._shader = shader;
        this._textures = {};
        this._textureRoles = [];
        this._isRenderedWithDepthMask = renderedWithDepthMask === undefined ? true : renderedWithDepthMask;
        this._isRenderedWithoutDepthMask = renderedWithoutDepthMask === undefined ? true : renderedWithoutDepthMask;
        this._instancedShader = instancedShader || null;
        this._canBeReused = false;
        this._visible = true;
        this._castsShadows = (castsShadows !== undefined) ? castsShadows : true;
        this._name = null;
    };
    /**
     * Returns the node that contains this object. If there is no such node,
     * creates an isolated one to contain it from now on and returns that.
     * @returns {RenderableNode}
     */
    RenderableObject.prototype.getNode = function () {
        return this._node;
    };
    /**
     * Sets a new node reference for this object.
     * @param {RenderableNode} node
     */
    RenderableObject.prototype.setNode = function (node) {
        this._node = node;
    };
    /**
     * Return the shader of this object.
     * @returns {ManagedShader}
     */
    RenderableObject.prototype.getShader = function () {
        return this._shader;
    };
    /**
     * Sets a new shader. (for non instanced mode only!)
     * @param {ManagedShader} shader
     */
    RenderableObject.prototype.setShader = function (shader) {
        this._shader = shader;
    };
    /**
     * Sets a new instanced shader.
     * @param {ManagedShader} shader
     */
    RenderableObject.prototype.setInstancedShader = function (shader) {
        this._instancedShader = shader;
    };
    /**
     * Updates the internal state and uniform values functions in case the textures change.
     */
    RenderableObject.prototype._updateTextures = function () {
        var i, role, uniformName;
        this._textureRoles = Object.keys(this._textures);
        for (i = 0; i < this._textureRoles.length; i++) {
            role = this._textureRoles[i];
            if (this._textures[role] instanceof managedGL.ManagedTexture) {
                uniformName = managedGL.getUniformName(managedGL.getTextureUniformRawName(role));
            } else if (this._textures[role] instanceof managedGL.ManagedCubemap) {
                uniformName = managedGL.getUniformName(managedGL.getCubemapUniformRawName(role));
            } else {
                application.showError("Attemtping to add a texture of unknown type (" + this._textures[role].constructor.name + ") to the GL context.");
                continue;
            }
            // reusing functions created before
            this._uniformValueFunctions[uniformName] = this._uniformValueFunctions[uniformName] || this._getTextureLocation.bind(this, role);
        }
    };
    /**
     * Sets the texture specified for the given role. If there was already a
     * texture set, overwrites the reference.
     * @param {String} role
     * @param {Texture|Cubemap} texture
     */
    RenderableObject.prototype.setTexture = function (role, texture) {
        this._textures[role] = texture;
        this._updateTextures();
    };
    /**
     * Sets all the textures of the object based on the passed value.
     * @param {Object.<String, Texture|Cubemap>} textures
     */
    RenderableObject.prototype.setTextures = function (textures) {
        this._textures = textures;
        if (textures) {
            this._updateTextures();
        }
    };
    /**
     * Whether this object should be rendered in passes when the depth mask is turned off
     * @returns {Boolean}
     */
    RenderableObject.prototype.isRenderedWithoutDepthMask = function () {
        return this._isRenderedWithoutDepthMask;
    };
    /**
     * Whether this object should be rendered in passes when the depth mask is turned on
     * @returns {Boolean}
     */
    RenderableObject.prototype.isRenderedWithDepthMask = function () {
        return this._isRenderedWithDepthMask;
    };
    /**
     * Assigns a function to get the value of the uniform with the passed name.
     * Overwrites potential previous assignments.
     * @param {String} rawUniformName
     * @param {Function(this:RenderableObject)} valueFunction
     * @param {Object} alternativeThis
     */
    RenderableObject.prototype.setUniformValueFunction = function (rawUniformName, valueFunction, alternativeThis) {
        this._uniformValueFunctions[managedGL.getUniformName(rawUniformName)] = valueFunction.bind(alternativeThis || this);
    };
    /*
     * Sets a name for this object by which later it can be identified.
     * @param {String} value
     */
    RenderableObject.prototype.setName = function (value) {
        this._name = value;
    };
    /**
     * Returns the name set for this object.
     * @returns {String}
     */
    RenderableObject.prototype.getName = function () {
        return this._name;
    };
    /**
     * @param {String} role
     * @param {String} contextName
     * @returns {Number} 
     */
    RenderableObject.prototype._getTextureLocation = function (role, contextName) {
        return this._textures[role].getLastTextureBindLocation(contextName);
    };
    /**
     * Adds and sets up the resources used for rendering of this object to the
     * passed context. Subclasses must extend its functionality to add 
     * additional resources they might use.
     * @param {ManagedGLContext} context
     */
    RenderableObject.prototype.addToContext = function (context) {
        var role, i;
        if (this._shader) {
            context.addShader(this._shader);
        }
        if (this._instancedShader) {
            context.addShader(this._instancedShader);
        }
        for (i = 0; i < this._textureRoles.length; i++) {
            role = this._textureRoles[i];
            context.addTexture(this._textures[role]);
        }
    };
    /**
     * Binds the used textures within the passed context.
     * @param {ManagedGLContext} context
     */
    RenderableObject.prototype.bindTextures = function (context) {
        var role, i;
        for (i = 0; i < this._textureRoles.length; i++) {
            role = this._textureRoles[i];
            context.bindTexture(this._textures[role]);
        }
    };
    /**
     * Marks the object as one that is no longer valid and can be reused to hold a different object.
     * For pooling support.
     * @param {Boolean} removeFromParent If true, the corresponding node (if any) is removed from its parent if it has one
     */
    RenderableObject.prototype.markAsReusable = function (removeFromParent) {
        this._canBeReused = true;
        if (this._node) {
            this._node.handleObjectBecameReusable(removeFromParent);
        }
    };
    /**
     * Returns whether this object is invalid and can be reused to hold a new 
     * one. For pooling support.
     * @returns {Boolean}
     */
    RenderableObject.prototype.canBeReused = function () {
        return this._canBeReused;
    };
    /**
     * Returns whether the object is set to be rendered (based on its own state and the visibility settings in the scene graph)
     * @returns {Boolean}
     */
    RenderableObject.prototype.isVisible = function () {
        return this._visible && (!this._node || this._node.isVisible());
    };
    /**
     * Returns a combination of bits corresponding to which rendered queues (based on distance) should this object be added to for rendering
     * for the current frame. Will get the camera to the view point of which the distance should be calculated as parameter when called.
     * @returns {Number} (enum RenderQueueBits)
     */
    RenderableObject.prototype.getRenderQueueBits = function () {
        return this._visible ? RenderQueueBits.FRONT_QUEUE_BIT : RenderQueueBits.NONE;
    };
    /**
     * Sets up the rendering of an instance queue storing nodes that can be rendered together with this node in instance mode.
     * @param {ManagedGLContext} context
     * @param {Scene} scene
     * @param {Number} instanceQueueIndex Identifies the instance queue, so that multiple queues using the same shader will not use the same
     * instance buffers of that shader
     * @param {Number} instanceCount
     */
    RenderableObject.prototype.prepareForInstancedRender = function (context, scene, instanceQueueIndex, instanceCount) {
        if (context.setCurrentShader(this._instancedShader)) {
            scene.assignUniforms(context, this._instancedShader);
        }
        if (context.getCurrentShader() === this._instancedShader) {
            this.bindTextures(context);
            this._instancedShader.assignUniforms(context, this._uniformValueFunctions);
            this._instancedShader.createInstanceBuffers(instanceQueueIndex, instanceCount);
        }
    };
    /**
     * Early check called before every render to determine whether based on its current state, the object might need to be rendered.
     * Subclasses must add their own subsequent checks to this function.
     * @returns {Boolean}
     */
    RenderableObject.prototype.mightBeRendered = function () {
        return (this._canBeReused !== true) && this._visible;
    };
    /**
     * Called before every render to check whether to proceed with the rendering or not, according to the current parameters. 
     * Subclasses must add their own subsequent checks to this function.
     * @param {RenderParameters} renderParameters
     * @returns {Boolean}
     */
    RenderableObject.prototype.shouldBeRendered = function (renderParameters) {
        return (renderParameters.depthMask && this._isRenderedWithDepthMask) || (!renderParameters.depthMask && this._isRenderedWithoutDepthMask);
    };
    /**
     * Called before every render, after the object passes the test whether it
     * should be rendered. Subclasses must add their own preparation to this
     * function.
     * @param {RenderParameters} renderParameters
     */
    RenderableObject.prototype.prepareForRender = function (renderParameters) {
        if (renderParameters.useInstancing && (renderParameters.context.getCurrentShader() === this._instancedShader)) {
            this._instancedShader.addDataToInstanceBuffers(renderParameters.instanceQueueIndex, this._uniformValueFunctions);
        } else {
            if (renderParameters.context.setCurrentShader(this._shader)) {
                renderParameters.scene.assignUniforms(renderParameters.context, this._shader);
            }
            if (renderParameters.context.getCurrentShader() === this._shader) {
                this.bindTextures(renderParameters.context);
                this._shader.assignUniforms(renderParameters.context, this._uniformValueFunctions);
            }
        }
    };
    /**
     * The function actually performing the rendering, after all checks and
     * preparations. Override this function with appropriate functionality
     * for subclasses. Here it does nothing.
     */
    RenderableObject.prototype.performRender = function () {
        return true;
    };
    /**
     * Handles the full render flow, with checks and preparations. Don't override this.
     * In instanced mode, only performs the preparation and the finish step, and not the rendering itself.
     * @param {RenderParameters} renderParameters
     * @returns {Boolean} Whether the object was rendered (or in case of instanced rendering, the instance buffers were filled with its data)
     */
    RenderableObject.prototype.render = function (renderParameters) {
        if (this.shouldBeRendered(renderParameters)) {
            this.prepareForRender(renderParameters);
            if (!renderParameters.useInstancing) {
                this.performRender(renderParameters);
            }
            return true;
        }
        return false;
    };
    /*
     * Finishes the preparation for instanced rendering and renders the given number of instances of this object to the given context, using
     * the instance attributes for the instance queue with the given index.
     * @param {ManagedGLContext} context
     * @param {Number} instanceQueueIndex
     * @param {Number} instanceCount
     */
    RenderableObject.prototype.renderInstances = function (context, instanceQueueIndex, instanceCount) {
        this._instancedShader.bindAndFillInstanceBuffers(context, instanceQueueIndex);
        this._peformRenderInstances(context, instanceCount);
    };
    /**
     * An early check to determine if the object might need to be rendered to the shadow maps, based on
     * just its own state and no render parameters.
     * Subclasses must add their own subsequent checks to this function.
     * @returns {Boolean}
     */
    RenderableObject.prototype.mightBeRenderedToShadowMap = function () {
        return !this._canBeReused && this._visible && this._castsShadows;
    };
    /**
     * Called every time before rendering to a shadow map would occur (if the early check has passed) to check 
     * whether to proceed with the rendering or not, according to the current parameters. 
     * Subclasses must implement their own checks in this function.
     * @returns {Boolean}
     */
    RenderableObject.prototype.shouldBeRenderedToShadowMap = function () {
        return true;
    };
    /**
     * Returns whether this object has been rendered to the last shadow map.
     * @returns {Boolean}
     */
    RenderableObject.prototype.wasRenderedToShadowMap = function () {
        return this._wasRenderedToShadowMap;
    };
    /**
     * Called before every shadow map render, after the object passes the test 
     * whether it should be rendered to shadow map. Subclasses must add their 
     * own preparation to this function.
     */
    RenderableObject.prototype.prepareForRenderToShadowMap = function () {
        return true;
    };
    /**
     * The function actually performing the rendering to shadow map, after all 
     * checks and preparations. Override this function with appropriate 
     * functionality for subclasses. Here it does nothing.
     */
    RenderableObject.prototype.performRenderToShadowMap = function () {
        return true;
    };
    /**
     * Handles the full shadow map render flow, with checks and preparations. 
     * Don't override this.
     * @param {RenderParameters} renderParameters
     * @returns {Boolean} Whether the object actually has been rendered to the shadow map (it passed all checks)
     */
    RenderableObject.prototype.renderToShadowMap = function (renderParameters) {
        if (this.shouldBeRenderedToShadowMap(renderParameters)) {
            this.prepareForRenderToShadowMap(renderParameters);
            this.performRenderToShadowMap(renderParameters);
            this._wasRenderedToShadowMap = true;
            return true;
        }
        this._wasRenderedToShadowMap = false;
        return false;
    };
    /**
     * Returns whether animation should be performed for this object. Override this
     * adding additional conditions.
     * @param {Number} dt
     * @returns {Boolean}
     */
    RenderableObject.prototype.shouldAnimate = function (dt) {
        // the object not being visible does not block the animation, as it can be a part of the animation (e.g. blinking lights)
        // the node not being visible however blocks the animation, and the animations of all of the subnodes so that unnecessary animation can be avoided
        return dt > 0;
    };
    /**
     * Override this implementing the actual calculations for the animation of the
     * object. The passed time in milliseconds (dt) will be passed as a parameter, when called.
     */
    RenderableObject.prototype.performAnimate = function () {
        return true;
    };
    /**
     * Performs the animation step for the object if needed. Do not override.
     * @param {Number} dt
     */
    RenderableObject.prototype.animate = function (dt) {
        if (this.shouldAnimate(dt)) {
            this.performAnimate(dt);
        }
    };
    /**
     * Returns whether this object can be put in the same rendering queue as the passed other rendering object.
     * @param {RenderableObject} otherRenderableObject
     * @returns {Boolean}
     */
    RenderableObject.prototype.shouldGoInSameRenderQueue = function (otherRenderableObject) {
        return this._shader === otherRenderableObject.getShader();
    };
    /**
     * Returns whether this object can be rendered together with the other objects in the same instanced rendering queue.
     * Override to add specific attribute checks to subclasses.
     * @param {RenderableObject} otherRenderableObject
     * @returns {Boolean}
     */
    RenderableObject.prototype.shouldGoInSameRenderQueueInstanced = function (otherRenderableObject) {
        return (this.constructor === otherRenderableObject.constructor) &&
                (this._shader === otherRenderableObject._shader);
    };
    // #########################################################################
    /**
     * @class A renderable object with the functionality of the Object3D class
     * mixed in. In addition, provides caching for frustum calculations.
     * @constructor
     * @extends RenderableObject
     * @extends Object3D
     * @param {ManagedShader} shader
     * @param {Boolean} renderedWithDepthMask
     * @param {Boolean} renderedWithoutDepthMask
     * @param {Float32Array} [positionMatrix] Initial position.
     * @param {Float32Array} [orientationMatrix] Initial orientation.
     * @param {Float32Array} [scalingMatrix] Initial scaling.
     * @param {ManagedShader} [instancedShader]
     * @param {Number} [size=1]
     * @param {Boolean} [childrenAlwaysInside=false]
     * @param {Boolean} [ignoreTransform=false]
     */
    function RenderableObject3D(shader, renderedWithDepthMask, renderedWithoutDepthMask, positionMatrix, orientationMatrix, scalingMatrix, instancedShader, size, childrenAlwaysInside, ignoreTransform) {
        RenderableObject.call(this, shader, renderedWithDepthMask, renderedWithoutDepthMask, instancedShader);
        object3D.Object3D.call(this, positionMatrix, orientationMatrix, scalingMatrix, size, childrenAlwaysInside, ignoreTransform);
        /**
         * The cached value of the size of this object on the screen from the 
         * last frustum calculation.
         * @type {width: Number, height: Number}
         */
        this._visibleSize = {width: -1, height: -1};
        /**
         * Whether the visible size has already been updated for the current frame (before used in shouldBeRendered())
         * @type Boolean
         */
        this._visibleSizeUpdated = false;
        /**
         * If the visible width or height of the object is below this limit, it
         * will not be rendered. (measured in pixels)
         * @type Number
         */
        this._smallestSizeWhenDrawn = 0;
    }
    RenderableObject3D.prototype = new RenderableObject();
    object3D.makeObject3DMixinClass.call(RenderableObject3D);
    RenderableObject3D.prototype.constructor = RenderableObject;
    /**
     * Reinitializes the renderable object with new properties.
     * @param {ManagedShader} shader
     * @param {Boolean} renderedWithDepthMask
     * @param {Boolean} renderedWithoutDepthMask
     * @param {Float32Array} [positionMatrix] Initial position.
     * @param {Float32Array} [orientationMatrix] Initial orientation.
     * @param {Float32Array} [scalingMatrix] Initial scaling.
     * @param {ManagedShader} [instancedShader]
     * @param {Boolean} [childrenAlwaysInside=false]
     * @param {Boolean} [ignoreTransform=false]
     * @param {Number} [size=1]
     */
    RenderableObject3D.prototype.init = function (shader, renderedWithDepthMask, renderedWithoutDepthMask, positionMatrix, orientationMatrix, scalingMatrix, instancedShader, size, childrenAlwaysInside, ignoreTransform) {
        RenderableObject.prototype.init.call(this, shader, renderedWithDepthMask, renderedWithoutDepthMask, instancedShader);
        object3D.Object3D.prototype.init.call(this, positionMatrix, orientationMatrix, scalingMatrix, size, childrenAlwaysInside, ignoreTransform);
        this._visibleSize = {width: -1, height: -1};
        this._smallestSizeWhenDrawn = 0;
    };
    /**
     * Sets a new minimum size limit, below which rendering will be disabled.
     * @param {Number} value
     */
    RenderableObject3D.prototype.setSmallestSizeWhenDrawn = function (value) {
        this._smallestSizeWhenDrawn = value;
    };
    /**
     * Returns the size of the object on the screen, using the frustum of the
     * camera of the passed render parameters. Uses caching.
     * @param {RenderParameters} renderParameters
     * @param {Boolean} beforeMainRender Whether this update comes before the main render (the main update is in shouldBeRendered())
     * @returns {{width: Number, height: Number}}
     */
    RenderableObject3D.prototype.updateVisibleSize = function (renderParameters, beforeMainRender) {
        // we only recalculate if the last call was not before the call in the main render (but that one itself, which is the last one for the frame)
        if (!this._visibleSizeUpdated) {
            this._visibleSize = this.getSizeInsideViewFrustum(renderParameters.camera);
        }
        this._visibleSizeUpdated = beforeMainRender;
        return this._visibleSize;
    };
    /**
     * Returns the size of the object on the screen as last updated by updateVisibleSize()
     * @returns {{width: Number, height: Number}}
     */
    RenderableObject3D.prototype.getVisibleSize = function () {
        return this._visibleSize;
    };
    /**
     * Return the maximum (horizontal or vertical) span of the object on the
     * screen. Uses the cached visible size value.
     * @param {RenderParameters} renderParameters
     * @returns {Number}
     */
    RenderableObject3D.prototype.getSizeInPixels = function (renderParameters) {
        return Math.max(this._visibleSize.width * renderParameters.viewportWidth / 2, this._visibleSize.height * renderParameters.viewportHeight / 2);
    };
    /**
     * Erases cached values that are only valid for one frame.
     */
    RenderableObject3D.prototype.resetForNewFrame = function () {
        RenderableObject3D.prototype.resetCachedValues.call(this);
    };
    /**
     * @override
     * @param {Camera} camera 
     * @param {Number} parentQueueBits (option ParentQueueBits) The render queue bits of the parent
     * @returns {Number}
     */
    RenderableObject3D.prototype.getRenderQueueBits = function (camera, parentQueueBits) {
        var result = RenderQueueBits.NONE, baseMatrix, scalingMatrix, size;
        if (this.isInsideParent()) {
            return parentQueueBits;
        }
        baseMatrix = this.getPositionMatrixInCameraSpace(camera);
        scalingMatrix = this.getCascadeScalingMatrix();
        size = this.getSize() * scalingMatrix[0];
        if ((baseMatrix[14] - size <= -camera.getNearDistance()) && ((baseMatrix[14] + size) > -camera.getViewDistance())) {
            result |= RenderQueueBits.FRONT_QUEUE_BIT;
        }
        if ((baseMatrix[14] - size <= -camera.getViewDistance()) && ((baseMatrix[14] + size) > -camera.getExtendedCamera().getViewDistance())) {
            result |= RenderQueueBits.DISTANCE_QUEUE_BIT;
        }
        return result;
    };
    /**
     * @override
     * Adds a cached frustum check to the checks of the superclass.
     * @param {RenderParameters} renderParameters
     * @returns {Boolean}
     */
    RenderableObject3D.prototype.shouldBeRendered = function (renderParameters) {
        var visibleSize, relativeFactor;
        if (RenderableObject.prototype.shouldBeRendered.call(this, renderParameters)) {
            if (this.isInsideParent() === true) {
                visibleSize = renderParameters.parent.getVisibleSize();
                if (visibleSize.width > 0) {
                    relativeFactor = Math.max(this.getSize() / renderParameters.parent.getSize(), renderParameters.lodContext.minimumRelativeSize);
                    this._visibleSize.width = visibleSize.width * relativeFactor;
                    this._visibleSize.height = visibleSize.height * relativeFactor;
                    return (this.getSizeInPixels(renderParameters) >= this._smallestSizeWhenDrawn);
                }
                this._visibleSize.width = 0;
                this._visibleSize.height = 0;
                return false;
            }
            visibleSize = this.updateVisibleSize(renderParameters, false);
            return ((visibleSize.width > 0) && (this.getSizeInPixels(renderParameters) >= this._smallestSizeWhenDrawn));
        }
        this._visibleSize.width = 0;
        this._visibleSize.height = 0;
        return false;
    };
    /**
     * Aside from the checks of regular renderable objects, checks whether this object (or its parent, if it is located inside the parent)
     * is inside the respective shadow map region.
     * @param {RenderParameters} renderParameters
     * @returns {Boolean}
     */
    RenderableObject3D.prototype.shouldBeRenderedToShadowMap = function (renderParameters) {
        if (this.isInsideParent() === true) {
            return renderParameters.parent.wasRenderedToShadowMap();
        }
        return this.isInsideShadowRegion(renderParameters.light);
    };
    // #########################################################################
    /**
     * @class A Full Viewport Quad to be used for rendering the background using a cube mapped texture.
     * @extends RenderableObject
     * @param {Model} model Pass a model describing a simple quad that fills the screen.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {String} samplerName The name of the uniform variable that holds 
     * the texture sampler for the drawing, which will be appropriately prefixed and suffixed
     * @param {Cubemap} cubemap The cubemap object to be used for mapping the  background
     * @param {Camera} camera The camera to be used for querying the cube map.
     * */
    function CubemapSampledFVQ(model, shader, samplerName, cubemap, camera) {
        RenderableObject.call(this, shader, false, true);
        /**
         * Must be a quad model that fills the screen.
         * @type Model
         */
        this._model = model;
        /**
         * The name of the sampler which will be appropriately prefixed and suffixed to get the uniform sampler variable name
         * @type String
         */
        this._samplerName = samplerName;
        /**
         * The camera to be used for querying the cube map.
         * @type Camera
         */
        this._camera = camera;
        this.setTexture(samplerName, cubemap);
        this.setUniformValueFunction(UNIFORM_VIEW_PROJECTION_INVERSE_MATRIX_NAME, function () {
            return mat.inverse4Aux(mat.prod4Aux(this._camera.getInverseOrientationMatrix(), this._camera.getProjectionMatrix()));
        });
    }
    CubemapSampledFVQ.prototype = new RenderableObject();
    CubemapSampledFVQ.prototype.constructor = CubemapSampledFVQ;
    /**
     * @override
     * @param {ManagedGLContext} context
     */
    CubemapSampledFVQ.prototype.addToContext = function (context) {
        RenderableObject.prototype.addToContext.call(this, context);
        this._model.addToContext(context, false);
    };
    /**
     * @override
     * @param {RenderParameters} renderParameters
     */
    CubemapSampledFVQ.prototype.performRender = function (renderParameters) {
        this._model.render(renderParameters.context, false);
    };
    // #########################################################################
    /**
     * @class Visual object that renders a 3D model from a set of different LOD
     * options.
     * @constructor
     * @extends RenderableObject3D
     * @param {Model} model The 3D model with meshes for different LODs.
     * @param {ManagedShader} shader The shader that should be active while rendering 
     * this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that 
     * should be bound while rendering this object in an associative array, with 
     * the roles as keys.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix 
     * representing the initial position of the object.
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix 
     * representing the initial orientation of the object.
     * @param {Float32Array} scalingMatrix The 4x4 scaling matrix representing 
     * the initial size of the object.
     * @param {Boolean} wireframe Whether the mesh should be drawn as wireframe 
     * instead of solid.
     * @param {Number} [lod] If given, only this specific LOD (if available) 
     * will be used for rendering this model
     * @param {Number} [smallestSizeWhenDrawn] The minimum visible size at which
     * to render the mesh
     */
    function ShadedLODMesh(model, shader, textures, positionMatrix, orientationMatrix, scalingMatrix, wireframe, lod, smallestSizeWhenDrawn) {
        RenderableObject3D.call(this);
        /**
         * Stores all the models representing this mesh at different levels of
         * detail.
         * @type Model
         */
        this._model = null;
        /**
         * Whether or not the rendering mode of this mesh is wireframe.
         * @type Boolean
         */
        this._wireframe = false;
        /**
         * The model currently chosen for rendering. Acts as a cached reference
         * to be used after the proper model has been chosen for a frame.
         * @type Number
         */
        this._currentLOD = this.LOD_NOT_SET;
        /**
         * A saved value of the last valid LOD that was chosen to render this object. This is used e.g. when rendering the shadow of
         * an object that itself is no longer inside the view frustum, and so it doesn't have a valid current LOD anymore.
         * @type Number
         */
        this._lastLOD = this.LOD_NOT_SET;
        /**
         * Stores the size of the largest model (of any LOD) representing this
         * object. It is the double of the (absolute) largest coordinate found 
         * among the vertices of the model.
         * @type Number
         */
        this._modelSize = 0;
        /**
         * The factors to use when calculating compensated LOD sizes, order by
         * the reference sizes.
         * @type Object.<String, Number>
         */
        this._lodSizeFactors = null;
        /**
         * If a static LOD is chosen, the model is always rendered using this 
         * LOD (or the closest available one)
         * @type Number
         */
        this._staticLOD = this.LOD_NOT_SET;
        if (model) {
            this.init(model, shader, textures, positionMatrix, orientationMatrix, scalingMatrix, wireframe, lod, smallestSizeWhenDrawn);
        }
        this.setUniformValueFunction(UNIFORM_MODEL_MATRIX_NAME, function () {
            return this.getModelMatrix();
        });
        this.setUniformValueFunction(UNIFORM_NORMAL_MATRIX_NAME, function () {
            return mat.transposed3Aux(mat.inverse3Aux(mat.matrix3from4Aux(this.getModelMatrix())));
        });
    }
    ShadedLODMesh.prototype = new RenderableObject3D();
    ShadedLODMesh.prototype.constructor = ShadedLODMesh;
    /**
     * The value for LOD levels that have not been set (chosen) yet
     * @constant
     * @type Number
     */
    ShadedLODMesh.prototype.LOD_NOT_SET = -1;
    /**
     * @override
     * @param {Model} model The 3D model with meshes for different LODs.
     * @param {ManagedShader} shader The shader that should be active while rendering 
     * this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that 
     * should be bound while rendering this object in an associative array, with 
     * the roles as keys.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix 
     * representing the initial position of the object.
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix 
     * representing the initial orientation of the object.
     * @param {Float32Array} scalingMatrix The 4x4 scaling matrix representing 
     * the initial size of the object.
     * @param {Boolean} wireframe Whether the mesh should be drawn as wireframe 
     * instead of solid.
     * @param {Number} [lod] If given, only this specific LOD (if available) 
     * will be used for rendering this model
     * @param {Number} [smallestSizeWhenDrawn] The minimum visible size at which
     * to render the mesh
     */
    ShadedLODMesh.prototype.init = function (model, shader, textures, positionMatrix, orientationMatrix, scalingMatrix, wireframe, lod, smallestSizeWhenDrawn) {
        RenderableObject3D.prototype.init.call(this, shader, true, true, positionMatrix, orientationMatrix, scalingMatrix);
        this.setSmallestSizeWhenDrawn(smallestSizeWhenDrawn || DEFAULT_SMALLEST_MESH_SIZE_WHEN_DRAWN);
        this.setTextures(textures);
        this._model = model;
        this._wireframe = (wireframe === true);
        if (this._wireframe) {
            this._isRenderedWithDepthMask = false;
        }
        this._currentLOD = this.LOD_NOT_SET;
        this._lastLOD = this.LOD_NOT_SET;
        this._modelSize = 0;
        this._lodSizeFactors = {};
        this._staticLOD = (lod !== undefined) ? lod : this.LOD_NOT_SET;
        // initializing modelSize
        for (var i = this._model.getMinLOD(); i <= this._model.getMaxLOD(); i++) {
            if (this._model.getSize(i) > this._modelSize) {
                this._modelSize = this._model.getSize(i);
            }
        }
    };
    /**
     * @override
     * @param {ManagedGLContext} context
     */
    ShadedLODMesh.prototype.addToContext = function (context) {
        RenderableObject3D.prototype.addToContext.call(this, context);
        this._model.addToContext(context, this._wireframe);
    };
    /**
     * Returns the 3D model object of this shaded mesh.
     * @returns {Model}
     */
    ShadedLODMesh.prototype.getModel = function () {
        return this._model;
    };
    /**
     * Returns whether this model is rendered in wireframe mode
     * @returns {Model}
     */
    ShadedLODMesh.prototype.isWireframe = function () {
        return this._wireframe;
    };
    /**
     * Returns the size of the largest model of the mesh.
     * @returns {Number} The size of the largest model of the mesh.
     */
    ShadedLODMesh.prototype.getSize = function () {
        return this._modelSize;
    };
    /**
     * 
     * @param {Number} visibleSize
     * @param {Number} referenceSize
     * @returns {Number}
     */
    ShadedLODMesh.prototype.getLODSize = function (visibleSize, referenceSize) {
        if (this._lodSizeFactors[referenceSize.toString()] === undefined) {
            this._lodSizeFactors[referenceSize.toString()] = Math.log10(referenceSize + 10) / Math.log10(this.getScaledSize() + 10);
        }
        return visibleSize * this._lodSizeFactors[referenceSize.toString()];
    };
    /**
     * Returns the height (size on the Y axis) of the largest mesh of the model, measured in mesh coordinates.
     * @returns {Number}
     */
    ShadedLODMesh.prototype.getHeight = function () {
        return this._model.getHeight();
    };
    /**
     * Returns the height (size on the Y axis) of the largest mesh of the model, measured in meters.
     * @returns {Number}
     */
    ShadedLODMesh.prototype.getHeightInMeters = function () {
        return this._model.getHeightInMeters();
    };
    /**
     * Returns largest Y coordinate that any of the vertices of any of the meshes of this model have
     * @returns {Number}
     */
    ShadedLODMesh.prototype.getMaxY = function () {
        return this._model.getMaxY();
    };
    /**
     * Returns the LOD that should be used when rendering using the passed 
     * render parameters.
     * @param {RenderParameters} renderParameters
     * @returns {Number}
     */
    ShadedLODMesh.prototype.getCurrentLOD = function (renderParameters) {
        var visibleSize, lodSize, i;
        if (this._currentLOD === this.LOD_NOT_SET) {
            if (this._staticLOD !== this.LOD_NOT_SET) {
                this._currentLOD = this._model.getClosestAvailableLOD(this._staticLOD);
            } else {
                if (!renderParameters) {
                    return this.LOD_NOT_SET;
                }
                this.updateVisibleSize(renderParameters, true);
                visibleSize = this.getSizeInPixels(renderParameters);
                lodSize = renderParameters.lodContext.compensateForObjectSize ? this.getLODSize(visibleSize, renderParameters.lodContext.referenceSize) : visibleSize;
                if (lodSize > 0) {
                    for (i = Math.min(this._model.getMaxLOD(), renderParameters.lodContext.maxEnabledLOD); i >= this._model.getMinLOD(); i--) {
                        if (renderParameters.lodContext.thresholds[i] <= lodSize) {
                            this._currentLOD = i;
                            break;
                        }
                    }
                }
            }
        }
        if (this._currentLOD !== this.LOD_NOT_SET) {
            this._lastLOD = this._currentLOD;
            return this._currentLOD;
        }
        if (this._lastLOD !== this.LOD_NOT_SET) {
            return this._lastLOD;
        }
        return DEFAULT_LOD;
    };
    /**
     * Sets a new static LOD (after calling this the model will be rendered using the LOD closest to this static setting, regardless of the
     * LOD context settings (limits).
     * @param {Number} value
     */
    ShadedLODMesh.prototype.setStaticLOD = function (value) {
        this._staticLOD = value;
        this._currentLOD = this.LOD_NOT_SET;
        this._lastLOD = this.LOD_NOT_SET;
    };
    /**
     * @override
     */
    ShadedLODMesh.prototype.resetForNewFrame = function () {
        RenderableObject3D.prototype.resetForNewFrame.call(this);
        if (this._staticLOD === this.LOD_NOT_SET) {
            this._currentLOD = this.LOD_NOT_SET;
        }
    };
    /**
     * @override
     * @param {RenderParameters} renderParameters
     * @returns {Boolean}
     */
    ShadedLODMesh.prototype.shouldBeRendered = function (renderParameters) {
        if (RenderableObject3D.prototype.shouldBeRendered.call(this, renderParameters)) {
            if (this._wireframe === true) {
                return true;
            }
            if (renderParameters.depthMask === true) {
                if (this._model.getNumOpaqueTriangles(this.getCurrentLOD(renderParameters)) > 0) {
                    return true;
                }
            } else if ((renderParameters.depthMask === false) && (this._model.getNumTransparentTriangles(this.getCurrentLOD(renderParameters)) > 0)) {
                return true;
            }
            return false;
        }
        return false;
    };
    /**
     * @override
     * @param {RenderParameters} renderParameters
     */
    ShadedLODMesh.prototype.performRender = function (renderParameters) {
        this._model.render(renderParameters.context, this._wireframe, renderParameters.depthMask, this.getCurrentLOD(renderParameters));
    };
    /**
     * @override
     * @param {RenderParameters} renderParameters
     */
    ShadedLODMesh.prototype.shouldBeRenderedToShadowMap = function (renderParameters) {
        if (RenderableObject3D.prototype.shouldBeRenderedToShadowMap.call(this, renderParameters)) {
            return this._model.getNumOpaqueTriangles(this.getCurrentLOD(renderParameters)) > 0;
        }
    };
    /**
     * @override
     * @param {RenderParameters} renderParameters
     */
    ShadedLODMesh.prototype.prepareForRenderToShadowMap = function (renderParameters) {
        renderParameters.context.getCurrentShader().assignUniforms(renderParameters.context, this._uniformValueFunctions);
    };
    /**
     * @override
     * @param {RenderParameters} renderParameters
     */
    ShadedLODMesh.prototype.performRenderToShadowMap = function (renderParameters) {
        this._model.render(renderParameters.context, this._wireframe, true, this.getCurrentLOD(renderParameters));
        application.log_DEBUG("Rendered model (" + this._model.getName() + ") to shadow map.", 5);
    };
    // #########################################################################
    /**
     * @class A mesh that has associated float parameter arrays, which can be 
     * set through this object and are passed to WebGL through uniforms before
     * each render.
     * @extends ShadedLODMesh
     * @constructor
     * @param {Model} model
     * @param {ManagedShader} shader The shader that should be active while rendering 
     * this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that 
     * should be bound while rendering this object in an associative array, with 
     * the roles as keys.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix 
     * representing the initial position of the object.
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix 
     * representing the initial orientation of the object.
     * @param {Float32Array} scalingMatrix The 4x4 scaling matrix representing 
     * the initial size of the object.
     * @param {Boolean} wireframe Whether the mesh should be drawn as wireframe 
     * instead of solid.
     * @param {Number} [lod] If given, only this specific LOD (if available) 
     * will be used for rendering this model
     * @param {Number} [smallestSizeWhenDrawn] The minimum visible size at which
     * to render the mesh
     * @param {Object} parameterArrayDeclarations The names and types to identify the parameter arrays later when setting their values.
     * The keys in this object should be the names (the uniform variables will be identified by names based on these - generated by 
     * managedGL), and the values should indicate the type of elements in the corresponding uniform array (using the enum 
     * managedGL.ShaderVariableType). E.g. { "myFloatArray": managedGL.ShaderVariableType.FLOAT }
     */
    function ParameterizedMesh(model, shader, textures, positionMatrix, orientationMatrix, scalingMatrix, wireframe, lod, smallestSizeWhenDrawn, parameterArrayDeclarations) {
        ShadedLODMesh.call(this);
        /**
         * The values of the parameter arrays.
         * @type Object.<String, Float32Array>
         */
        this._parameterArrays = null;
        if (model) {
            this.init(model, shader, textures, positionMatrix, orientationMatrix, scalingMatrix, wireframe, lod, smallestSizeWhenDrawn, parameterArrayDeclarations);
        }
    }
    ParameterizedMesh.prototype = new ShadedLODMesh();
    ParameterizedMesh.prototype.constructor = ParameterizedMesh;
    /**
     * @param {Model} model
     * @param {ManagedShader} shader The shader that should be active while rendering 
     * this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that 
     * should be bound while rendering this object in an associative array, with 
     * the roles as keys.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix 
     * representing the initial position of the object.
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix 
     * representing the initial orientation of the object.
     * @param {Float32Array} scalingMatrix The 4x4 scaling matrix representing 
     * the initial size of the object.
     * @param {Boolean} wireframe Whether the mesh should be drawn as wireframe 
     * instead of solid.
     * @param {Number} [lod] If given, only this specific LOD (if available) 
     * will be used for rendering this model
     * @param {Number} [smallestSizeWhenDrawn] The minimum visible size at which
     * to render the mesh
     * @param {Object} parameterArrayDeclarations The names and types to identify the parameter arrays later when setting their values.
     * The keys in this object should be the names (the uniform variables will be identified by names based on these - generated by 
     * managedGL), and the values should indicate the type of elements in the corresponding uniform array (using the enum 
     * managedGL.ShaderVariableType). E.g. { "myFloatArray": managedGL.ShaderVariableType.FLOAT }
     */
    ParameterizedMesh.prototype.init = function(model, shader, textures, positionMatrix, orientationMatrix, scalingMatrix, wireframe, lod, smallestSizeWhenDrawn, parameterArrayDeclarations) {
        var i, j, uniformArrayName, uniformArrayLength, parameterArrayNames;
        ShadedLODMesh.prototype.init.call(this, model, shader, textures, positionMatrix, orientationMatrix, scalingMatrix, wireframe, lod, smallestSizeWhenDrawn);
        /**
         * The values of the parameter arrays.
         * @type Object.<String, Float32Array>
         */
        this._parameterArrays = {};
        parameterArrayNames = Object.keys(parameterArrayDeclarations);
        for (i = 0; i < parameterArrayNames.length; i++) {
            uniformArrayName = managedGL.getUniformName(parameterArrayNames[i]);
            uniformArrayLength = shader.getUniformArrayLength(uniformArrayName);
            if (uniformArrayLength > 0) {
                switch (parameterArrayDeclarations[parameterArrayNames[i]]) {
                    case managedGL.ShaderVariableType.FLOAT:
                        break;
                    case managedGL.ShaderVariableType.MAT4:
                        uniformArrayLength *= 16;
                        break;
                    default:
                        application.showError("Cannot create uniform parameter array with elements of type: '" + parameterArrayDeclarations[parameterArrayNames[i]] + "'!");
                }
                this._parameterArrays[parameterArrayNames[i]] = new Float32Array(uniformArrayLength);
                for (j = 0; j < uniformArrayLength; j++) {
                    this._parameterArrays[parameterArrayNames[i]][j] = 0.0;
                }
                this.setUniformValueFunction(parameterArrayNames[i], this.createGetParameterArrayFunction(parameterArrayNames[i]));
            } else {
                application.log_DEBUG("Note: cannot initialize parameter array '" + parameterArrayNames[i] + "' for parameterized mesh, as the given shader (" + shader.getName() + ") does not have a uniform array named '" + uniformArrayName + "'.", 2);
                this._parameterArrays[parameterArrayNames[i]] = new Float32Array();
            }
        }
    };
    /**
     * Returns a function to that returns the parameter array identified by the 
     * passed name.
     * @param {String} name
     * @returns {Function}
     */
    ParameterizedMesh.prototype.createGetParameterArrayFunction = function (name) {
        return function () {
            return this._parameterArrays[name];
        };
    };
    /**
     * Returns whether the mesh has a parameter array available with the passed name
     * @param {String} name
     */
    ParameterizedMesh.prototype.hasParameterArray = function (name) {
        return !!this._parameterArrays[name] && (this._parameterArrays[name].length > 0);
    };
    /**
     * Sets the value of the float element at the passed index of the parameter array identified by the passed name.
     * @param {String} name
     * @param {Number} index
     * @param {Number} value
     */
    ParameterizedMesh.prototype.setFloatParameter = function (name, index, value) {
        this._parameterArrays[name][index] = value;
    };
    /**
     * Sets a 4x4 matrix value for the element at the passed index of the parameter array identified by the passed name.
     * @param {String} name
     * @param {Number} index
     * @param {Float32Array} value
     */
    ParameterizedMesh.prototype.setMat4Parameter = function (name, index, value) {
        this._parameterArrays[name].set(value, 16 * index);
    };
    /**
     * Copies the values in the passed array to the parameter array identified by the passed name.
     * @param {String} name
     * @param {Float32Array} value
     */
    ParameterizedMesh.prototype.setParameterArray = function (name, value) {
        this._parameterArrays[name].set(value, 0);
    };
    // #########################################################################
    /**
     * @class Visual object that renders a 2D billboard transformed in 3D space.
     * The orientation of the billboard is currently fixed at init() time.
     * @extends RenderableObject3D
     * @param {Model} model The model to store the simple billboard data.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that should be bound while rendering this object in an associative 
     * array, with the roles as keys.
     * @param {Number} size The size of the billboard
     * @param {Boolean} wireframe whether this billboard should be rendered in wireframe mode
     * @param {Float32Array} positionMatrix The 4x4 translation matrix representing the initial position of the object.
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix representing the initial orientation of the object. This will be fixed until
     * the billboard is reused with a new init() call.
     * @param {ManagedShader} instancedShader The shader that should be active while rendering this object using instancing.
     */
    function Billboard(model, shader, textures, size, wireframe, positionMatrix, orientationMatrix, instancedShader) {
        RenderableObject3D.call(this);
        /**
         * The model to store the simple billboard data.
         * @type Model
         */
        this._model = null;
        /**
         * Whether or not the rendering mode of this billboard is wireframe.
         * @type Boolean
         */
        this._wireframe = false;
        /**
         * The vector to be reused for storing the calculated position for rendering. The 4th coordinate stores the size.
         * @type Number[3]
         */
        this._renderPosition = [0, 0, 0, 0];
        /**
         * The vector to be reused for storing the calculated direction for rendering. The 4th coordinate stores the opacity.
         * @type Number[3]
         */
        this._renderDirection = [0, 0, 0, 0];
        if (model) {
            this.init(model, shader, textures, size, wireframe, positionMatrix, orientationMatrix, instancedShader);
        }
        this.setUniformValueFunction(UNIFORM_POSITION_NAME, function () {
            this.copyPositionToVector(this._renderPosition);
            return this._renderPosition;
        });
        this.setUniformValueFunction(UNIFORM_DIRECTION_NAME, function () {
            return this._renderDirection;
        });
    }
    Billboard.prototype = new RenderableObject3D();
    Billboard.prototype.constructor = Billboard;
    /**
     * @param {Model} model The model to store the simple billboard data.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that should be bound while rendering this object in an associative 
     * array, with the roles as keys.
     * @param {Number} size The size of the billboard
     * @param {Boolean} wireframe whether this billboard should be rendered in wireframe mode
     * @param {Float32Array} positionMatrix The 4x4 translation matrix representing the initial position of the object.
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix representing the initial orientation of the object.
     * @param {ManagedShader} instancedShader The shader that should be active while rendering this object using instancing.
     */
    Billboard.prototype.init = function (model, shader, textures, size, wireframe, positionMatrix, orientationMatrix, instancedShader) {
        RenderableObject3D.prototype.init.call(this, shader, false, true, positionMatrix, orientationMatrix, mat.scaling4Aux(size), instancedShader);
        this.setTextures(textures);
        vec.setRowB43(this._renderDirection, this.getOrientationMatrix());
        this._renderDirection[3] = 1;
        this._renderPosition[3] = size;
        this._model = model;
        this._wireframe = (wireframe === true);
        if (this._wireframe) {
            this._isRenderedWithDepthMask = false;
        }
    };
    /**
     * Returns the model used to render the billboard.
     * @returns {Model}
     */
    Billboard.prototype.getModel = function () {
        return this._model;
    };
    /**
     * Returns the level of detail this billboard should be considered at. (always 0)
     * @returns {Number}
     */
    Billboard.prototype.getCurrentLOD = function () {
        return 0;
    };
    /**
     * Call this after changing the orientation of the billboard, to make sure it is correctly rendered
     */
    Billboard.prototype.updateDirection = function () {
        vec.setRowB43(this._renderDirection, this.getOrientationMatrix());
    };
    /**
     * Sets the 4th coordinate of the direction vector passed to the shader for rendering (stores the opacity)
     * @param {Number} value
     */
    Billboard.prototype.setDirectionW = function (value) {
        this._renderDirection[3] = value;
    };
    /** 
     * @override
     * @param {ManagedGLContext} context
     */
    Billboard.prototype.addToContext = function (context) {
        RenderableObject3D.prototype.addToContext.call(this, context);
        this._model.addToContext(context, this._wireframe);
    };
    /**
     * @override
     * @param {RenderParameters} renderParameters
     */
    Billboard.prototype.performRender = function (renderParameters) {
        this._model.render(renderParameters.context, this._wireframe);
    };
    /**
     * @override
     * @param {ManagedGLContext} context
     * @param {Number} instanceCount
     */
    Billboard.prototype._peformRenderInstances = function (context, instanceCount) {
        this._model.renderInstances(context, this._wireframe, undefined, undefined, instanceCount);
    };
    /**
     * @override
     * @returns {Boolean}
     */
    Billboard.prototype.mightBeRenderedToShadowMap = function () {
        return false;
    };
    /**
     * @override
     * @param {Billboard} otherRenderableObject
     * @returns {Boolean}
     */
    Billboard.prototype.shouldGoInSameRenderQueueInstanced = function (otherRenderableObject) {
        return (RenderableObject3D.prototype.shouldGoInSameRenderQueueInstanced.call(this, otherRenderableObject)) &&
                (this._textures === otherRenderableObject._textures) &&
                (this._model === otherRenderableObject._model);
    };
    // #########################################################################
    /**
     * @class A container object to be used for the parent node housing trail segments
     * that visualize a trail that an object leaves behind as it moves.
     * @extends RenderableObject3D
     * @param {Number} size Initial size to be set for the trail
     */
    function Trail(size) {
        RenderableObject3D.call(this);
        if (size) {
            this.init(null, false, false, null, null, null, null, size, true, true);
        }
        this.setUniformValueFunction(UNIFORM_MODEL_MATRIX_NAME, function () {
            return this.getModelMatrix();
        });
    }
    Trail.prototype = new RenderableObject3D();
    Trail.prototype.constructor = Trail;
    /**
     * @override
     * TrailSegments don't use the traditional matrix hierarchy just position vectors 
     * for performance, so if we want to move the whole trail, we need to call translate
     * on all the segments
     * @param {Number[3]} v [x,y,z]
     */
    Trail.prototype.translatev = function (v) {
        var node;
        object3D.Object3D.prototype.translatev.call(this, v);
        for (node = this.getNode().getSubnodes().getFirst(); node; node = node.next) {
            node.getRenderableObject().translatev(v);
        }
    };
    // #########################################################################
    /**
     * @class Visual object that renders a segment of a trail, which is a 2D billboard transformed in 3D space, with separate
     * properties for its two ends, to make sure its ends are matching the propertes of the segment coming before / after it
     * @extends RenderableObject3D
     * @constructor
     * @param {Model} model The model to store the simple billboard data.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that should be bound while rendering this object in an associative 
     * array, with the roles as keys.
     * @param {Number} size The thickness of the trail (scaling perpendicular to the trail path)
     * @param {Boolean} wireframe whether this billboard should be rendered in wireframe mode
     * @param {Number[3]} startPosition The coordinates where this segment starts
     * @param {Number[3]} startDirection The direction of the trail path at the position where this segment starts
     * @param {Number[3]} endPosition The coordinates where this segment ends
     * @param {Number[3]} endDirection The direction of the trail path at the position where this segment ends
     * @param {Number[4]} color The RGBA color of this segment
     * @param {Number} duration The total duration of this segment (either ends), in milliseconds
     * @param {Number} startTimeLeft The time left of the total duration at the position where this segment starts, at the time when this segment is created.
     * When the start position expires (time left is zero), it will be moved toward the end position and reach it when it expires, too. In milliseconds.
     * @param {Number} endTimeLeft The time left of the total duration at the position where this segment ends, at the time when this segment is created.
     * When this time expires, the segment is removed. In milliseconds.
     * @param {ManagedShader} instancedShader The shader that should be active while rendering this object using instancing.
     */
    function TrailSegment(model, shader, textures, size, wireframe, startPosition, startDirection, endPosition, endDirection, color, duration, startTimeLeft, endTimeLeft, instancedShader) {
        RenderableObject3D.call(this);
        /**
         * The model to store the simple billboard data.
         * @type Model
         */
        this._model = null;
        /**
         * Whether or not the rendering mode of this billboard is wireframe.
         * @type Boolean
         */
        this._wireframe = false;
        /**
         * Stores the size (thickness) of the trail, as well as the time left ratios at the start
         * and end positions of this segment, to be passed as a shader uniform.
         * @type Number[3]
         */
        this._sizeVector = [0, 0, 0];
        /**
         * The vector to be reused for storing the start position for rendering
         * @type Number[3]
         */
        this._startPosition = [0, 0, 0];
        /**
         * The vector to be reused for storing the end position for rendering
         * @type Number[3]
         */
        this._endPosition = [0, 0, 0];
        /**
         * The vector to be reused for storing the start direction for rendering
         * @type Number[3]
         */
        this._startDirection = [0, 0, 0];
        /**
         * The vector to be reused for storing the end direction for rendering
         * @type Number[3]
         */
        this._endDirection = [0, 0, 0];
        /**
         * The vector to be reused for storing the calculated direction  (from start to end positon)
         * @type Number[3]
         */
        this._direction = [0, 0, 0];
        /**
         * The RGBA color of this segment
         * @type Number[4]
         */
        this._color = [0, 0, 0, 0];
        /**
         * The total duration of this segment (either ends), in milliseconds
         * @type Number
         */
        this._duration = 0;
        /**
         * The time left of the total duration at the position where this segment starts.
         * When the start position expires (time left is zero), it will be moved toward the end position and reach it when it expires, too
         * In milliseconds.
         * @type Number
         */
        this._startTimeLeft = 0;
        /**
         * The time left of the total duration at the position where this segment ends.
         * When this time expires, the segment is removed. In milliseconds.
         * @type Number
         */
        this._endTimeLeft = 0;
        if (model) {
            this.init(model, shader, textures, size, wireframe, startPosition, startDirection, endPosition, endDirection, color, duration, startTimeLeft, endTimeLeft, instancedShader);
        }
        this.setUniformValueFunction(UNIFORM_START_POSITION_NAME, function () {
            return this._startPosition;
        });
        this.setUniformValueFunction(UNIFORM_END_POSITION_NAME, function () {
            return this._endPosition;
        });
        this.setUniformValueFunction(UNIFORM_START_DIRECTION_NAME, function () {
            return this._startDirection;
        });
        this.setUniformValueFunction(UNIFORM_END_DIRECTION_NAME, function () {
            return this._endDirection;
        });
        this.setUniformValueFunction(UNIFORM_SIZE_NAME, function () {
            return this._sizeVector;
        });
        this.setUniformValueFunction(UNIFORM_COLOR_NAME, function () {
            return this._color;
        });
    }
    TrailSegment.prototype = new RenderableObject3D();
    TrailSegment.prototype.constructor = TrailSegment;
    /**
     * @param {Model} model The model to store the simple billboard data.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that should be bound while rendering this object in an associative 
     * array, with the roles as keys.
     * @param {Number} size The thickness of the trail (scaling perpendicular to the trail path)
     * @param {Boolean} wireframe whether this billboard should be rendered in wireframe mode
     * @param {Number[3]} startPosition The coordinates where this segment starts
     * @param {Number[3]} startDirection The direction of the trail path at the position where this segment starts
     * @param {Number[3]} endPosition The coordinates where this segment ends
     * @param {Number[3]} endDirection The direction of the trail path at the position where this segment ends
     * @param {Number[4]} color The RGBA color of this segment
     * @param {Number} duration The total duration of this segment (either ends), in milliseconds
     * @param {Number} startTimeLeft The time left of the total duration at the position where this segment starts, at the time when this segment is created.
     * When the start position expires (time left is zero), it will be moved toward the end position and reach it when it expires, too. In milliseconds.
     * @param {Number} endTimeLeft The time left of the total duration at the position where this segment ends, at the time when this segment is created.
     * When this time expires, the segment is removed. In milliseconds.
     * @param {ManagedShader} instancedShader The shader that should be active while rendering this object using instancing.
     */
    TrailSegment.prototype.init = function (model, shader, textures, size, wireframe, startPosition, startDirection, endPosition, endDirection, color, duration, startTimeLeft, endTimeLeft, instancedShader) {
        RenderableObject3D.prototype.init.call(this, shader, false, true, mat.translation4vAux(startPosition), mat.IDENTITY4, mat.scaling4Aux(size), instancedShader);
        this.setTextures(textures);
        vec.setVector3(this._startPosition, startPosition);
        vec.setVector3(this._endPosition, endPosition);
        vec.setVector3(this._startDirection, startDirection);
        vec.setVector3(this._endDirection, endDirection);
        vec.setVector4(this._color, color);
        this._duration = duration;
        this._startTimeLeft = startTimeLeft;
        this._endTimeLeft = endTimeLeft;
        this._sizeVector[0] = size;
        this._model = model;
        this._wireframe = (wireframe === true);
        if (this._wireframe) {
            this._isRenderedWithDepthMask = false;
        }
    };
    /**
     * @override
     * Omit 3D checks, as those will be handled by the parent node housing the whole trail
     * @param {RenderParameters} renderParameters
     */
    TrailSegment.prototype.shouldBeRendered = function (renderParameters) {
        return RenderableObject.prototype.shouldBeRendered.call(this, renderParameters);
    };
    /**
     * @override
     * We don't use the classic position and model matrices for trail segments, so we need 
     * to modify the position vectors instead
     * @param {Number[3]} v [x,y,z]
     */
    TrailSegment.prototype.translatev = function (v) {
        vec.add3(this._startPosition, v);
        vec.add3(this._endPosition, v);
    };
    /**
     * Returns the model used to render the billboard.
     * @returns {Model}
     */
    TrailSegment.prototype.getModel = function () {
        return this._model;
    };
    /**
     * Returns the level of detail this billboard should be considered at. (always 0)
     * @returns {Number}
     */
    TrailSegment.prototype.getCurrentLOD = function () {
        return 0;
    };
    /**
     * The direction of the trail path at the position where this segment ends
     * @returns {Number[3]}
     */
    TrailSegment.prototype.getEndDirection = function () {
        return this._endDirection;
    };
    /**
     * The time left of the total duration at the position where this segment ends, in milliseconds.
     * @returns {Number}
     */
    TrailSegment.prototype.getEndTimeLeft = function () {
        return this._endTimeLeft;
    };
    /** 
     * @override
     * @param {ManagedGLContext} context
     */
    TrailSegment.prototype.addToContext = function (context) {
        RenderableObject3D.prototype.addToContext.call(this, context);
        this._model.addToContext(context, this._wireframe);
    };
    /**
     * @override
     * Performs one animation step
     * @param {Number} dt The time passed since the last animation step in milliseconds
     */
    TrailSegment.prototype.performAnimate = function (dt) {
        var length;
        this._startTimeLeft -= dt;
        this._endTimeLeft -= dt;
        if (this._endTimeLeft <= 0) {
            this._startTimeLeft = 0;
            this._endTimeLeft = 0;
            this.markAsReusable(true);
            return;
        }
        if (this._startTimeLeft < 0) {
            // move the start position towards the end position if it has expired
            vec.setDiff3(this._direction, this._endPosition, this._startPosition);
            length = vec.extractLength3(this._direction);
            vec.add3(this._startPosition, vec.scaled3Aux(this._direction, length * (1 - this._endTimeLeft / (this._endTimeLeft - this._startTimeLeft))));
            this._startTimeLeft = 0;
        }
        this._sizeVector[1] = this._startTimeLeft / this._duration;
        this._sizeVector[2] = this._endTimeLeft / this._duration;
    };
    /**
     * @override
     * @param {RenderParameters} renderParameters
     */
    TrailSegment.prototype.performRender = function (renderParameters) {
        this._model.render(renderParameters.context, this._wireframe);
    };
    /**
     * @override
     * @param {ManagedGLContext} context
     * @param {Number} instanceCount
     */
    TrailSegment.prototype._peformRenderInstances = function (context, instanceCount) {
        this._model.renderInstances(context, this._wireframe, undefined, undefined, instanceCount);
    };
    /**
     * @override
     * @returns {Boolean}
     */
    TrailSegment.prototype.mightBeRenderedToShadowMap = function () {
        return false;
    };
    /**
     * @override
     * @param {TrailSegment} otherRenderableObject
     * @returns {Boolean}
     */
    TrailSegment.prototype.shouldGoInSameRenderQueueInstanced = function (otherRenderableObject) {
        return (RenderableObject3D.prototype.shouldGoInSameRenderQueueInstanced.call(this, otherRenderableObject)) &&
                (this._textures === otherRenderableObject._textures) &&
                (this._model === otherRenderableObject._model);
    };
    // #########################################################################
    /**
     * @struct Stores the attributes of a particle for a given state
     * @param {Number[4]} color
     * @param {Number} size
     * @param {Number} [timeToReach=0]
     */
    function ParticleState(color, size, timeToReach) {
        /**
         * When in this state, the particle is rendered using this color for modulation of the texture color
         * @type Number[4]
         */
        this.color = color || DEFAULT_PARTICLE_STATE_COLOR;
        /**
         * When in this state, the particle is rendered in this size
         * @type Number
         */
        this.size = (size !== undefined) ? size : 1;
        /**
         * How many milliseconds does it take for the particle to transition to this state
         * @type Number
         */
        this.timeToReach = timeToReach || 0;
    }
    /**
     * @class Visual object that renders a 2D billboard positioned in 3D space and can
     * dynamically change size and color during it's lifespan. Used for flashes and
     * particle systems.
     * @extends RenderableObject3D
     * @param {Model} model The model to store the simple billboard data.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that should be bound while rendering this object in an associative 
     * array, with the roles as keys.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix representing the initial position of the object.
     * @param {ParticleState[]} states The list of states this particle will go through during its lifespan.
     * If only one state is given, the particle will stay forever in that state
     * @param {Boolean} [looping=false] Whether to start over from the first state once the last one is reached (or to delete the particle)
     * @param {ManagedShader} [instancedShader]
     * @param {Number} [initialSize] If given, the particle's size will initially be set to this value rather than the starting size of the
     * first particle state.
     */
    function Particle(model, shader, textures, positionMatrix, states, looping, instancedShader, initialSize) {
        RenderableObject3D.call(this);
        this.setSmallestSizeWhenDrawn(0.1);
        /**
         * The model to store the simple billboard data.
         * @type Model
         */
        this._model = model;
        /**
         * The currently active color of the color used to modulate the texture color when rendering.
         * Do not set directly! It changes automatically and linearly with time using the colors 
         * specified in the states of the particle.
         * @type Number[4]
         */
        this._color = [0, 0, 0, 0];
        /**
         * The billboard will be scaled using this number when rendering.
         * Do not set directly! It changes automatically and linearly with time using the colors 
         * specified in the states of the particle.
         * @type Number
         */
        this._size = 0;
        /**
         * The billboard will be scaled using this number when rendering.
         * Can be set from outside to influence the visible size of the particle.
         * @type Number
         */
        this._relativeSize = 0;
        /**
         * An array storing the calculated world position vector to be passed to the shader uniform.
         * @type Number
         */
        this._positionVector = [0, 0, 0, 0];
        /**
         * The list of states this particle goes through during its lifespan. If only one state is stored,
         * the particle statically stays in that state. If multiple states are stored, the _looping
         * field specifies whether the particle starts over from the first state or is deleted after the
         * last state has been reached.
         * @type ParticleState[]
         */
        this._states = null;
        /**
         * The index of the current state the particle is in, that is, the last state it fully reached
         * (the actual attributes might be already transitioning towards the next state)
         * @type Number
         */
        this._currentStateIndex = 0;
        /**
         * Whether to start over from the first state once the last one is reached (or to delete the particle)
         * @type Boolean
         */
        this._looping = false;
        /**
         * Time passed since the current state has been reached, in milliseconds
         * @type Number
         */
        this._timeSinceLastTransition = 0;
        /**
         * The velocity of the particle in m/s
         * @type Number[3]
         */
        this._velocityVector = [0, 0, 0];
        /**
         * The cached value of the direction (unit vector) of the velocity vector of this particle in world coordinates.
         * ParticleSystems automatically invalidate this for all contained particles when their orientation changes, but if the 
         * ParticleSystem is the subnode of another node in the scene graph, and that parent node changes orientation, the invalidation 
         * needs to be issued manually (by calling invalidateWorldVelocityDirectionVector()). This is because continuous checks would be 
         * expensive and would bring minimal benefits.
         * @type Number[3]
         */
        this._worldVelocityDirectionVector = [0, 0, 0];
        /**
         * Whether the currently stored world velocity direction vector value is valid.
         * @type Boolean
         */
        this._worldVelocityDirectionVectorValid = false;
        /**
         * Whether the particle needs to be animated (there are more states or it has a non-zero velocity).
         * This is a cache variable.
         * @type Boolean
         */
        this._shouldAnimate = false;
        /**
         * Calculated cached value of the total duration this particle takes to animate from its first state to the last (in milliseconds)
         * @type Number
         */
        this._duration = 0;
        if (model) {
            this.init(model, shader, textures, positionMatrix, states, looping, instancedShader, initialSize);
        }
        this.setUniformValueFunction(UNIFORM_POSITION_NAME, function () {
            var modelMatrix;
            modelMatrix = this.getModelMatrix();
            this._positionVector[0] = modelMatrix[12];
            this._positionVector[1] = modelMatrix[13];
            this._positionVector[2] = modelMatrix[14];
            return this._positionVector;
        });
        this.setUniformValueFunction(UNIFORM_COLOR_NAME, function () {
            return this._color;
        });
        this.setUniformValueFunction(UNIFORM_DIRECTION_NAME, function () {
            return vec.floatVector3Aux(this.getWorldVelocityDirectionVector());
        });
    }
    Particle.prototype = new RenderableObject3D();
    Particle.prototype.constructor = Particle;
    /**
     * Initializes the fields of the particle.
     * @param {Model} model The model to store the simple billboard data.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that should be bound while rendering this object in an associative 
     * array, with the roles as keys.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix representing the initial position of the object.
     * @param {ParticleState[]} states The list of states this particle will go through during its lifespan.
     * If only one state is given, the particle will stay forever in that state
     * @param {Boolean} [looping=false] Whether to start over from the first state once the last one is reached (or to delete the particle)
     * @param {ManagedShader} [instancedShader]
     * @param {Number} [initialSize] If given, the particle's size will initially be set to this value rather than the starting size of the
     * first particle state.
     */
    Particle.prototype.init = function (model, shader, textures, positionMatrix, states, looping, instancedShader, initialSize) {
        RenderableObject3D.prototype.init.call(this, shader, false, true, positionMatrix, mat.IDENTITY4, mat.IDENTITY4, instancedShader);
        this.setTextures(textures);
        this._model = model;
        if (states) {
            this._color[0] = states[0].color[0];
            this._color[1] = states[0].color[1];
            this._color[2] = states[0].color[2];
            this._color[3] = states[0].color[3];
            this._states = states;
        } else {
            this._states = utils.EMPTY_ARRAY;
        }
        this._size = (initialSize !== undefined) ? initialSize : (states ? states[0].size : 0);
        this._relativeSize = 1;
        this._calculateSize();
        this._calculateDuration();
        this._currentStateIndex = 0;
        this._looping = (looping === true);
        this._timeSinceLastTransition = 0;
        this._velocityVector[0] = 0;
        this._velocityVector[1] = 0;
        this._velocityVector[2] = 0;
        this._worldVelocityDirectionVector[0] = 0;
        this._worldVelocityDirectionVector[1] = 0;
        this._worldVelocityDirectionVector[2] = 0;
        this._worldVelocityDirectionVectorValid = false;
        this._shouldAnimate = false;
        this._updateShouldAnimate();
    };
    /**
     * Updates the cached value of the calculated duration.
     * @returns {Number}
     */
    Particle.prototype._calculateDuration = function () {
        var i;
        this._duration = 0;
        for (i = 1; i < this._states.length; i++) {
            this._duration += this._states[i].timeToReach;
        }
    };
    /**
     * Updates the cached value of the calculated size (considering both size animation and the deliberately set relative size). Updates
     * visibility based on the size as well.
     */
    Particle.prototype._calculateSize = function () {
        this._positionVector[3] = this._size * this._relativeSize;
        this._visible = this._positionVector[3] >= PARTICLE_MINIMUM_VISIBLE_SIZE;
    };
    /**
     * Returns the total duration this particle takes to animate from its first state to the last (in milliseconds)
     * @returns {Number}
     */
    Particle.prototype.getDuration = function () {
        return this._duration;
    };
    /**
     * @override
     * @returns {Number}
     */
    Particle.prototype.getSize = function () {
        return this._positionVector[3];
    };
    /**
     * 
     * @returns {Number}
     */
    Particle.prototype.getFinalSize = function () {
        if (this._states.length === 0) {
            return this._size;
        }
        return this._states[this._states.length - 1].size;
    };
    /**
     * 
     * @returns {Number}
     */
    Particle.prototype.getMaxSize = function () {
        var result, i;
        if (this._states.length === 0) {
            return this._size;
        }
        result = 0;
        for (i = 0; i < this._states.length; i++) {
            if (this._states[i].size > result) {
                result = this._states[i].size;
            }
        }
        return result;
    };
    /**
     * Returns whether the particle has a non-zero velocity set.
     * @returns {Boolean}
     */
    Particle.prototype._hasVelocity = function () {
        return this._velocityVector && ((this._velocityVector[0] !== 0) || (this._velocityVector[1] !== 0) || (this._velocityVector[2] !== 0));
    };
    /**
     * @override
     * @param {Float32Array} matrix
     */
    Particle.prototype.rotateByMatrix3 = function (matrix) {
        if (this._velocityVector) {
            vec.mulVec3Mat3(this._velocityVector, matrix);
            this._updateVelocity();
        } else {
            RenderableObject3D.prototype.rotateByMatrix3.call(this, matrix);
        }
    };
    /**
     * Updates the _shouldAnimate cache variable.
     */
    Particle.prototype._updateShouldAnimate = function () {
        this._shouldAnimate = (this._states.length > 1) || this._hasVelocity();
    };
    /**
     * Called internally when the velocity vector changes.
     */
    Particle.prototype._updateVelocity = function () {
        this._worldVelocityDirectionVectorValid = false;
        this._updateShouldAnimate();
    };
    /**
     * Updates the visibility as well based on the new size.
     * @param {number} value The new value of the relative size.
     */
    Particle.prototype.setRelativeSize = function (value) {
        this._relativeSize = value;
        this._calculateSize();
    };
    /**
     * Set the velocity of the particle (m/s)
     * @param {Float32Array} value
     */
    Particle.prototype.setVelocityVector = function (value) {
        this._velocityVector = value;
        this._updateVelocity();
    };
    /**
     * Set the velocity of the particle (m/s)
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     */
    Particle.prototype.setVelocity = function (x, y, z) {
        this._velocityVector[0] = x;
        this._velocityVector[1] = y;
        this._velocityVector[2] = z;
        this._updateVelocity();
    };
    /**
     * Set the velocity of the particle (m/s) to the translation component in the passed matrix
     * @param {Float32Array} m A 4x4 translation matrix
     */
    Particle.prototype.setVelocityM = function (m) {
        this._velocityVector[0] = m[12];
        this._velocityVector[1] = m[13];
        this._velocityVector[2] = m[14];
        this._updateVelocity();
    };
    /**
     * 
     * @returns {Number[3]}
     */
    Particle.prototype.getWorldVelocityDirectionVector = function () {
        if (!this._worldVelocityDirectionVectorValid) {
            vec.setProdVec3Mat4(this._worldVelocityDirectionVector, this._velocityVector, this.getModelMatrix());
            vec.normalize3(this._worldVelocityDirectionVector);
            this._worldVelocityDirectionVectorValid = true;
        }
        return this._worldVelocityDirectionVector;
    };
    /**
     * Invalidates the current cached world velocity vector value, causing it to be recalculated next time it is required.
     */
    Particle.prototype.invalidateWorldVelocityDirectionVector = function () {
        this._worldVelocityDirectionVectorValid = false;
    };
    /**
     * Sets the animation state of the particle to be the one occuring after the passed amount of time from the start
     * @param {Number} elapsedTime In milliseconds
     */
    Particle.prototype.setAnimationTime = function (elapsedTime) {
        this._currentStateIndex = 0;
        this._timeSinceLastTransition = 0;
        this.performAnimate(elapsedTime);
    };
    /**
     * @override
     * @param {ManagedGLContext} context
     */
    Particle.prototype.addToContext = function (context) {
        RenderableObject3D.prototype.addToContext.call(this, context);
        this._model.addToContext(context, false);
    };
    /**
     * @override
     * Adds a quick check for visibility to the superclass method.
     * @param {Camera} camera
     * @param {Number} parentQueueBits
     * @returns {Number}
     */
    Particle.prototype.getRenderQueueBits = function (camera, parentQueueBits) {
        if (!this._visible) {
            return RenderQueueBits.NONE;
        }
        return RenderableObject3D.prototype.getRenderQueueBits.call(this, camera, parentQueueBits);
    };
    /**
     * @override
     * Renders the particle, binding the needed texture.
     * @param {RenderParameters} renderParameters
     */
    Particle.prototype.performRender = function (renderParameters) {
        this._model.render(renderParameters.context, false);
    };
    /**
     * @override
     * @param {ManagedGLContext} context
     * @param {Number} instanceCount
     */
    Particle.prototype._peformRenderInstances = function (context, instanceCount) {
        this._model.renderInstances(context, false, undefined, undefined, instanceCount);
    };
    /**
     * @override
     * @returns {Boolean}
     */
    Particle.prototype.mightBeRenderedToShadowMap = function () {
        return false;
    };
    /**
     * @override
     * @param {Number} dt
     * @returns {Boolean}
     */
    Particle.prototype.shouldAnimate = function (dt) {
        if (RenderableObject3D.prototype.shouldAnimate.call(this, dt)) {
            return this._shouldAnimate;
        }
        return false;
    };
    /**
     * @override
     * Performs one animation step, changing the attributes of the particle based on the state list
     * and marking it for deletion if needed.
     * @param {Number} dt The time passed since the last animation step in milliseconds
     */
    Particle.prototype.performAnimate = function (dt) {
        var nextStateIndex, stateProgress, i;
        // only animating through states if there is more than one of them
        if (this._states.length > 1) {
            this._timeSinceLastTransition += dt;
            // find out which state did we arrive to and which is next
            nextStateIndex = (this._currentStateIndex + 1) % this._states.length;
            while (this._timeSinceLastTransition > this._states[nextStateIndex].timeToReach) {
                if ((nextStateIndex === 0) && (!this._looping)) {
                    this._size = 0;
                    this.markAsReusable(true);
                    return;
                }
                this._timeSinceLastTransition -= this._states[nextStateIndex].timeToReach;
                nextStateIndex = (nextStateIndex + 1) % this._states.length;
            }
            this._currentStateIndex = (nextStateIndex === 0) ? (this._states.length - 1) : (nextStateIndex - 1);
            // calculate the relative progress
            stateProgress = this._timeSinceLastTransition / this._states[nextStateIndex].timeToReach;
            for (i = 0; i < 4; i++) {
                this._color[i] = (this._states[this._currentStateIndex].color[i] * (1.0 - stateProgress)) + (this._states[nextStateIndex].color[i] * stateProgress);
            }
            this._size = this._states[this._currentStateIndex].size * (1.0 - stateProgress) + this._states[nextStateIndex].size * stateProgress;
            this._calculateSize();
        }
        // only move if there is a non-zero velocity set
        if (this._hasVelocity()) {
            this.translatev(vec.scaled3Aux(this._velocityVector, dt * 0.001));
        }
    };
    /**
     * @override
     * @param {Particle} otherRenderableObject
     * @returns {Boolean}
     */
    Particle.prototype.shouldGoInSameRenderQueueInstanced = function (otherRenderableObject) {
        return (RenderableObject3D.prototype.shouldGoInSameRenderQueueInstanced.call(this, otherRenderableObject)) &&
                (this._textures === otherRenderableObject._textures) &&
                (this._model === otherRenderableObject._model);
    };
    // #########################################################################
    /**
     * Initializes the properties of the given particle so that it dynamically shrinks to zero size during it's lifespan. Used for flashes.
     * @param {Particle} particle The particle object to initialize.
     * @param {Model} model The model to store the simple billboard data.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that should be bound while rendering this object in an associative 
     * array, with the roles as keys.
     * @param {Number[4]} color The RGBA components of the color to modulate the billboard texture with.
     * @param {Number} size The size of the billboard
     * @param {Float32Array} positionMatrix The 4x4 translation matrix representing the initial position of the object.
     * @param {Number} duration The lifespan of the particle in milliseconds.
     * @param {ManagedShader} [instancedShader]
     */
    function initDynamicParticle(particle, model, shader, textures, color, size, positionMatrix, duration, instancedShader) {
        particle.init(model, shader, textures, positionMatrix, [new ParticleState(color, size, 0), new ParticleState(color, 0, duration)], false, instancedShader);
    }
    /**
     * Creates and returns a particle that dynamically shrinks to zero size during it's lifespan. Used for flashes.
     * @param {Model} model The model to store the simple billboard data.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that should be bound while rendering this object in an associative 
     * array, with the roles as keys.
     * @param {Number[4]} color The RGBA components of the color to modulate the billboard texture with.
     * @param {Number} size The size of the billboard
     * @param {Float32Array} positionMatrix The 4x4 translation matrix representing the initial position of the object.
     * @param {Number} duration The lifespan of the particle in milliseconds.
     * @param {ManagedShader} [instancedShader]
     */
    function dynamicParticle(model, shader, textures, color, size, positionMatrix, duration, instancedShader) {
        var result = new Particle();
        initDynamicParticle(result, model, shader, textures, color, size, positionMatrix, duration, instancedShader);
        return result;
    }
    // #########################################################################
    /**
     * Creates and returns a particle that does not change its state on it's own, but its attributes can be set directly.
     * @param {Model} model The model to store the simple billboard data.
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that 
     * should be bound while rendering this object in an associative array, with 
     * the roles as keys.
     * @param {Number[4]} color The RGBA components of the color to modulate the billboard texture with.
     * @param {Number} size The size of the billboard
     * @param {Float32Array} positionMatrix The 4x4 translation matrix representing the initial position of the object.
     * @param {ManagedShader} [instancedShader]
     */
    function staticParticle(model, shader, textures, color, size, positionMatrix, instancedShader) {
        return new Particle(model, shader, textures, positionMatrix, [new ParticleState(color, size, 0)], false, instancedShader);
    }
    /**
     * @class Can be used for a static particle that is rendered as part of the background. (such as a star)
     * @extends Particle
     * @param {Model} model A billboard or similar model.
     * @param {ManagedShader} shader The shader to use for render.
     * @param {Object.<String, Texture|Cubemap>} textures The textures that 
     * should be bound while rendering this object in an associative array, with 
     * the roles as keys.
     * @param {Number[4]} color Will be available for the shader as uniform
     * @param {Number} size Will be available to the shader as the uniform 
     * @param {Float32Array} positionMatrix The 4x4 translation matrix describing the position. Should be
     * a far away position in the distance for objects part of te background
     * @param {Number} angle This angle is used to calculate the orientation of the object - it will be rotated around its position vector
     * by this angle (in radians), with 0 meaning the Y vector of the object should point upwards
     */
    function BackgroundBillboard(model, shader, textures, color, size, positionMatrix, angle) {
        var up, direction, directionYawAndPitch, v;
        Particle.call(this, model, shader, textures, positionMatrix, [new ParticleState(color, size, 0)], false);
        // calculating an orientation matrix that has the Z vector pointing opposite to the position of the object, and a Y vector rotated
        // by the given angle compared to pointing towards the zenith ([0,0,1])
        v = [0, 1];
        vec.rotate2(v, angle);
        up = [v[0], 0, v[1]];
        direction = vec.normalize3(mat.translationVector3(positionMatrix));
        directionYawAndPitch = vec.getYawAndPitch(direction);
        v = [0, v[1]];
        vec.rotate2(v, directionYawAndPitch.pitch);
        up = [up[0], v[0], v[1]];
        v = [up[0], v[0]];
        vec.rotate2(v, directionYawAndPitch.yaw);
        up = [v[0], v[1], up[2]];
        this.setOrientationMatrix(mat.lookTowards4(vec.scaled3(direction, -1), up));
        this._positionVector.length = 3;
        /**
         * Cached value of the size to use for rendering, needed for in number (for uniform) and array (instance attribute) format
         * @type Number
         */
        this._calculatedSize = [size];
        this.setUniformValueFunction(UNIFORM_BILLBOARD_SIZE_NAME, function (contextName) {
            return (contextName === utils.EMPTY_STRING) ? this._calculatedSize : this._calculatedSize[0];
        });
        this.setUniformValueFunction(UNIFORM_MODEL_MATRIX_NAME, function () {
            return this.getModelMatrix();
        });
    }
    BackgroundBillboard.prototype = new Particle();
    BackgroundBillboard.prototype.constructor = BackgroundBillboard;
    /**
     * @override
     * The size is fix for this type of object, we don't need to do anything
     * @returns {Boolean}
     */
    BackgroundBillboard.prototype._calculateSize = function () {
        return true;
    };
    /**
     * @override
     * Will only do the same basic check as for a general RenderableObject
     * @param {RenderParameters} renderParameters
     * @returns {Boolean}
     */
    BackgroundBillboard.prototype.shouldBeRendered = function (renderParameters) {
        return RenderableObject.prototype.shouldBeRendered.call(this, renderParameters);
    };
    // #########################################################################
    /**
     * @class Visual object that renders a point like object as a line as it is
     * moving. Used to represent dust particles that give a visual clue about the
     * motion of the camera.
     * @extends RenderableObject
     * @param {Model} model A model of 2 vertices has to be passed (see lineModel()).
     * @param {ManagedShader} shader The shader that should be active while rendering this object.
     * @param {ManagedShader} instancedShader
     * @param {Number[3]} positionVector The initial position of the point.
     * @param {Number[4]} color The RGBA components of the color of the point particle. It will be available to the shader as uniform.
     * @param {Number} range How deep the point cloud should extend forward from the screen (meters) Can be used by the shader to fade out
     * particles that are farther.
     */
    function PointParticle(model, shader, instancedShader, positionVector, color, range) {
        RenderableObject.call(this, shader, false, true, instancedShader);
        /**
         * A 4x4 translation matrix representing the position of this point in space to be passed
         * to the shader.
         * @type Number[3]
         */
        this._positionVector = positionVector;
        /**
         * Stores a reference to the 2-vertex line model. (see lineModel())
         * @type Model
         */
        this._model = model;
        /**
         * The RGBA components of the color of the point particles.
         * Available to the shader as uniform 
         * @type Number[4]
         */
        this._color = color;
        /**
         * How deep the point cloud should extend forward from the screen (meters).
         * Available to the shader as uniform, using which particles can be gradually blended
         * into the background based on their distance.
         * @type Number
         */
        this._range = range;
        /**
         * Which direction the particles are currently moving and how much (meters). 
         * Available to the shader as uniform, using which
         * the trails of the particles can be visualised to indicate the direction of their movement.
         * @type Number[3]
         */
        this._shift = null;
        this.setUniformValueFunction(UNIFORM_POSITION_NAME, function () {
            return this._positionVector;
        });
        if (this._color) {
            this._shift = [0.0, 0.0, 0.0];
            this.setUniformValueFunction(UNIFORM_COLOR_NAME, function () {
                return this._color;
            });
            this.setUniformValueFunction(UNIFORM_POINT_CLOUD_SHIFT_NAME, function () {
                return this._shift;
            });
            this.setUniformValueFunction(UNIFORM_POINT_CLOUD_FARTHEST_Z_NAME, function () {
                return this._range;
            });
        }
    }
    PointParticle.prototype = new RenderableObject();
    PointParticle.prototype.constructor = PointParticle;
    /**
     * @override
     * Adds the line model resource next to the general ones.
     * @param {ManagedGLContext} context
     */
    PointParticle.prototype.addToContext = function (context) {
        if (this._color) {
            RenderableObject.prototype.addToContext.call(this, context);
            this._model.addToContext(context, true);
        }
    };
    /**
     * Updates the shift vector.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     */
    PointParticle.prototype.setShift = function (x, y, z) {
        this._shift[0] = x;
        this._shift[1] = y;
        this._shift[2] = z;
    };
    /**
     * Modifies the position matrix of the particle to make sure it the particle is situated
     * within a given range from a given center point.
     * Use this to relocate the point cloud to be around a camera.
     * @param {Float32Array} centerPositionMatrix The 4x4 translation matrix describing the center
     * location around which to place the particle (meters)
     * @param {Number} range The maximum x,y or z distance the replaced particle can have from the
     * center point.
     */
    PointParticle.prototype.fitPositionWithinRange = function (centerPositionMatrix, range) {
        var i;
        for (i = 0; i < 3; i++) {
            while (this._positionVector[i] > centerPositionMatrix[12 + i] + range) {
                this._positionVector[i] -= range * 2;
            }
            while (this._positionVector[i] < centerPositionMatrix[12 + i] - range) {
                this._positionVector[i] += range * 2;
            }
        }
    };
    /**
     * @override
     * Renders the particle.
     * @param {RenderParameters} renderParameters
     */
    PointParticle.prototype.performRender = function (renderParameters) {
        this._model.render(renderParameters.context, true);
    };
    /**
     * @override
     * @param {ManagedGLContext} context
     * @param {Number} instanceCount
     */
    PointParticle.prototype._peformRenderInstances = function (context, instanceCount) {
        this._model.renderInstances(context, true, false, undefined, instanceCount);
    };
    /**
     * @override
     * @returns {Boolean}
     */
    PointParticle.prototype.mightBeRenderedToShadowMap = function () {
        return false;
    };
    /**
     * Always returns false, there are no animations for this type of objects.
     * @returns {Boolean}
     */
    PointParticle.prototype.shouldAnimate = function () {
        return false;
    };
    /**
     * @override
     * @param {PointParticle} otherRenderableObject
     * @returns {Boolean}
     */
    PointParticle.prototype.shouldGoInSameRenderQueueInstanced = function (otherRenderableObject) {
        return (RenderableObject.prototype.shouldGoInSameRenderQueueInstanced.call(this, otherRenderableObject)) &&
                (this._color === otherRenderableObject._color) &&
                (this._range === otherRenderableObject._range);
    };
    // #########################################################################
    /**
     * @class A renderable object that can be used to model a simple UI element, rendered on top of the main scene view in 2D.
     * @extends RenderableObject
     * @param {Model} model The model storing the vertices of the UI element, typically a simple square.
     * @param {ManagedShader} shader The shader to be used to render this element.
     * @param {Object.<String, ManagedTexture>} textures The textures organized by roles to be used.
     * @param {Number[2]|Number[3]} position The position of the element either on the screen (2D) or in world space (3D), depending on the
     * shader to be used.
     * @param {Number[2]} size The size of the element by which the model can be scaled.
     * @param {String} scaleMode (enum ScaleMode) The scale mode to be used for sizing this element.
     * @param {Number[4]} color A color to modulate the element with. (inside its clip zone)
     * @param {Number} [angle] An angle based on which a 2D rotation matrix will be created and stored that can be used to rotate the 
     * element in 2D.
     * @param {Numbe[4]} [clipCoordinates] The coordinates specifying the clip zone for this element, in the form of [minX, maxX, minY, 
     * maxY], where the area outside the min-max range on either the X or Y is considered to be outside the clip zone, and all coordinates 
     * go from -1 (left / bottom) to 1 (right / top), corresponding to a relative position within the element.
     * @param {Number[4]} [clipColor] A color to modulate the element with outside its clip zone.
     */
    function UIElement(model, shader, textures, position, size, scaleMode, color, angle, clipCoordinates, clipColor) {
        RenderableObject.call(this, shader, false, true);
        this.setTextures(textures);
        /**
         * The model to store the shape of the 2D UI element.
         * @type Model
         */
        this._model = model;
        /**
         * The position of the element in 2D or 3D, whichever is needed by the used shader.
         * @type Number[2]|Number[3]
         */
        this._position = position;
        /**
         * The currently active color of the color used to modulate the texture color when rendering inside the clip zone.
         * @type Number[4]
         */
        this._color = color;
        /**
         * The size of the element that can be used by the shader to scale the element.
         * @type Number[2]
         */
        this._size = size;
        /**
         * This number is passed to the shader to indicate the scaling mode to be used to size the element.
         * @type Number
         */
        this._scaleMode = _getScaleModeInt(scaleMode);
        /**
         * A 2D rotation matrix that can be used by the shader to rotate the element.
         * @type Floar32Array
         */
        this._rotationMatrix = mat.rotation2(Math.radians(angle || 0));
        /**
         * The coordinates specifying the clip zone for this element, in the form of [minX, maxX, minY, maxY], where the area outside the 
         * min-max range on either the X or Y is considered to be outside the clip zone, and all coordinates  go from -1 (left / bottom) to 
         * 1 (right / top), corresponding to a relative position within the element.
         * @type Number[4]
         */
        this._clipCoordinates = clipCoordinates || CLIP_COORDINATES_NO_CLIP.slice();
        /**
         * The currently active color of the color used to modulate the texture color when rendering outside of the clip zone.
         * @type Number[4]
         */
        this._clipColor = clipColor || [0, 0, 0, 0];
        this.setUniformValueFunction(UNIFORM_POSITION_NAME, function () {
            return this._position;
        });
        this.setUniformValueFunction(UNIFORM_SIZE_NAME, function () {
            return this._size;
        });
        this.setUniformValueFunction(UNIFORM_SCALE_MODE_NAME, function () {
            return this._scaleMode;
        });
        this.setUniformValueFunction(UNIFORM_COLOR_NAME, function () {
            return this._color;
        });
        this.setUniformValueFunction(UNIFORM_ROTATION_MATRIX_NAME, function () {
            return this._rotationMatrix;
        });
        this.setUniformValueFunction(UNIFORM_CLIP_COORDINATES_NAME, function () {
            return this._clipCoordinates;
        });
        this.setUniformValueFunction(UNIFORM_CLIP_COLOR_NAME, function () {
            return this._clipColor;
        });
    }
    UIElement.prototype = new RenderableObject();
    UIElement.prototype.constructor = UIElement;
    /**
     * Initializes the properties of this UI element.
     * @param {Model} model The model storing the vertices of the UI element, typically a simple square.
     * @param {ManagedShader} shader The shader to be used to render this element.
     * @param {Object.<String, ManagedTexture>} textures The textures organized by roles to be used.
     * @param {Number[2]|Number[3]} position The position of the element either on the screen (2D) or in world space (3D), depending on the
     * shader to be used.
     * @param {Number[2]} size The size of the element by which the model can be scaled.
     * @param {String} scaleMode (enum ScaleMode) The scale mode to be used for sizing this element.
     * @param {Number[4]} color A color to modulate the element with. (inside its clip zone)
     * @param {Number} [angle] An angle based on which a 2D rotation matrix will be created and stored that can be used to rotate the 
     * element in 2D.
     * @param {Numbe[4]} [clipCoordinates] The coordinates specifying the clip zone for this element, in the form of [minX, maxX, minY, 
     * maxY], where the area outside the min-max range on either the X or Y is considered to be outside the clip zone, and all coordinates 
     * go from -1 (left / bottom) to 1 (right / top), corresponding to a relative position within the element.
     * @param {Number[4]} [clipColor] A color to modulate the element with outside its clip zone.
     */
    UIElement.prototype.init = function (model, shader, textures, position, size, scaleMode, color, angle, clipCoordinates, clipColor) {
        RenderableObject.prototype.init.call(this, shader, false, true);
        this.setTextures(textures);
        this._model = model;
        this._position = position;
        this._color = color;
        this._size = size;
        this._scaleMode = _getScaleModeInt(scaleMode);
        mat.setRotation2(this._rotationMatrix, Math.radians(angle || 0));
        this._clipCoordinates = clipCoordinates || CLIP_COORDINATES_NO_CLIP.slice();
        this._clipColor = clipColor || [0, 0, 0, 0];
    };
    /**
     * @override
     * @param {ManagedGLContext} context
     */
    UIElement.prototype.addToContext = function (context) {
        RenderableObject.prototype.addToContext.call(this, context);
        this._model.addToContext(context, false);
    };
    /**
     * @override
     * Renders the UI element.
     * @param {RenderParameters} renderParameters
     */
    UIElement.prototype.performRender = function (renderParameters) {
        this._model.render(renderParameters.context);
    };
    /**
     * Sets a new position for this element.
     * @param {Number[2]|Number[3]} value
     */
    UIElement.prototype.setPosition = function (value) {
        this._position = value;
    };
    /**
     * Sets a new size to be used for scaling the element.
     * @param {Number[2]} value
     */
    UIElement.prototype.setSize = function (value) {
        this._size = value;
    };
    /**
     * Sets a new color for this element.
     * @param {Number[4]} value An RGBA color
     */
    UIElement.prototype.setColor = function (value) {
        this._color = value;
    };
    /**
     * Sets a new rotation matrix for this element based on the given rotation angle.
     * @param {Number} value The angle by which to rotate, in radians.
     */
    UIElement.prototype.setAngle = function (value) {
        mat.setRotation2(this._rotationMatrix, value);
    };
    /**
     * Sets a new set of clip coordinates ([minX, maxX, minY, maxY]) to define the clip zone of the element.
     * @param {Number[4]} value
     */
    UIElement.prototype.setClipCoordinates = function (value) {
        this._clipCoordinates = value;
    };
    /**
     * Sets new minimum and maximum X coordinates for the clip zone of the element.
     * @param {Number} minimum
     * @param {Number} maximum
     */
    UIElement.prototype.clipX = function (minimum, maximum) {
        this._clipCoordinates[0] = minimum;
        this._clipCoordinates[1] = maximum;
    };
    /**
     * Sets new minimum and maximum Y coordinates for the clip zone of the element.
     * @param {Number} minimum
     * @param {Number} maximum
     */
    UIElement.prototype.clipY = function (minimum, maximum) {
        this._clipCoordinates[2] = 1 - maximum;
        this._clipCoordinates[3] = 1 - minimum;
    };
    /**
     * Sets a new color to be used when rendering the parts of this element outside of its clip zone.
     * @param {Number[4]} value
     */
    UIElement.prototype.setClipColor = function (value) {
        this._clipColor = value;
    };
    /**
     * Sets a new model to be used for this UI element.
     * After adding this element to contexts, only use this with models that also have been added to them!
     * @param {Model} value
     */
    UIElement.prototype.setModel = function (value) {
        this._model = value;
    };
    /**
     * Sets a new scale mode for this UI element
     * @param {String} value (enum ScaleMode)
     */
    UIElement.prototype.setScaleMode = function (value) {
        this._scaleMode = _getScaleModeInt(value);
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        RenderQueueBits: RenderQueueBits,
        UNIFORM_COLOR_NAME: UNIFORM_COLOR_NAME,
        CLIP_COORDINATES_NO_CLIP: CLIP_COORDINATES_NO_CLIP,
        RenderableObject: RenderableObject,
        RenderableObject3D: RenderableObject3D,
        CubemapSampledFVQ: CubemapSampledFVQ,
        ShadedLODMesh: ShadedLODMesh,
        ParameterizedMesh: ParameterizedMesh,
        Billboard: Billboard,
        Trail: Trail,
        TrailSegment: TrailSegment,
        ParticleState: ParticleState,
        Particle: Particle,
        staticParticle: staticParticle,
        initDynamicParticle: initDynamicParticle,
        dynamicParticle: dynamicParticle,
        BackgroundBillboard: BackgroundBillboard,
        PointParticle: PointParticle,
        UIElement: UIElement
    };
});
/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file A general purpose WebGL scene engine building on the functionality of ManagedGL.
 * Create a Scene, add background and main scene objects and light sources, then add it to a ManagedGLContext (or several ones), and it can
 * be rendered on them.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Float32Array, Int32Array */

/**
 * @param utils Used for shallow copying
 * @param types Used for type checking.
 * @param vec Used for 3D vector operations.
 * @param mat Used for 3D (and 4D) matrix operations.
 * @param application Used for displaying errors and logging (and intentional crashing)
 * @param managedGL Used for handling managed framebuffers, creating uniform names, feature checking
 * @param egomModel Used for debug stats management
 * @param containers Used for linked lists
 * @param camera Used for creating default cameras for scenes
 * @param renderableObjects Used to create container nodes and for accessing render queue bits
 */
define('modules/scene/scene-graph',[
    "utils/utils",
    "utils/types",
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/managed-gl",
    "modules/egom-model",
    "modules/containers",
    "modules/scene/camera",
    "modules/scene/renderable-objects"
], function (utils, types, vec, mat, application, managedGL, egomModel, containers, camera, renderableObjects) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // constants
            /**
             * For new LOD contexts, this will be the default value for the reference size
             * @type Number
             */
            DEFAULT_LOD_REFERENCE_SIZE = 100,
            /**
             * For new LOD contexts, this wil be the default value for the minimum relative size
             * @type Number
             */
            DEFAULT_LOD_MINIMUM_RELATIVE_SIZE = 0.05,
            // the raw names of uniforms using which the various renderable object classes make their properties available to shaders
            // the actual shader uniform names are created by ManagedGL, using these names as a basis, and adding the appropriate prefixes/suffixes
            /**
             * When creating a shadow map framebuffer, this prefix will be added before the light index for which it is created.
             * @type String
             */
            SHADOW_MAP_BUFFER_NAME_PREFIX = "shadow-map-buffer-",
            /**
             * When creating a shadow map framebuffer, this infix will be added in between the indices of the light and the shadow map range
             * for which it is created.
             * @type String
             */
            SHADOW_MAP_BUFFER_NAME_INFIX = "-",
            /**
             * The number of available priorities with which new point light sources can be added. If set to e.g. 5, the available priorities
             * will be 0 to 4
             * @type Number
             */
            MAX_POINT_LIGHT_PRIORITIES = 5,
            // the names of uniforms that scenes provide values for (these names will be pre/suffixed by ManagedGL)
            /**
             * @type String
             */
            UNIFORM_AMBIENT_COLOR_NAME = "ambientColor",
            UNIFORM_NUM_DIRECTIONAL_LIGHTS_NAME = "numDirLights",
            UNIFORM_DIRECTIONAL_LIGHTS_ARRAY_NAME = "dirLights",
            UNIFORM_NUM_POINT_LIGHTS_NAME = "numPointLights",
            UNIFORM_POINT_LIGHTS_ARRAY_NAME = "pointLights",
            UNIFORM_NUM_SPOT_LIGHTS_NAME = "numSpotLights",
            UNIFORM_SPOT_LIGHTS_ARRAY_NAME = "spotLights",
            UNIFORM_VIEW_MATRIX_NAME = "cameraMatrix",
            UNIFORM_PROJECTION_MATRIX_NAME = "projMatrix",
            UNIFORM_VIEW_PROJECTION_MATRIX_NAME = "viewProjMatrix",
            UNIFORM_VIEW_ORIENTATION_MATRIX_NAME = "cameraOrientationMatrix",
            UNIFORM_VIEW_ASPECT_NAME = "aspect",
            UNIFORM_VIEWPORT_SIZE_NAME = "viewportSize",
            UNIFORM_EYE_POSITION_VECTOR_NAME = "eyePos",
            UNIFORM_SHADOW_MAPPING_NUM_RANGES_NAME = "numRanges",
            UNIFORM_SHADOW_MAPPING_RANGES_ARRAY_NAME = "shadowMapRanges",
            UNIFORM_SHADOW_MAPPING_DEPTH_RATIO_NAME = "shadowMapDepthRatio",
            UNIFORM_SHADOW_MAPPING_TEXTURE_SIZE_NAME = "shadowMapTextureSize",
            UNIFORM_SHADOW_MAPPING_SHADOW_MAPS_ARRAY_NAME = "shadowMaps",
            UNIFORM_SHADOW_MAPPING_SHADOW_MAP_SAMPLE_OFFSET_ARRAY_NAME = "shadowMapSampleOffsets",
            SHADOW_MAP_SAMPLE_OFFSETS = [
                0.0, 0.0,
                1.0, 0.0,
                0.0, 1.0,
                -1.0, 0.0,
                0.0, -1.0,
                1.0, 1.0,
                1.0, -1.0,
                -1.0, 1.0,
                -1.0, -1.0
            ],
            /**
             * The index of the array storing the front - opaque render queues in the main render queues array of scenes.
             * @type Number
             */
            FRONT_OPAQUE_RENDER_QUEUES_INDEX = 0,
            /**
             * The index of the array storing the front - transparent render queues in the main render queues array of scenes.
             * @type Number
             */
            FRONT_TRANSPARENT_RENDER_QUEUES_INDEX = 1,
            /**
             * The index of the array storing the distance - opaque render queues in the main render queues array of scenes.
             * @type Number
             */
            DISTANCE_OPAQUE_RENDER_QUEUES_INDEX = 2,
            /**
             * The index of the array storing the distance - transparent render queues in the main render queues array of scenes.
             * @type Number
             */
            DISTANCE_TRANSPARENT_RENDER_QUEUES_INDEX = 3,
            /**
             * A color mask to be set when all color components should be updated.
             * @type Number[4]
             */
            COLOR_MASK_ALL_TRUE = [true, true, true, true],
            /**
             * This name is used for the full viewport quad models created for render-to-texture effects / post-processing / etc
             * @type String
             */
            FVQ_NAME = "fvq",
            /**
             * This name is used for the framebuffers created for stereoscopic rendering (render-to-texture)
             * @type String
             */
            STEREOSCOPY_FRAMEBUFFER_NAME = "stereo",
            /**
             * Name for the uniform used to pass the texture unit for stereoscopic rendering
             * @type String
             */
            UNIFORM_STEREOSCOPY_TEXTURE_NAME = "stereo",
            /**
             * Name for the uniform used to pass the texture unit for shadow map debug rendering
             * @type String
             */
            UNIFORM_SHADOW_MAP_DEBUG_TEXTURE_NAME = "shadowMapDebug",
            /**
             * This string is available to other modules through a public function so that an arbitrary piece of information from this 
             * module can be exposed for debug purposes.
             * @type String
             */
            _debugInfo = "";
    // -------------------------------------------------------------------------
    // Public functions
    /**
     * Queries a module-level string for debug purposes.
     * @returns {String}
     */
    function getDebugInfo() {
        return _debugInfo;
    }
    // #########################################################################
    /**
     * @struct Holds a certain LOD configuration to be used for making LOD 
     * decisions while rendering.
     * @constructor
     * @param {Number} maxEnabledLOD The highest LOD that can be chosen while 
     * rendering.
     * @param {Number[]} thresholds The threshold size in pixels for each LOD.
     * For each object the highest LOD, for which its size exceeds the 
     * threshold, will be used.
     * @param {Boolean} compensateForObjectSize Whether a compensated object 
     * size should be taken into account for the LOD decision, taking objects
     * bigger than a reference size as smaller, and smallers ones as bigger.
     * This is used to make better LOD decisions for objects spanning a wide
     * range of sizes, but having more similar size details.
     * @param {Number} [referenceSize] The size that should be taken as is, when
     * compensation is enabled.
     * @param {Number} [minimumRelativeSize] If the relative size of a object 
     * inside a parent (compared to the size of the parent) is smaller than this
     * value, this value will be used instead to calculate the relative visible
     * size.
     * @returns {LODContext}
     */
    function LODContext(maxEnabledLOD, thresholds, compensateForObjectSize, referenceSize, minimumRelativeSize) {
        /**
         * The highest renderable LOD.
         * @type type Number
         */
        this.maxEnabledLOD = maxEnabledLOD;
        /**
         * The threshold for each LOD that a renderable object must exceed (in 
         * size) to be drawn with that LOD.
         * @type Number[]
         */
        this.thresholds = thresholds;
        /**
         * Whether a compensated object size should be taken into account for 
         * the LOD decision, taking objects bigger than a reference size as 
         * smaller, and smallers ones as bigger.
         * This is used to make better LOD decisions for objects spanning a wide
         * range of sizes, but having more similar size details.
         * @type Boolean
         */
        this.compensateForObjectSize = (compensateForObjectSize === true);
        /**
         * The size that should be taken as is, when compensation is enabled.
         * @type Number
         */
        this.referenceSize = referenceSize || DEFAULT_LOD_REFERENCE_SIZE;
        /**
         * If the relative size of a object inside a parent (compared to the 
         * size of the parent) is smaller than this value, this value will be 
         * used instead to calculate the relative visible size.
         * @type Number
         */
        this.minimumRelativeSize = minimumRelativeSize || DEFAULT_LOD_MINIMUM_RELATIVE_SIZE;
    }
    // #########################################################################
    /**
     * @constructor
     * @struct
     * @param {ManagedGLContext} context
     * @param {Boolean} depthMask
     * @param {Scene} scene
     * @param {RenderableObject} parent
     * @param {Camera} camera
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @param {LODContext} lodContext
     * @param {Number} dt
     * @param {Boolean} [useInstancing=false] 
     * @param {Number} [instanceQueueIndex]
     * @param {DirectionalLight} [light]
     * @returns {RenderParameters}
     */
    function RenderParameters(context, depthMask, scene, parent, camera, viewportWidth, viewportHeight, lodContext, dt, useInstancing, instanceQueueIndex, light) {
        /**
         * @type ManagedGLContext
         */
        this.context = context;
        /**
         * @type Boolean
         */
        this.depthMask = depthMask;
        /**
         * @type Scene
         */
        this.scene = scene;
        /**
         * @type RenderableObject
         */
        this.parent = parent;
        /**
         * @type Camera
         */
        this.camera = camera;
        /**
         * @type Number
         */
        this.viewportWidth = viewportWidth;
        /**
         * @type Number
         */
        this.viewportHeight = viewportHeight;
        /**
         * @type LODContext
         */
        this.lodContext = lodContext;
        /**
         * @type Number
         */
        this.dt = dt || 0;
        /**
         * @type Boolean
         */
        this.useInstancing = useInstancing || false;
        /**
         * @type Number
         */
        this.instanceQueueIndex = instanceQueueIndex;
        /**
         * @type DirectionalLight
         */
        this.light = light;
    }
    // #########################################################################
    /**
     * @class A node on the rendering tree, that can hold a renderable object as 
     * well as references to children nodes.
     * @constructor
     * @param {RenderableObject} renderableObject
     * @param {Boolean} [renderToShadowMap=true] If false, this node and its subnodes will never be rendered to shadow maps
     * @param {Boolean} [instancedSubnodes=false] If true, then when this node is added to render queues and it has enough subnodes for
     * instanced rendering, only its first subnode will be checked about which queues it should be added to, and all the subnodes will be 
     * added to the same queues together, without checking them for further subnodes. Use this on container nodes storing large amounts
     * of (leaf) subnodes that are suitable for instancing to improve performance.
     * @param {Number} [minimumCountForInstancing=0] If greater than zero, then when at least this amount of nodes of the same type are
     * added to the same render queue and instancing is available, they will be rendered using instancing.
     */
    function RenderableNode(renderableObject, renderToShadowMap, instancedSubnodes, minimumCountForInstancing) {
        /**
         * The object this node holds that can be rendered.
         * @type RenderableObject
         */
        this._renderableObject = renderableObject;
        renderableObject.setNode(this);
        /**
         * The scene this node is part of.
         * @type Scene
         */
        this._scene = null;
        /**
         * A reference to the parent node of this node.
         * @type RenderableNode
         */
        this._parent = null;
        /**
         * The list of subnodes (children) this node is connected to.
         * @type DirectDoubleLinkedList
         */
        this._subnodes = new containers.DirectDoubleLinkedList();
        /**
         * A flag to mark whether this node and its subnodes should be rendered.
         * @type Boolean
         */
        this._visible = true;
        /**
         * A variable to hold the rendering parameters passed to the held object
         * before each render, in order to avoid creating a new object to store
         * these at each render.
         * @type RenderParameters
         */
        this._renderParameters = new RenderParameters();
        /**
         * A list of camera configurations that are associated with this node.
         * @type CameraConfiguration[]
         */
        this._cameraConfigurations = [];
        /**
         * If false, this node and its subnodes are never rendered to shadow maps
         * @type Boolean
         */
        this._isRenderedToShadowMap = renderToShadowMap !== false;
        /**
         * Whether this node has subnodes of the same type, which are leaf nodes and are suitable for instancing, so can be added to the
         * same instanced queue.
         * @type Boolean
         */
        this._hasInstancedSubnodes = instancedSubnodes;
        /**
         * The minimum number of nodes of this same type that should be added to the same render queue to be rendered in instanced mode.
         * @type Number
         */
        this._minimumCountForInstancing = minimumCountForInstancing || 0;
        /**
         * A shortcut cache variable that is set to true once this node is set to be resuable or it is found reusable in a check, so that
         * later this can be determined in one step
         * @type Boolean
         */
        this._canBeReused = false;
        // direct linked list element properties
        this.next = null;
        this.previous = null;
        this.list = null;
    }
    /**
     * Returns whether this node can be reused to hold a different object.
     * @returns {Boolean}
     */
    RenderableNode.prototype.canBeReused = function () {
        var subnode;
        if (this._canBeReused) {
            return true;
        }
        if (this._renderableObject.canBeReused()) {
            for (subnode = this._subnodes.getFirst(); subnode; subnode = subnode.next) {
                if (subnode.canBeReused() === false) {
                    return false;
                }
            }
            this._canBeReused = true;
            return true;
        }
        return false;
    };
    /**
     * Returns the scene this node is part of.
     * @returns {Scene}
     */
    RenderableNode.prototype.getScene = function () {
        return this._scene;
    };
    /**
     * Sets up the node (and its subnodes) as part of the passed scene.
     * @param {Scene} scene
     * @param {Boolean} [addToContexts=false]
     */
    RenderableNode.prototype.setScene = function (scene, addToContexts) {
        var subnode;
        this._scene = scene;
        if (scene && addToContexts) {
            scene.addObjectToContexts(this._renderableObject);
        }
        for (subnode = this._subnodes.getFirst(); subnode; subnode = subnode.next) {
            subnode.setScene(scene, addToContexts);
        }
    };
    /**
     * Adds the node to the appropriate render queue out of the passed ones based on what shader does its object use.
     * Do not call from outside.
     * @param {RenderableNode[][]} renderQueues The render queues, each being an array of renderable nodes using the same shader.
     * @returns {Number}
     */
    RenderableNode.prototype.addToRenderQueue = function (renderQueues) {
        var i;
        if (this._minimumCountForInstancing === 0) {
            for (i = 0; i < renderQueues.length; i++) {
                if ((renderQueues[i].length > 0) &&
                        (renderQueues[i][0].getMinimumCountForInstancing() === 0) &&
                        (this._renderableObject.shouldGoInSameRenderQueue(renderQueues[i][0].getRenderableObject()))) {
                    renderQueues[i].push(this);
                    return i;
                }
            }
        } else {
            for (i = 0; i < renderQueues.length; i++) {
                if ((renderQueues[i].length > 0) &&
                        (renderQueues[i][0].getMinimumCountForInstancing() > 0) &&
                        (this._renderableObject.shouldGoInSameRenderQueueInstanced(renderQueues[i][0].getRenderableObject()))) {
                    renderQueues[i].push(this);
                    return i;
                }
            }
        }
        renderQueues.push([this]);
        return renderQueues.length - 1;
    };
    /**
     * Performs the animation of the object stored at this node if needed and adds this node to one of the passed render queues, to the one 
     * which has nodes using the same shader as this ones, so that rendering nodes in one queue will not require a shader change. Adds the 
     * subnodes to the queues as well, but does not add either itself or the subnodes if it is not set to visible as they do no need to be 
     * rendered.
     * @param {RenderableNode[][][]} renderQueues A two dimensional array of render queues. Meaning of indices: 
     * -1st: front / distance, transparent / opaque render queues
     * -2nd: queues storing nodes that should be rendered together
     * -3rd: the nodes to render
     * @param {Boolean} distanceRendering Whether distance rendering is enabled (if not, the node will be added to the front queues without
     * distance checks)
     * @param {Camera} camera The camera from the view point of which renderable nodes need to be organized to front and distant nodes
     * @param {Number} dt The elapsed time since the last render, for animation, in milliseconds
     * @param {queueBits} [parentQueueBits] The render queue bits of the parent node
     */
    RenderableNode.prototype.animateAndAddToRenderQueues = function (renderQueues, distanceRendering, camera, dt, parentQueueBits) {
        var queueBits, subnode, next, renderQueueIndex, transparent, opaque, object;
        if (!this._visible) {
            return;
        }
        if (this._renderableObject.resetForNewFrame) {
            this._renderableObject.resetForNewFrame();
        }
        if (this._scene.shouldAnimate()) {
            this._renderableObject.animate(dt);
        }
        if (this._renderableObject.canBeReused()) {
            return;
        }
        transparent = this._renderableObject.isRenderedWithoutDepthMask();
        opaque = this._renderableObject.isRenderedWithDepthMask();
        if (transparent || opaque) {
            if (distanceRendering) {
                queueBits = this._renderableObject.getRenderQueueBits(camera, parentQueueBits);
                if (queueBits & renderableObjects.RenderQueueBits.FRONT_QUEUE_BIT) {
                    if (transparent) {
                        this.addToRenderQueue(renderQueues[FRONT_TRANSPARENT_RENDER_QUEUES_INDEX]);
                    }
                    if (opaque) {
                        this.addToRenderQueue(renderQueues[FRONT_OPAQUE_RENDER_QUEUES_INDEX]);
                    }
                }
                if (queueBits & renderableObjects.RenderQueueBits.DISTANCE_QUEUE_BIT) {
                    if (transparent) {
                        this.addToRenderQueue(renderQueues[DISTANCE_TRANSPARENT_RENDER_QUEUES_INDEX]);
                    }
                    if (opaque) {
                        this.addToRenderQueue(renderQueues[DISTANCE_OPAQUE_RENDER_QUEUES_INDEX]);
                    }
                }
            } else {
                // if distance rendering is disabled, skip the check and add to the front queues
                if (transparent) {
                    this.addToRenderQueue(renderQueues[FRONT_TRANSPARENT_RENDER_QUEUES_INDEX]);
                }
                if (opaque) {
                    this.addToRenderQueue(renderQueues[FRONT_OPAQUE_RENDER_QUEUES_INDEX]);
                }
            }
        }
        if (this._subnodes.getLength() > 0) {
            // if children are inside the parent, they will take its render queue bits, so make sure they are calculated
            if (queueBits === undefined) {
                queueBits = distanceRendering ? this._renderableObject.getRenderQueueBits(camera, parentQueueBits) : renderableObjects.RenderQueueBits.FRONT_QUEUE_BIT;
            }
            if (!this._hasInstancedSubnodes || (this._subnodes.getLength() < this._subnodes.getFirst().getMinimumCountForInstancing())) {
                for (subnode = this._subnodes.getFirst(); subnode; subnode = next) {
                    next = subnode.next;
                    subnode.animateAndAddToRenderQueues(renderQueues, distanceRendering, camera, dt, queueBits);
                }
            } else {
                // if subnodes can be added to the same instanced queue, do the addition and animation directly and do not go into recursion further
                // as a result, we need to do the frame reset manually for them as well here
                if (this._scene.shouldAnimate()) {
                    for (subnode = this._subnodes.getFirst(); subnode; subnode = next) {
                        next = subnode.next;
                        object = subnode.getRenderableObject();
                        object.animate(dt);
                        if (object.resetForNewFrame) {
                            object.resetForNewFrame();
                        }
                    }
                } else {
                    for (subnode = this._subnodes.getFirst(); subnode; subnode = next) {
                        next = subnode.next;
                        object = subnode.getRenderableObject();
                        if (object.resetForNewFrame) {
                            object.resetForNewFrame();
                        }
                    }
                }
                subnode = this._subnodes.getFirst();
                // the animation might have removed all the subnodes
                if (subnode) {
                    transparent = subnode.getRenderableObject().isRenderedWithoutDepthMask();
                    opaque = subnode.getRenderableObject().isRenderedWithDepthMask();
                    if (transparent || opaque) {
                        queueBits = subnode.getRenderableObject().getRenderQueueBits(camera, queueBits);
                        if (queueBits & renderableObjects.RenderQueueBits.FRONT_QUEUE_BIT) {
                            if (transparent) {
                                renderQueueIndex = subnode.addToRenderQueue(renderQueues[FRONT_TRANSPARENT_RENDER_QUEUES_INDEX]);
                                renderQueues[FRONT_TRANSPARENT_RENDER_QUEUES_INDEX][renderQueueIndex].pop();
                                this._subnodes.appendToArray(renderQueues[FRONT_TRANSPARENT_RENDER_QUEUES_INDEX][renderQueueIndex]);
                            }
                            if (opaque) {
                                renderQueueIndex = subnode.addToRenderQueue(renderQueues[FRONT_OPAQUE_RENDER_QUEUES_INDEX]);
                                renderQueues[FRONT_OPAQUE_RENDER_QUEUES_INDEX][renderQueueIndex].pop();
                                this._subnodes.appendToArray(renderQueues[FRONT_OPAQUE_RENDER_QUEUES_INDEX][renderQueueIndex]);
                            }
                        }
                        if (queueBits & renderableObjects.RenderQueueBits.DISTANCE_QUEUE_BIT) {
                            if (transparent) {
                                renderQueueIndex = subnode.addToRenderQueue(renderQueues[DISTANCE_TRANSPARENT_RENDER_QUEUES_INDEX]);
                                renderQueues[DISTANCE_TRANSPARENT_RENDER_QUEUES_INDEX][renderQueueIndex].pop();
                                this._subnodes.appendToArray(renderQueues[DISTANCE_TRANSPARENT_RENDER_QUEUES_INDEX][renderQueueIndex]);
                            }
                            if (opaque) {
                                renderQueueIndex = subnode.addToRenderQueue(renderQueues[DISTANCE_OPAQUE_RENDER_QUEUES_INDEX]);
                                renderQueues[DISTANCE_OPAQUE_RENDER_QUEUES_INDEX][renderQueueIndex].pop();
                                this._subnodes.appendToArray(renderQueues[DISTANCE_OPAQUE_RENDER_QUEUES_INDEX][renderQueueIndex]);
                            }
                        }
                    }
                }
            }
        }
    };
    /**
     * Sets up the node to have a new parent.
     * @param {RenderableNode} parent
     */
    RenderableNode.prototype.setParent = function (parent) {
        this._parent = parent;
        this.setScene(parent.getScene());
        if (this._renderableObject.setParent) {
            this._renderableObject.setParent(parent.getRenderableObject());
        }
    };
    /**
     * Returns the renderable object held by this node.
     * @returns {RenderableObject}
     */
    RenderableNode.prototype.getRenderableObject = function () {
        return this._renderableObject;
    };
    /**
     * Returns whether the node (and its subnodes) are set to be rendered.
     * @returns {Boolean}
     */
    RenderableNode.prototype.isVisible = function () {
        return this._visible && (!this._parent || this._parent.isVisible());
    };
    /**
     * Sets the node (and its visible subnodes) to be rendered from now on.
     */
    RenderableNode.prototype.show = function () {
        this._visible = true;
    };
    /**
     * Sets the node and its subnodes not to be rendered from now on.
     */
    RenderableNode.prototype.hide = function () {
        this._visible = false;
    };
    /**
     * Switches the visibility of the node to the opposite.
     */
    RenderableNode.prototype.toggleVisibility = function () {
        this._visible = !this._visible;
    };
    /**
     * Adds a subnode to this node.
     * @param {RenderableNode} subnode The subnode to be added to the rendering tree. 
     * It will be rendered relative to this object (transformation matrices stack)
     * @param {Boolean} [addToContexts=false]
     * @returns {RenderableNode} The added subnode, for convenience
     */
    RenderableNode.prototype.addSubnode = function (subnode, addToContexts) {
        this._subnodes.add(subnode);
        subnode.setParent(this);
        if (this._scene) {
            subnode.setScene(this._scene, addToContexts);
        }
        return subnode;
    };
    /**
     * Returns the array of subnodes this node has.
     * @returns {RenderableNode[]}
     */
    RenderableNode.prototype.getSubnodes = function () {
        return this._subnodes;
    };
    /**
     * Return the first subnode of this node.
     * @returns {RenderableNode}
     */
    RenderableNode.prototype.getFirstSubnode = function () {
        return this._subnodes.getFirst();
    };
    /**
     * Returns the node coming after the specified node among the subnodes of this node. If the given node is not among the subnodes,
     * returns the first subnode.
     * @param {RenderableNode} currentNode
     * @returns {RenderableNode}
     */
    RenderableNode.prototype.getNextSubnode = function (currentNode) {
        return this._subnodes.getNext(currentNode);
    };
    /**
     * Returns the node coming before the specified node among the subnodes of this node. If the given node is not among the subnodes,
     * returns the last subnode.
     * @param {RenderableNode} currentNode
     * @returns {RenderableNode}
     */
    RenderableNode.prototype.getPreviousSubnode = function (currentNode) {
        return this._subnodes.getPrevious(currentNode);
    };
    /**
     * Adds a new associated camera configuration to this node.
     * @param {CameraConfiguration} cameraConfiguration
     */
    RenderableNode.prototype.addCameraConfiguration = function (cameraConfiguration) {
        this._cameraConfigurations.push(cameraConfiguration);
    };
    /**
     * Returns whether the given camera configuration is among the ones associated with this node.
     * @param {CameraConfiguration} cameraConfiguration
     * @returns {Boolean}
     */
    RenderableNode.prototype.hasCameraConfiguration = function (cameraConfiguration) {
        var i;
        for (i = 0; i < this._cameraConfigurations.length; i++) {
            if (this._cameraConfigurations[i] === cameraConfiguration) {
                return true;
            }
        }
        return false;
    };
    /**
     * Returns the camera configuration the comes after the one passed as parameter in the list of associated camera configurations.
     * If the last configuration is passed, returns the first one. Returns the first configuration if called with a null parameter, and
     * crashes if the given configuration is not in the list.
     * Excludes camera configurations that return true to shouldExcludeFromCycle()
     * @param {CameraConfiguration} currentCameraConfiguration
     * @returns {CameraConfiguration}
     */
    RenderableNode.prototype.getNextCameraConfiguration = function (currentCameraConfiguration) {
        var i, currentIndex, length = this._cameraConfigurations.length;
        if (length <= 0) {
            return null;
        }
        if (!currentCameraConfiguration) {
            currentIndex = -1;
        } else {
            for (i = 0; i < length; i++) {
                if (this._cameraConfigurations[i] === currentCameraConfiguration) {
                    currentIndex = i;
                    break;
                }
            }
            if (i >= length) {
                application.crash(); // the current configuration was not in the list
                return;
            }
        }
        i = (currentIndex + 1) % length;
        while ((i !== currentIndex) && this._cameraConfigurations[i].shouldExcludeFromCycle()) {
            i = (i + 1) % length;
        }
        return this._cameraConfigurations[i];
    };
    /**
     * Returns the camera configuration the comes before the one passed as parameter in the list of associated camera configurations.
     * If the first configuration is passed, returns the last one. Returns the last configuration if called with a null parameter, and
     * crashes if the given configuration is not in the list.
     * Excludes camera configurations that return true to shouldExcludeFromCycle()
     * @param {CameraConfiguration} [currentCameraConfiguration]
     * @returns {CameraConfiguration}
     */
    RenderableNode.prototype.getPreviousCameraConfiguration = function (currentCameraConfiguration) {
        var i, currentIndex, length = this._cameraConfigurations.length;
        if (length <= 0) {
            return null;
        }
        if (!currentCameraConfiguration) {
            currentIndex = length;
        } else {
            for (i = (length - 1); i >= 0; i--) {
                if (this._cameraConfigurations[i] === currentCameraConfiguration) {
                    currentIndex = i;
                    break;
                }
            }
            if (i < 0) {
                application.crash(); // the current configuration was not in the list
                return;
            }
        }
        i = (currentIndex + length - 1) % length;
        while ((i !== currentIndex) && this._cameraConfigurations[i].shouldExcludeFromCycle()) {
            i = (i + length - 1) % length;
        }
        return this._cameraConfigurations[i];
    };
    /**
     * Returns a list of the associated camera configurations that have the specified name.
     * @param {String} name
     * @returns {CameraConfiguration[]}
     */
    RenderableNode.prototype.getCameraConfigurationsWithName = function (name) {
        var result = [], i;
        for (i = 0; i < this._cameraConfigurations.length; i++) {
            if (this._cameraConfigurations[i].getName() === name) {
                result.push(this._cameraConfigurations[i]);
            }
        }
        return result;
    };
    /**
     * Resets the default settings of all the associated camera configurations.
     */
    RenderableNode.prototype.resetCameraConfigurations = function () {
        var i;
        for (i = 0; i < this._cameraConfigurations.length; i++) {
            this._cameraConfigurations[i].resetToDefaults();
        }
    };
    /**
     * Logs the information about this node (used for logging scene graph structure)
     * @param {Number} level How deep is this node located within its scene graph.
     */
    RenderableNode.prototype.log = function (level) {
        var i, subnode, msg = "", typeName = this._renderableObject.constructor.name;
        for (i = 0; i < level; i++) {
            msg += ". ";
        }
        msg += typeName;
        application.log_DEBUG(msg);
        this._scene.increaseCount(typeName);
        for (subnode = this._subnodes.getFirst(); subnode; subnode = subnode.next) {
            subnode.log(level + 1);
        }
    };
    /**
     * Sets up the stored render parameters that are passed to the held renderable object for the next rendering.
     * @param {ManagedGLContext} context
     * @param {Number} screenWidth
     * @param {Number} screenHeight
     * @param {Boolean} depthMask
     * @param {Boolean} [useInstancing=false] 
     * @param {Number} [instanceQueueIndex]
     * @param {DirectionalLight} [light]
     */
    RenderableNode.prototype.setRenderParameters = function (context, screenWidth, screenHeight, depthMask, useInstancing, instanceQueueIndex, light) {
        var rp = this._renderParameters;
        rp.context = context;
        rp.depthMask = depthMask;
        rp.scene = this._scene;
        rp.parent = this._parent ? this._parent.getRenderableObject() : null;
        rp.camera = this._scene.getCamera();
        rp.viewportWidth = screenWidth;
        rp.viewportHeight = screenHeight;
        rp.lodContext = this._scene.getLODContext();
        rp.useInstancing = useInstancing;
        rp.instanceQueueIndex = instanceQueueIndex;
        rp.light = light;
    };
    /**
     * Renders the object at this node and all subnodes, if visible.
     * @param {ManagedGLContext} context
     * @param {Number} screenWidth
     * @param {Number} screenHeight
     * @param {Boolean} depthMask
     * @param {Boolean} [withoutSubnodes=false] If true, subnodes will not be rendered.
     * @param {Boolean} [useInstancing=false] If true, the node will not be rendered, just its data will be added to the corresponding 
     * instance attribute buffers.
     * @param {Number} [instanceQueueIndex] This index identifies the instance queue so that instance attribute buffer data for different
     * queues using the same shader do not mix
     * @param {Boolean} [noReset=false] If true, resetForNewFrame() will not be called on the node and its subnodes (used when the nodes are added to render
     * queues, as in that case the reset is already called there)
     * @returns {Boolean} Whether the node was rendered.
     */
    RenderableNode.prototype.render = function (context, screenWidth, screenHeight, depthMask, withoutSubnodes, useInstancing, instanceQueueIndex, noReset) {
        var subnode, result;
        // the visible property determines visibility of all subnodes as well
        if (this._visible) {
            if (!noReset && this._renderableObject.resetForNewFrame) {
                this._renderableObject.resetForNewFrame();
            }
            if (this._renderableObject.mightBeRendered()) {
                this.setRenderParameters(context, screenWidth, screenHeight, depthMask, useInstancing, instanceQueueIndex);
                result = this._renderableObject.render(this._renderParameters);
            } else {
                result = false;
            }
            if (!withoutSubnodes) {
                for (subnode = this._subnodes.getFirst(); subnode; subnode = subnode.next) {
                    subnode.render(context, screenWidth, screenHeight, depthMask, withoutSubnodes, useInstancing, instanceQueueIndex, noReset);
                }
            }
            return result;
        }
        return false;
    };
    /**
     * Call this on the first node of an instance render queue comprised of nodes that should be rendered together as instances. Sets up
     * the instance buffers so that the nodes in the queue can add their own data to it before rendering.
     * @param {ManagedGLContext} context
     * @param {Number} instanceQueueIndex This identifies the instance queue so if multiple queues use the same shader, their instance
     * attribute data will not mix
     * @param {Number} instanceCount The number of instances in this queue
     */
    RenderableNode.prototype.prepareForInstancedRender = function (context, instanceQueueIndex, instanceCount) {
        this._renderableObject.prepareForInstancedRender(context, this._scene, instanceQueueIndex, instanceCount);
    };
    /**
     * Call this on any of the nodes of an instance queue after all of them have been set up to render them all.
     * @param {ManagedGLContex} context
     * @param {Number} instanceQueueIndex
     * @param {Number} instanceCount
     */
    RenderableNode.prototype.renderInstances = function (context, instanceQueueIndex, instanceCount) {
        this._renderableObject.renderInstances(context, instanceQueueIndex, instanceCount);
    };
    /**
     * Renders the object at this node and all subnodes to the shadow map, if it is visible.
     * @param {ManagedGLContext} context
     * @param {Number} screenWidth
     * @param {Number} screenHeight
     * @param {DirectionalLight} [light]
     * @returns {Boolean}
     */
    RenderableNode.prototype.renderToShadowMap = function (context, screenWidth, screenHeight, light) {
        var subnode, result;
        // the visible property determines visibility of all subnodes as well
        if (this._visible && this._isRenderedToShadowMap) {
            if (this._renderableObject.mightBeRenderedToShadowMap()) {
                this.setRenderParameters(context, screenWidth, screenHeight, true, undefined, undefined, light);
                result = this._renderableObject.renderToShadowMap(this._renderParameters);
            } else {
                result = false;
            }
            // recursive rendering of all subnodes
            for (subnode = this._subnodes.getFirst(); subnode; subnode = subnode.next) {
                subnode.renderToShadowMap(context, screenWidth, screenHeight, light);
            }
            return result;
        }
        return false;
    };
    /**
     * Executes the given callback function passing the held renderable object as a parameter to it and recursively calls for the execution 
     * for all the subnodes.
     * @param {Function} callback
     */
    RenderableNode.prototype.execute = function (callback) {
        var subnode;
        callback(this._renderableObject);
        for (subnode = this._subnodes.getFirst(); subnode; subnode = subnode.next) {
            subnode.execute(callback);
        }
    };
    /**
     * Adds and sets up all resources needed to render the held object and all
     * subnodes to the given context.
     * @param {ManagedGLContext} context
     */
    RenderableNode.prototype.addToContext = function (context) {
        var subnode;
        this._renderableObject.addToContext(context);
        for (subnode = this._subnodes.getFirst(); subnode; subnode = subnode.next) {
            subnode.addToContext(context);
        }
    };
    /**
     * Returns the managed shader that the renderable object stored at this node uses.
     * @returns {unresolved}
     */
    RenderableNode.prototype.getShader = function () {
        return this._renderableObject.getShader();
    };
    /**
     * Sets the shader to use for the held object and for all subnodes.
     * @param {ManagedShader} shader
     */
    RenderableNode.prototype.setShader = function (shader) {
        var subnode;
        this._renderableObject.setShader(shader);
        for (subnode = this._subnodes.getFirst(); subnode; subnode = subnode.next) {
            subnode.setShader(shader);
        }
    };
    /**
     * Marks the node and all its subnodes (and their renderable objects) as reusable.
     * @param {Boolean} removeFromParent If true, the node is also removed from its parent (if it has one)
     */
    RenderableNode.prototype.markAsReusable = function (removeFromParent) {
        var subnode, next;
        this._renderableObject.markAsReusable(removeFromParent);
        // need to mark all subnodes as reusable in case they hold pooled objects
        for (subnode = this._subnodes.getFirst(); subnode; subnode = next) {
            next = subnode.next;
            subnode.markAsReusable(removeFromParent);
        }
        this._canBeReused = true;
        if (removeFromParent && this._parent) {
            this._parent.removeSubnode(this, true);
        }
    };
    /**
     * Gets called when the contained renderable object is marked reusable.
     * @param {Boolean} removeFromParent If true, the node is removed from its parent (if it has one)
     */
    RenderableNode.prototype.handleObjectBecameReusable = function (removeFromParent) {
        if (removeFromParent && this._parent && (this._subnodes.getLength() === 0)) {
            this._parent.removeSubnode(this, true);
        }
    };
    /**
     * Removes all subnodes from the subtree of this object that are deleted or
     * are marked for deletion.
     */
    RenderableNode.prototype.cleanUp = function () {
        var subnode, next;
        subnode = this._subnodes.getFirst();
        while (subnode) {
            next = subnode.next;
            if (subnode.canBeReused()) {
                this._subnodes.remove(subnode);
            }
            subnode = next;
        }
        for (subnode = this._subnodes.getFirst(); subnode; subnode = subnode.next) {
            subnode.cleanUp();
        }
    };
    /**
     * Returns the minimum number of nodes that should be in the same render queue to enable instanced rendering for that queue.
     * @returns {Number}
     */
    RenderableNode.prototype.getMinimumCountForInstancing = function () {
        return this._minimumCountForInstancing;
    };
    /**
     * Remove the given subnode from this node.
     * @param {RenderableNode} subnode 
     * @param {Boolean} removeFromParent If true, the node is removed from its parent in case no subnodes are left under it and it has no
     * non-reusable renderable object itself.
     */
    RenderableNode.prototype.removeSubnode = function (subnode, removeFromParent) {
        this._subnodes.remove(subnode);
        if (removeFromParent && (this._subnodes.getLength() === 0) && this._renderableObject.canBeReused()) {
            if (this._parent) {
                this._parent.removeSubnode(this, true);
            }
        }
    };
    /**
     * Removes all subnodes from this node.
     * @param {Boolean} [hard=false] If true, also removes the reference to the subnode list stored in the subnodes.
     */
    RenderableNode.prototype.removeSubnodes = function (hard) {
        this._subnodes.clear(hard);
    };
    /**
     * Removes all references stored by this object. Recursively destroys all subnodes.
     */
    RenderableNode.prototype.destroy = function () {
        var subnode, next;
        this._renderableObject.setNode(null);
        this._renderableObject = null;
        this._scene = null;
        this._parent = null;
        if (this._subnodes) {
            for (subnode = this._subnodes.getFirst(); subnode; subnode = next) {
                next = subnode.next;
                subnode.destroy();
                subnode = null;
            }
            this._subnodes = null;
        }
        this._renderParameters = null;
        this._cameraConfigurations = null;
        this.next = null;
        this.previous = null;
        this.list = null;
    };
    // #########################################################################
    /**
     * @typedef Scene~CameraSettings
     * @property {Boolean} [useVerticalValues]
     * @property {Number} viewDistance
     * @property {CameraConfiguration} [configuration]
     * @property {Boolean} [fps]
     * @property {Float32Array} [positionMatrix]
     * @property {Float32Array} [orientationMatrix]
     * @property {Number} [fov]
     * @property {Number[2]} [fovRange]
     * @property {Number} [span]
     * @property {Number} [transitionDuration]
     * @property {String} [transitionStyle] (enum Camera.TransitionStyle)
     */
    /**
     * @class An object to hold a hierarchic scene graph and webGL configuration for rendering.
     * @param {Number} left The relative X position of the bottom left corner of the viewport on the canvas in 0-1 range.
     * @param {Number} bottom The relative Y position of the bottom left corner of the viewport on the canvas in 0-1 range.
     * @param {Number} width The width of the viewport relative to the canvas.
     * @param {Number} height The height of the viewport relative to the canvas.
     * @param {Boolean} clearColorOnRender Whether to clear the color buffer every time at the beginning of rendering the scene.
     * @param {Boolean[4]} clearColorMask Which components shall be cleared if the color buffer is to be cleared.
     * @param {Number[4]} clearColor What color to use when clearing the buffer (RGBA components).
     * @param {Boolean} clearDepthOnRender Whether to clear the depth buffer every time at the beginning of rendering the scene.
     * @param {LODContext} lodContext The LOD threshold and configuration to be used
     * for rendering object with the appropriate level of detail.
     * @param {Number} maxRenderedDirectionalLights The maximum number of directional lights that should be considered when rendering this scene.
     * @param {Number} maxRenderedPointLights The maximum number of point lights that should be considered when rendering this scene.
     * @param {Number} maxRenderedSpotLights The maximum number of spot lights that should be considered when rendering this scene.
     * @param {Scene~CameraSettings} cameraSettings The properties based on which the camera for this scene will be set up.
     * @param {Boolean} [distanceRendering=true] Whether distance rendering should be turned on for this scene. Distance rendering renders far away 
     * objects with a second camera, thus increasing view range, but causes computational overhead even if all objects are near.
     */
    function Scene(left, bottom, width, height, clearColorOnRender, clearColorMask, clearColor, clearDepthOnRender, lodContext, maxRenderedDirectionalLights, maxRenderedPointLights, maxRenderedSpotLights, cameraSettings, distanceRendering) {
        /**
         * The relative X coordinate of the bottom left corner of the viewport on the canvas in 0-1 range.
         * @type Number
         */
        this._left = left;
        /**
         * The relative Y coordinate of the bottom left corner of the viewport on the canvas in 0-1 range.
         * @type Number
         */
        this._bottom = bottom;
        /**
         * The width of the viewport relative to the canvas.
         * @type Number
         */
        this._width = width;
        /**
         * The height of the viewport relative to the canvas.
         * @type Number
         */
        this._height = height;
        /**
         * Whether to clear the color buffer every time at the beginning of rendering the scene.
         * @type Boolean
         */
        this._shouldClearColorOnRender = clearColorOnRender;
        /**
         * Which components shall be cleared if the color buffer is to be cleared.
         * @type Boolean[4]
         */
        this._clearColorMask = clearColorMask;
        /**
         * What color to use when clearing the buffer (RGBA components).
         * @type Number[4]
         */
        this._clearColor = clearColor;
        /**
         * Whether to clear the depth buffer every time at the beginning of rendering the scene.
         * @type Boolean
         */
        this._shouldClearDepthOnRender = clearDepthOnRender;
        /**
         * The root node for the node tree storing the background objects. (rendered behind the main objects, without depth check)
         * @type RenderableNode
         */
        this._rootBackgroundNode = null;
        /**
         * The root node for the node tree storing the main scene objects.
         * @type RenderableNode
         */
        this._rootNode = null;
        /**
         * The root node for the node tree storing the UI objects (rendered on top of the background and main objects without depth check)
         * @type RenderableNode
         */
        this._rootUINode = null;
        /**
         * An array for any special objects that need to be moved when the scene is moved to follow the camera (with a translatev() method)
         * @type Object[]
         */
        this._objectsToMove = null;
        /**
         * The color of ambient light in the scene
         * @type Number[3]
         */
        this._ambientColor = [0, 0, 0];
        /**
         * The list of directional light sources that are available to all objects in the scene.
         * @type DirectionalLightSource[]
         */
        this._directionalLights = [];
        /**
         * The maximum number of directional light sources that should be considered when rendering this scene.
         * @type Number
         */
        this._maxRenderedDirectionalLights = maxRenderedDirectionalLights || 0;
        /**
         * The number of directional lights to be rendered for the current frame
         * @type Number
         */
        this._renderedDirectionalLights = 0;
        /**
         * This array stores the (calculated) data about the directional lights that is in the right format to be sent to the shaders as uniforms.
         * @type SceneGraph~DirectionalLightUniformData[]
         */
        this._directionalLightUniformData = new Array(this._maxRenderedDirectionalLights);
        /**
         * The lists of point light sources that are available to all objects in the scene, ordered by the priorities of the light sources.
         * The first list contains the light sources with the highest priority. If the amount of light sources that can be rendered is 
         * smaller than the stored light sources, the ones with higher priority will be chosen for rendering.
         * @type PointLightSource[][]
         */
        this._pointLightPriorityArrays = null;
        /**
         * The maximum number of point light sources that should be considered when rendering this scene.
         * @type Number
         */
        this._maxRenderedPointLights = maxRenderedPointLights || 0;
        /**
         * The number of point lights to be rendered for the current frame
         * @type Number
         */
        this._renderedPointLights = 0;
        /**
         * This array stores the (calculated) data about the point lights that is in the right format to be sent to the shaders as uniforms.
         * @type SceneGraph~PointLightUniformData[]
         */
        this._pointLightUniformData = new Array(this._maxRenderedPointLights);
        /**
         * The list of spot light sources that are available to all objects in the scene.
         * @type SpotLightSource[]
         */
        this._spotLights = [];
        /**
         * The maximum number of spot light sources that should be considered when rendering this scene.
         * @type Number
         */
        this._maxRenderedSpotLights = maxRenderedSpotLights || 0;
        /**
         * The number of spot lights to be rendered for the current frame
         * @type Number
         */
        this._renderedSpotLights = 0;
        /**
         * This array stores the (calculated) data about the spot lights that is in the right format to be sent to the shaders as uniforms.
         * @type SceneGraph~SpotLightUniformData[]
         */
        this._spotLightUniformData = new Array(this._maxRenderedSpotLights);
        /**
         * The root node for the node tree that contains the objects which are not part of the scene right when it is added to a context,
         * but will be added later, so their resources also need to be added to the context.
         * @type RenderableNode
         */
        this._rootResourceNode = null;
        /**
         * Stores the IDs with which resource nodes were added to this scene, so that attempting to add another object with the same ID
         * will not add another node, and thus duplicates can be avoided
         * @type Object.<String, String>
         */
        this._resourceObjectIDs = null;
        /**
         * The camera used for rendering this scene.
         * @type Camera
         */
        this._camera = new camera.Camera(
                this,
                this._width / this._height,
                cameraSettings.useVerticalValues,
                cameraSettings.viewDistance,
                cameraSettings.configuration || camera.getFreeCameraConfiguration(
                        cameraSettings.fps,
                        cameraSettings.positionMatrix || mat.IDENTITY4,
                        cameraSettings.orientationMatrix || mat.IDENTITY4,
                        cameraSettings.fov,
                        (cameraSettings.fovRange && cameraSettings.fovRange[0]) || cameraSettings.fov,
                        (cameraSettings.fovRange && cameraSettings.fovRange[1]) || cameraSettings.fov,
                        cameraSettings.span),
                cameraSettings.transitionDuration,
                cameraSettings.transitionStyle);
        /**
         * The context that stores the LOD settings for rendering models in this scene with multiple LOD meshes.
         * @type LODContext
         */
        this._lodContext = lodContext;
        /**
         * Whether shadow maps should be rendered and used when rendering this scene.
         * @type Boolean
         */
        this._shadowMappingEnabled = false;
        /**
         * A reference to the shader that is to be used for rendering shadow maps.
         * @type ManagedShader
         */
        this._shadowMappingShader = null;
        /**
         * The size (width and height in texels) of the framebuffer textures to which the shadow maps should be rendered.
         * @type Number
         */
        this._shadowMapTextureSize = 0;
        /**
         * The array of sizes (width and height) of the shadow maps in world-coordinates. For each light source, one shadow map is rendered
         * for each range in this array.
         * @type Float32Array
         */
        this._shadowMapRanges = new Float32Array([]);
        /**
         * The factor that determines the depth of the shadow maps in world coordinates. The depth is calculated by multiplying the shadow
         * map size (width and height) by this factor. For depth, a smaller accuracy is enough (to avoid shadow lines on surfaces which the
         * light hits at a sharp angle), therefore the shadow map can cover more area on this axis, resulting in farther objects casting
         * shadows (or the same objects casting shadows with a finer quality)
         * @type Number
         */
        this._shadowMapDepthRatio = 0;
        /**
         * @type Number
         */
        this._numShadowMapSamples = 0;
        /**
         * When sampling a shadow map for PCF, the samples will be taken from coordinates offset from the center by these vectors.
         * @type Number[][]
         */
        this._shadowMapSampleOffsets = [];
        /**
         * The functions that can be used to set the values of non-camera-related (e.g. light) uniform variables (which need to be
         * updated once every frame) in shaders when rendering this scene. When rendering any object in this scene with a shader 
         * that has a uniform with one of the names this object has a function for, its values will be calculated with the function 
         * and passed to the shader.
         * @type Object.<String, Function>
         */
        this._uniformValueFunctions = {};
        /**
         * Same as _uniformValueFunctions, but for camera-related uniforms (which might need to be updated several times during one 
         * frame - for extended camera / stereographic rendering)
         * @type Object.<String, Function>
         */
        this._cameraUniformValueFunctions = {};
        /**
         * Same as _uniformValueFunctions, but for uniforms that only need to be updated when a context is set up. (e.g. shadow mapping
         * settings)
         * @type Object.<String, Function>
         */
        this._constantUniformValueFunctions = {};
        /**
         * The uniform value functions to be used for the shaders rendering the full viewport quads containing rendered stereoscopic images
         * of this scene.
         * @type Object.<String, Function>
         */
        this._stereoscopicUniformValueFunctions = {};
        /**
         * The index of the texture unit where the framebuffer texture used for rendering the stereoscopic images of this scene was 
         * last bound.
         * @type Number
         */
        this._stereoscopicTextureUnit = 0;
        // setting up the uniform value function for stereoscopic rendering (to pass the bound framebuffer)
        this._stereoscopicUniformValueFunctions[managedGL.getUniformName(managedGL.getTextureUniformRawName(UNIFORM_STEREOSCOPY_TEXTURE_NAME))] = function () {
            return this._stereoscopicTextureUnit;
        }.bind(this);
        /**
         * The uniform value functions to be used for the shader rendering the shadow map for debugging
         * @type Object.<String, Function>
         */
        this._shadowMapDebugUniformValueFunctions = {};
        /**
         * The index of the texture unit where the framebuffer texture used for rendering the shadow map for debugging was last bound.
         * @type Number
         */
        this._shadowMapTextureUnit = 0;
        // setting up the uniform value function for shadow map debug rendering (to pass the bound framebuffer)
        this._shadowMapDebugUniformValueFunctions[managedGL.getUniformName(UNIFORM_SHADOW_MAP_DEBUG_TEXTURE_NAME)] = function () {
            return this._shadowMapTextureUnit;
        }.bind(this);
        /**
         * This array that stores those uniform value function bindings that are not the same across all contexts the scene has been added to.
         * In each element of the array, the bindings corresponding to the context with the same index are stored. For example, the function
         * with the key "uniformName" in the object at index 2 will return the value for the uniform named "uniformName" for shaders when
         * rendering on the third context this scene has been added to.
         * @type Array.<Object.<String, Function>>
         */
        this._contextUniformValueFunctions = [];
        /**
         * Same as _contextUniformValueFunctions, but for uniforms that only need to be updated when a context is set up. (e.g. shadow mapping
         * settings)
         * @type Array.<Object.<String, Function>>
         */
        this._contextConstantUniformValueFunctions = [];
        /**
         * Whether light sources and objects in the scene should be animated when rendering based on the elapsed time since the last render.
         * @type Boolean
         */
        this._shouldAnimate = true;
        /**
         * Whether the camera state (position, orientation, FOV etc) should be updated when rendering based on the elapsed time since the 
         * last render. (e.g. if the camera is moving or transitioning, that should be progressed)
         * @type Boolean
         */
        this._shouldUpdateCamera = true;
        /**
         * The array of managed contexts to which this scene has been added. The scene needs to be added to a managed context before it can
         * be rendered to it, so that it sets up the vertex buffers and framebuffers of the context to contain the vertices and shadow map 
         * buffers required to render this scene.
         * @type ManagedGLContext[]
         */
        this._contexts = [];
        /**
         * Whether distance is turned on for this scene. Distance rendering renders far away objects with a second camera, thus increasing 
         * view range, but causes computational overhead even if all objects are near.
         * @type Boolean
         */
        this._distanceRendering = (distanceRendering !== undefined) ? distanceRendering : true;
        /**
         * The array of arrays of render queues, with each queue being an array of nodes in the scene that need to be rendered and use the same 
         * shader. This way, rendering all the queues after each other requires the minimum amount of shader switches and thus scene
         * uniform (such as light source) assignments.
         * This top level array contains four elements corresponding to the four categories of render queues depending on whether they are
         * front or distance queues and transparent or opaque queues.
         * @type RenderableNode[][][]
         */
        this._renderQueues = this._distanceRendering ? [[], [], [], []] : [[], []];
        /**
         * The array of renderable nodes to be rendered to the next shadow map.
         * @type RenderableNode[]
         */
        this._shadowQueue = null;
        /**
         * A flag storing whether the scene uniforms have already been assigned at least once during the current frame. If the whole scene
         * is rendered using just one shader, there are no shader switches and thus no automatic scene uniform assignments, so this flag
         * is used to make sure that uniform values get updated for each frame even in this case.
         * @type Boolean
         */
        this._uniformsUpdatedForFrame = false;
        /**
         * The set containing the shaders for which the values of the non-camera related (e.g. light) scene uniforms (which 
         * need to be updated once every frame) have been updated for the current frame.
         * This is used to avoid updating the scene uniforms for the same shader multiple times during one frame.
         * @type Set
         */
        this._uniformsUpdated = new Set();
        /**
         * Similar to _uniformsUpdated, but marks updates for camera-related uniforms, which might need to be updated multiple times during
         * a frame - for extended camera / stereographic rendering.
         * @type Set
         */
        this._cameraUniformsUpdated = new Set();
        /**
         * Similar to _uniformsUpdated, but marks updates for uniforms which only need to be updated when a context is set up (e.g. shadow
         * mapping settings)
         * @type Set
         */
        this._constantUniformsUpdated = new Set();
        /**
         * Used for debug stat logging - counting the number of nodes in the scene.
         * @type Number
         */
        this._nodeCount = 0;
        /**
         * Used for debug stat logging - counting the number of nodes per object type in the scene.
         * @type Object.<String, Number>
         */
        this._nodeCountByType = null;
        /**
         * Stores the rendering statistics for the current frame about the scene graph in debug mode (shadow map rendering not included)
         * @type ModelDebugStats
         */
        this._mainDebugStats = null;
        /**
         * Stores the rendering statistics for the current frame about the shadow maps in debug mode
         * @type ModelDebugStats
         */
        this._shadowMapDebugStats = null;
        /**
         * (enum Scene.StereoscopicMode) In what stereoscopic mode to render this scene.
         * @type String
         */
        this._stereoscopicMode = Scene.StereoscopicMode.NONE;
        /**
         * For anaglyph stereoscopic rendering, the shader to be used for rendering scene for the left eye (with a red filter)
         * @type ManagedShader
         */
        this._redShader = null;
        /**
         * For anaglyph stereoscopic rendering, the shader to be used for rendering scene for the right eye (with a cyan filter)
         * @type ManagedShader
         */
        this._cyanShader = null;
        /**
         * The framebuffer used for rendering the left and right eye images when in stereoscopic mode
         * @type FrameBuffer
         */
        this._stereoscopicFrameBuffer = null;
        /**
         * For side by side stereoscopic rendering, the shader to be used for rendering scene for the left eye (offset to the left)
         * @type ManagedShader
         */
        this._leftShader = null;
        /**
         * For side by side stereoscopic rendering, the shader to be used for rendering scene for the right eye (offset to the right)
         * @type ManagedShader
         */
        this._rightShader = null;
        /**
         * When in side by side stereoscopic rendering mode, this value determines whether to use the original aspect ratio when 
         * rendering the two images (false means rendering the original area, condensed, thus at half the aspect ratio)
         * @type Boolean
         */
        this._sideBySideOriginalAspect = false;
        /**
         * Whether shadow map debugging (rendering shadow map on screen) is currently enabled
         * @type Boolean
         */
        this._shadowMapDebugging = false;
        /**
         * If shadow map rendering on screen is enabled, which light's shadow map to render
         * @type Number
         */
        this._shadowMapDebugLightIndex = 0;
        /**
         * If shadow map rendering on screen is enabled, which shadow map range (cascade) to render
         * @type Number
         */
        this._shadowMapDebugRangeIndex = 0;
        /**
         * The shader used to render a shadow map on the screen for debugging
         * @type ManagedShader
         */
        this._shadowMapDebugShader = null;
        this._initNodes();
        this.clearPointLights();
        this._setGeneralUniformValueFunctions();
    }
    /**
     * Scenes can be rendered in one of these stereoscopic modes
     * @enum String
     */
    Scene.StereoscopicMode = {
        /** Non-stereoscopig (plain, simple) rendering */
        NONE: "none",
        /** Anaglyph stereoscopic rendering - the scene rendered twice, on top of itself, using two different color filters */
        ANAGLYPH: "anaglyph",
        /** Side by side stereoscopic rendering - the scene rendered twice, reduced to 50% horizontal size, on the left and right side of the viewport */
        SIDE_BY_SIDE: "sideBySide"
    };
    /**
     * Set the color to use when clearing the buffer (RGBA components).
     * @param {Number[4]} value
     */
    Scene.prototype.setClearColor = function (value) {
        this._clearColor = value;
    };
    /**
     * Set the color of ambient light in the scene
     * @param {Number[3]} value
     */
    Scene.prototype.setAmbientColor = function (value) {
        this._ambientColor = value;
    };
    /**
     * Sets the uniform value functions for the scene that can be used to set all the uniforms referring to data that belongs to the whole
     * scene. After this, any shader used when rendering objects of this scene using any of these uniforms will get the data.
     */
    Scene.prototype._setGeneralUniformValueFunctions = function () {
        this.setUniformValueFunction(UNIFORM_AMBIENT_COLOR_NAME, function () {
            return this._ambientColor;
        });
        this.setUniformValueFunction(UNIFORM_NUM_DIRECTIONAL_LIGHTS_NAME, function () {
            return this._renderedDirectionalLights;
        });
        this.setUniformValueFunction(UNIFORM_DIRECTIONAL_LIGHTS_ARRAY_NAME, function () {
            return this._directionalLightUniformData;
        });
        this.setUniformValueFunction(UNIFORM_NUM_POINT_LIGHTS_NAME, function () {
            return this._renderedPointLights;
        });
        this.setUniformValueFunction(UNIFORM_POINT_LIGHTS_ARRAY_NAME, function () {
            return this._pointLightUniformData;
        });
        this.setUniformValueFunction(UNIFORM_NUM_SPOT_LIGHTS_NAME, function () {
            return this._renderedSpotLights;
        });
        this.setUniformValueFunction(UNIFORM_SPOT_LIGHTS_ARRAY_NAME, function () {
            return this._spotLightUniformData;
        });
        this.setCameraUniformValueFunction(UNIFORM_VIEW_MATRIX_NAME, function () {
            return this._camera.getViewMatrix();
        });
        this.setCameraUniformValueFunction(UNIFORM_VIEW_ORIENTATION_MATRIX_NAME, function () {
            return this._camera.getInverseOrientationMatrix();
        });
        this.setCameraUniformValueFunction(UNIFORM_VIEW_ASPECT_NAME, function () {
            return this._camera.getAspect();
        });
        this.setCameraUniformValueFunction(UNIFORM_PROJECTION_MATRIX_NAME, function () {
            return this._camera.getProjectionMatrix();
        });
        this.setCameraUniformValueFunction(UNIFORM_VIEW_PROJECTION_MATRIX_NAME, function () {
            return mat.prod4Aux(this._camera.getViewMatrix(), this._camera.getProjectionMatrix());
        });
        this.setCameraUniformValueFunction(UNIFORM_EYE_POSITION_VECTOR_NAME, function () {
            return vec.floatVector3Aux(this._camera.getCameraPositionVector());
        });
    };
    /**
     * Sets the uniform value functions for the scene that can be used to set all the uniforms referring to data that is uniform for all
     * objects within this scene while rendering to the associated context with the passed index. (but might be different for different
     * contexts)
     * @param {Number} contextIndex
     */
    Scene.prototype._setContextUniformValueFunctions = function (contextIndex) {
        var gl = this._contexts[contextIndex].gl,
                viewportSize = [0, 0];
        this.setContextUniformValueFunction(contextIndex, UNIFORM_VIEWPORT_SIZE_NAME, function () {
            viewportSize[0] = gl.drawingBufferWidth * this._width;
            viewportSize[1] = gl.drawingBufferHeight * this._height;
            return viewportSize;
        });
    };
    /**
     * Sets the uniform value functions for the uniforms that are needed by shaders that want to use shadow mapping to provide the up-to-date
     * data for this scene.
     * @param {Number} [contextIndex] Shadow maps to be passed to uniforms are different for each context, and so this index tells which
     * context (of the ones the scene has been added to) do the functions need to be set for. If omitted, they will be set for all associated
     * contexts.
     */
    Scene.prototype._setShadowMappedShaderUniformValueFunctions = function (contextIndex) {
        var i;
        // there are some functions that are the same for all contexts, so only set these once, when the first context is chosen
        if (contextIndex === 0) {
            this.setConstantUniformValueFunction(UNIFORM_SHADOW_MAPPING_NUM_RANGES_NAME, function () {
                return this._shadowMapRanges.length;
            });
            this.setConstantUniformValueFunction(UNIFORM_SHADOW_MAPPING_RANGES_ARRAY_NAME, function () {
                return this._shadowMapRanges;
            });
            this.setConstantUniformValueFunction(UNIFORM_SHADOW_MAPPING_DEPTH_RATIO_NAME, function () {
                return this._shadowMapDepthRatio;
            });
            this.setConstantUniformValueFunction(UNIFORM_SHADOW_MAPPING_TEXTURE_SIZE_NAME, function () {
                return this._shadowMapTextureSize;
            });
            this.setConstantUniformValueFunction(UNIFORM_SHADOW_MAPPING_SHADOW_MAP_SAMPLE_OFFSET_ARRAY_NAME, function () {
                return this._shadowMapSampleOffsets;
            });
        }
        // if a specific index was given, set the values functions for that context
        if (contextIndex !== undefined) {
            // NOTE: if multiple scenes use the same, shadow-map-utilizing shader, the uniform value set below will clash 
            // as it is specified as a constant, set only for the first frame
            // However, this is not a use case for now, so we can skip updating the uniform for better performance
            // To avoid clashing the below code should be refactored so that the function simply returns the array, which is
            // created during the first frame
            this.setContextConstantUniformValueFunction(contextIndex, UNIFORM_SHADOW_MAPPING_SHADOW_MAPS_ARRAY_NAME, function () {
                var j, k, shadowMaps = [];
                for (j = 0; (j < this._directionalLights.length) && (j < this._maxRenderedDirectionalLights); j++) {
                    for (k = 0; k < this._shadowMapRanges.length; k++) {
                        shadowMaps.push(this._contexts[contextIndex].getFrameBuffer(this._directionalLights[j].getShadowMapBufferName(k)).getLastTextureBindLocation(this._contexts[contextIndex].getName()));
                    }
                }
                return new Int32Array(shadowMaps);
            });
            // if no specific index was given, set the functions up for all contexts
        } else {
            for (i = 0; i < this._contexts.length; i++) {
                this._setShadowMappedShaderUniformValueFunctions(i);
            }
        }
    };
    /**
     * Updates the data of static lights sources of the scene and sets it up to be used in shaders.
     * This needs to be called to update the light matrices used in shadow mapped shaders.
     */
    Scene.prototype._updateStaticLightUniformData = function () {
        var i;
        this._renderedDirectionalLights = Math.min(this._directionalLights.length, this._maxRenderedDirectionalLights);
        // for directional lights, simply collect all the up-to-date data from all the lights
        for (i = 0; i < this._renderedDirectionalLights; i++) {
            this._directionalLightUniformData[i] = this._directionalLights[i].getUniformData();
        }
        if (i < this._maxRenderedDirectionalLights) {
            // when setting uniforms, ignore the irrelevant part of the array
            this._directionalLightUniformData[i] = null;
        }
    };
    /**
     * Clears the data stored for uniforms about dynamic light sources, so after calling this, the
     * data will not be sent to shaders when assigning scene uniforms.
     */
    Scene.prototype._clearDynamicLightUniformData = function () {
        this._renderedPointLights = 0;
        this._pointLightUniformData[0] = null;
        this._renderedSpotLights = 0;
        this._spotLightUniformData[0] = null;
    };
    /**
     * Updates the calculated data about the stored dynamic light sources to up-to-date state for the current render step and collects them in
     * a format that can be sent to the shaders. Those properties of light sources that are needed only for rendering are not calculated
     * if the light source cannot be rendered in this step.
     * @param {Number} dt The time elapsed since the last update, in milliseconds.
     */
    Scene.prototype._updateDynamicLightUniformData = function (dt) {
        var i, j, count, max;
        // for point lights, collect the lights to be rendered going through the priority lists, starting from the highest priority, and
        // perform a full update (including e.g. world position calculation) only for those light sources that can be rendered
        for (i = 0, count = 0; (i < this._pointLightPriorityArrays.length); i++) {
            for (j = 0; (j < this._pointLightPriorityArrays[i].length) && (count < this._maxRenderedPointLights); j++) {
                if (this._pointLightPriorityArrays[i][j].isVisible()) {
                    this._pointLightPriorityArrays[i][j].update(dt);
                    if (this._pointLightPriorityArrays[i][j].shouldBeRendered(this._camera)) {
                        this._pointLightUniformData[count] = this._pointLightPriorityArrays[i][j].getUniformData();
                        count++;
                    }
                }
            }
            // for the lights sources in this priority list that cannot be rendered, the state still needs to be updated to make sure if
            // they get rendered at one point, their state will be correct
            while (j < this._pointLightPriorityArrays[i].length) {
                if (this._pointLightPriorityArrays[i][j].isVisible()) {
                    this._pointLightPriorityArrays[i][j].updateState(dt);
                }
                j++;
            }
        }
        this._renderedPointLights = count;
        if (count < this._maxRenderedPointLights) {
            this._pointLightUniformData[count] = null; // when setting the uniforms, ignore the irrelevant part of the array
        }
        // for spot lights, only calculate the rendered ones fully, like with point lights, but there are no priorities here
        count = 0;
        for (i = 0, max = Math.min(this._spotLights.length, this._maxRenderedSpotLights); (i < this._spotLights.length) && (count < max); i++) {
            this._spotLights[i].update(dt);
            if (this._spotLights[i].shouldBeRendered(this._camera)) {
                this._spotLightUniformData[count] = this._spotLights[i].getUniformData();
                count++;
            }
        }
        while (i < this._spotLights.length) {
            this._spotLights[i].updateState(dt);
            i++;
        }
        this._renderedSpotLights = count;
        if (count < this._maxRenderedSpotLights) {
            this._spotLightUniformData[count] = null; // when setting the uniforms, ignore the irrelevant part of the array
        }
    };
    /**
     * Returns the framebuffer name prefix to use for the shadow maps for the light with the given index.
     * @param {Number} lightIndex
     * @returns {String}
     */
    Scene.prototype._getShadowMapBufferNamePrefix = function (lightIndex) {
        return SHADOW_MAP_BUFFER_NAME_PREFIX + lightIndex + SHADOW_MAP_BUFFER_NAME_INFIX;
    };
    /**
     * Returns the width a rendering of this scene should use when rendered on the passed context, in pixels.
     * @param {ManagedGLContext} context
     * @returns {Number}
     */
    Scene.prototype._getWidthInPixels = function (context) {
        return context.gl.drawingBufferWidth * this._width;
    };
    /**
     * Returns the height a rendering of this scene should use when rendered on the passed context, in pixels.
     * @param {ManagedGLContext} context
     * @returns {Number}
     */
    Scene.prototype._getHeightInPixels = function (context) {
        return context.gl.drawingBufferHeight * this._height;
    };
    /**
     * Does all preparations needed to render the scene to the associated context with the given index, according to the current scene 
     * settings. If no index is given, preparations are done for all contexts.
     * @param {Number} [contextIndex]
     */
    Scene.prototype._setupContext = function (contextIndex) {
        var i, context;
        this._constantUniformsUpdated.clear();
        // if a specific index is given, set up the corresponding context
        if (contextIndex !== undefined) {
            context = this._contexts[contextIndex];
            this._setContextUniformValueFunctions(contextIndex);
            // if shadow mapping is to be used, some additional preparations are needed
            if (this._shadowMappingEnabled) {
                context.addShader(this._shadowMappingShader);
                this._setShadowMappedShaderUniformValueFunctions(contextIndex);
            }
            for (i = 0; (i < this._directionalLights.length) && (i < this._maxRenderedDirectionalLights); i++) {
                this._directionalLights[i].addToContext(this._contexts[contextIndex], this._shadowMappingEnabled, this._getShadowMapBufferNamePrefix(i), this._shadowMapRanges.length, this._shadowMapTextureSize);
            }
            // set up stereoscopic rendering
            if (this._stereoscopicMode !== Scene.StereoscopicMode.NONE) {
                // set up anaglyph stereoscopic rendering
                if (this._stereoscopicMode === Scene.StereoscopicMode.ANAGLYPH) {
                    context.addShader(this._redShader);
                    context.addShader(this._cyanShader);
                    // set up side by side stereoscopic rendering
                } else if (this._stereoscopicMode === Scene.StereoscopicMode.SIDE_BY_SIDE) {
                    context.addShader(this._leftShader);
                    context.addShader(this._rightShader);
                }
                this._stereoscopicFrameBuffer = this._stereoscopicFrameBuffer || new managedGL.FrameBuffer(STEREOSCOPY_FRAMEBUFFER_NAME,
                        this._getWidthInPixels(context), this._getHeightInPixels(context), false);
                context.addFrameBuffer(this._stereoscopicFrameBuffer);
                this._fvq = this._fvq || egomModel.fvqModel(FVQ_NAME);
                this._fvq.addToContext(context, false);
            }
            if (this._shadowMapDebugging) {
                context.addShader(this._shadowMapDebugShader);
                this._fvq = this._fvq || egomModel.fvqModel(FVQ_NAME);
                this._fvq.addToContext(context, false);
            }
        } else {
            // if no specific index is given, set up all associated contexts
            for (i = 0; i < this._contexts.length; i++) {
                this._setupContext(i);
            }
        }
    };
    /**
     * Sets the scene up for anaglyph stereoscopic rendering mode, according to the passed parameters.
     * Call before setting up the contexts!
     * @param {Object} params
     */
    Scene.prototype.setAnaglyphRendering = function (params) {
        this._stereoscopicMode = Scene.StereoscopicMode.ANAGLYPH;
        this._redShader = params.redShader;
        this._cyanShader = params.cyanShader;
        if (params.interocularDistance !== undefined) {
            this._camera.setInterocularDistance(params.interocularDistance);
        }
        if (params.convergenceDistance !== undefined) {
            this._camera.setStereoscopicConvergenceDistance(params.convergenceDistance);
        }
    };
    /**
     * Sets the scene up for side by side stereoscopic rendering mode, according to the passed parameters.
     * Call before setting up the contexts!
     * @param {Object} params
     */
    Scene.prototype.setSideBySideRendering = function (params) {
        this._stereoscopicMode = Scene.StereoscopicMode.SIDE_BY_SIDE;
        this._leftShader = params.leftShader;
        this._rightShader = params.rightShader;
        if (params.interocularDistance !== undefined) {
            this._camera.setInterocularDistance(params.interocularDistance);
        }
        if (params.convergenceDistance !== undefined) {
            this._camera.setStereoscopicConvergenceDistance(params.convergenceDistance);
        }
        if (params.originalAspect !== undefined) {
            this._sideBySideOriginalAspect = params.originalAspect;
        }
    };
    /**
     * Sets the scene up for rendering shadow maps for debugging
     * @param {Object} params
     */
    Scene.prototype.setupShadowMapDebugging = function (params) {
        this._shadowMapDebugging = true;
        this._shadowMapDebugShader = params.shader;
        this._shadowMapDebugLightIndex = params.lightIndex || 0;
        this._shadowMapDebugRangeIndex = params.rangeIndex || 0;
    };
    /**
     * Sets new relative coordinates for the viewport of this scene - when the scene is rendered to a canvas, its viewport will be 
     * calculated by scaling these relative coordinates to the size of the canvas.
     * @param {Number} left
     * @param {Number} bottom
     * @param {Number} width
     * @param {Number} height
     */
    Scene.prototype.setRelativeViewport = function (left, bottom, width, height) {
        this._left = left;
        this._bottom = bottom;
        this._width = width;
        this._height = height;
    };
    /**
     * The scene can be rendered on a managed context after it has been added to it using this function. This makes sure the context is
     * prepared correctly, with all the resources such as vertex and frame buffers needed to render this scene are added. After this,
     * the setup function of the managed context needs to be called to make sure all the data from the scene is pulled to the buffers.
     * @param {ManagedGLContext} context
     */
    Scene.prototype.addToContext = function (context) {
        var contextIndex = this._contexts.findIndex(function (element) {
            return element.getName() === context.getName();
        });
        if (contextIndex < 0) {
            this._contexts.push(context);
            contextIndex = this._contexts.length - 1;
        }
        this._setupContext(contextIndex);
        // adding all the nodes
        this._rootBackgroundNode.addToContext(context);
        this._rootNode.addToContext(context);
        this._rootUINode.addToContext(context);
        this._rootResourceNode.addToContext(context);
    };
    /**
     * If the shadow mapping properties were appropriately set up, after this call the scene will be rendered using shadow mapping.
     */
    Scene.prototype.enableShadowMapping = function () {
        if (this._shadowMappingShader && this._shadowMapRanges.length > 0) {
            this._shadowMappingEnabled = true;
            this._setupContext();
        } else {
            application.showError("Cannot enable shadow mapping, as no shadow mapping shader or no shadow mapping ranges were specified");
        }
    };
    /**
     * After this call, the scene will be rendered without using shadow mapping.
     */
    Scene.prototype.disableShadowMapping = function () {
        this._shadowMappingEnabled = false;
    };
    /**
     * Switches whether shadow mapping for this scene is turned on to its opposite state.
     */
    Scene.prototype.toggleShadowMapping = function () {
        this._shadowMappingEnabled = !this._shadowMappingEnabled;
        if (this._shadowMappingEnabled) {
            this.enableShadowMapping();
        } else {
            this.disableShadowMapping();
        }
    };
    /**
     * Sets a new list of shadow map ranges to use when rendering this scene.
     * @param {Number[]} ranges
     */
    Scene.prototype.setShadowMapRanges = function (ranges) {
        this._shadowMapRanges = new Float32Array(ranges);
        this._setupContext();
    };
    /**
     * @typedef Scene~ShadowMappingParams
     * @property {Boolean} [enable]
     * @property {ManagedShader} [shader]
     * @property {Number} [textureSize]
     * @property {Number[]} [ranges]
     * @property {Number} [depthRatio]
     * @property {Number} [numSamples]
     * @property {Boolean} [deferSetup=false]
     */
    /**
     * Sets the parameters of shadow mapping that are defined in the passed object, and leaves the others at their current value. If there
     * is no object passed, resets all shadow mapping parameters to their void value.
     * @param {Scene~ShadowMappingParams} [params]
     */
    Scene.prototype.setShadowMapping = function (params) {
        if (params) {
            this._shadowMappingEnabled = (params.enable !== undefined) ? params.enable : this._shadowMappingEnabled;
            this._shadowMappingShader = params.shader || this._shadowMappingShader;
            this._shadowMapTextureSize = params.textureSize || this._shadowMapTextureSize;
            this._shadowMapRanges = params.ranges ? new Float32Array(params.ranges) : this._shadowMapRanges;
            this._shadowMapDepthRatio = params.depthRatio || this._shadowMapDepthRatio;
            this._numShadowMapSamples = params.numSamples ? types.getNumberValueInRange(
                    "shadowMappingParams.numSamples",
                    params.numSamples,
                    this._shadowMappingEnabled ? 1 : 0,
                    this._shadowMappingEnabled ? SHADOW_MAP_SAMPLE_OFFSETS.length / 2 : 0,
                    this._shadowMappingEnabled ? 1 : 0) : params.numSamples;
            this._shadowMapSampleOffsets = SHADOW_MAP_SAMPLE_OFFSETS.slice(0, 2 * this._numShadowMapSamples);
            if (!params.deferSetup) {
                this._setupContext();
            }
        } else {
            this._shadowMappingEnabled = false;
            this._shadowMappingShader = null;
            this._shadowMapTextureSize = 0;
            this._shadowMapRanges = new Float32Array([]);
            this._shadowMapDepthRatio = 0;
            this._numShadowMapSamples = 0;
            this._shadowMapSampleOffsets = [];
        }
        this._constantUniformsUpdated.clear();
    };
    /**
     * 
     * @returns {RenderableNode}
     */
    Scene.prototype.getRootNode = function () {
        return this._rootNode;
    };
    /**
     * Returns the camera that is used when rendering this scene.
     * @returns {Camera}
     */
    Scene.prototype.getCamera = function () {
        return this._camera;
    };
    /**
     * Returns whether this scene is set to animate when it is rendered.
     * @returns {Boolean}
     */
    Scene.prototype.shouldAnimate = function () {
        return this._shouldAnimate;
    };
    /**
     * Sets whether this scene should animate when it is rendered.
     * @param {Boolean} value
     */
    Scene.prototype.setShouldAnimate = function (value) {
        this._shouldAnimate = value;
    };
    /**
     * Sets whether this scene should update its camera's state when it is rendered.
     * @param {Boolean} value
     */
    Scene.prototype.setShouldUpdateCamera = function (value) {
        this._shouldUpdateCamera = value;
    };
    /**
     * Adds a new node containing the passed renderable object to be rendered among the background objects of this scene. The background
     * objects are rendered before the main scene objects, without depth checking, on top of each other in the order they were added.
     * @param {RenderableObject} backgroundObject The object to add.
     * @returns {RenderableNode} The node that was created to contain the passed object.
     */
    Scene.prototype.addBackgroundObject = function (backgroundObject) {
        var node = new RenderableNode(backgroundObject, false);
        this._rootBackgroundNode.addSubnode(node);
        return node;
    };
    /**
     * Adds a new node containing the passed renderable object to be rendered among the main scene objects of this scene. 
     * If the passed object already has an associated node, uses that one instead.
     * @param {RenderableObject} newObject The object to add.
     * @param {Boolean} [renderedToShadowMap=true] If false, the node for this object and its subnodes will never be rendered to shadow maps
     * @param {Number} [minimumCountForInstancing=0] When given, the object will be rendered using instancing if this many or more
     * instances of it are added to the scene.
     * @returns {RenderableNode} The node that was created / used to contain the passed object.
     */
    Scene.prototype.addObject = function (newObject, renderedToShadowMap, minimumCountForInstancing) {
        var node = newObject.getNode() || new RenderableNode(newObject, renderedToShadowMap, false, minimumCountForInstancing);
        this._rootNode.addSubnode(node);
        return node;
    };
    /**
     * Adds the given node to the main scene object nodes of this scene, and returns it for convenience.
     * @param {RenderableNode} node
     * @returns {RenderableNode}
     */
    Scene.prototype.addNode = function (node) {
        this._rootNode.addSubnode(node);
        return node;
    };
    /**
     * Adds a new node to the UI node tree, which will be rendered atop the background and main scene objects, without depth buffer.
     * @param {RebderableObject} uiObject
     * @returns {RenderableNode} The node that was created to contain the passed object.
     */
    Scene.prototype.addUIObject = function (uiObject) {
        var node = new RenderableNode(uiObject, false);
        this._rootUINode.addSubnode(node);
        return node;
    };
    /**
     * Adds the passed renderable object to all contexts this scene is associated with. Should be called when the node or an ancestor of the
     * node of an object is added to this scene. (automatically called by RenderableNode)
     * @param {RenderableObject} renderableObject
     */
    Scene.prototype.addObjectToContexts = function (renderableObject) {
        var i;
        for (i = 0; i < this._contexts.length; i++) {
            renderableObject.addToContext(this._contexts[i]);
        }
    };
    /**
     * Adds the passed object to the list of objects that moved (by calling translatev() on them) when the scene is moved to follow the camera
     * @param {Object} object
     */
    Scene.prototype.addObjectToMove = function (object) {
        this._objectsToMove.push(object);
    };
    /**
     * Clears all nodes and lights from the scene.
     * @param {Boolean} [hard=false] If true, also removes the list references from the nodes.
     */
    Scene.prototype.clear = function (hard) {
        this.clearNodes(hard);
        this.clearDirectionalLights();
        this.clearPointLights();
        this.clearSpotLights();
    };
    /**
     * Initializes the root nodes for this scene.
     */
    Scene.prototype._initNodes = function () {
        // we are adding RenderableObject3D so if nodes with object 3D-s are added, they will have a parent with position and orientation
        // a size of 0 is specified so that no child 3D objects will ever think they are inside their parent
        this._rootBackgroundNode = new RenderableNode(new renderableObjects.RenderableObject3D(null, false, false, mat.IDENTITY4, mat.IDENTITY4, mat.IDENTITY4, undefined, 0, false, true), false);
        this._rootBackgroundNode.setScene(this);
        this._rootNode = new RenderableNode(new renderableObjects.RenderableObject3D(null, false, false, mat.IDENTITY4, mat.IDENTITY4, mat.IDENTITY4, undefined, 0, false, true));
        this._rootNode.setScene(this);
        this._rootResourceNode = new RenderableNode(new renderableObjects.RenderableObject3D(null, false, false, mat.IDENTITY4, mat.IDENTITY4, mat.IDENTITY4, undefined, 1, false, true), false);
        this._rootResourceNode.setScene(this);
        this._resourceObjectIDs = {};
        this._rootUINode = new RenderableNode(new renderableObjects.RenderableObject3D(null, false, false, mat.IDENTITY4, mat.IDENTITY4, mat.IDENTITY4, undefined, 0, false, true), false);
        this._rootUINode.setScene(this);
        this._objectsToMove = [];
    };
    /**
     * Clears all added nodes from this scene.
     * @param {Boolean} [hard=false] If true, also removes the list references from the nodes.
     */
    Scene.prototype.clearNodes = function (hard) {
        if (this._rootBackgroundNode) {
            this._rootBackgroundNode.removeSubnodes(hard);
        }
        if (this._rootNode) {
            this._rootNode.removeSubnodes(hard);
        }
        if (this._rootResourceNode) {
            this._rootResourceNode.removeSubnodes(hard);
        }
        this._resourceObjectIDs = {};
        if (this._rootUINode) {
            this._rootUINode.removeSubnodes(hard);
        }
        this._objectsToMove.length = 0;
    };
    /**
     * Removes all the previously added directional light sources from the scene.
     */
    Scene.prototype.clearDirectionalLights = function () {
        this._directionalLights = [];
    };
    /**
     * Removes all the previously added point light sources from the scene.
     */
    Scene.prototype.clearPointLights = function () {
        var i;
        this._pointLightPriorityArrays = new Array(MAX_POINT_LIGHT_PRIORITIES);
        for (i = 0; i < MAX_POINT_LIGHT_PRIORITIES; i++) {
            this._pointLightPriorityArrays[i] = [];
        }
    };
    /**
     * Removes all the previously added spot light sources from the scene.
     */
    Scene.prototype.clearSpotLights = function () {
        this._spotLights = [];
    };
    /**
     * Returns an array containing all the top level main objects of the scene.
     * @returns {RenderableObject[]}
     */
    Scene.prototype.getAllObjects = function () {
        var result = [], subnode, subnodes = this._rootNode.getSubnodes();
        for (subnode = subnodes.getFirst(); subnode; subnode = subnode.next) {
            result.push(subnode.getRenderableObject());
        }
        return result;
    };
    /**
     * Returns an array containing all the top level main objects of the scene that have functions defined to access their position and 
     * orientation.
     * @returns {RenderableObject3D[]}
     */
    Scene.prototype.getAll3DObjects = function () {
        var o, result = [], subnode, subnodes = this._rootNode.getSubnodes();
        for (subnode = subnodes.getFirst(); subnode; subnode = subnode.next) {
            o = subnode.getRenderableObject();
            if (o.getPositionMatrix && o.getOrientationMatrix) {
                result.push(o);
            }
        }
        return result;
    };
    /**
     * Moves (translates) all movable root level main object in the scene by the passed vector.
     * @param {Number[3]} v A 3D vector.
     */
    Scene.prototype.moveAllObjectsByVector = function (v) {
        var i, o, subnode, subnodes = this._rootNode.getSubnodes();
        for (subnode = subnodes.getFirst(); subnode; subnode = subnode.next) {
            o = subnode.getRenderableObject();
            if (o.translatev) {
                o.translatev(v);
            }
        }
        for (i = 0; i < this._objectsToMove.length; i++) {
            this._objectsToMove[i].translatev(v);
        }
    };
    /**
     * If the current positon of the scene's camera exceeds plus/minus the given limit on any of the three axes, moves the camera back to 
     * the origo and moves all the objects in the scene to stay in sync with the camera as well as returns the vector by which the objects
     * have been moved. Otherwise returns null.
     * @param {Number} limit
     * @returns {Number[3]|null}
     */
    Scene.prototype.moveCameraToOrigoIfNeeded = function (limit) {
        var result = this._camera.moveToOrigoIfNeeded(limit);
        if (result) {
            this.moveAllObjectsByVector(result);
        }
        return result;
    };
    /**
     * Returns the node storing the first added main scene object.
     * @returns {RenderableNode}
     */
    Scene.prototype.getFirstNode = function () {
        return this._rootNode.getFirstSubnode();
    };
    /**
     * Returns the node coming after the passed one among the nodes storing the main scene objects.
     * @param {RenderableNode} currentNode
     * @returns {RenderableNode}
     */
    Scene.prototype.getNextNode = function (currentNode) {
        return this._rootNode.getNextSubnode(currentNode);
    };
    /**
     * Returns the node coming before the passed one among the nodes storing the main scene objects.
     * @param {RenderableNode} currentNode
     * @returns {RenderableNode}
     */
    Scene.prototype.getPreviousNode = function (currentNode) {
        return this._rootNode.getPreviousSubnode(currentNode);
    };
    /**
     * Returns whether the resources of an object have already been added to the scene with the passed ID
     * @param {String} id
     * @returns {Boolean}
     */
    Scene.prototype.hasResourcesOfObject = function (id) {
        return !!this._resourceObjectIDs[id];
    };
    /**
     * Marks the resources of the passed renderable object to be added to any contexts this scene will get added to. This will make it 
     * possible to dynamically add objects of this type to the scene after it has already been added to a context, as its resources (such
     * as vertices in the vertex buffers of the context) will be available.
     * @param {RenderableObject} [object] Can be omitted, in which case the passed id will simply be marked as having its resources added
     * @param {String} [id] If given, the resources will only be added if no other object has been added with the same ID as this before
     */
    Scene.prototype.addResourcesOfObject = function (object, id) {
        var node;
        if (!id || !this._resourceObjectIDs[id]) {
            if (object) {
                node = new RenderableNode(object, false);
                this._rootResourceNode.addSubnode(node, true);
                // mark it as reusable so in case this is a pooled object, the pooled instance can be marked free
                node.markAsReusable(false);
            }
            if (id) {
                this._resourceObjectIDs[id] = true;
            }
        }
    };
    /**
     * Adds the passed directional light source to this scene.
     * @param {DirectionalLightSource} lightSource
     */
    Scene.prototype.addDirectionalLightSource = function (lightSource) {
        this._directionalLights.push(lightSource);
    };
    /**
     * Adds the passed point light source to this scene with the given priority. The highest priority is 0 and larger number means lower
     * priority, with the number of available priority determined by MAX_POINT_LIGHT_PRIORITIES. If there are more point light sources in
     * the scene than the rendering limit, the ones with the higher priority will be rendered.
     * @param {PointLightSource} lightSource
     * @param {Number} priority
     */
    Scene.prototype.addPointLightSource = function (lightSource, priority) {
        priority = Math.min(priority || 0, MAX_POINT_LIGHT_PRIORITIES - 1);
        this._pointLightPriorityArrays[priority].push(lightSource);
    };
    /**
     * Adds the passed spot light source to this scene.
     * @param {SpotLightSource} lightSource
     */
    Scene.prototype.addSpotLightSource = function (lightSource) {
        this._spotLights.push(lightSource);
    };
    /**
     * Returns the LOD context containing the settings that govern how the LOD of multi-LOD models is chosen when rendering this scene.
     * @returns {LODContext}
     */
    Scene.prototype.getLODContext = function () {
        return this._lodContext;
    };
    /**
     * Sets the passed function to be called when a shader asks for the value of a non-camera-related uniform (which need to be updated
     * once every frame) with the given name while rendering this scene. The name given here is appropriately prefixed/suffixed by ManagedGL. 
     * The value of this will be the scene instance, when calling the function.
     * @param {String} rawUniformName
     * @param {Function} valueFunction
     */
    Scene.prototype.setUniformValueFunction = function (rawUniformName, valueFunction) {
        this._uniformValueFunctions[managedGL.getUniformName(rawUniformName)] = valueFunction.bind(this);
    };
    /**
     * Same as setUniformValueFunction, but for camera-related uniforms (which might need to be updated multiple times during one
     * frame, such as for extended or stereoscopic cameras)
     * @param {String} rawUniformName
     * @param {Function} valueFunction
     */
    Scene.prototype.setCameraUniformValueFunction = function (rawUniformName, valueFunction) {
        this._cameraUniformValueFunctions[managedGL.getUniformName(rawUniformName)] = valueFunction.bind(this);
    };
    /**
     * Same as setUniformValueFunction, but for uniforms which only need to be updated when the contexts are set up.
     * @param {String} rawUniformName
     * @param {Function} valueFunction
     */
    Scene.prototype.setConstantUniformValueFunction = function (rawUniformName, valueFunction) {
        this._constantUniformValueFunctions[managedGL.getUniformName(rawUniformName)] = valueFunction.bind(this);
    };
    /**
     * Sets the passed function to be called when a shader asks for the value of a uniform with the given name while rendering this scene to
     * the associated context with the given index.
     * The name given here is appropriately prefixed/suffixed by ManagedGL. The value of this will be the scene instance, when calling the
     * function.
     * Use for uniforms which need to be updated every frame.
     * @param {Number} contextIndex
     * @param {String} rawUniformName
     * @param {Function} valueFunction
     */
    Scene.prototype.setContextUniformValueFunction = function (contextIndex, rawUniformName, valueFunction) {
        if (!this._contextUniformValueFunctions[contextIndex]) {
            this._contextUniformValueFunctions[contextIndex] = {};
        }
        this._contextUniformValueFunctions[contextIndex][managedGL.getUniformName(rawUniformName)] = valueFunction.bind(this);
    };
    /**
     * Same as setContextUniformValueFunction, but for uniforms which only need to be updated when the context is set up.
     * @param {Number} contextIndex
     * @param {String} rawUniformName
     * @param {Function} valueFunction
     */
    Scene.prototype.setContextConstantUniformValueFunction = function (contextIndex, rawUniformName, valueFunction) {
        if (!this._contextConstantUniformValueFunctions[contextIndex]) {
            this._contextConstantUniformValueFunctions[contextIndex] = {};
        }
        this._contextConstantUniformValueFunctions[contextIndex][managedGL.getUniformName(rawUniformName)] = valueFunction.bind(this);
    };
    /**
     * Adds a new camera configuration that will be associated with the scene itself.
     * @param {CameraConfiguration} cameraConfiguration
     */
    Scene.prototype.addCameraConfiguration = function (cameraConfiguration) {
        this._rootNode.addCameraConfiguration(cameraConfiguration);
    };
    /**
     * Returns whether the given camera configuration is among the ones associated with this scene.
     * @param {CameraConfiguration} cameraConfiguration
     * @returns {Boolean}
     */
    Scene.prototype.hasCameraConfiguration = function (cameraConfiguration) {
        return this._rootNode.hasCameraConfiguration(cameraConfiguration);
    };
    /**
     * Returns the camera configuration the comes after the one passed as parameter in the list of associated camera configurations.
     * If the last configuration is passed, returns the first one. Returns the first configuration if called with a null parameter, and
     * crashes if the given configuration is not in the list.
     * @param {CameraConfiguration} [currentCameraConfiguration]
     * @returns {CameraConfiguration}
     */
    Scene.prototype.getNextCameraConfiguration = function (currentCameraConfiguration) {
        return this._rootNode.getNextCameraConfiguration(currentCameraConfiguration);
    };
    /**
     * Returns the camera configuration the comes before the one passed as parameter in the list of associated camera configurations.
     * If the first configuration is passed, returns the last one. Returns the last configuration if called with a null parameter, and
     * crashes if the given configuration is not in the list.
     * @param {CameraConfiguration} [currentCameraConfiguration]
     * @returns {CameraConfiguration}
     */
    Scene.prototype.getPreviousCameraConfiguration = function (currentCameraConfiguration) {
        return this._rootNode.getPreviousCameraConfiguration(currentCameraConfiguration);
    };
    /**
     * Returns a list of the associated camera configurations that have the specified name.
     * @param {String} name
     * @returns {CameraConfiguration[]}
     */
    Scene.prototype.getCameraConfigurationsWithName = function (name) {
        return this._rootNode.getCameraConfigurationsWithName(name);
    };
    /**
     * Hides the UI node tree (it will not be rendered in subsequent render calls until shown again)
     */
    Scene.prototype.hideUI = function () {
        this._rootUINode.hide();
    };
    /**
     * Shows the UI node tree (it will be rendered in subsequent render calls until hidden)
     */
    Scene.prototype.showUI = function () {
        this._rootUINode.show();
    };
    /**
     * Assigns all uniforms in the given shader program that the scene has a value function for, using the appropriate webGL calls.
     * The matching is done based on the names of the uniforms.
     * @param {ManagedGLContext} context 
     * @param {ManagedShader} shader
     */
    Scene.prototype.assignUniforms = function (context, shader) {
        if (!this._uniformsUpdated.has(shader)) {
            shader.assignUniforms(context, this._uniformValueFunctions);
            shader.assignUniforms(context, this._contextUniformValueFunctions[this._contexts.indexOf(context)]);
            this._uniformsUpdated.add(shader);
            this._uniformsUpdatedForFrame = true;
        }
        if (!this._cameraUniformsUpdated.has(shader)) {
            shader.assignUniforms(context, this._cameraUniformValueFunctions);
            this._cameraUniformsUpdated.add(shader);
        }
        if (!this._constantUniformsUpdated.has(shader)) {
            shader.assignUniforms(context, this._constantUniformValueFunctions);
            shader.assignUniforms(context, this._contextConstantUniformValueFunctions[this._contexts.indexOf(context)]);
            this._constantUniformsUpdated.add(shader);
        }
    };
    /**
     * Cleans up the light sources, removing the ones that no longer have an active source object.
     */
    Scene.prototype.cleanUpLights = function () {
        var i, j, k, prio;
        // cleaning up dynamic point light sources
        for (prio = 0; prio < this._pointLightPriorityArrays.length; prio++) {
            for (i = 0; i < this._pointLightPriorityArrays[prio].length; i++) {
                j = i;
                k = 0;
                while ((j < this._pointLightPriorityArrays[prio].length) && ((!this._pointLightPriorityArrays[prio][j]) || (this._pointLightPriorityArrays[prio][j].canBeReused() === true))) {
                    j++;
                    k++;
                }
                this._pointLightPriorityArrays[prio].splice(i, k);
            }
        }
        // cleaning up dynamic spot light sources 
        for (i = 0; i < this._spotLights.length; i++) {
            j = i;
            k = 0;
            while ((j < this._spotLights.length) && ((!this._spotLights[j]) || (this._spotLights[j].canBeReused() === true))) {
                j++;
                k++;
            }
            this._spotLights.splice(i, k);
        }
    };
    /**
     * Renders the main scene objects for a shadow map after it has been set up appropriately for a light source and shadow map range.
     * This method only performs the rendering itself (clearing the background and rendering the nodes on it)
     * @param {ManagedGLContext} context
     * @param {Number} widthInPixels The width of the viewport in pixels.
     * @param {Number} heightInPixels The height of the viewport in pixels.
     * @param {DirectionalLight} light
     */
    Scene.prototype._renderShadowMap = function (context, widthInPixels, heightInPixels, light) {
        var gl = context.gl, i, newShadowQueue;
        application.log_DEBUG("Starting new shadow map...", 4);
        if (this._shadowQueue.length > 0) {
            if (managedGL.areDepthTexturesAvailable()) {
                gl.clear(gl.DEPTH_BUFFER_BIT);
            } else {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            }
            newShadowQueue = [];
            for (i = 0; i < this._shadowQueue.length; i++) {
                if (this._shadowQueue[i].renderToShadowMap(context, widthInPixels, heightInPixels, light)) {
                    newShadowQueue.push(this._shadowQueue[i]);
                }
            }
            this._shadowQueue = newShadowQueue;
        }
    };
    /**
     * If shadow mapping is enabled, renders all the shadow maps according to the current settings to separate textures, and binds all these
     * textures to be used by subsequent shaders.
     * @param {ManagedGLContext} context
     * @param {Number} widthInPixels The width of the viewport in pixels.
     * @param {Number} heightInPixels The height of the viewport in pixels.
     */
    Scene.prototype._renderShadowMaps = function (context, widthInPixels, heightInPixels) {
        var i, j, gl = context.gl, subnode;
        // rendering the shadow maps, if needed
        if (this._shadowMappingEnabled) {
            application.log_DEBUG("Rendering shadow maps for scene...", 4);
            // common GL state setup
            gl.viewport(0, 0, this._shadowMapTextureSize, this._shadowMapTextureSize);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            context.setColorMask(COLOR_MASK_ALL_TRUE);
            context.disableBlending();
            context.setDepthMask(true);
            // choosing the shadow map shader
            context.setCurrentShader(this._shadowMappingShader);
            this.assignUniforms(context, this._shadowMappingShader);
            // rendering for each light source and shadow map range
            for (i = 0; (i < this._directionalLights.length) && (i < this._maxRenderedDirectionalLights); i++) {
                this._directionalLights[i].reset();
                this._shadowQueue = new Array(this._rootNode.getSubnodes().getLength());
                for (j = 0, subnode = this._rootNode.getSubnodes().getFirst(); subnode; subnode = subnode.next, j++) {
                    this._shadowQueue[j] = subnode;
                }
                application.log_DEBUG("Rendering shadow maps for light " + i + "...", 4);
                for (j = this._shadowMapRanges.length - 1; j >= 0; j--) {
                    this._directionalLights[i].startShadowMap(context, this._camera, j, this._shadowMapRanges[j], this._shadowMapRanges[j] * this._shadowMapDepthRatio);
                    this._renderShadowMap(context, widthInPixels, heightInPixels, this._directionalLights[i]);
                }
            }
            // binding the created textures to be used by the subsequent rendering calls
            for (i = 0; (i < this._directionalLights.length) && (i < this._maxRenderedDirectionalLights); i++) {
                for (j = 0; j < this._shadowMapRanges.length; j++) {
                    context.bindTexture(context.getFrameBuffer(this._directionalLights[i].getShadowMapBufferName(j)), undefined, true);
                }
            }
        }
        // switch back to rendering to the screen
        context.setCurrentFrameBuffer(null);
    };
    /**
     * Renders the background node tree using appropriate context settings.
     * @param {ManagedGLContext} context
     * @param {Number} widthInPixels The width of the viewport in pixels.
     * @param {Number} heightInPixels The height of the viewport in pixels.
     */
    Scene.prototype._renderBackgroundObjects = function (context, widthInPixels, heightInPixels) {
        application.log_DEBUG("Rendering background objects of scene...", 4);
        // preparing to render background objects
        context.enableBlending();
        context.setDepthMask(false);
        // rendering background objects
        this._rootBackgroundNode.render(context, widthInPixels, heightInPixels, false);
    };
    /**
     * Renders the specified render queues of the scene with the given settings.
     * @param {ManagedGLContext} context
     * @param {Number} widthInPixels The width of the viewport in pixels.
     * @param {Number} heightInPixels The height of the viewport in pixels.
     * @param {RenderableNode[]} renderQueue
     * @param {Number} index This is the index to identify the queue in case it is rendered in instanced mode.
     * @param {Boolean} depthMask
     */
    Scene.prototype._renderQueue = function (context, widthInPixels, heightInPixels, renderQueue, index, depthMask) {
        var i, queueLength = renderQueue.length, minimumInstancingCount, count;
        if (queueLength > 0) {
            minimumInstancingCount = renderQueue[0].getMinimumCountForInstancing();
            if ((minimumInstancingCount > 0) && (queueLength >= minimumInstancingCount) && (context.instancingExt)) {
                count = 0;
                renderQueue[0].prepareForInstancedRender(context, index, queueLength);
                for (i = 0; i < queueLength; i++) {
                    if (renderQueue[i].render(context, widthInPixels, heightInPixels, depthMask, true, true, index, true)) {
                        count++;
                    }
                }
                if (count > 0) {
                    renderQueue[0].renderInstances(context, index, count);
                }
            } else {
                for (i = 0; i < queueLength; i++) {
                    renderQueue[i].render(context, widthInPixels, heightInPixels, depthMask, true, undefined, undefined, true);
                }
            }
        }
    };
    /**
     * Renders all the objects stored in the passed render queues in two passes (one for transparent and another for opaque triangles) with
     * appropriate context settings.
     * @param {ManagedGLContext} context
     * @param {Number} widthInPixels The width of the viewport in pixels.
     * @param {Number} heightInPixels The height of the viewport in pixels.
     * @param {RenderableNode[][]} opaqueRenderQueues The queues storing the nodes to render, with nodes using the same shader in each queue.
     * In these queues should be the nodes that contain objects that should be rendered in opaque mode.
     * @param {RenderableNode[][]} transparentRenderQueues In these queues should be the nodes that contain objects that should be rendered 
     * in transparent mode.
     * @param {Boolean} renderBackground If true, the background objects are rendered as well.
     */
    Scene.prototype._renderMainObjects = function (context, widthInPixels, heightInPixels, opaqueRenderQueues, transparentRenderQueues, renderBackground) {
        var i;
        // preparing to render main scene objects
        // first rendering pass: rendering the non-transparent triangles with Z buffer writing turned on
        application.log_DEBUG("Rendering opaque phase...", 4);
        if (opaqueRenderQueues.length > 0) {
            context.setDepthMask(true);
            context.disableBlending();
            // rendering using the render queues instead of the scene hierarchy to provide better performance by minimizing shader switches
            for (i = 0; i < opaqueRenderQueues.length; i++) {
                this._renderQueue(context, widthInPixels, heightInPixels, opaqueRenderQueues[i], i, true);
            }
        }
        // rendering the background objects after the opaque pass so background will only be rendered where it is not occluded by opaque
        // triangles. Transparent triangles are not changing the depth buffer so they would be overwritten by the background if it was 
        // rendered after them
        if (renderBackground) {
            this._renderBackgroundObjects(context, widthInPixels, heightInPixels);
        }
        // second rendering pass: rendering the transparent triangles with Z buffer writing turned off
        application.log_DEBUG("Rendering transparent phase...", 4);
        if (transparentRenderQueues.length > 0) {
            context.setDepthMask(false);
            context.enableBlending();
            // rendering using the render queues instead of the scene hierarchy to provide better performance by minimizing shader switches
            for (i = 0; i < transparentRenderQueues.length; i++) {
                this._renderQueue(context, widthInPixels, heightInPixels, transparentRenderQueues[i], i, false);
            }
        }
    };
    /**
     * Renders the UI node tree using appropriate context settings.
     * @param {ManagedGLContext} context
     * @param {Number} widthInPixels The width of the viewport in pixels.
     * @param {Number} heightInPixels The height of the viewport in pixels.
     */
    Scene.prototype._renderUIObjects = function (context, widthInPixels, heightInPixels) {
        var originalCamera, gl = context.gl; // caching the variable for easier access
        if (this._rootUINode.isVisible() && this._rootUINode.getSubnodes().getLength() > 0) {
            // rendering UI elements based on 3D positions should work both for positions inside the front and the distance range
            originalCamera = this._camera;
            if (this._distanceRendering) {
                this._camera = this._camera.getExtendedCamera(true);
            }
            // preparing to render UI objects
            context.enableBlending();
            gl.disable(gl.DEPTH_TEST);
            context.setDepthMask(false);
            // rendering background objects
            this._rootUINode.render(context, widthInPixels, heightInPixels, false);
            gl.enable(gl.DEPTH_TEST);
            this._camera = originalCamera;
        }
    };
    /**
     * An internal method used for rendering all objects, but without any proper frame data / shadow map preparation.
     * Used multiple times within one frame for stereoscopic rendering.
     * @param {ManagedGLContext} context
     * @param {Boolean} distanceQueuesNotEmpty
     * @param {Boolean} frontQueuesNotEmpty
     * @param {Number} widthInPixels
     * @param {Number} heightInPixels
     * @param {Number} dt The time elapsed since the last render step, for animation, in milliseconds
     */
    Scene.prototype._render = function (context, distanceQueuesNotEmpty, frontQueuesNotEmpty, widthInPixels, heightInPixels, dt) {
        var gl = context.gl, clearBits, originalCamera;
        if (this._shouldClearColorOnRender) {
            context.setColorMask(this._clearColorMask);
            gl.clearColor(this._clearColor[0], this._clearColor[1], this._clearColor[2], this._clearColor[3]);
        }
        // glClear is affected by the depth mask, so we need to turn it on here!
        // (it's disabled for the second (transparent) render pass)
        context.setDepthMask(true);
        // clearing color and depth buffers as set for this scene
        clearBits = this._shouldClearColorOnRender ? gl.COLOR_BUFFER_BIT : 0;
        clearBits = this._shouldClearDepthOnRender ? clearBits | gl.DEPTH_BUFFER_BIT : clearBits;
        gl.clear(clearBits);
        // -----------------------------------------------------------------------
        // rendering the queues storing distant main objects
        if (distanceQueuesNotEmpty) {
            // switching to an extended camera
            originalCamera = this._camera;
            this._camera = this._camera.getExtendedCamera();
            this._cameraUniformsUpdated.clear();
            // dynamic lights are not support for these objects as they are not really visible but expensive
            this._clearDynamicLightUniformData();
            this._renderMainObjects(context, widthInPixels, heightInPixels, this._renderQueues[DISTANCE_OPAQUE_RENDER_QUEUES_INDEX], this._renderQueues[DISTANCE_TRANSPARENT_RENDER_QUEUES_INDEX], true);
            // switching back the camera
            this._camera = originalCamera;
            // there is no overlap in the two view frustums, simply a new blank depth buffer can be used for the front objects
            context.setDepthMask(true);
            gl.clear(gl.DEPTH_BUFFER_BIT);
            this._cameraUniformsUpdated.clear();
        }
        // -----------------------------------------------------------------------
        // rendering the queues storing front (close) main objects
        // the background objects are rendered within _renderMainObjects so it needs to be called here even
        // if there are no main objects in the scene at all 
        if (frontQueuesNotEmpty || !distanceQueuesNotEmpty) {
            // filling the arrays storing the light source data for uniforms that need it
            this._updateDynamicLightUniformData(this._shouldAnimate ? dt : 0);
            if (context.getCurrentShader()) {
                // uniforms need to be updated with the new camera and light data in case the first used shader for the front object is the
                // same as the last one used for the distant objects
                this.assignUniforms(context, context.getCurrentShader());
            }
            this._renderMainObjects(context, widthInPixels, heightInPixels, this._renderQueues[FRONT_OPAQUE_RENDER_QUEUES_INDEX], this._renderQueues[FRONT_TRANSPARENT_RENDER_QUEUES_INDEX], !distanceQueuesNotEmpty);
        }
        // -----------------------------------------------------------------------
        // rendering the UI objects
        this._renderUIObjects(context, widthInPixels, heightInPixels);
    };
    /**
     * Renders the whole scene applying the general configuration and then rendering all background and main scene objects (as well as
     * shadow maps if applicable).
     * @param {ManagedGLContext} context
     * @param {Number} dt The time elapsed since the last render step, for animation, in milliseconds
     */
    Scene.prototype.render = function (context, dt) {
        var gl = context.gl,
                frontQueuesNotEmpty, distanceQueuesNotEmpty,
                bufferWidth = gl.drawingBufferWidth,
                bufferHeight = gl.drawingBufferHeight,
                widthInPixels = bufferWidth * this._width,
                heightInPixels = bufferHeight * this._height,
                anaglyph, leftShader, rightShader,
                lightsUpdated;
        application.log_DEBUG("Rendering scene...", 3);
        egomModel.resetDebugStats();
        this._camera.setAspect(widthInPixels / heightInPixels);
        // updating camera
        if (this._shouldUpdateCamera) {
            this._camera.update(dt);
        }
        // scene uniforms will need to be updated for this frame
        this._uniformsUpdated.clear();
        this._cameraUniformsUpdated.clear();
        lightsUpdated = false;
        // if only one shader is used in rendering the whole scene, we will need to update its uniforms (as they are normally updated 
        // every time a new shader is set)
        if ((this._uniformsUpdatedForFrame === false) && context.getCurrentShader()) {
            this._updateStaticLightUniformData();
            this.assignUniforms(context, context.getCurrentShader());
            lightsUpdated = true;
        }
        this._uniformsUpdatedForFrame = false;
        // animating all the needed nodes and preparing them for rendering by organizing them to render queues
        this._renderQueues[FRONT_OPAQUE_RENDER_QUEUES_INDEX].length = 0;
        this._renderQueues[FRONT_TRANSPARENT_RENDER_QUEUES_INDEX].length = 0;
        if (this._distanceRendering) {
            this._renderQueues[DISTANCE_OPAQUE_RENDER_QUEUES_INDEX].length = 0;
            this._renderQueues[DISTANCE_TRANSPARENT_RENDER_QUEUES_INDEX].length = 0;
        }
        this._rootNode.animateAndAddToRenderQueues(this._renderQueues, this._distanceRendering, this._camera, dt);
        this.cleanUpLights(); // the animation might have removed some light sources
        frontQueuesNotEmpty = (this._renderQueues[FRONT_OPAQUE_RENDER_QUEUES_INDEX].length > 0) || (this._renderQueues[FRONT_TRANSPARENT_RENDER_QUEUES_INDEX].length > 0);
        distanceQueuesNotEmpty = this._distanceRendering && ((this._renderQueues[DISTANCE_OPAQUE_RENDER_QUEUES_INDEX].length > 0) || (this._renderQueues[DISTANCE_TRANSPARENT_RENDER_QUEUES_INDEX].length > 0));
        // rendering shadow maps
        if (frontQueuesNotEmpty) {
            this._renderShadowMaps(context, widthInPixels, heightInPixels);
            if (this._shadowMappingEnabled) {
                lightsUpdated = false;
            }
        }
        if (application.isDebugVersion()) {
            this._shadowMapDebugStats = utils.shallowCopy(egomModel.getDebugStats());
            egomModel.resetDebugStats();
        }
        if (!lightsUpdated) {
            // updating the light matrices to be consistent with the shadow maps
            this._updateStaticLightUniformData();
        }
        // viewport preparation
        gl.viewport(this._left * bufferWidth, this._bottom * bufferHeight, widthInPixels, heightInPixels);

        if (this._stereoscopicMode !== Scene.StereoscopicMode.NONE) {
            anaglyph = this._stereoscopicMode === Scene.StereoscopicMode.ANAGLYPH;
            if (anaglyph) {
                leftShader = this._redShader;
                rightShader = this._cyanShader;
            } else {
                leftShader = this._leftShader;
                rightShader = this._rightShader;
            }
            context.setCurrentFrameBuffer(STEREOSCOPY_FRAMEBUFFER_NAME);
            this._camera.setLeftEye();
            if (this._sideBySideOriginalAspect) {
                this._camera.setAspect(widthInPixels * 0.5 / heightInPixels);
            }
            this._cameraUniformsUpdated.clear();
            this._render(context, distanceQueuesNotEmpty, frontQueuesNotEmpty, widthInPixels * (anaglyph ? 1.0 : 0.5), heightInPixels, dt);
            context.setCurrentFrameBuffer(null);
            context.setCurrentShader(leftShader);
            this._stereoscopicTextureUnit = context.bindTexture(context.getFrameBuffer(STEREOSCOPY_FRAMEBUFFER_NAME), undefined, true);
            leftShader.assignUniforms(context, this._stereoscopicUniformValueFunctions);
            this._fvq.render(context, false, true);

            context.setCurrentFrameBuffer(STEREOSCOPY_FRAMEBUFFER_NAME);
            this._camera.setRightEye();
            this._cameraUniformsUpdated.clear();
            this._render(context, distanceQueuesNotEmpty, frontQueuesNotEmpty, widthInPixels * (anaglyph ? 1.0 : 0.5), heightInPixels, 0);
            context.setCurrentFrameBuffer(null);
            context.setCurrentShader(rightShader);
            rightShader.assignUniforms(context, this._stereoscopicUniformValueFunctions);
            this._fvq.render(context, false, true);
        } else {
            this._render(context, distanceQueuesNotEmpty, frontQueuesNotEmpty, widthInPixels, heightInPixels, dt);
        }
        if (this._shadowMapDebugging) {
            context.setCurrentShader(this._shadowMapDebugShader);
            this._shadowMapTextureUnit = context.bindTexture(context.getFrameBuffer(this._directionalLights[this._shadowMapDebugLightIndex].getShadowMapBufferName(this._shadowMapDebugRangeIndex)), undefined, true);
            this._shadowMapDebugShader.assignUniforms(context, this._shadowMapDebugUniformValueFunctions);
            this._fvq.render(context, false, true);
        }
        if (application.isDebugVersion()) {
            this._mainDebugStats = utils.shallowCopy(egomModel.getDebugStats());
        }
    };
    /**
     * Used during debug stats logging - increases the counter corresponding to the passed object type.
     * @param {String} objectType The object type (constructor name)
     */
    Scene.prototype.increaseCount = function (objectType) {
        this._nodeCount++;
        this._nodeCountByType[objectType] = this._nodeCountByType[objectType] || 0;
        this._nodeCountByType[objectType]++;
    };
    /**
     * Logs the structure of the scene and some statistics about it.
     */
    Scene.prototype.logNodes = function () {
        var objectTypes, i;
        application.log_DEBUG("--------------");
        this._nodeCount = 0;
        this._nodeCountByType = {};
        application.log_DEBUG("Scene structure:");
        this._rootNode.log(0);
        application.log_DEBUG("Scene statistics:");
        application.log_DEBUG("Total node count: " + this._nodeCount);
        application.log_DEBUG("Count by type:");
        objectTypes = Object.keys(this._nodeCountByType);
        for (i = 0; i < objectTypes.length; i++) {
            application.log_DEBUG("[" + objectTypes[i] + "]: " + this._nodeCountByType[objectTypes[i]]);
        }
        application.log_DEBUG("--------------");
    };
    /**
     * Returns the rendering statistics for the current frame about the scene graph in debug mode (shadow map rendering not included)
     * @returns {ModelDebugStats}
     */
    Scene.prototype.getMainDebugStats = function () {
        return this._mainDebugStats;
    };
    /**
     * Stores the rendering statistics for the current frame about the shadow maps in debug mode
     * @returns {ModelDebugStats}
     */
    Scene.prototype.getShadowMapDebugStats = function () {
        return this._shadowMapDebugStats;
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        getDebugInfo: getDebugInfo,
        LODContext: LODContext,
        RenderableNode: RenderableNode,
        Scene: Scene
    };
});
/**
 * @fileOverview Polyfill functions for better cross-browser compatibility.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @version 1.0
 */

/**********************************************************************
 Copyright 2014-2016, 2020 Krisztián Nagy
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this file.  If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/

(function polyfill() {
    "use strict";

    /**
     * Math.sign from ECMAScript 6, only implemented in Chrome and Firefox.
     * @param {Number} x
     * @returns {Number} Returns a 1 if the number is positive, -1 if it is negative,
     * 0 if it is 0, and NaN if it is not a number.
     */
    Math.sign = Math.sign || function (x) {
        x = +x; // convert to a number
        if (x === 0 || isNaN(x)) {
            return x;
        }
        return x > 0 ? 1 : -1;
    };

    /**
     * Math.log10 from ECMAScript 6, only implemented in Chrome, Firefox and recent
     * Opera.
     * @param {Number} x
     * @returns {Number}
     */
    Math.log10 = Math.log10 || function (x) {
        return Math.log(x) / Math.LN10;
    };

    /**
     * Math.log2 from ECMAScript 6, only implemented in Chrome, Firefox and recent
     * Opera.
     * @param {Number} x
     * @returns {Number}
     */
    Math.log2 = Math.log2 || function (x) {
        return Math.log(x) / Math.LN2;
    };

    /**
     * The seed of the standard random number function is not controllable, which
     * prevents consistent testing with the same pseudo random sample data. This
     * is a quick and relatively good replacement which returns a custom seeded
     * PRNG function.
     * @param {Number} s The seed the resulting function should use.
     * @returns {Function} A PRNG that returns pseudo random numbers between 0.0
     * and 1.0 with each call, and uses the supplied seed.
     */
    Math.seed = function (s) {
        return function () {
            s = Math.sin(s) * 10000;
            return s - Math.floor(s);
        };
    };

    Math.radians = function (degrees) {
        return degrees * Math.PI / 180;
    };

    Math.degrees = function (radians) {
        return radians * 180 / Math.PI;
    };

    /**
     * Number.isInteger() from ECMAScript 6, not implemented in IE and Safari.
     * @param {Number} value
     * @returns {Boolean}
     */
    Number.isInteger = Number.isInteger || function (value) {
        return typeof value === "number" &&
                isFinite(value) &&
                Math.floor(value) === value;
    };

    /**
     * @typedef {Function} arrayFindCallback
     * @param {} element
     * @param {Number} index
     * @param {Array} array
     * @returns {Boolean}
     */
    /**
     * Returns the index of the first element stored in the array that passes the given test, or -1 if no elements pass the test.
     * @param {arrayFindCallback} callback The function to test the elements.
     * @param {Object} [thisArg] If given, this will be the value of this when the test function is called.
     * @returns {Number}
     */
    Array.prototype.findIndex = Array.prototype.findIndex || function (callback, thisArg) {
        var i;
        for (i = 0; i < this.length; i++) {
            if (callback.call(thisArg || callback, this[i], i, this)) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Returns the first element stored in the array that passes the given test, or undefined if no elements pass the test.
     * @param {arrayFindCallback} callback The function to test the elements.
     * @param {Object} [thisArg] If given, this will be the value of this when the test function is called.
     * @returns {}
     */
    Array.prototype.find = Array.prototype.find || function (callback, thisArg) {
        var i;
        for (i = 0; i < this.length; i++) {
            if (callback.call(thisArg || callback, this[i], i, this)) {
                return this[i];
            }
        }
        return undefined;
    };


}());
define("utils/polyfill", function(){});

/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides functionality to parse and load the graphics settings of Interstellar Armada from an external file as well as to save them
 * to or load from HTML5 local storage and access derived settings.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, parseFloat, window, localStorage, screen */

/**
 * @param mat Used for getting the elements of identity matrices for default uniform values
 * @param types Used for type checking JSON settings and set values
 * @param application Using the application module for error displaying functionality
 * @param asyncResource GraphicsSettingsContext is an AsynchResource subclass
 * @param managedGL Used for checking valid texture filtering values
 * @param resources Used to provide resource accessor functions that access resources through this module but add parameters based on current graphics context settings
 * @param sceneGraph The graphics context creates and stores a default LODContext
 * @param constants Used to access common game constants
 */
define('armada/graphics',[
    "utils/matrices",
    "utils/types",
    "modules/application",
    "modules/async-resource",
    "modules/managed-gl",
    "modules/media-resources",
    "modules/scene/scene-graph",
    "armada/constants",
    "utils/polyfill"
], function (mat, types, application, asyncResource, managedGL, resources, sceneGraph, constants) {
    "use strict";
    var
            // --------------------------------------------------------------------------------------------
            // Constants
            /**
             * All location IDs where setting values are stored in local storage are prefixed by this value.
             * @type String
             */
            MODULE_LOCAL_STORAGE_PREFIX = constants.LOCAL_STORAGE_PREFIX + "graphics_",
            // ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
            // Configuration
            // ............................................................................................
            // Texture quality
            /**
             * The definition object for texture quality descriptors, based on which the array of descriptors defined in the config JSON
             * is type-verified.
             * @type Object
             */
            TEXTURE_QUALITY_DESCRIPTOR_TYPE = types.getNameAndValueDefinitionObject("maximumResolution"),
            // ............................................................................................
            // Model LOD
            /**
             * The definition object for model LOD descriptors, based on which the array of descriptors defined in the config JSON
             * is type-verified.
             * @type Object
             */
            LOD_LEVEL_DESCRIPTOR_TYPE = types.getNameAndValueDefinitionObject("lod"),
            // ............................................................................................
            // Shader complexity
            /**
             * The definition object for dependent shader requirement descriptors. A dependent shader requirement descriptor describes
             * shader requirements (e.g. required amount of varying vectors or texture units) that depend on values set by the game (through
             * replacing the original value in #define statements in the shader source). This basically means requirements coming from 
             * array variables (uniforms, attributes or varyings), that have an array length dependent on game variables.
             * The properties of such a descriptor refer to different variables the requirement depends on, and the values of the properties
             * give the coefficient for the dependency. Example dependent requirement descriptor:
             * "requiredVaryingsPer": {
             *   "dirLight": 2,
             *   "luminosityFactor": 3
             * }
             * This would describe that 2 varying vectors should be added to the requirements for each directional light source and 3 for 
             * each available luminosity factor index.
             * @type Object
             */
            DEPENDENT_SHADER_REQUIREMENT_DESCRIPTOR_TYPE = {
                baseType: "object",
                properties: {
                    /**
                     * Number of required vectors to be added for each available luminosity factor index.
                     */
                    LUMINOSITY_FACTOR: {
                        name: "luminosityFactor",
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * Number of required vectors to be added for each available group transform index.
                     */
                    GROUP_TRANSFORM: {
                        name: "groupTransform",
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * Number of required vectors to be added for each available directional light source.
                     */
                    DIR_LIGHT: {
                        name: "dirLight",
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * Number of required vectors to be added for each available point light source.
                     */
                    POINT_LIGHT: {
                        name: "pointLight",
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * Number of required vectors to be added for each available spot light source.
                     */
                    SPOT_LIGHT: {
                        name: "spotLight",
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * Number of required vectors to be added for each available shadow map texture.
                     */
                    SHADOW_MAP: {
                        name: "shadowMap",
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * Number of required vectors to be added for each available shadow map range.
                     */
                    SHADOW_MAP_RANGE: {
                        name: "shadowMapRange",
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * Number of required vectors to be added for each available shadow map sample. (for PCF)
                     */
                    SHADOW_MAP_SAMPLE: {
                        name: "shadowMapSample",
                        type: "number",
                        defaultValue: 0
                    }
                }
            },
            /**
             * A shortcut to access the dependent shader requirement property definition objects.
             * @type Object
             */
            DEPENDENT_SHADER_REQUIREMENT_PROPERTIES = DEPENDENT_SHADER_REQUIREMENT_DESCRIPTOR_TYPE.properties,
            /**
             * A shader requirement descriptor has a property with this name to define the number of (static) required vertex uniform vectors.
             * @type String
             */
            REQ_VERTEX_UNIFORMS_PROP_NAME = "requiredVertexUniformVectors",
            /**
             * A shader requirement descriptor has a property with this name to define the required dependent vertex uniform vectors.
             * (in a dependent shader requirement descriptor)
             * @type String
             */
            REQ_VERTEX_UNIFORMS_PER_PROP_NAME = "requiredVertexUniformVectorsPer",
            REQ_ATTRIBUTES_PROP_NAME = "requiredAttributeVectors",
            REQ_ATTRIBUTES_PER_PROP_NAME = "requiredAttributeVectorsPer",
            REQ_VARYINGS_PROP_NAME = "requiredVaryingVectors",
            REQ_VARYINGS_PER_PROP_NAME = "requiredVaryingVectorsPer",
            REQ_TEXTURE_UNITS_PROP_NAME = "requiredTextureUnits",
            REQ_TEXTURE_UNITS_PER_PROP_NAME = "requiredTextureUnitsPer",
            REQ_FRAGMENT_UNIFORMS_PROP_NAME = "requiredFragmentUniformVectors",
            REQ_FRAGMENT_UNIFORMS_PER_PROP_NAME = "requiredFragmentUniformVectorsPer",
            /**
             * The definition object used to type-verify shader requirements descriptors. A shader requirements descriptor contains all
             * static and dependent requirements of a shader from which the actual requirements can be calculated for any given combination
             * of game variable values (upon which the requirements might depend).
             * @type Object
             */
            SHADER_REQUIREMENTS_DESCRIPTOR_TYPE = {
                baseType: "object",
                properties: {
                    /**
                     * The number of static required vertex shader uniform vectors needed to compile this shader.
                     */
                    VERTEX_UNIFORM_VECTORS: {
                        name: REQ_VERTEX_UNIFORMS_PROP_NAME,
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * The dependent requirement descriptor defining the number of required dependent vertex shader uniform vectors for each 
                     * game variable they depend upon.
                     */
                    VERTEX_UNIFORM_VECTORS_PER: {
                        name: REQ_VERTEX_UNIFORMS_PER_PROP_NAME,
                        type: DEPENDENT_SHADER_REQUIREMENT_DESCRIPTOR_TYPE,
                        defaultValue: {}
                    },
                    /**
                     * The number of static required attribute vectors needed to compile this shader.
                     */
                    ATTRIBUTE_VECTORS: {
                        name: REQ_ATTRIBUTES_PROP_NAME,
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * The dependent requirement descriptor defining the number of required dependent attribute vectors for each game
                     * variable they depend upon.
                     */
                    ATTRIBUTE_VECTORS_PER: {
                        name: REQ_ATTRIBUTES_PER_PROP_NAME,
                        type: DEPENDENT_SHADER_REQUIREMENT_DESCRIPTOR_TYPE,
                        defaultValue: {}
                    },
                    /**
                     * The number of static required varying vectors needed to compile this shader.
                     */
                    VARYING_VECTORS: {
                        name: REQ_VARYINGS_PROP_NAME,
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * The dependent requirement descriptor defining the number of required dependent varying vectors for each game
                     * variable they depend upon.
                     */
                    VARYING_VECTORS_PER: {
                        name: REQ_VARYINGS_PER_PROP_NAME,
                        type: DEPENDENT_SHADER_REQUIREMENT_DESCRIPTOR_TYPE,
                        defaultValue: {}
                    },
                    /**
                     * The number of static required texture units (for the fragment shader) needed to compile this shader.
                     */
                    TEXTURE_UNITS: {
                        name: REQ_TEXTURE_UNITS_PROP_NAME,
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * The dependent requirement descriptor defining the number of required dependent texture units (for the fragment shader) 
                     * for each game variable they depend upon.
                     */
                    TEXTURE_UNITS_PER: {
                        name: REQ_TEXTURE_UNITS_PER_PROP_NAME,
                        type: DEPENDENT_SHADER_REQUIREMENT_DESCRIPTOR_TYPE,
                        defaultValue: {}
                    },
                    /**
                     * The number of static required fragment shader uniform vectors needed to compile this shader.
                     */
                    FRAGMENT_UNIFORM_VECTORS: {
                        name: REQ_FRAGMENT_UNIFORMS_PROP_NAME,
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * The dependent requirement descriptor defining the number of required dependent fragment shader uniform vectors for each 
                     * game variable they depend upon.
                     */
                    FRAGMENT_UNIFORM_VECTORS_PER: {
                        name: REQ_FRAGMENT_UNIFORMS_PER_PROP_NAME,
                        type: DEPENDENT_SHADER_REQUIREMENT_DESCRIPTOR_TYPE,
                        defaultValue: {}
                    }
                }
            },
            /**
             * A constant defining the structure of shader descriptor object, used to verify the shader complexity descriptors read from JSON.
             * @type Object
             */
            SHADER_COMPLEXITY_DESCRIPTOR_TYPE = {
                baseType: "object",
                properties: {
                    /**
                     * Identifies this shader complexity level.
                     */
                    NAME: {
                        name: "name",
                        type: "string"
                    },
                    /**
                     * Whether shadow mapping is available to turn on when this shader complexity level is used.
                     */
                    SHADOW_MAPPING_AVAILABLE: {
                        name: "shadows",
                        type: "boolean"
                    },
                    /**
                     * The number of samples to be used for shadow mapping PCF when this shader complexity is used.
                     */
                    NUM_SHADOW_MAP_SAMPLES: {
                        name: "numShadowMapSamples",
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * Whether dynamic lights are available to turn on when this shader complexity level is used.
                     */
                    DYNAMIC_LIGHTS_AVAILABLE: {
                        name: "dynamicLights",
                        type: "boolean"
                    },
                    /**
                     * The number of maximum available directional light sources when this shader complexity is used.
                     */
                    MAX_DIR_LIGHTS: {
                        name: "maxDirLights",
                        type: "number"
                    },
                    /**
                     * The number of maximum available spot light sources (for dynamic lighting) when this shader complexity is used.
                     */
                    MAX_SPOT_LIGHTS: {
                        name: "maxSpotLights",
                        type: "number",
                        defaultValue: 0
                    },
                    /**
                     * Whether luminosity textures are available when this shader complexity level is used.
                     */
                    LUMINOSITY_TEXTURES_AVAILABLE: {
                        name: "luminosityTextures",
                        type: "boolean"
                    },
                    /**
                     * Whether the reveal feature is available when this shader complexity level is used.
                     */
                    REVEAL_AVAILABLE: {
                        name: "reveal",
                        type: "boolean"
                    },
                    /**
                     * The object describing the base requirements of this shader complexity level (without any of the features (shadow mapping, 
                     * dynamic lights...) being turned on.
                     */
                    REQUIREMENTS: {
                        name: "requirements",
                        type: SHADER_REQUIREMENTS_DESCRIPTOR_TYPE
                    }
                }
            },
            /**
             * A shortcut to access the shader complexity property definition objects.
             * @type Object
             */
            SHADER_COMPLEXITY_PROPERTIES = SHADER_COMPLEXITY_DESCRIPTOR_TYPE.properties,
            /**
             * The array of shader complexity descriptors will be read from the property with this name in the shader settings JSON.
             * @type String
             */
            SHADER_COMPLEXITIES_PROPERTY_NAME = "complexities",
            /**
             * Describes the structure of the shader configuration descriptor object read from the configuration JSON file.
             * @type Object
             */
            SHADER_CONFIG = {
                /**
                 * The shader requirements that should be added on top of the base requirement of the selected shader complexity level when
                 * the various features are turned on.
                 */
                FEATURE_REQUIREMENTS: {
                    name: "featureRequirements",
                    type: "object",
                    properties: {
                        /**
                         * Requirements to be added when shadow mapping is turned on.
                         */
                        SHADOWS: {
                            name: "shadows",
                            type: SHADER_REQUIREMENTS_DESCRIPTOR_TYPE
                        },
                        /**
                         * Requirements to be added when dynamic lights are turned on.
                         */
                        DYNAMIC_LIGHTS: {
                            name: "dynamicLights",
                            type: SHADER_REQUIREMENTS_DESCRIPTOR_TYPE
                        },
                        /**
                         * Requirements to be added when reveal is turned on (which automatically happens when it is available)
                         */
                        REVEAL: {
                            name: "reveal",
                            type: SHADER_REQUIREMENTS_DESCRIPTOR_TYPE
                        }
                    }
                },
                /**
                 * The array storing the descriptors for the available shader complexities, from the least complex to the most complex.
                 */
                COMPLEXITIES: {
                    name: SHADER_COMPLEXITIES_PROPERTY_NAME,
                    type: "array",
                    elementType: SHADER_COMPLEXITY_DESCRIPTOR_TYPE,
                    minLength: 1
                },
                /**
                 * Name of the shader that should be used when rendering the shadow maps.
                 */
                SHADOW_MAPPING_SHADER_NAME: {
                    name: "shadowMappingShaderName",
                    type: "string"
                },
                /**
                 * Name of the #define that determines the maximum number of directional lights in shaders.
                 */
                MAX_DIR_LIGHTS_DEFINE_NAME: {
                    name: "maxDirLightsDefineName",
                    type: "string"
                },
                /**
                 * The name of the #define that determines the maximum number of dynamic point lights in shaders.
                 */
                MAX_POINT_LIGHTS_DEFINE_NAME: {
                    name: "maxPointLightsDefineName",
                    type: "string"
                },
                /**
                 * The name of the #define that determines the maximum number of dynamic spot lights in shaders.
                 * @type String
                 */
                MAX_SPOT_LIGHTS_DEFINE_NAME: {
                    name: "maxSpotLightsDefineName",
                    type: "string"
                },
                /**
                 * The divisor of the dust particle length in shaders. The original value defined in the shader is replaced by this value, 
                 * and since it has to be strictly given in floating point format for the shader to compile, it is defined as a string here.
                 */
                DUST_LENGTH_DIVISOR: {
                    name: "dustLengthDivisor",
                    type: "string"
                },
                /**
                 * The name of the #define that determines the divisor by which the length of dust particles is divided.
                 */
                DUST_LENGTH_DIVISOR_DEFINE_NAME: {
                    name: "dustLengthDivisorDefineName",
                    type: "string"
                },
                /**
                 * The maximum amount of luminosity factors (length of the respective uniform variable) available to shaders.
                 */
                MAX_LUMINOSITY_FACTORS: {
                    name: "maxLuminosityFactors",
                    type: "number"
                },
                /**
                 * The name of the #define that determines the maximum amount of luminosity factors available to shaders.
                 */
                MAX_LUMINOSITY_FACTORS_DEFINE_NAME: {
                    name: "maxLuminosityFactorsDefineName",
                    type: "string"
                },
                /**
                 * The maximum amount of group transforms (length of the respective uniform variable) available to shaders.
                 */
                MAX_GROUP_TRANSFORMS: {
                    name: "maxGroupTransforms",
                    type: "number"
                },
                /**
                 * The name of the #define that determines the maximum amount of group transforms available to shaders.
                 */
                MAX_GROUP_TRANSFORMS_DEFINE_NAME: {
                    name: "maxGroupTransformsDefineName",
                    type: "string"
                },
                /**
                 * The name of the #define that determines the maximum number of available shadow map ranges (for each directional light 
                 * source) in shaders.
                 */
                MAX_SHADOW_MAP_RANGES_DEFINE_NAME: {
                    name: "maxShadowMapRangesDefineName",
                    type: "string"
                },
                /**
                 * The name of the #define that determines the maximum number of available shadow maps (which will be set to maximum number
                 * of light sources * maximum number of shadow map ranges) in shaders.
                 */
                MAX_SHADOW_MAPS_DEFINE_NAME: {
                    name: "maxShadowMapsDefineName",
                    type: "string"
                },
                /**
                 * The name of the #define that determines how many samples of shadow maps should be taken and averaged to determine how
                 * much a certain point is in shadow. (PCF)
                 */
                NUM_SHADOW_MAP_SAMPLES_DEFINE_NAME: {
                    name: "numShadowMapSamplesDefineName",
                    type: "string"
                },
                /**
                 * The name of the #define that informs the shader whether depth textures are used (1) or not (0).
                 */
                DEPTH_TEXTURES_DEFINE_NAME: {
                    name: "depthTexturesDefineName",
                    type: "string"
                },
                /**
                 * The shininess (specular exponent) of fragments is determined by the value of the alpha component of the specular texture.
                 * Since that is a value in the range 0-1, it is multiplied by this number to get a useful exponent.
                 */
                MAX_SHININESS: {
                    name: "maxShininess",
                    type: "string"
                },
                /**
                 * The name of the #define that detemines tha maximum shininess
                 */
                MAX_SHININESS_DEFINE_NAME: {
                    name: "maxShininessDefineName",
                    type: "string"
                },
                /**
                 * The minimum near value for Light-Space Perspective Shadow Mapping (the value to replace the shader #define value with)
                 */
                LISPSM_MINIMUM_NEAR: {
                    name: "lispsmMinimumNear",
                    type: "string"
                },
                /**
                 * The name of the #define that detemines the minimum near value for Light-Space Perspective Shadow Mapping
                 */
                LISPSM_MINIMUM_NEAR_DEFINE_NAME: {
                    name: "lispsmMinimumNearDefineName",
                    type: "string"
                },
                /**
                 * The near factor for Light-Space Perspective Shadow Mapping (the value to replace the shader #define value with)
                 */
                LISPSM_NEAR_FACTOR: {
                    name: "lispsmNearFactor",
                    type: "string"
                },
                /**
                 * The name of the #define that detemines the near factor for Light-Space Perspective Shadow Mapping
                 */
                LISPSM_NEAR_FACTOR_DEFINE_NAME: {
                    name: "lispsmNearFactorDefineName",
                    type: "string"
                },
                /**
                 * Name of the shader that should be used when rendering the red filtered part of the anaglyph scene (for the left eye)
                 */
                ANAGLYPH_RED_SHADER_NAME: {
                    name: "anaglyphRedShaderName",
                    type: "string"
                },
                /**
                 * Name of the shader that should be used when rendering the cyan filtered part of the anaglyph scene (for the right eye)
                 */
                ANAGLYPH_CYAN_SHADER_NAME: {
                    name: "anaglyphCyanShaderName",
                    type: "string"
                },
                /**
                 * Name of the shader that should be used when rendering the left part of the side by side stereoscopic scene (for the left eye)
                 */
                SIDE_BY_SIDE_LEFT_SHADER_NAME: {
                    name: "sideBySideLeftShaderName",
                    type: "string"
                },
                /**
                 * Name of the shader that should be used when rendering the right part of the side by side stereoscopic scene (for the right eye)
                 */
                SIDE_BY_SIDE_RIGHT_SHADER_NAME: {
                    name: "sideBySideRightShaderName",
                    type: "string"
                },
                /**
                 * Name of the shader that should be used when rendering the shadow map on screen for debug purposes
                 */
                SHADOW_MAP_DEBUG_SHADER_NAME: {
                    name: "shadowMapDebugShaderName",
                    type: "string"
                },
                /**
                 * When coloring objects for an anaglyph stereoscopic scene, the color is a mix of the original color and the luminance
                 * of the object (filtered with red/cyan), where the ratio of the original is as given in this define
                 */
                ANAGLYPH_ORIGINAL_COLOR_RATIO: {
                    name: "anaglyphOriginalColorRatio",
                    type: "string"
                },
                /**
                 * The name of the #define that detemines tha anaglyph original color ratio
                 */
                ANAGLYPH_ORIGINAL_COLOR_RATIO_DEFINE_NAME: {
                    name: "anaglyphOriginalColorRatioDefineName",
                    type: "string"
                },
                /**
                 * The value for the gamma correction applied on anaglyph stereoscopic scenes to compensate for the lower brightness
                 * of the color-filtered images
                 */
                ANAGLYPH_GAMMA: {
                    name: "anaglyphGamma",
                    type: "string"
                },
                /**
                 * The name of the #define that detemines tha anaglyph gamma value
                 */
                ANAGLYPH_GAMMA_DEFINE_NAME: {
                    name: "anaglyphGammaDefineName",
                    type: "string"
                },
                /**
                 * When coloring objects for an anaglyph stereoscopic scene, the luminance calculated for the cyan side gets corrected
                 * using this factor (to compansate that cyan is seen brighter by the human eye)
                 */
                ANAGLYPH_CYAN_FACTOR: {
                    name: "anaglyphCyanFactor",
                    type: "string"
                },
                /**
                 * The name of the #define that detemines tha anaglyph cyan factor
                 */
                ANAGLYPH_CYAN_FACTOR_DEFINE_NAME: {
                    name: "anaglyphCyanFactorDefineName",
                    type: "string"
                }
            },
            /**
             * A shortcut to access the shader feature requirements property definition objects.
             * @type Object
             */
            FEATURE_REQUIREMENTS_PROPERTIES = SHADER_CONFIG.FEATURE_REQUIREMENTS.properties,
            // ............................................................................................
            // Shadow distance (number of used shadow map ranges)
            /**
             * The definition object for shadow distance descriptors, based on which the array of descriptors defined in the config JSON
             * is type-verified.
             * @type Object
             */
            SHADOW_DISTANCE_DESCRIPTOR_TYPE = types.getNameAndValueDefinitionObject("numRanges"),
            // ............................................................................................
            // Amount of dynamic (point) lights
            /**
             * The definition object for dynamic light amount descriptors, based on which the array of descriptors defined in the config JSON
             * is type-verified.
             * @type Object
             */
            DYNAMIC_LIGHT_AMOUNT_DESCRIPTOR_TYPE = types.getNameAndValueDefinitionObject("maxLights"),
            // ............................................................................................
            // Amount of dust particles
            /**
             * The definition object for particle amount descriptors, based on which the arrays of descriptors defined in the config JSON
             * are type-verified.
             * @type Object
             */
            PARTICLE_AMOUNT_DESCRIPTOR_TYPE = types.getNameAndValueDefinitionObject("particleCountFactor"),
            // ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
            // Settings
            /**
             * The key identifying the location where the general level setting is stored in local storage.
             * @type String
             */
            GENERAL_LEVEL_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "generalLevel",
            // ............................................................................................
            // Antialiasing
            /**
             * The key identifying the location where the antialiasing setting is stored in local storage.
             * @type String
             */
            ANTIALIASING_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "antialiasing",
            // ............................................................................................
            // Texture filtering
            /**
             * The key identifying the location where the texture filtering setting is stored in local storage.
             * @type String
             */
            FILTERING_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "filtering",
            /**
             * If the texture filtering setting loaded from file or local storage specifies anisotropic filtering, but it is not supported
             * by the hardware, this filtering mode will be used instead.
             * @type String
             */
            ANISOTROPIC_FALLBACK_FILTERING = managedGL.TextureFiltering.TRILINEAR,
            // ............................................................................................
            // Texture quality
            /**
             * The key identifying the location where the texture quality setting is stored in local storage.
             * @type String
             */
            TEXTURE_QUALITY_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "textureQuality",
            // ............................................................................................
            // Cubemap quality
            /**
             * The key identifying the location where the cubemap quality setting is stored in local storage.
             * @type String
             */
            CUBEMAP_QUALITY_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "cubemapQuality",
            // ............................................................................................
            // Model LOD
            /**
             * The key identifying the location where the highest displayed model LOD setting is stored in local storage.
             * @type String
             */
            MAX_LOD_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "maxLOD",
            // ............................................................................................
            // Show missiles in launchers
            /**
             * The key identifying the location where the visibility of loaded missiles in launchers setting is stored in local storage.
             * @type String
             */
            MISSILES_IN_LAUNCHERS_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "missilesInLaunchers",
            // ............................................................................................
            // Shader complexity
            /**
             * The key identifying the location where the shader complexity level setting is stored in local storage.
             * @type String
             */
            SHADER_COMPLEXITY_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "shaderComplexity",
            // ............................................................................................
            // Shadow mapping
            /**
             * The key identifying the location where the shader mapping setting (whether shadow mapping is enabled) is stored in local 
             * storage.
             * @type String
             */
            SHADOW_MAPPING_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "shadowMapping",
            // ............................................................................................
            // Shadow map quality (texture size)
            /**
             * The key identifying the location where the shader map quality setting is stored in local storage.
             * @type String
             */
            SHADOW_MAP_QUALITY_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "shadowQuality",
            // ............................................................................................
            // Shadow distance (number of used shadow map ranges)
            /**
             * The key identifying the location where the shader distance setting is stored in local storage.
             * @type String
             */
            SHADOW_DISTANCE_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "shadowDistance",
            // ............................................................................................
            // Amount of dynamic (point) lights
            /**
             * The key identifying the location where the point light amount setting is stored in local storage.
             * @type String
             */
            POINT_LIGHT_AMOUNT_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "pointLightAmount",
            // ............................................................................................
            // Amount of particles (for particle systems)
            /**
             * The key identifying the location where the particle amount setting is stored in local storage.
             * @type String
             */
            PARTICLE_AMOUNT_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "particleAmount",
            // ............................................................................................
            // Amount of dust particles
            /**
             * The key identifying the location where the dust particle amount setting is stored in local storage.
             * @type String
             */
            DUST_PARTICLE_AMOUNT_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "dustParticleAmount",
            // ............................................................................................
            /**
             * Shaders that implement the same function but without shadows should be referenced among the variant shaders with this type key
             * @type String
             */
            SHADER_VARIANT_WITHOUT_SHADOWS_NAME = "withoutShadows",
            /**
             * Shaders that implement the same function but without dynamic lights should be referenced among the variant shaders with this type key
             * @type String
             */
            SHADER_VARIANT_WITHOUT_DYNAMIC_LIGHTS_NAME = "withoutDynamicLights",
            /**
             * Callbacks to execute when the graphics settings change (not called automatically, call handleSettingsChanged() to execute when after
             * all the changes needed were done)
             * @type Function[]
             */
            _changeHandlers = [],
            /**
             * Stores a default context the methods of which are exposed in the interface of this module.
             * @type GraphicsSettingsContext
             */
            _context;
    // --------------------------------------------------------------------------------------------
    // Private functions dealing with shader requirements
    /**
     * Calculates and returns a shader requirement (such as number of required varying vectors) that depend on game variables uring the
     * supplied values of those game variables.
     * @param {Object} dependentRequirementDescriptor An object describing the dependencies of this requirement. The structure of this 
     * object is defined in DEPENDENT_SHADER_REQUIREMENT_DESCRIPTOR_TYPE. Example: {"dirLight": 2} -> 2 units (e.g. varying vectors) of this 
     * requirement should be added for each available directional light source. 
     * Has to include all the possible dependencies as properties (even if 0).
     * @param {Object} params Has to contain the values for the game variables that the requirement depends upon. Example: {"dirLight": 4}
     * would mean that the game has currently 4 directional light sources available. Should have the same structure as the other parameter.
     * @returns {Number}
     */
    function _getDependentShaderRequirement(dependentRequirementDescriptor, params) {
        var propertyDescriptorName, propertyDescriptor, result = 0;
        for (propertyDescriptorName in DEPENDENT_SHADER_REQUIREMENT_PROPERTIES) {
            if (DEPENDENT_SHADER_REQUIREMENT_PROPERTIES.hasOwnProperty(propertyDescriptorName)) {
                propertyDescriptor = DEPENDENT_SHADER_REQUIREMENT_PROPERTIES[propertyDescriptorName];
                if (params.hasOwnProperty(propertyDescriptor.name)) {
                    result += dependentRequirementDescriptor[propertyDescriptor.name] * params[propertyDescriptor.name];
                }
            }
        }
        return result;
    }
    /**
     * Returns a valid shader requirements object containing the actual shader requirements for a particular set of game variable values, by 
     * adding up the static requirements and the dependent requirements described in a requirements descriptor object.
     * @param {Object} requirementsDescriptor An object describing all static and and dependent requirements (for a certain shader 
     * complexity level or shader feature) in a structure defined by SHADER_REQUIREMENTS_DESCRIPTOR_TYPE.
     * @param {Object} params An object describing the current values of game variables that the requirements might depend upon, in a 
     * structure defined by DEPENDENT_SHADER_REQUIREMENT_DESCRIPTOR_TYPE.
     * @returns {ManagedShader~ShaderRequirements}
     */
    function _getShaderRequirementsFromDescriptor(requirementsDescriptor, params) {
        return {
            requiredVertexUniformVectors:
                    requirementsDescriptor[REQ_VERTEX_UNIFORMS_PROP_NAME] +
                    _getDependentShaderRequirement(requirementsDescriptor[REQ_VERTEX_UNIFORMS_PER_PROP_NAME], params),
            requiredAttributeVectors:
                    requirementsDescriptor[REQ_ATTRIBUTES_PROP_NAME] +
                    _getDependentShaderRequirement(requirementsDescriptor[REQ_ATTRIBUTES_PER_PROP_NAME], params),
            requiredVaryingVectors:
                    requirementsDescriptor[REQ_VARYINGS_PROP_NAME] +
                    _getDependentShaderRequirement(requirementsDescriptor[REQ_VARYINGS_PER_PROP_NAME], params),
            requiredTextureUnits:
                    requirementsDescriptor[REQ_TEXTURE_UNITS_PROP_NAME] +
                    _getDependentShaderRequirement(requirementsDescriptor[REQ_TEXTURE_UNITS_PER_PROP_NAME], params),
            requiredFragmentUniformVectors:
                    requirementsDescriptor[REQ_FRAGMENT_UNIFORMS_PROP_NAME] +
                    _getDependentShaderRequirement(requirementsDescriptor[REQ_FRAGMENT_UNIFORMS_PER_PROP_NAME], params)
        };
    }
    /**
     * Adds up two sets of shader requirements and returns the resulting combined requirement set.
     * @param {ManagedShader~ShaderRequirements} r
     * @param {ManagedShader~ShaderRequirements} s
     * @returns {ManagedShader~ShaderRequirements}
     */
    function _getCombinedRequirements(r, s) {
        return {
            requiredVertexUniformVectors: r.requiredVertexUniformVectors + s.requiredVertexUniformVectors,
            requiredAttributeVectors: r.requiredAttributeVectors + s.requiredAttributeVectors,
            requiredVaryingVectors: r.requiredVaryingVectors + s.requiredVaryingVectors,
            requiredTextureUnits: r.requiredTextureUnits + s.requiredTextureUnits,
            requiredFragmentUniformVectors: r.requiredFragmentUniformVectors + s.requiredFragmentUniformVectors
        };
    }
    // ############################################################################################
    /**
     * @class 
     * Handles a set of options that have a numeric value as well as a name (a string ID) and the values have a meaningful order.
     * @param {Array} list The array of objects that contain the names and values of the different options.
     * @param {Object} optionDescriptorType The object that describes the structure of one element in the passed array, with a NAME 
     * property that gives the name of the property containing the name (string ID) of the option and a VALUE property that gives the name
     * property containing the value of the option. The format of this option is the same as the definition objects used by types.js.
     * (example: {NAME: {name: "name", type: "string"}, VALUE: {name: "numericValue", type: "number"}})
     * @param {String} [name] Identification of what these options stand for. Used in error messages in case the provided list does not pass
     * type verification.
     * @param {Number} [limit] If given, options (the numeric value of which) pass this limit will not be included from the passed list.
     */
    function OrderedNamedNumericOptions(list, optionDescriptorType, name, limit) {
        /**
         * The array of object storing the name-value pairs of the options.
         * @type Array
         */
        this._list = list ? types.getArrayValue(
                name || "OrderedNamedNumericOptions.list",
                list,
                optionDescriptorType,
                null,
                {minLength: 1},
                []) : [];
        /**
         * The name of the property which contains the name of the option in the elements of the stored list.
         * @type String
         */
        this._optionNamePropertyName = optionDescriptorType ? optionDescriptorType.properties.NAME.name : null;
        /**
         * The name of the property which contains the numeric value of the option in the elements of the stored list.
         * @type String
         */
        this._optionValuePropertyName = optionDescriptorType ? optionDescriptorType.properties.VALUE.name : null;
        this._list.sort(function (a, b) {
            return a[this._optionValuePropertyName] - b[this._optionValuePropertyName];
        }.bind(this));
        /**
         * The currently selected option in the list.
         * @type Number
         */
        this._currentIndex = this._list.length - 1;
        if (limit) {
            this.applyLimit(limit);
        }
    }
    /**
     * Use this on one element of the stored list to retrieve its name.
     * @param {Object} element
     * @returns {String}
     */
    OrderedNamedNumericOptions.prototype._getNameFunction = function (element) {
        return element[this._optionNamePropertyName];
    };
    /**
     * Use this on one element of the stored list to check whether its name equals the passed value.
     * @param {String} name
     * @param {Object} element
     * @returns {Boolean}
     */
    OrderedNamedNumericOptions.prototype._checkNameFunction = function (name, element) {
        return element[this._optionNamePropertyName] === name;
    };
    /**
     * Use this on one element of the stored list to check whether its numeric value is within the passed limit.
     * @param {Number} limit
     * @param {Object} element
     * @returns {Boolean}
     */
    OrderedNamedNumericOptions.prototype._isWithinLimitFunction = function (limit, element) {
        return element[this._optionValuePropertyName] <= limit;
    };
    /**
     * @typedef {Function} OrderedNamedNumericOptions~valueFilterFunction
     * @param {Number} value
     * @returns {Boolean}
     */
    /**
     * Use this on one element of the stored list to filter it using a supplied filter function that will receive the numeric value of the
     * element.
     * @param {OrderedNamedNumericOptions~valueFilterFunction} valueFilterFunction
     * @param {Object} element
     * @returns {Boolean}
     */
    OrderedNamedNumericOptions.prototype._valueFilterFunction = function (valueFilterFunction, element) {
        return valueFilterFunction(element[this._optionValuePropertyName]);
    };
    /**
     * Returns an error message explaining that a non-existent option name was specified.
     * @param {String} name The name by which an option was attempted to be accessed. (and which is not in the list)
     * @returns {String}
     */
    OrderedNamedNumericOptions.prototype._getInvalidOptionAccessErrorMessage = function (name) {
        return "Invalid option (" + this._optionValuePropertyName + ") '" + name + "' specified! Valid values are: " + this.getNameList().join(", ") + ".";
    };
    /**
     * Return an array containing the names of all the stored options in order.
     * @returns {Array}
     */
    OrderedNamedNumericOptions.prototype.getNameList = function () {
        return this._list.map(this._getNameFunction.bind(this));
    };
    /**
     * Returns an array containing the names of the stored options that pass the given numeric filter function.
     * @param {OrderedNamedNumericOptions~valueFilterFunction} valueFilterFunction
     * @returns {Array}
     */
    OrderedNamedNumericOptions.prototype.getFilteredNameList = function (valueFilterFunction) {
        return this._list.filter(this._valueFilterFunction.bind(this, valueFilterFunction)).map(this._getNameFunction.bind(this));
    };
    /**
     * Selects the option from the stored list that is identified by the passed name and remembers the selection.
     * @param {String} name The name of the option to be selected.
     * @param {Boolean} [fallbackToHighest=false] If true, then in case there is no option in the list with the given name, instead of 
     * showing an error message, the last option (the one with the highest numeric value) will be selected.
     * @returns {Boolean} Whether a valid option was be selected.
     */
    OrderedNamedNumericOptions.prototype.setCurrent = function (name, fallbackToHighest) {
        this._currentIndex = this._list.findIndex(this._checkNameFunction.bind(this, name));
        if ((this._currentIndex < 0) && fallbackToHighest) {
            this._currentIndex = this._list.length - 1;
        }
        if (this._currentIndex < 0) {
            application.showError(this._getInvalidOptionAccessErrorMessage(name));
            return false;
        }
        return true;
    };
    /**
     * Returns the name of the currently selected option.
     * @returns {String|null}
     */
    OrderedNamedNumericOptions.prototype.getCurrentName = function () {
        return this._currentIndex >= 0 ? this._list[this._currentIndex][this._optionNamePropertyName] : null;
    };
    /**
     * Returns the numeric value of the currently selected option.
     * @returns {Number|null}
     */
    OrderedNamedNumericOptions.prototype.getCurrentValue = function () {
        return this._currentIndex >= 0 ? this._list[this._currentIndex][this._optionValuePropertyName] : 0;
    };
    /**
     * Returns the numeric value that belongs to the option with the passed name.
     * @param {String} name
     * @returns {Number}
     */
    OrderedNamedNumericOptions.prototype.getValueForName = function (name) {
        var index = this._list.findIndex(this._checkNameFunction.bind(this, name));
        if (index >= 0) {
            return this._list[index][this._optionValuePropertyName];
        }
        application.showError(this._getInvalidOptionAccessErrorMessage(name));
        return 0;
    };
    /**
     * Removes the options from the stored list the numeric value of which surpass the given limit. If the currently selected option is
     * removed, the last (highest) option will be selected instead.
     * @param {Number} limit
     */
    OrderedNamedNumericOptions.prototype.applyLimit = function (limit) {
        var originalName = this.getCurrentName();
        this._list = this._list.filter(this._isWithinLimitFunction.bind(this, limit));
        if (this._currentIndex >= this._list.length) {
            this._currentIndex = this._list.length - 1;
            application.log_DEBUG("Setting (" + this._optionValuePropertyName + ") changed to '" + this.getCurrentName() + "' from '" + originalName + "' as a result of limiting the setting to " + limit + ".", 1);
        }
    };
    /**
     * Selects the option right before the currently selected option, if possible.
     * @returns {Boolean} Whether a lower option could be selected.
     */
    OrderedNamedNumericOptions.prototype.decrease = function () {
        if (this._currentIndex > 0) {
            this._currentIndex--;
            return true;
        }
        return false;
    };
    /**
     * Selects the first option (having the lowest value) in the list.
     */
    OrderedNamedNumericOptions.prototype.setLowest = function () {
        this._currentIndex = 0;
    };
    /**
     * Returns the numeric value of the first (lowest) option in the stored list.
     * @returns {Number}
     */
    OrderedNamedNumericOptions.prototype.getFirstValue = function () {
        return this._list[0][this._optionValuePropertyName];
    };
    // ############################################################################################
    /**
     * @class 
     * Handles a list of possible texture qualities, storing an identifying name and the maximum texture
     * resolution for each quality level.
     * @extends OrderedNumbericOptions
     * @param {Array} list See OrderedNamedNumericOptions.
     * @param {String} [name] See OrderedNamedNumericOptions.
     * @param {Number} [maxResolution] An initial limit on the maximum resolution to be applied. Quality levels
     * with a maximum resolution higher than this will not be included in the stored list.
     */
    function TextureQuality(list, name, maxResolution) {
        OrderedNamedNumericOptions.call(this, list, TEXTURE_QUALITY_DESCRIPTOR_TYPE, name, maxResolution);
        /**
         * An array storing the quality levels in the (descending) order of preference for when choosing the most fitting quality level of
         * a given texture (which might not be available in the exact quality level that is selected)
         * Currently, this will start with the selected quality level, then contain all lower quality levels in descending order and finally
         * all higher quality levels in ascending order.
         * @type Array
         */
        this._preferenceList = null;
        /**
         * The cached list of quality level names in the order of preference.
         * @type String[]
         */
        this._preferenceNameList = null;
        this._updatePreferenceList();
    }
    TextureQuality.prototype = new OrderedNamedNumericOptions();
    TextureQuality.prototype.constructor = TextureQuality;
    /**
     * Generates and stores a new preference list based on the currently selected quality.
     */
    TextureQuality.prototype._updatePreferenceList = function () {
        var i;
        this._preferenceList = [];
        for (i = this._currentIndex; i >= 0; i--) {
            this._preferenceList.push(this._list[i]);
        }
        for (i = this._currentIndex + 1; i < this._list.length; i++) {
            this._preferenceList.push(this._list[i]);
        }
        this._preferenceNameList = this._preferenceList.map(this._getNameFunction.bind(this));
    };
    /**
     * @override
     * @param {String} name
     * @param {Boolean} [fallbackToHighest=false]
     * @returns {Boolean}
     */
    TextureQuality.prototype.setCurrent = function (name, fallbackToHighest) {
        var result;
        result = OrderedNamedNumericOptions.prototype.setCurrent.call(this, name, fallbackToHighest);
        this._updatePreferenceList();
        return result;
    };
    /**
     * Returns the names of the stored texture quality levels in the order of preference (to choose the most fitting texture quality for a
     * texture that is not available in the exact selected quality)
     * @returns {Array}
     */
    TextureQuality.prototype.getPreferenceNameList = function () {
        return this._preferenceNameList;
    };
    /**
     * @override
     * @param {Number} limit
     */
    TextureQuality.prototype.applyLimit = function (limit) {
        OrderedNamedNumericOptions.prototype.applyLimit.call(this, limit);
        this._updatePreferenceList();
    };
    // ############################################################################################
    /**
     * @class Can load, store, save, and modify a set of graphics settings and provide their current values for other game modules.
     * @extends AsyncResource
     */
    function GraphicsSettingsContext() {
        asyncResource.AsyncResource.call(this);
        /**
         * The JSON object storing the default graphics settings.
         * @type Object
         */
        this._dataJSON = null;
        /**
         * The current antialiasing setting.
         * @type Boolean
         */
        this._antialiasing = false;
        /**
         * (enum managedGL.TextureFiltering) The current texture filtering setting.
         * @type String
         */
        this._filtering = null;
        /**
         * The available and current model LOD levels.
         * @type OrderedNamedNumericOptions
         */
        this._lodLevel = null;
        /**
         * The maximum level of detail for which the model files should be loaded.
         * @type Number
         */
        this._maxLoadedLOD = 0;
        /**
         * The currently active LOD context.
         * @type LODContext
         */
        this._lodContext = null;
        /**
         * Whether loaded missiles should be visible in their launch tubes.
         * @type Boolean
         */
        this._missilesInLaunchers = false;
        /**
         * The currently set and available texture qualities.
         * @type TextureQuality
         */
        this._textureQuality = null;
        /**
         * The currently set and available cubemap qualities.
         * @type TextureQuality
         */
        this._cubemapQuality = null;
        /**
         * Whether shadow mapping is currently enabled.
         * @type Boolean
         */
        this._shadowMappingEnabled = false;
        /**
         * The currently set and available shadow map texture qualities.
         * @type TextureQuality
         */
        this._shadowMapQuality = null;
        /**
         * The list of ranges (distance from center to the sides, in game world
         * space coordinates) that the shadow maps generated for one light source
         * should cover. Must be in ascending order.
         * @type Number[]
         */
        this._shadowRanges = null;
        /**
         * The available and currently set shadow distance levels (governing how many shadow map ranges should be active)
         * @type OrderedNamedNumericOptions
         */
        this._shadowDistances = null;
        /**
         * The depth coverage of each shadow map should equal twice the range of the shadow map (as range refers to the distance from the
         * center to the sides) multiplied by this factor.
         * @type Number
         */
        this._shadowDepthRatio = 0;
        /**
         * The available and currently set maximum amount for dynamic point lights.
         * @type OrderedNamedNumericOptions
         */
        this._pointLightAmount = null;
        /**
         * The available and currently set amount (factor) for particle count in particle systems.
         * @type OrderedNamedNumericOptions
         */
        this._particleAmount = null;
        /**
         * The available and currently set amount (factor) for dust particle count.
         * @type OrderedNamedNumericOptions
         */
        this._dustParticleAmount = null;
        /**
         * An object storing all the configuration settings for this context (such as lists of valied values for the different options)
         * @type Object
         */
        this._shaderConfig = null;
        /**
         * The string ID of the currently selected shader complexity level.
         * @type String
         */
        this._shaderComplexity = null;
        /**
         * A cached value storing whether luminosity texture are available at the current shader complexity.
         * @type Boolean
         */
        this._luminosityTextureAreAvailable = false;
        /**
         * Precalculated value of an array containing as many identity matrices (flattened into a single one dimensional array) as the
         * number of available transform groups.
         * @type Float32Array
         */
        this._groupTransformIdentityArray = null;
        /**
         * An object storing the general graphics quality levels, the names of the properties are the level string IDs (e.g. "low", "medium"...),
         * the values are objects storing all the graphics settings the same way the default settings are stored
         * @type Object
         */
        this._generalLevels = null;
        /**
         * The string ID of the general graphics quality level that has been last set (with all its corresponding settings), if any.
         * Not updated automatically as specific settings are changed, needs to be changed separately.
         * @type String
         */
        this._currentGeneralLevel = null;
    }
    GraphicsSettingsContext.prototype = new asyncResource.AsyncResource();
    GraphicsSettingsContext.prototype.constructor = GraphicsSettingsContext;
    /**
     * @typedef {Object} GraphicsSettingsContext~CustomShaderRequirementsParams
     * @property {Number} [numPointLights]
     * @property {Number} [numShadowRanges]
     * @property {Number} [complexityLevelIndex]
     */
    /**
     * Returns the set of shader requirements valid for the current graphics settings stored in this context.
     * @param {GraphicsSettingsContext~CustomShaderRequirementsParams} [params] Certain game variable values to be taken into account when 
     * calculating the requirements dependent upon them can be overridden by the values provided in this parameter. An index for a 
     * different shader complexity than the currently selected one can also be provided here so that it will be taken as the base for
     * the requirements.
     * @returns {ManagedShader~ShaderRequirements}
     */
    GraphicsSettingsContext.prototype._getShaderRequirements = function (params) {
        params = params || {};
        var
                complexityDescriptor = this._getShaderComplexityDescriptor(params.complexityLevelIndex),
                featureRequirementsDescriptor = this.getShaderConfig(SHADER_CONFIG.FEATURE_REQUIREMENTS),
                numDirLights = complexityDescriptor[SHADER_COMPLEXITY_PROPERTIES.MAX_DIR_LIGHTS.name],
                numPointLights = (params.numPointLights === undefined) ? this.getMaxPointLights() : params.numPointLights,
                numSpotLights = (numPointLights > 0) ? complexityDescriptor[SHADER_COMPLEXITY_PROPERTIES.MAX_SPOT_LIGHTS.name] : 0,
                numShadowMapRanges = (params.numShadowRanges === undefined) ? this.getNumShadowMapRanges() : params.numShadowRanges,
                numShadowMaps = numDirLights * numShadowMapRanges,
                numShadowMapSamples = complexityDescriptor[SHADER_COMPLEXITY_PROPERTIES.NUM_SHADOW_MAP_SAMPLES.name],
                result,
                gameParams = {};
        gameParams[DEPENDENT_SHADER_REQUIREMENT_PROPERTIES.DIR_LIGHT.name] = numDirLights;
        gameParams[DEPENDENT_SHADER_REQUIREMENT_PROPERTIES.POINT_LIGHT.name] = numPointLights;
        gameParams[DEPENDENT_SHADER_REQUIREMENT_PROPERTIES.SPOT_LIGHT.name] = numSpotLights;
        gameParams[DEPENDENT_SHADER_REQUIREMENT_PROPERTIES.SHADOW_MAP.name] = numShadowMaps;
        gameParams[DEPENDENT_SHADER_REQUIREMENT_PROPERTIES.SHADOW_MAP_RANGE.name] = numShadowMapRanges;
        gameParams[DEPENDENT_SHADER_REQUIREMENT_PROPERTIES.SHADOW_MAP_SAMPLE.name] = numShadowMapSamples;
        gameParams[DEPENDENT_SHADER_REQUIREMENT_PROPERTIES.LUMINOSITY_FACTOR.name] = this.getShaderConfig(SHADER_CONFIG.MAX_LUMINOSITY_FACTORS);
        gameParams[DEPENDENT_SHADER_REQUIREMENT_PROPERTIES.GROUP_TRANSFORM.name] = this.getShaderConfig(SHADER_CONFIG.MAX_GROUP_TRANSFORMS);
        result = _getShaderRequirementsFromDescriptor(complexityDescriptor[SHADER_COMPLEXITY_PROPERTIES.REQUIREMENTS.name], gameParams);
        if (complexityDescriptor[SHADER_COMPLEXITY_PROPERTIES.SHADOW_MAPPING_AVAILABLE.name] && (numShadowMapRanges > 0)) {
            result = _getCombinedRequirements(result, _getShaderRequirementsFromDescriptor(
                    featureRequirementsDescriptor[FEATURE_REQUIREMENTS_PROPERTIES.SHADOWS.name],
                    gameParams));
        }
        if (complexityDescriptor[SHADER_COMPLEXITY_PROPERTIES.DYNAMIC_LIGHTS_AVAILABLE.name] && (numPointLights > 0)) {
            result = _getCombinedRequirements(result, _getShaderRequirementsFromDescriptor(
                    featureRequirementsDescriptor[FEATURE_REQUIREMENTS_PROPERTIES.DYNAMIC_LIGHTS.name],
                    gameParams));
        }
        if (complexityDescriptor[SHADER_COMPLEXITY_PROPERTIES.REVEAL_AVAILABLE.name]) {
            result = _getCombinedRequirements(result, _getShaderRequirementsFromDescriptor(
                    featureRequirementsDescriptor[FEATURE_REQUIREMENTS_PROPERTIES.REVEAL.name],
                    gameParams));
        }
        return result;
    };
    /**
     * Returns whether the shader requirements valid for the current settings stored in this graphics context are satisfied by the graphics
     * driver.
     * @param {GraphicsSettingsContext~CustomShaderRequirementsParams} [params] Provide game variable values or a shader complexity level index in
     * this object to override the respective current settings when calculating the requirements.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype._shaderRequirementsAreSatisfied = function (params) {
        return managedGL.requirementsAreSatisfied(this._getShaderRequirements(params));
    };
    /**
     * Removes all stored shader complexity levels for which even the basic requirements (with all features turned off) are not satisfiable
     * by the graphics driver.
     */
    GraphicsSettingsContext.prototype._limitShaderComplexities = function () {
        var complexities = [], originalComplexities = this.getShaderConfig(SHADER_CONFIG.COMPLEXITIES), i;
        for (i = 0; i < originalComplexities.length; i++) {
            if (this._shaderRequirementsAreSatisfied({
                numPointLights: 0,
                numShadowRanges: 0,
                complexityLevelIndex: i
            })) {
                complexities.push(originalComplexities[i]);
            } else {
                application.log_DEBUG("Defined shader complexity level '" + originalComplexities[i][SHADER_COMPLEXITY_PROPERTIES.NAME.name] + "', which has too high requirements and thus will be dropped from the available shader complexities.", 1);
            }
        }
        this.setShaderConfig(SHADER_CONFIG.COMPLEXITIES, complexities);
    };
    /**
     * If needed, decreases the currently set shader complexity level to one at which the requirements (with the current feature settings)
     * are satisfied by the graphics driver.
     * @param {Boolean} disableFeatures If true, disables all shader features if the current settings are not satisfied, and only starts to
     * lower the complexity if the requirements are still not met.
     */
    GraphicsSettingsContext.prototype._setFallbackShaderComplexity = function (disableFeatures) {
        var i;
        if (disableFeatures && !this._shaderRequirementsAreSatisfied()) {
            this._disableShaderFeatures();
        }
        i = this.getShaderComplexities().indexOf(this.getShaderComplexity());
        while ((i > 0) && !this._shaderRequirementsAreSatisfied({complexityLevelIndex: i})) {
            i--;
        }
        this.setShaderComplexity(this.getShaderComplexities()[i], false);
    };
    /**
     * Loads all configuration information for the context from the passed JSON object. This includes the list of options for the various
     * settings and other meta and non-changeable data. Needs to be called only once, before the settings themselves are to be loaded.
     * @param {Object} dataJSON
     */
    GraphicsSettingsContext.prototype.loadConfigurationFromJSON = function (dataJSON) {
        var i, n, limit, lodDisplayLimits;
        this._shaderConfig = types.getVerifiedObject("config.graphics.shaders", dataJSON.shaders, SHADER_CONFIG);
        this._limitShaderComplexities();
        this._textureQuality = new TextureQuality(
                dataJSON.context.textureQualities,
                "config.graphics.context.textureQualities",
                managedGL.getMaxTextureSize());
        this._cubemapQuality = new TextureQuality(
                dataJSON.context.cubemapQualities,
                "config.graphics.context.cubemapQualities",
                managedGL.getMaxCubemapSize());
        this._shadowMapQuality = new TextureQuality(
                dataJSON.context.shadows.qualities,
                "config.graphics.context.shadows.qualities",
                managedGL.getMaxRenderbufferSize());
        this._shadowRanges = types.getArrayValue("config.graphics.context.shadows.ranges", dataJSON.context.shadows.ranges, "number", null, {minLength: 1});
        this._shadowDistances = new OrderedNamedNumericOptions(
                dataJSON.context.shadows.distances,
                SHADOW_DISTANCE_DESCRIPTOR_TYPE,
                "config.graphics.context.shadows.distances",
                this._shadowRanges.length);
        this._shadowDepthRatio = types.getNumberValue("config.graphics.context.shadows.depthRatio", dataJSON.context.shadows.depthRatio);
        this._pointLightAmount = new OrderedNamedNumericOptions(
                dataJSON.context.pointLightAmounts,
                DYNAMIC_LIGHT_AMOUNT_DESCRIPTOR_TYPE,
                "config.graphics.context.pointLightAmounts");
        this._particleAmount = new OrderedNamedNumericOptions(
                dataJSON.context.particleAmounts,
                PARTICLE_AMOUNT_DESCRIPTOR_TYPE,
                "config.graphics.context.particleAmounts");
        this._dustParticleAmount = new OrderedNamedNumericOptions(
                dataJSON.context.dustParticleAmounts,
                PARTICLE_AMOUNT_DESCRIPTOR_TYPE,
                "config.graphics.context.dustParticleAmounts");
        this._lodLevel = new OrderedNamedNumericOptions(
                dataJSON.levelOfDetailSettings.lodLevels,
                LOD_LEVEL_DESCRIPTOR_TYPE,
                "config.graphics.levelOfDetailSettings.lodLevels");
        // configuring the LOD context
        lodDisplayLimits = new Array(dataJSON.levelOfDetailSettings.lodDisplayProfile.limits.length + 1);
        lodDisplayLimits[0] = 0;
        for (i = 0, n = dataJSON.levelOfDetailSettings.lodDisplayProfile.limits.length; i < n; i++) {
            limit = dataJSON.levelOfDetailSettings.lodDisplayProfile.limits[i];
            lodDisplayLimits[this._lodLevel.getValueForName(limit.level) + 1] = limit.objectSizeLessThan;
        }
        this._lodContext = new sceneGraph.LODContext(
                this._lodLevel.getFirstValue(),
                lodDisplayLimits,
                dataJSON.levelOfDetailSettings.lodDisplayProfile.compensateForObjectSize,
                dataJSON.levelOfDetailSettings.lodDisplayProfile.referenceSize,
                dataJSON.levelOfDetailSettings.lodDisplayProfile.minimumRelativeSize);
        this._generalLevels = dataJSON.generalLevels;
        this._groupTransformIdentityArray = new Float32Array(this.getShaderConfig(SHADER_CONFIG.MAX_GROUP_TRANSFORMS) * 16);
        for (i = 0; i < this._groupTransformIdentityArray.length; i++) {
            this._groupTransformIdentityArray[i] = mat.IDENTITY4[i % 16];
        }
    };
    /**
     * Based on the passed limiting settings, if necessary, lowers the value of the passed setting to the appropriate level
     * @param {Object} dataJSON The object storing the limiting settings (whether or not limiting is turned off, and what are the limits and their associated settings)
     * @param {OrderedNamedNumericOptions} setting The setting that should be limited
     * @param {Function} getSettingValueFunction The function that returns the current value (not name) of the setting
     * @param {Function} setSettingFunction The function that sets the setting by name (not value)
     * @param {String} settingType The name of the property by which the setting levels are referred to in the limiting settings (e.g. "level" or "amount")
     */
    GraphicsSettingsContext.prototype._limitSettingByScreenSize = function (dataJSON, setting, getSettingValueFunction, setSettingFunction, settingType) {
        var screenSize, i, n, limit;
        if (dataJSON.autoLimitByScreenSize === true) {
            screenSize = Math.max(screen.width, screen.height);
            for (i = 0, n = dataJSON.limits.length; i < n; i++) {
                limit = dataJSON.limits[i];
                if ((screenSize < limit.screenSizeLessThan) &&
                        (getSettingValueFunction() > setting.getValueForName(limit[settingType]))) {
                    setSettingFunction(limit[settingType], false);
                }
            }
        }
    };
    /**
     * Loads the graphics setting from the data stored in the passed JSON object.
     * @param {Object} dataJSON The JSON object storing the game settings.
     * @param {Boolean} [onlyRestoreSettings=false] Whether only the default 
     * settings should be restored or completely new settings should be initialized.
     */
    GraphicsSettingsContext.prototype.loadSettingsFromJSON = function (dataJSON, onlyRestoreSettings) {
        onlyRestoreSettings = onlyRestoreSettings || false;
        if (!onlyRestoreSettings) {
            this._dataJSON = dataJSON;
        }
        if (typeof dataJSON.shaders === "object") {
            // enabling fallback disables the check for requirements - feature settings are not loaded yet, requirements cannot be checked
            this.setShaderComplexity(dataJSON.shaders.complexity, false, true);
        } else {
            application.showError("Missing required settings.graphics.shaders from the setting definition object!");
        }
        if (typeof dataJSON.context === "object") {
            this.setAntialiasing(types.getBooleanValue(dataJSON.context.antialiasing, {name: "settings.graphics.context.antialiasing"}), false);
            this.setFiltering(types.getEnumValue(managedGL.TextureFiltering, dataJSON.context.filtering, {name: "settings.graphics.context.filtering"}), false);
            this.setTextureQuality(dataJSON.context.textureQuality, false, true);
            this.setCubemapQuality(dataJSON.context.cubemapQuality.level, false, true);
            this._limitSettingByScreenSize(dataJSON.context.cubemapQuality, this._cubemapQuality, this.getCubemapMaxResolution.bind(this), this.setCubemapQuality.bind(this), "level");
            this.setShadowMapping(types.getBooleanValue(dataJSON.context.shadowMapping, {name: "settings.graphics.context.shadowMapping"}), false, true);
            if (typeof dataJSON.context.shadows === "object") {
                this.setShadowMapQuality(dataJSON.context.shadows.quality, false, true);
                this.setShadowDistance(dataJSON.context.shadows.distance, false, true);
            }
            this.setPointLightAmount(dataJSON.context.pointLightAmount, false, true);
        } else {
            application.showError("Missing required settings.graphics.context from the setting definition object!");
        }
        // load the LOD load settings (maximum loaded LOD)
        this.setLODLevel(dataJSON.levelOfDetail.maxLevel, false);
        // if the maximum loaded LOD is limited by screen size, check the current size and apply the limit
        this._limitSettingByScreenSize(dataJSON.levelOfDetail, this._lodLevel, this.getMaxLoadedLOD.bind(this), this.setLODLevel.bind(this), "level");
        // whether to show loaded missiles in their launchers (during missions)
        this.setMissilesInLaunchersVisible(types.getBooleanValue(dataJSON.showMissilesInLaunchers, {name: "settings.graphics.showMissilesInLaunchers"}), false);
        // load the particle amount settings
        this.setParticleAmount(dataJSON.particleAmount.amount, false);
        // if the particle amount is limited by screen size, check the current size and apply the limit
        this._limitSettingByScreenSize(dataJSON.particleAmount, this._particleAmount, this.getParticleCountFactor.bind(this), this.setParticleAmount.bind(this), "amount");
        // if the particle amount should be automatically decreased by a level if there is no instancing available, apply this decrease
        // as necessary
        if (dataJSON.particleAmount.autoDecreaseIfInstancingNotAvailable === true) {
            if (!managedGL.isInstancingAvailable()) {
                this._particleAmount.decrease();
            }
        }
        // load the dust particle amount settings
        this.setDustParticleAmount(dataJSON.dustParticleAmount.amount, false);
        // if the dust particle amount is limited by screen size, check the current size and apply the limit
        this._limitSettingByScreenSize(dataJSON.dustParticleAmount, this._dustParticleAmount, this.getDustParticleCountFactor.bind(this), this.setDustParticleAmount.bind(this), "amount");
        // if the dust particle amount should be automatically decreased by a level if there is no instancing available, apply this decrease
        // as necessary
        if (dataJSON.dustParticleAmount.autoDecreaseIfInstancingNotAvailable === true) {
            if (!managedGL.isInstancingAvailable()) {
                this._dustParticleAmount.decrease();
            }
        }
        // now that all default settings are loaded, disable the features and decrease the shader complexity until the requirements are 
        // satisfied
        this._setFallbackShaderComplexity(true);
    };
    /**
     * Loads the custom graphics settings stored in HTML5 local storage.
     */
    GraphicsSettingsContext.prototype.loadFromLocalStorage = function () {
        var value, params, loadSetting = function (location, type, defaultValue, setterFunction) {
            if (localStorage[location] !== undefined) {
                // settings might be saved in different formats in different game versions, so do not show errors for invalid type if the version
                // has changed since the last run
                params = {
                    silentFallback: application.hasVersionChanged(),
                    defaultValue: defaultValue
                };
                value = types.getValueOfTypeFromLocalStorage(type, location, params);
                // apply the setting if it is valid or if the game version has changed, in which case the fallback of the invalid setting 
                // (namely the default setting from the JSON) will be applied and also saved to local storage
                if (!params.error || application.hasVersionChanged()) {
                    setterFunction(value, !!params.error && (params.error !== types.Errors.INVALID_ENUM_OBJECT_ERROR));
                }
            }
        };
        loadSetting(GENERAL_LEVEL_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getGeneralLevelNames())}, this.getGeneralLevel(), function (value) {
            this._currentGeneralLevel = value;
        }.bind(this));
        loadSetting(ANTIALIASING_LOCAL_STORAGE_ID, "boolean", this.getAntialiasing(), this.setAntialiasing.bind(this));
        loadSetting(FILTERING_LOCAL_STORAGE_ID, {baseType: "enum", values: managedGL.TextureFiltering}, this.getFiltering(), this.setFiltering.bind(this));
        loadSetting(TEXTURE_QUALITY_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getTextureQualities())}, this.getTextureQuality(), this.setTextureQuality.bind(this));
        loadSetting(CUBEMAP_QUALITY_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getCubemapQualities())}, this.getCubemapQuality(), this.setCubemapQuality.bind(this));
        loadSetting(MAX_LOD_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getLODLevels())}, this.getLODLevel(), this.setLODLevel.bind(this));
        loadSetting(MISSILES_IN_LAUNCHERS_LOCAL_STORAGE_ID, "boolean", this.areMissilesInLaunchersVisible(), this.setMissilesInLaunchersVisible.bind(this));
        loadSetting(SHADER_COMPLEXITY_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getShaderComplexities())}, this.getShaderComplexity(), this.setShaderComplexity.bind(this));
        loadSetting(SHADOW_MAPPING_LOCAL_STORAGE_ID, "boolean", this.isShadowMappingEnabled(), this.setShadowMapping.bind(this));
        loadSetting(SHADOW_MAP_QUALITY_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getShadowMapQualities())}, this.getShadowMapQuality(), this.setShadowMapQuality.bind(this));
        if (this.canEnableShadowMapping()) {
            loadSetting(SHADOW_DISTANCE_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getShadowDistances())}, this.getShadowDistance(), this.setShadowDistance.bind(this));
            // otherwise the shadow distances will be an empty array, and we cannot verify the value
        }
        loadSetting(POINT_LIGHT_AMOUNT_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getPointLightAmounts())}, this.getPointLightAmount(), this.setPointLightAmount.bind(this));
        loadSetting(PARTICLE_AMOUNT_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getParticleAmounts())}, this.getParticleAmount(), this.setParticleAmount.bind(this));
        loadSetting(DUST_PARTICLE_AMOUNT_LOCAL_STORAGE_ID, {baseType: "enum", values: types.getEnumObjectForArray(this.getDustParticleAmounts())}, this.getDustParticleAmount(), this.setDustParticleAmount.bind(this));
        this.setToReady();
    };
    /**
     * Restores the default settings that were loaded from file, and erases the custom changes that are stored in HTML5 local storage.
     */
    GraphicsSettingsContext.prototype.restoreDefaults = function () {
        this.loadSettingsFromJSON(this._dataJSON, true);
        localStorage.removeItem(GENERAL_LEVEL_LOCAL_STORAGE_ID);
        localStorage.removeItem(ANTIALIASING_LOCAL_STORAGE_ID);
        localStorage.removeItem(FILTERING_LOCAL_STORAGE_ID);
        localStorage.removeItem(TEXTURE_QUALITY_LOCAL_STORAGE_ID);
        localStorage.removeItem(CUBEMAP_QUALITY_LOCAL_STORAGE_ID);
        localStorage.removeItem(MAX_LOD_LOCAL_STORAGE_ID);
        localStorage.removeItem(MISSILES_IN_LAUNCHERS_LOCAL_STORAGE_ID);
        localStorage.removeItem(SHADER_COMPLEXITY_LOCAL_STORAGE_ID);
        localStorage.removeItem(SHADOW_MAPPING_LOCAL_STORAGE_ID);
        localStorage.removeItem(SHADOW_MAP_QUALITY_LOCAL_STORAGE_ID);
        localStorage.removeItem(SHADOW_DISTANCE_LOCAL_STORAGE_ID);
        localStorage.removeItem(POINT_LIGHT_AMOUNT_LOCAL_STORAGE_ID);
        localStorage.removeItem(PARTICLE_AMOUNT_LOCAL_STORAGE_ID);
        localStorage.removeItem(DUST_PARTICLE_AMOUNT_LOCAL_STORAGE_ID);
    };
    /**
     * Returns the current antialiasing setting.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.getAntialiasing = function () {
        return this._antialiasing;
    };
    /**
     * Sets a new antialiasing setting.
     * @param {Boolean} value
     * @param {Boolean} [saveToLocalStorage=true]
     * @returns {Boolean} Whether the setting was successfully set to the passed value.
     */
    GraphicsSettingsContext.prototype.setAntialiasing = function (value, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (managedGL.isAntialiasingAvailable()) {
            this._antialiasing = value;
        } else {
            this._antialiasing = false;
            if (value) {
                application.log_DEBUG("Attempted to enable antialiasing, but it is not supported and so will be disabled.", 1);
            }
        }
        // saving the original preference
        if (saveToLocalStorage) {
            localStorage[ANTIALIASING_LOCAL_STORAGE_ID] = value.toString();
        }
        return this._antialiasing === value;
    };
    /**
     * Returns the current texture filtering setting.
     * @returns {String} enum managedGL.TextureFiltering
     */
    GraphicsSettingsContext.prototype.getFiltering = function () {
        return this._filtering;
    };
    /**
     * Sets a new texture filtering setting.
     * @param {String} value enum managedGL.TextureFiltering
     * @param {Boolean} [saveToLocalStorage=true]
     * @returns {Boolean} Whether the setting was successfully set to the passed value.
     */
    GraphicsSettingsContext.prototype.setFiltering = function (value, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        value = types.getEnumValue(managedGL.TextureFiltering, value, {name: "texture filtering", defaultValue: this._filtering});
        this._filtering = value;
        if ((!managedGL.isAnisotropicFilteringAvailable()) && (value === managedGL.TextureFiltering.ANISOTROPIC)) {
            this._filtering = ANISOTROPIC_FALLBACK_FILTERING;
            application.log_DEBUG("Attempted to set texture filtering to anisotropic, but it is not supported and so a fallback filtering will be applied instead.", 1);
        }
        // saving the original preference
        if (saveToLocalStorage) {
            localStorage[FILTERING_LOCAL_STORAGE_ID] = value.toString();
        }
    };
    /**
     * Returns the list of strings identifying the available texture quality levels, in ascending order.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getTextureQualities = function () {
        return this._textureQuality.getNameList();
    };
    /**
     * Returns the list of strings identifying the available texture quality levels, in order of preference.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getTextureQualityPreferenceList = function () {
        return this._textureQuality.getPreferenceNameList();
    };
    /**
     * Returns the string identifying the current texture quality level setting.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getTextureQuality = function () {
        return this._textureQuality.getCurrentName();
    };
    /**
     * Sets a new texture quality level.
     * @param {String} value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     * @param {Boolean} [fallbackToHighest=false] If true, then in case the passed value cannot be set (because it is not valid e.g. 
     * because it is higher than the maximum supported by the graphics driver), then instead of showing an error, the highest available
     * option is set.
     */
    GraphicsSettingsContext.prototype.setTextureQuality = function (value, saveToLocalStorage, fallbackToHighest) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (this._textureQuality.setCurrent(value, fallbackToHighest)) {
            if (saveToLocalStorage) {
                localStorage[TEXTURE_QUALITY_LOCAL_STORAGE_ID] = value;
            }
        }
    };
    /**
     * Returns the maximum resolution of cubemaps at the current cubemap quality level setting.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getCubemapMaxResolution = function () {
        return this._cubemapQuality.getCurrentValue();
    };
    /**
     * Returns the list of strings identifying the available cubemap quality levels, in ascending order.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getCubemapQualities = function () {
        return this._cubemapQuality.getNameList();
    };
    /**
     * Returns the list of strings identifying the available cubemap quality levels, in order of preference.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getCubemapQualityPreferenceList = function () {
        return this._cubemapQuality.getPreferenceNameList();
    };
    /**
     * Returns the string identifying the current cubemap quality level setting.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getCubemapQuality = function () {
        return this._cubemapQuality.getCurrentName();
    };
    /**
     * Sets a new cubemap quality level.
     * @param {String} value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     * @param {Boolean} [fallbackToHighest=false] If true, then in case the passed value cannot be set (because it is not valid e.g. 
     * because it is higher than the maximum supported by the graphics driver), then instead of showing an error, the highest available
     * option is set.
     */
    GraphicsSettingsContext.prototype.setCubemapQuality = function (value, saveToLocalStorage, fallbackToHighest) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (this._cubemapQuality.setCurrent(value, fallbackToHighest)) {
            if (saveToLocalStorage) {
                localStorage[CUBEMAP_QUALITY_LOCAL_STORAGE_ID] = value;
            }
        }
    };
    /**
     * Returns the numeric value marking the maximum detail level in which model files are to be loaded.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getMaxLoadedLOD = function () {
        return this._maxLoadedLOD;
    };
    /**
     * Returns the list of strings identifying the available model LOD levels, in ascending order.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getLODLevels = function () {
        return this._lodLevel.getNameList();
    };
    /**
     * Returns the string identifying the current model LOD level setting.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getLODLevel = function () {
        return this._lodLevel.getCurrentName();
    };
    /**
     * Returns the numeric LOD value for the passed LOD level string identifier.
     * @param {String} level
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getLOD = function (level) {
        return this._lodLevel.getValueForName(level);
    };
    /**
     * Sets a new maximum model LOD. (both for displaying and loading models)
     * @param {String} value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     */
    GraphicsSettingsContext.prototype.setLODLevel = function (value, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (this._lodLevel.setCurrent(value)) {
            this._maxLoadedLOD = this._lodLevel.getCurrentValue();
            this._lodContext.maxEnabledLOD = this._lodLevel.getCurrentValue();
            if (saveToLocalStorage) {
                localStorage[MAX_LOD_LOCAL_STORAGE_ID] = value;
            }
        }
    };
    /**
     * Returns the LOD context object storing the currently active LOD settings in the format defined by SceneGraph.
     * @returns {LODContext}
     */
    GraphicsSettingsContext.prototype.getLODContext = function () {
        return this._lodContext;
    };
    /**
     * Sets whether the loaded missiles should be visible in their launch tubes on ships during missions.
     * @param {Boolean} [value]
     * @param {Boolean} [saveToLocalStorage=true]
     */
    GraphicsSettingsContext.prototype.setMissilesInLaunchersVisible = function (value, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        this._missilesInLaunchers = value;
        if (saveToLocalStorage) {
            localStorage[MISSILES_IN_LAUNCHERS_LOCAL_STORAGE_ID] = value.toString();
        }
    };
    /**
     * Returns whether the loaded missiles should be visible in their launch tubes on ships during missions.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.areMissilesInLaunchersVisible = function () {
        return this._missilesInLaunchers;
    };
    /**
     * Returns the string identifying the current shader complexity level setting.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getShaderComplexity = function () {
        return this._shaderComplexity;
    };
    /**
     * Decreases the level of enabled shader features or disables them completely if required until a level can be reached where the 
     * graphics driver supports the resulting shader requirements.
     */
    GraphicsSettingsContext.prototype._limitShaderFeatures = function () {
        var
                originalShadowMapping = this.isShadowMappingEnabled(),
                originalNumShadowMapRanges = this.getNumShadowMapRanges(),
                originalMaxPointLights = this.getMaxPointLights();
        application.log_DEBUG("Checking requirements for current shader complexity...");
        while (!this._shaderRequirementsAreSatisfied()) {
            if (this.isShadowMappingEnabled()) {
                if (!this._shadowDistances.decrease()) {
                    this.setShadowMapping(false, false, true);
                }
            } else if (!this._pointLightAmount.decrease()) {
                application.showError("Cannot satisfy shader requirements for current complexity!");
                return;
            }
        }
        if (this.isShadowMappingEnabled() !== originalShadowMapping) {
            application.log_DEBUG("Disabled shadow mapping to satisfy requirements of current shader complexity.", 1);
        } else if (this.getNumShadowMapRanges() !== originalNumShadowMapRanges) {
            application.log_DEBUG("Changed number of shadow map ranges from " + originalNumShadowMapRanges + " to " + this.getNumShadowMapRanges() + " to satisfy requirements of current shader complexity.", 1);
        }
        if (this.getMaxPointLights() !== originalMaxPointLights) {
            application.log_DEBUG("Changed number of maximum point lights from " + originalMaxPointLights + " to " + this.getMaxPointLights() + " to satisfy requirements of current shader complexity.", 1);
        }
    };
    /**
     * Disables all shader features, resulting in a minimal setup for the current shader complexity level.
     */
    GraphicsSettingsContext.prototype._disableShaderFeatures = function () {
        if (this.isShadowMappingEnabled()) {
            this.setShadowMapping(false, false, true);
        }
        this._pointLightAmount.setLowest();
    };
    /**
     * Sets a new shader complexity level. Automatically lowers enabled shader features if needed to ensure that the shader requirements
     * are satisfied for the new level as well.
     * @param value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     * @param {Boolean} [fallbackToHighest=false] If true, then in case the passed value cannot be set (because it is not valid e.g. 
     * because it is higher than the maximum supported by the graphics driver), then instead of showing an error, the highest available
     * option is set. The requirements are not checked if the complexity level is set through fallback!
     */
    GraphicsSettingsContext.prototype.setShaderComplexity = function (value, saveToLocalStorage, fallbackToHighest) {
        var complexities = this.getShaderComplexities();
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (complexities.indexOf(value) >= 0) {
            if (this._shaderComplexity !== value) {
                this._shaderComplexity = value;
                this._limitShaderFeatures();
            }
            if (saveToLocalStorage) {
                localStorage[SHADER_COMPLEXITY_LOCAL_STORAGE_ID] = value;
            }
        } else {
            if (fallbackToHighest) {
                this._shaderComplexity = complexities[complexities.length - 1];
                application.log_DEBUG("Attempted to set shader complexity to '" + value + "', which is not supported, and thus '" + this._shaderComplexity + "' has been selected instead.", 1);
            } else {
                application.showError(
                        "Attempting to set shader complexity to '" + value + "', which is not one of the available options (" + this.getShaderComplexities().join(", ") + ").",
                        application.ErrorSeverity.MINOR,
                        "The shader complexity will stay '" + this.getShaderComplexity() + "'.");
            }
        }
        // caching the availability of luminosity textures as it is frequently queried
        this._luminosityTextureAreAvailable = this._getShaderComplexityDescriptor()[SHADER_COMPLEXITY_PROPERTIES.LUMINOSITY_TEXTURES_AVAILABLE.name];
    };
    /**
     * Return a list containing the names of all available shader complexity levels that can be set.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getShaderComplexities = function () {
        return this.getShaderConfig(SHADER_CONFIG.COMPLEXITIES).map(function (complexityDescriptor) {
            return complexityDescriptor[SHADER_COMPLEXITY_PROPERTIES.NAME.name];
        });
    };
    /**
     * Returns the name of the shader that is to be used for rendering shadow maps
     * @returns {String|null}
     */
    GraphicsSettingsContext.prototype.getShadowMappingShaderName = function () {
        return this.getShaderConfig(SHADER_CONFIG.SHADOW_MAPPING_SHADER_NAME);
    };
    /**
     * Returns whether shadow mapping is enabled.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.isShadowMappingEnabled = function () {
        return this._shadowMappingEnabled;
    };
    /**
     * Sets whether shadow mapping should be enabled. Also checks whether enabling shadow mapping is possible at the current settings 
     * (shader requirements would be satisfied at least using the closest shadow distance) and only enables it if possible, also ensuring
     * that the requirements are met by lowering the shadow distance level, if needed.
     * @param {Boolean} [value] If undefined, the setting will be restored from local storage or the stored JSON
     * @param {Boolean} [saveToLocalStorage=true]
     * @param {Boolean} [ignoreRequirements=false] If true, the requirements are not checked and the shadow mapping is set to the desired
     * value in any case.
     * @returns {Boolean} Whether shadow mapping has been successfully set to the passed value.
     */
    GraphicsSettingsContext.prototype.setShadowMapping = function (value, saveToLocalStorage, ignoreRequirements) {
        if (value === undefined) {
            if (localStorage[SHADOW_MAPPING_LOCAL_STORAGE_ID] !== undefined) {
                value = (localStorage[SHADOW_MAPPING_LOCAL_STORAGE_ID] === "true");
            } else {
                value = types.getBooleanValue(this._dataJSON.context.shadowMapping, {name: "settings.graphics.context.shadowMapping"});
            }
            saveToLocalStorage = false;
            ignoreRequirements = false;
        }
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (ignoreRequirements || !value || this.canEnableShadowMapping()) {
            if (this._shadowMappingEnabled !== value) {
                this._shadowMappingEnabled = value;
                if (!ignoreRequirements && value) {
                    // it is possible that a too high, unsupported shadow distance is set, which needs to be lowered
                    this._limitShaderFeatures();
                }
            }
        } else {
            this._shadowMappingEnabled = false;
            application.log_DEBUG("Attempted to enable shadow mapping, but it is not supported (at the current shader complexity level) and so will be disabled.", 1);
        }
        // saving the original preference
        if (saveToLocalStorage) {
            localStorage[SHADOW_MAPPING_LOCAL_STORAGE_ID] = value.toString();
        }
        return this._shadowMappingEnabled === value;
    };
    /**
     * Returns the list of strings identifying the available shadow map quality levels, in ascending order.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getShadowMapQualities = function () {
        return this._shadowMapQuality.getNameList();
    };
    /**
     * Returns the string identifying the current shadow map quality level.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getShadowMapQuality = function () {
        return this._shadowMapQuality.getCurrentName();
    };
    /**
     * Returns the size (in texels, both width and height) of shadow map texture used at the currentl set quality level.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getShadowMapTextureSize = function () {
        return this._shadowMapQuality.getCurrentValue();
    };
    /**
     * Sets a new shadow map quality level.
     * @param {String} value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     * @param {Boolean} [fallbackToHighest=false] If true, then in case the passed value cannot be set (because it is not valid e.g. 
     * because it is higher than the maximum supported by the graphics driver), then instead of showing an error, the highest available
     * option is set.
     */
    GraphicsSettingsContext.prototype.setShadowMapQuality = function (value, saveToLocalStorage, fallbackToHighest) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (this._shadowMapQuality.setCurrent(value, fallbackToHighest)) {
            if (saveToLocalStorage) {
                localStorage[SHADOW_MAP_QUALITY_LOCAL_STORAGE_ID] = value;
            }
        }
    };
    /**
     * Returns the array of ranges (size of the area covered by each shadow map, in world coordinates, from the center to the sides) for the 
     * active number of shadow maps.
     * @returns {Number[]}
     */
    GraphicsSettingsContext.prototype.getShadowRanges = function () {
        var i, result = [], numRanges = this.getNumShadowMapRanges();
        for (i = 0; i < numRanges; i++) {
            result.push(this._shadowRanges[i]);
        }
        return result;
    };
    /**
     * Returns the list of strings identifying the available shadow distance levels, in ascending order.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getShadowDistances = function () {
        return this._shadowDistances.getFilteredNameList(function (value) {
            return this._shaderRequirementsAreSatisfied({numShadowRanges: value});
        }.bind(this));
    };
    /**
     * Returns the string identifying the current shadow distance level.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getShadowDistance = function () {
        return this._shadowDistances.getCurrentName();
    };
    /**
     * Returns the number of shadow map ranges actively used at the current settings.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getNumShadowMapRanges = function () {
        return this._shadowMappingEnabled ? this._shadowDistances.getCurrentValue() : 0;
    };
    /**
     * Sets a new distance level for rendering shadows. (which determines the number of ranges to use for shadow mapping)
     * @param {String} value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     * @param {Boolean} [fallbackToHighest=false] If true, then in case the passed value cannot be set (because it is not valid e.g. 
     * because it is higher than the maximum supported by the graphics driver), then instead of showing an error, the highest available
     * option is set.
     */
    GraphicsSettingsContext.prototype.setShadowDistance = function (value, saveToLocalStorage, fallbackToHighest) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (this._shadowDistances.setCurrent(value, fallbackToHighest)) {
            if (saveToLocalStorage) {
                localStorage[SHADOW_DISTANCE_LOCAL_STORAGE_ID] = value;
            }
        }
    };
    /**
     * Returns the depth ratio for shadow mapping. The depth area covered by each shadow map has a size multiplied by this factor compared
     * to the size covered in width and height.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getShadowDepthRatio = function () {
        return this._shadowDepthRatio;
    };
    /**
     * Returns whether anaglyph stereoscopic rendering is enabled according to the graphics settings.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.isAnaglyphRenderingEnabled = function () {
        return this._dataJSON.stereoscopy.enabled && (this._dataJSON.stereoscopy.mode === "anaglyph");
    };
    /**
     * Returns an object containing the setup parameters for anaglyph stereoscopic rendering according to the graphics settings.
     * @returns {Object}
     */
    GraphicsSettingsContext.prototype.getAnaglyphRenderingSettings = function () {
        return  {
            redShader: this.getManagedShader(this.getShaderConfig(SHADER_CONFIG.ANAGLYPH_RED_SHADER_NAME)),
            cyanShader: this.getManagedShader(this.getShaderConfig(SHADER_CONFIG.ANAGLYPH_CYAN_SHADER_NAME)),
            interocularDistance: this._dataJSON.stereoscopy.interocularDistance,
            convergenceDistance: this._dataJSON.stereoscopy.convergenceDistance
        };
    };
    /**
     * Returns whether side by side stereoscopic rendering is enabled according to the graphics settings.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.isSideBySideRenderingEnabled = function () {
        return this._dataJSON.stereoscopy.enabled && (this._dataJSON.stereoscopy.mode === "sideBySide");
    };
    /**
     * Returns an object containing the setup parameters for side by side stereoscopic rendering according to the graphics settings.
     * @returns {Object}
     */
    GraphicsSettingsContext.prototype.getSideBySideRenderingSettings = function () {
        return  {
            leftShader: this.getManagedShader(this.getShaderConfig(SHADER_CONFIG.SIDE_BY_SIDE_LEFT_SHADER_NAME)),
            rightShader: this.getManagedShader(this.getShaderConfig(SHADER_CONFIG.SIDE_BY_SIDE_RIGHT_SHADER_NAME)),
            interocularDistance: this._dataJSON.stereoscopy.interocularDistance,
            convergenceDistance: this._dataJSON.stereoscopy.convergenceDistance,
            originalAspect: this._dataJSON.stereoscopy.sideBySideOriginalAspect
        };
    };
    /**
     * Returns whether shadow map debug rendering is enabled according to the graphics settings.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.isShadowMapDebuggingEnabled = function () {
        return this._dataJSON.shadowMapDebugging.enabled;
    };
    /**
     * Returns an object containing the setup parameters for shadow map debugging (rendering shadow maps on screen) according to the graphics settings.
     * @returns {Object}
     */
    GraphicsSettingsContext.prototype.getShadowMapDebuggingSettings = function () {
        return  {
            shader: this.getManagedShader(this.getShaderConfig(SHADER_CONFIG.SHADOW_MAP_DEBUG_SHADER_NAME)),
            lightIndex: this._dataJSON.shadowMapDebugging.lightIndex,
            rangeIndex: this._dataJSON.shadowMapDebugging.rangeIndex
        };
    };
    /**
     * Returns the shader complexity descriptor object for the currently set shader complexity level.
     * @param {Number} [index] If given, the descriptor object belonging to the complexity level at this index is returned instead of the
     * one belonging to the current complexity.
     * @returns {Object}
     */
    GraphicsSettingsContext.prototype._getShaderComplexityDescriptor = function (index) {
        return (index === undefined) ?
                this.getShaderConfig(SHADER_CONFIG.COMPLEXITIES).find(function (complexityDescriptor) {
            return complexityDescriptor[SHADER_COMPLEXITY_PROPERTIES.NAME.name] === this.getShaderComplexity();
        }.bind(this), this) :
                this.getShaderConfig(SHADER_CONFIG.COMPLEXITIES)[index];
    };
    /**
     * Returns the maximum number of directional lights that can be used in shaders.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getMaxDirLights = function () {
        return this._getShaderComplexityDescriptor()[SHADER_COMPLEXITY_PROPERTIES.MAX_DIR_LIGHTS.name];
    };
    /**
     * Returns the list of strings identifying the available maximum point light amount settings, in ascending order.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getPointLightAmounts = function () {
        return this._pointLightAmount.getFilteredNameList(function (value) {
            return this._shaderRequirementsAreSatisfied({numPointLights: value});
        }.bind(this));
    };
    /**
     * Returns the string identifying the current maximum point light amount setting.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getPointLightAmount = function () {
        return this._pointLightAmount.getCurrentName();
    };
    /**
     * Returns the maximum number of point lights that can be used in shaders.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getMaxPointLights = function () {
        return this._pointLightAmount.getCurrentValue();
    };
    /**
     * Sets a new maximum dynamic light amount to be used in shaders.
     * @param {String} value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     * @param {Boolean} [fallbackToHighest=false] If true, then in case the passed value cannot be set (because it is not valid e.g. 
     * because it is higher than the maximum supported by the graphics driver), then instead of showing an error, the highest available
     * option is set.
     */
    GraphicsSettingsContext.prototype.setPointLightAmount = function (value, saveToLocalStorage, fallbackToHighest) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (this._pointLightAmount.setCurrent(value, fallbackToHighest)) {
            if (saveToLocalStorage) {
                localStorage[POINT_LIGHT_AMOUNT_LOCAL_STORAGE_ID] = value;
            }
        }
    };
    /**
     * Returns the maximum number of spot lights that can be used in shaders.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getMaxSpotLights = function () {
        return this._getShaderComplexityDescriptor()[SHADER_COMPLEXITY_PROPERTIES.MAX_SPOT_LIGHTS.name];
    };
    /**
     * Returns the list of strings identifying the available particle amount settings, in ascending order.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getParticleAmounts = function () {
        return this._particleAmount.getNameList();
    };
    /**
     * Returns the string identifying the current particle amount setting.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getParticleAmount = function () {
        return this._particleAmount.getCurrentName();
    };
    /**
     * Returns the factor by which the particle count should be multiplied according to current settings.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getParticleCountFactor = function () {
        return this._particleAmount.getCurrentValue();
    };
    /**
     * Sets a new particle amount.
     * @param {String} value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     * @param {Boolean} [fallbackToHighest=false] If true, then in case the passed value cannot be set (because it is not valid e.g. 
     * because it is higher than the maximum supported by the graphics driver), then instead of showing an error, the highest available
     * option is set.
     */
    GraphicsSettingsContext.prototype.setParticleAmount = function (value, saveToLocalStorage, fallbackToHighest) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (this._particleAmount.setCurrent(value, fallbackToHighest)) {
            if (saveToLocalStorage) {
                localStorage[PARTICLE_AMOUNT_LOCAL_STORAGE_ID] = value;
            }
        }
    };
    /**
     * Returns the list of strings identifying the available dust particle amount settings, in ascending order.
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getDustParticleAmounts = function () {
        return this._dustParticleAmount.getNameList();
    };
    /**
     * Returns the string identifying the current dust particle amount setting.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getDustParticleAmount = function () {
        return this._dustParticleAmount.getCurrentName();
    };
    /**
     * Returns the factor by which the dust particle count should be multiplied according to current settings.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getDustParticleCountFactor = function () {
        return this._dustParticleAmount.getCurrentValue();
    };
    /**
     * Sets a new dust particle amount.
     * @param {String} value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     * @param {Boolean} [fallbackToHighest=false] If true, then in case the passed value cannot be set (because it is not valid e.g. 
     * because it is higher than the maximum supported by the graphics driver), then instead of showing an error, the highest available
     * option is set.
     */
    GraphicsSettingsContext.prototype.setDustParticleAmount = function (value, saveToLocalStorage, fallbackToHighest) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (this._dustParticleAmount.setCurrent(value, fallbackToHighest)) {
            if (saveToLocalStorage) {
                localStorage[DUST_PARTICLE_AMOUNT_LOCAL_STORAGE_ID] = value;
            }
        }
    };
    /**
     * Returns the shader configuration value corresponding to the passed property definition object.
     * @param {Object} propertyDefinition A property definition object from SHADER_CONFIG
     * @returns {}
     */
    GraphicsSettingsContext.prototype.getShaderConfig = function (propertyDefinition) {
        return this._shaderConfig[propertyDefinition.name];
    };
    /**
     * Sets a new shader configuration value corresponding to the passed property definition object. (from the ones defined in SHADER_CONFIG)
     * @param {Object} propertyDefinition A property definition object from SHADER_CONFIG
     * @param {} value
     */
    GraphicsSettingsContext.prototype.setShaderConfig = function (propertyDefinition, value) {
        this._shaderConfig[propertyDefinition.name] = value;
    };
    /**
     * Returns how many samples should shaders take (and average) of the shadow maps to determine how much a point is in shadow.
     * @returns {Number}
     */
    GraphicsSettingsContext.prototype.getNumShadowMapSamples = function () {
        return this._getShaderComplexityDescriptor()[SHADER_COMPLEXITY_PROPERTIES.NUM_SHADOW_MAP_SAMPLES.name];
    };
    /**
     * Returns whether shadow mapping is available according to the currently set shader complexity level. Does not check if the graphics
     * driver support the corresponding shader requirements!
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.isShadowMappingAvailable = function () {
        return this._getShaderComplexityDescriptor()[SHADER_COMPLEXITY_PROPERTIES.SHADOW_MAPPING_AVAILABLE.name];
    };
    /**
     * Returns whether luminosity textures are available according to the currently set shader complexity level.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.areLuminosityTexturesAvailable = function () {
        return this._luminosityTextureAreAvailable;
    };
    /**
     * Returns the an array that can be passed as value for the group transforms uniform with all transforms being identity
     * @returns {Float32Array}
     */
    GraphicsSettingsContext.prototype.getGroupTransformIdentityArray = function () {
        return this._groupTransformIdentityArray;
    };
    /**
     * Returns whether the reveal effect is available according to the currently set shader complexity level.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.isRevealAvailable = function () {
        return this._getShaderComplexityDescriptor()[SHADER_COMPLEXITY_PROPERTIES.REVEAL_AVAILABLE.name];
    };
    /**
     * Returns whether dynamic (point and spot) lights are available according to the currently set shader complexity level.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.areDynamicLightsAvailable = function () {
        return this._getShaderComplexityDescriptor()[SHADER_COMPLEXITY_PROPERTIES.DYNAMIC_LIGHTS_AVAILABLE.name];
    };
    /**
     * Returns whether shadow mapping can be enabled (at least with the minimum available shadow distance setting) at the current settings
     * with the graphics driver still satisfying the resulting shader requirements.
     * @returns {Boolean}
     */
    GraphicsSettingsContext.prototype.canEnableShadowMapping = function () {
        return this.isShadowMappingAvailable() && this._shaderRequirementsAreSatisfied({numShadowRanges: this._shadowDistances.getFirstValue()});
    };
    /**
     * Return texture resource that should be used for the given name and requests it for loading if needed. Considers the context settings.
     * @param {String} textureName
     * @param {TextureResource~RequestParams} params
     * @returns {TextureResource}
     */
    GraphicsSettingsContext.prototype.getTexture = function (textureName, params) {
        params = params || {};
        params.qualityPreferenceList = this.getTextureQualityPreferenceList();
        return resources.getTexture(textureName, params);
    };
    /**
     * Return cubemap resource that should be used for the given name and requests it for loading if needed. Considers the context settings.
     * @param {String} cubemapName
     * @param {CubemapResource~RequestParams} params
     * @returns {CubemapResource}
     */
    GraphicsSettingsContext.prototype.getCubemap = function (cubemapName, params) {
        params = params || {};
        params.qualityPreferenceList = this.getCubemapQualityPreferenceList();
        return resources.getCubemap(cubemapName, params);
    };
    /**
     * Return shader resource that should be used for the given name and requests it for loading if needed. Considers the context settings.
     * @param {String} shaderName
     * @returns {ShaderResource}
     */
    GraphicsSettingsContext.prototype.getShader = function (shaderName) {
        shaderName = resources.getVariantShader(shaderName, this.getShaderComplexity()).getName();
        if (!this._shadowMappingEnabled) {
            shaderName = resources.getVariantShader(shaderName, SHADER_VARIANT_WITHOUT_SHADOWS_NAME).getName();
        }
        if (this._pointLightAmount.getCurrentValue() === 0) {
            shaderName = resources.getVariantShader(shaderName, SHADER_VARIANT_WITHOUT_DYNAMIC_LIGHTS_NAME).getName();
        }
        return resources.getShader(shaderName);
    };
    /**
     * Returns the managed shader corresponding to the passed name, taking into account the settings of the context.
     * @param {String} shaderName
     * @returns {ManagedShader}
     */
    GraphicsSettingsContext.prototype.getManagedShader = function (shaderName) {
        var replacedDefines = {}, result;
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.MAX_DIR_LIGHTS_DEFINE_NAME)] = this.getMaxDirLights();
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.MAX_POINT_LIGHTS_DEFINE_NAME)] = this.getMaxPointLights();
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.MAX_SPOT_LIGHTS_DEFINE_NAME)] = this.getMaxSpotLights();
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.MAX_SHADOW_MAP_RANGES_DEFINE_NAME)] = this.getNumShadowMapRanges();
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.MAX_SHADOW_MAPS_DEFINE_NAME)] = this.getMaxDirLights() * this.getNumShadowMapRanges();
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.NUM_SHADOW_MAP_SAMPLES_DEFINE_NAME)] = this.getNumShadowMapSamples();
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.DUST_LENGTH_DIVISOR_DEFINE_NAME)] = this.getShaderConfig(SHADER_CONFIG.DUST_LENGTH_DIVISOR);
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.MAX_LUMINOSITY_FACTORS_DEFINE_NAME)] = this.getShaderConfig(SHADER_CONFIG.MAX_LUMINOSITY_FACTORS);
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.MAX_GROUP_TRANSFORMS_DEFINE_NAME)] = this.getShaderConfig(SHADER_CONFIG.MAX_GROUP_TRANSFORMS);
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.DEPTH_TEXTURES_DEFINE_NAME)] = managedGL.areDepthTexturesAvailable() ? "1" : "0";
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.MAX_SHININESS_DEFINE_NAME)] = this.getShaderConfig(SHADER_CONFIG.MAX_SHININESS);
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.LISPSM_MINIMUM_NEAR_DEFINE_NAME)] = this.getShaderConfig(SHADER_CONFIG.LISPSM_MINIMUM_NEAR);
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.LISPSM_NEAR_FACTOR_DEFINE_NAME)] = this.getShaderConfig(SHADER_CONFIG.LISPSM_NEAR_FACTOR);
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.ANAGLYPH_ORIGINAL_COLOR_RATIO_DEFINE_NAME)] = this.getShaderConfig(SHADER_CONFIG.ANAGLYPH_ORIGINAL_COLOR_RATIO);
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.ANAGLYPH_GAMMA_DEFINE_NAME)] = this.getShaderConfig(SHADER_CONFIG.ANAGLYPH_GAMMA);
        replacedDefines[this.getShaderConfig(SHADER_CONFIG.ANAGLYPH_CYAN_FACTOR_DEFINE_NAME)] = this.getShaderConfig(SHADER_CONFIG.ANAGLYPH_CYAN_FACTOR);
        result = this.getShader(shaderName).getManagedShader(replacedDefines, true);
        if (!result.isAllowedByRequirements(this._getShaderRequirements())) {
            application.showError("Shader '" + shaderName + "' has too high requirements!");
        }
        return result;
    };
    /**
     * Return model resource that should be used for the given name and requests it for loading if needed. Considers the context settings.
     * @param {String} modelName
     * @returns {ModelResource}
     */
    GraphicsSettingsContext.prototype.getModel = function (modelName) {
        return resources.getModel(modelName, {maxLOD: this.getMaxLoadedLOD()});
    };
    /**
     * Returns the list of string IDs identifying the available general graphics settings levels (to each level corresponds a full set of 
     * graphics settings)
     * @returns {String[]}
     */
    GraphicsSettingsContext.prototype.getGeneralLevelNames = function () {
        return Object.keys(this._generalLevels);
    };
    /**
     * Set all settings to the ones corresponding to the general graphics quality level identified by the passed string.
     * Also save to local storage that this general graphics quality level has been applied.
     * Pass null as levelName to indicate that a custom graphics quality is set (i.e. some setting is changed independently)
     * @param {String} levelName
     * @param {Boolean} [saveToLocalStorage=true]
     */
    GraphicsSettingsContext.prototype.setGeneralLevel = function (levelName, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (levelName) {
            this.loadSettingsFromJSON(this._generalLevels[levelName], true);
            if (saveToLocalStorage) {
                localStorage[GENERAL_LEVEL_LOCAL_STORAGE_ID] = levelName;
            }
        } else {
            if (saveToLocalStorage) {
                localStorage.removeItem(GENERAL_LEVEL_LOCAL_STORAGE_ID);
            }
        }
        this._currentGeneralLevel = levelName;
    };
    /**
     * Returns the string ID corresponding to the general graphics quality level that was last set.
     * @returns {String}
     */
    GraphicsSettingsContext.prototype.getGeneralLevel = function () {
        return this._currentGeneralLevel;
    };
    // -------------------------------------------------------------------------
    // Public functions
    /**
     * Returns whether shadow mapping should be used if all current graphics settings are considered (not just the shadow mapping setting
     * itself)
     * @returns {Boolean}
     */
    function shouldUseShadowMapping() {
        return _context.isShadowMappingEnabled() && (_context.isShadowMappingAvailable());
    }
    /**
     * Returns the resource for the shader that is to be used when rendering shadow maps
     * @returns {ShaderResource}
     */
    function getShadowMappingShader() {
        return _context.getShader(_context.getShadowMappingShaderName());
    }
    /**
     * Returns a shadow mapping settings descriptor object that can be directly used as parameter for Scene constructors and contains the
     * state that reflect the current settings stored 
     * @returns {Scene~ShadowMappingParams|null}
     */
    function getShadowMappingSettings() {
        return shouldUseShadowMapping() ?
                {
                    enable: true,
                    shader: _context.getManagedShader(_context.getShadowMappingShaderName()),
                    textureSize: _context.getShadowMapTextureSize(),
                    ranges: _context.getShadowRanges(),
                    depthRatio: _context.getShadowDepthRatio(),
                    numSamples: _context.getNumShadowMapSamples()
                } :
                null;
    }
    /**
     * Returns the resource for the shader that is to be used when rendering the red part of anaglyph stereoscopic scenes
     * @returns {ShaderResource}
     */
    function getAnaglyphRedShader() {
        return _context.getShader(_context.getShaderConfig(SHADER_CONFIG.ANAGLYPH_RED_SHADER_NAME));
    }
    /**
     * Returns the resource for the shader that is to be used when rendering the cyan part of anaglyph stereoscopic scenes
     * @returns {ShaderResource}
     */
    function getAnaglyphCyanShader() {
        return _context.getShader(_context.getShaderConfig(SHADER_CONFIG.ANAGLYPH_CYAN_SHADER_NAME));
    }
    /**
     * Returns the resource for the shader that is to be used when rendering the left part of side by side stereoscopic scenes
     * @returns {ShaderResource}
     */
    function getSideBySideLeftShader() {
        return _context.getShader(_context.getShaderConfig(SHADER_CONFIG.SIDE_BY_SIDE_LEFT_SHADER_NAME));
    }
    /**
     * Returns the resource for the shader that is to be used when rendering the right part of side by side stereoscopic scenes
     * @returns {ShaderResource}
     */
    function getSideBySideRightShader() {
        return _context.getShader(_context.getShaderConfig(SHADER_CONFIG.SIDE_BY_SIDE_RIGHT_SHADER_NAME));
    }
    /**
     * Returns the resource for the shader that is to be used when rendering the shadow map on screen for debug purposes
     * @returns {ShaderResource}
     */
    function getShadowMapDebugShader() {
        return _context.getShader(_context.getShaderConfig(SHADER_CONFIG.SHADOW_MAP_DEBUG_SHADER_NAME));
    }
    /**
     * Returns the anaglyph original color ratio converted to a number (from string)
     * @returns {Number}
     */
    function getAnaglyphOriginalColorRatio() {
        return parseFloat(_context.getShaderConfig(SHADER_CONFIG.ANAGLYPH_ORIGINAL_COLOR_RATIO));
    }
    /**
     * Returns the anaglyph gamma value converted to a number (from string)
     * @returns {Number}
     */
    function getAnaglyphGamma() {
        return parseFloat(_context.getShaderConfig(SHADER_CONFIG.ANAGLYPH_GAMMA));
    }
    /**
     * Returns the anaglyph cyan factor converted to a number (from string)
     * @returns {Number}
     */
    function getAnaglyphCyanFactor() {
        return parseFloat(_context.getShaderConfig(SHADER_CONFIG.ANAGLYPH_CYAN_FACTOR));
    }
    /**
     * Returns the LiSPSM minimum near value converted to a number (from string)
     * @returns {Number}
     */
    function getLispsmMinimumNear() {
        return parseFloat(_context.getShaderConfig(SHADER_CONFIG.LISPSM_MINIMUM_NEAR));
    }
    /**
     * Returns the LiSPSM near factor converted to a number (from string)
     * @returns {Number}
     */
    function getLispsmNearFactor() {
        return parseFloat(_context.getShaderConfig(SHADER_CONFIG.LISPSM_NEAR_FACTOR));
    }
    /**
     * Add the passed callback function to be executed whenever handleSettingsChanged() is called
     * @param {Function} handler
     */
    function onSettingsChange(handler) {
        _changeHandlers.push(handler);
    }
    /**
     * Execute all the callback functions added via onSettingsChange()
     */
    function handleSettingsChanged() {
        var i;
        for (i = 0; i < _changeHandlers.length; i++) {
            _changeHandlers[i]();
        }
    }
    _context = new GraphicsSettingsContext();
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        SHADER_VARIANT_WITHOUT_SHADOWS_NAME: SHADER_VARIANT_WITHOUT_SHADOWS_NAME,
        SHADER_VARIANT_WITHOUT_DYNAMIC_LIGHTS_NAME: SHADER_VARIANT_WITHOUT_DYNAMIC_LIGHTS_NAME,
        loadConfigurationFromJSON: _context.loadConfigurationFromJSON.bind(_context),
        loadSettingsFromJSON: _context.loadSettingsFromJSON.bind(_context),
        loadSettingsFromLocalStorage: _context.loadFromLocalStorage.bind(_context),
        restoreDefaults: _context.restoreDefaults.bind(_context),
        getAntialiasing: _context.getAntialiasing.bind(_context),
        setAntialiasing: _context.setAntialiasing.bind(_context),
        getFiltering: _context.getFiltering.bind(_context),
        setFiltering: _context.setFiltering.bind(_context),
        getTextureQualities: _context.getTextureQualities.bind(_context),
        getTextureQuality: _context.getTextureQuality.bind(_context),
        setTextureQuality: _context.setTextureQuality.bind(_context),
        getTextureQualityPreferenceList: _context.getTextureQualityPreferenceList.bind(_context),
        getCubemapQualities: _context.getCubemapQualities.bind(_context),
        getCubemapQuality: _context.getCubemapQuality.bind(_context),
        setCubemapQuality: _context.setCubemapQuality.bind(_context),
        getCubemapQualityPreferenceList: _context.getCubemapQualityPreferenceList.bind(_context),
        getLODLevels: _context.getLODLevels.bind(_context),
        getLODLevel: _context.getLODLevel.bind(_context),
        getLOD: _context.getLOD.bind(_context),
        setLODLevel: _context.setLODLevel.bind(_context),
        getMaxLoadedLOD: _context.getMaxLoadedLOD.bind(_context),
        getLODContext: _context.getLODContext.bind(_context),
        setMissilesInLaunchersVisible: _context.setMissilesInLaunchersVisible.bind(_context),
        areMissilesInLaunchersVisible: _context.areMissilesInLaunchersVisible.bind(_context),
        getShaderComplexity: _context.getShaderComplexity.bind(_context),
        setShaderComplexity: _context.setShaderComplexity.bind(_context),
        getShaderComplexities: _context.getShaderComplexities.bind(_context),
        getMaxLuminosityFactors: _context.getShaderConfig.bind(_context, SHADER_CONFIG.MAX_LUMINOSITY_FACTORS),
        getMaxGroupTransforms: _context.getShaderConfig.bind(_context, SHADER_CONFIG.MAX_GROUP_TRANSFORMS),
        getLispsmMinimumNear: getLispsmMinimumNear,
        getLispsmNearFactor: getLispsmNearFactor,
        getShadowMappingShaderName: _context.getShadowMappingShaderName.bind(_context),
        isShadowMappingEnabled: _context.isShadowMappingEnabled.bind(_context),
        setShadowMapping: _context.setShadowMapping.bind(_context),
        getShadowMapQualities: _context.getShadowMapQualities.bind(_context),
        getShadowMapQuality: _context.getShadowMapQuality.bind(_context),
        getShadowMapTextureSize: _context.getShadowMapTextureSize.bind(_context),
        setShadowMapQuality: _context.setShadowMapQuality.bind(_context),
        getShadowDistances: _context.getShadowDistances.bind(_context),
        getShadowDistance: _context.getShadowDistance.bind(_context),
        setShadowDistance: _context.setShadowDistance.bind(_context),
        getShadowDepthRatio: _context.getShadowDepthRatio.bind(_context),
        getNumShadowMapSamples: _context.getNumShadowMapSamples.bind(_context),
        getMaxDirLights: _context.getMaxDirLights.bind(_context),
        getPointLightAmounts: _context.getPointLightAmounts.bind(_context),
        getPointLightAmount: _context.getPointLightAmount.bind(_context),
        getMaxPointLights: _context.getMaxPointLights.bind(_context),
        setPointLightAmount: _context.setPointLightAmount.bind(_context),
        getParticleAmounts: _context.getParticleAmounts.bind(_context),
        getParticleAmount: _context.getParticleAmount.bind(_context),
        getParticleCountFactor: _context.getParticleCountFactor.bind(_context),
        setParticleAmount: _context.setParticleAmount.bind(_context),
        getDustParticleAmounts: _context.getDustParticleAmounts.bind(_context),
        getDustParticleAmount: _context.getDustParticleAmount.bind(_context),
        getDustParticleCountFactor: _context.getDustParticleCountFactor.bind(_context),
        setDustParticleAmount: _context.setDustParticleAmount.bind(_context),
        getMaxSpotLights: _context.getMaxSpotLights.bind(_context),
        isShadowMappingAvailable: _context.isShadowMappingAvailable.bind(_context),
        areLuminosityTexturesAvailable: _context.areLuminosityTexturesAvailable.bind(_context),
        getGroupTransformIdentityArray: _context.getGroupTransformIdentityArray.bind(_context),
        isRevealAvailable: _context.isRevealAvailable.bind(_context),
        areDynamicLightsAvailable: _context.areDynamicLightsAvailable.bind(_context),
        canEnableShadowMapping: _context.canEnableShadowMapping.bind(_context),
        getTexture: _context.getTexture.bind(_context),
        getCubemap: _context.getCubemap.bind(_context),
        getShader: _context.getShader.bind(_context),
        getManagedShader: _context.getManagedShader.bind(_context),
        getModel: _context.getModel.bind(_context),
        getGeneralLevelNames: _context.getGeneralLevelNames.bind(_context),
        setGeneralLevel: _context.setGeneralLevel.bind(_context),
        getGeneralLevel: _context.getGeneralLevel.bind(_context),
        isAnaglyphRenderingEnabled: _context.isAnaglyphRenderingEnabled.bind(_context),
        getAnaglyphRenderingSettings: _context.getAnaglyphRenderingSettings.bind(_context),
        getAnaglyphOriginalColorRatio: getAnaglyphOriginalColorRatio,
        getAnaglyphGamma: getAnaglyphGamma,
        getAnaglyphCyanFactor: getAnaglyphCyanFactor,
        isSideBySideRenderingEnabled: _context.isSideBySideRenderingEnabled.bind(_context),
        getSideBySideRenderingSettings: _context.getSideBySideRenderingSettings.bind(_context),
        isShadowMapDebuggingEnabled: _context.isShadowMapDebuggingEnabled.bind(_context),
        getShadowMapDebuggingSettings: _context.getShadowMapDebuggingSettings.bind(_context),
        shouldUseShadowMapping: shouldUseShadowMapping,
        getShadowMappingShader: getShadowMappingShader,
        getShadowMappingSettings: getShadowMappingSettings,
        getAnaglyphRedShader: getAnaglyphRedShader,
        getAnaglyphCyanShader: getAnaglyphCyanShader,
        getSideBySideLeftShader: getSideBySideLeftShader,
        getSideBySideRightShader: getSideBySideRightShader,
        getShadowMapDebugShader: getShadowMapDebugShader,
        onSettingsChange: onSettingsChange,
        handleSettingsChanged: handleSettingsChanged,
        executeWhenReady: _context.executeWhenReady.bind(_context)
    };
});
/**
 * Copyright 2016, 2020 Krisztián Nagy
 * @file A stateful module that stores translation strings for different languages for the application and provides functions to load these
 * strings from an object 
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 0.1
 */

/*global define */

/**
 * @param types Used for parsing the string definition JSON with property and type verification
 * @param application Used for displaying error messages
 */
define('modules/strings',[
    "utils/types",
    "modules/application"
], function (types, application) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // constants
            CATEGORY_SEPARATOR = ".",
            // ------------------------------------------------------------------------------
            // holder for the exported functions
            exports = {},
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * 
             * @type String
             */
            _currentLanguage = null,
            /**
             * 
             * @type Object
             */
            _requiredStrings = {},
            /**
             * 
             * @type Object
             */
            _allStrings = {};
    /**
     * @typedef {Object} StringDefinitionObject Based on the property definition object in the types module.
     * @property {String} name The string is identified by this key.
     * @property {String} [defaultValue] The presence of this automatically makes the string optional.
     * @property {Boolean} [optional] To make the string optional without a default value.
     */
    /**
     * Returns the currently used language
     * @returns {String}
     */
    exports.getLanguage = function () {
        return _currentLanguage;
    };
    /**
     * After calling this, strings will be returned in the given language (if loaded)
     * @param {String} value
     */
    exports.setLanguage = function (value) {
        if (_allStrings.hasOwnProperty(value)) {
            _currentLanguage = value;
        } else {
            application.showError("Cannot set language to '" + value + "', as there are no strings loaded for that language!");
        }
    };
    /**
     * Returns whether a strings file has been loaded for the specified language F
     * @param {String} language
     * @returns {Boolean}
     */
    exports.languageIsLoaded = function (language) {
        return _allStrings.hasOwnProperty(language);
    };
    /**
     * Recursively creates a flat JSON object out of the passed one by using concatenated keys (separated by a separator) instead of nested
     * objects (i.e. {"super": { "sub": "value" }} becomes {"super.sub": "value"})
     * @param {Object} categoryObject This object gets modified to be flat
     */
    function _flatten(categoryObject) {
        var categoryName, stringName;
        for (categoryName in categoryObject) {
            if (categoryObject.hasOwnProperty(categoryName) && (typeof categoryObject[categoryName] === "object")) {
                _flatten(categoryObject[categoryName]);
                for (stringName in categoryObject[categoryName]) {
                    if (categoryObject[categoryName].hasOwnProperty(stringName)) {
                        categoryObject[categoryName + CATEGORY_SEPARATOR + stringName] = categoryObject[categoryName][stringName];
                    }
                }
                // the original category object is deleted so it will not be processed
                delete categoryObject[categoryName];
            }
        }
    }
    /**
     * @param {String} language The (ID of) the language for which to load the strings.
     * @param {Object} stringsJSON This object needs to contain the strings for the given language. Structure:
     * {
     *   "categoryNameOne": {
     *     "stringNameOne": "stringEins"
     *   },
     *   "categoryNameTwo": {
     *     "stringNameTwo": "stringZwei",
     *     "subcategoryNameOne": {
     *       "anotherStringName": "anotherStringInGerman"
     *     }
     *   }
     * @param {Object} stringDefinitions This object is used to verify the content of the strings JSON. Its structure:
     * {
     *   "stringCategoryOne": {
     *     "stringWhichIsRequiredToBeInTheStringObject": {
     *       name: "categoryNameOne.stringNameOne"
     *     }
     *   },
     *   "stringCategoryTwo": {  
     *     "thisStringIsNotRequired": {
     *       name: "categoryNameTwo.stringNameTwo",
     *       defaultValue: "string2"
     *     },
     *     "thisIsNotRequiredEitherButItDoesntHaveAValue": {
     *       name: "categoryNameTwo.subcategoryNameOne.anotherStringName",
     *       optional: true
     *     }
     *   }
     *   The categories are matched based on what is given in the name property using dot notation, the categories in the definition object
     *   does not need to be organized the same way (can be just one big category)
     *   The format is based on the types module object definition format, see there for more details.
     */
    exports.loadStrings = function (language, stringsJSON, stringDefinitions) {
        var categoryName;
        _requiredStrings[language] = {};
        // first, keys organized into categories are moved up to the first level of the JSON structure, so the processing will need to handle
        // a simple flat JSON
        _flatten(stringsJSON);
        // now we handle the simple flat JSON containing all the strings by their keys
        for (categoryName in stringDefinitions) {
            if (stringDefinitions.hasOwnProperty(categoryName) && (typeof stringDefinitions[categoryName] === "object")) {
                types.getVerifiedObject("strings." + categoryName, stringsJSON, stringDefinitions[categoryName], _requiredStrings[language], false, true, "string");
            }
        }
        _allStrings[language] = types.getVerifiedObject("strings." + categoryName, stringsJSON, {}, null, true, true, "string");
        if (!_currentLanguage) {
            exports.setLanguage(language);
        }
    };
    /**
     * Returns the string identified by the passed definition object for the currently set language.
     * @param {StringDefinitionObject} stringDefinitionObject If there is no available string with the name specified in this object, the
     * default value specified in it will be returned (if it exists)
     * @param {String} [suffix] If given, will be appended at the end of the name specified in the definition object.
     * @param {String} [defaultValue] If given, will override the default value given in the definition object.
     * @returns {String}
     */
    exports.get = function (stringDefinitionObject, suffix, defaultValue) {
        return (_allStrings[_currentLanguage] && _allStrings[_currentLanguage][stringDefinitionObject.name + (suffix || "")]) ||
                defaultValue ||
                stringDefinitionObject.defaultValue ||
                (stringDefinitionObject.name + (suffix || ""));
    };
    /**
     * Returns whether there is a string set for given string definition in the current language.
     * @param {StringDefinitionObject} stringDefinitionObject
     * @param {String} [suffix]
     * @returns {Boolean}
     */
    exports.has = function (stringDefinitionObject, suffix) {
        return _allStrings[_currentLanguage] && (_allStrings[_currentLanguage][stringDefinitionObject.name + (suffix || "")] !== undefined);
    };
    /**
     * Returns a list of all the translation keys that start with the passed prefix.
     * @param {String} prefix
     * @returns {String[]}
     */
    exports.getKeys = function (prefix) {
        return Object.keys(_allStrings[_currentLanguage]).filter(function (key) {
            return key.indexOf(prefix) === 0;
        });
    };
    exports.CATEGORY_SEPARATOR = CATEGORY_SEPARATOR;
    return exports;
});

/**
 * Copyright 2016-2020 Krisztián Nagy
 * @file Augments the general strings module with constants and functions to conveniently access strings in the game and to verify their 
 * presence in the strings files.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 0.1
 */

/*global define */

/**
 * @param strings This module augments the general strings module.
 */
define('armada/strings',[
    "modules/strings"
], function (strings) {
    "use strict";
    strings.GRAMMAR = {
        DEFINITE_ARTICLE_BEFORE_VOWEL: {name: "grammar.definiteArticle.beforeVowel"},
        DEFINITE_ARTICLE_BEFORE_CONSONANT: {name: "grammar.definiteArticle.beforeConsonant"},
        AND: {name: "grammar.and"}
    };
    strings.FIRST_RUN_NOTE = {
        HEADER: {name: "firstRunNote.header"},
        MESSAGE: {name: "firstRunNote.message"},
        BUTTON: {name: "firstRunNote.button"}
    };
    strings.RELEASE_NOTES = {
        PREFIX: {name: "releaseNotes.", optional: true},
        HEADER: {name: "releaseNotes.header"},
        GENERAL: {name: "releaseNotes.general"},
        NO_NEWS: {name: "releaseNotes.noNews"},
        BUTTON: {name: "releaseNotes.button"}
    };
    strings.SCREEN = {
        BACK: {name: "screen.back"},
        CANCEL: {name: "screen.cancel"}
    };
    strings.MAIN_MENU = {
        NEW_GAME: {name: "mainMenu.newGame"},
        DATABASE: {name: "mainMenu.database"},
        SETTINGS: {name: "mainMenu.settings"},
        ABOUT: {name: "mainMenu.about"},
        QUIT: {name: "mainMenu.quit"}
    };
    strings.MISSIONS = {
        BACK: {name: "missions.backButton"},
        TITLE: {name: "missions.title"},
        DIFFICULTY: {name: "missions.difficulty"},
        LAUNCH_BUTTON: {name: "missions.launchButton"},
        DEMO_BUTTON: {name: "missions.demoButton"},
        FILE_BUTTON: {name: "missions.fileButton"},
        CUSTOM_MISSION_CAPTION: {name: "missions.customMissionCaption"},
        CUSTOM_MISSION_SUBCAPTION: {name: "missions.customMissionSubcaption"},
        NOT_COMPLETED: {name: "missions.notCompleted"},
        BEST_SCORE: {name: "missions.bestScore"},
        SANDBOX_COMPLETED: {name: "missions.sandboxCompleted"},
        NO_SELECTED_NAME: {name: "missions.noSelectedName"},
        NO_SELECTED_DESCRIPTION: {name: "missions.noSelectedDescription"},
        CUSTOM_DESCRIPTION: {name: "missions.customDescription"},
        LOCATION: {name: "missions.location"},
        CREATED_BY: {name: "missions.createdBy"},
        LOADING_DESCRIPTION: {name: "missions.loadingDescription"},
        NO_TRANSLATED_DESCRIPTION: {name: "missions.noTranslatedDescription"},
        NO_DESCRIPTION: {name: "missions.noDescription"},
        OBJECTIVES_TITLE: {name: "missions.missionObjectivesTitle"},
        SPACECRAFT_TITLE: {name: "missions.playerSpacecraftTitle"},
        SPACECRAFT_DATA: {name: "missions.playerSpacecraftData"},
        SPACECRAFT_WEAPONS: {name: "missions.playerSpacecraftWeapons"},
        SPACECRAFT_MISSILES: {name: "missions.playerSpacecraftMissiles"},
        SPACECRAFT_SHIELD: {name: "missions.playerSpacecraftShield"},
        SPACECRAFT_PROPULSION: {name: "missions.playerSpacecraftPropulsion"},
        OBJECTIVE_SUBJECTS_SQUAD: {name: "missions.objectiveSubjects.squad"},
        OBJECTIVE_SUBJECTS_SQUADS: {name: "missions.objectiveSubjects.squads"},
        OBJECTIVE_SUBJECTS_TEAM: {name: "missions.objectiveSubjects.team"},
        OBJECTIVE_SUBJECTS_TEAMS: {name: "missions.objectiveSubjects.teams"},
        OBJECTIVE_WIN_PREFIX: {name: "missions.winObjective.", optional: true},
        OBJECTIVE_LOSE_PREFIX: {name: "missions.loseObjective.", optional: true}
    };
    strings.OBJECTIVE = {
        DESTROY_ALL_SUFFIX: {name: "destroyAll", optional: true},
        DESTROY_SUFFIX: {name: "destroy", optional: true},
        DESTROY_ONE_SUFFIX: {name: "destroyOne", optional: true},
        DESTROY_ANY_SUFFIX: {name: "destroyAny", optional: true},
        COUNT_BELOW_SUFFIX: {name: "countBelow", optional: true},
        TIME_SUFFIX: {name: "time", optional: true},
        TIME_MULTI_SUFFIX: {name: "timeMulti", optional: true}
    };
    strings.LOCATION = {
        UNKNOWN: {name: "location.unknown"},
        SYSTEM: {name: "location.system"}
    };
    strings.SETTINGS = {
        GENERAL: {name: "settings.general"},
        GRAPHICS: {name: "settings.graphics"},
        AUDIO: {name: "settings.audio"},
        GAMEPLAY: {name: "settings.gameplay"},
        CONTROLS: {name: "settings.controls"},
        DEFAULTS: {name: "settings.defaults"}
    };
    strings.INGAME_MENU = {
        TITLE: {name: "ingameMenu.title"},
        RESUME: {name: "ingameMenu.resume"},
        RESTART: {name: "ingameMenu.restart"},
        RESTART_HEADER: {name: "ingameMenu.restartDialog.header"},
        RESTART_MESSAGE: {name: "ingameMenu.restartDialog.message"},
        RESTART_RESTART: {name: "ingameMenu.restartDialog.restartButton"},
        QUIT: {name: "ingameMenu.quit"},
        QUIT_HEADER: {name: "ingameMenu.quitDialog.header"},
        QUIT_MESSAGE: {name: "ingameMenu.quitDialog.message"},
        QUIT_TO_MISSIONS: {name: "ingameMenu.quitDialog.quitToMissionsButton"},
        QUIT_TO_MAIN_MENU: {name: "ingameMenu.quitDialog.quitToMainMenuButton"}
    };
    strings.INFO_BOX = {
        HEADER: {name: "infoBox.header"},
        OK_BUTTON: {name: "infoBox.okButton"}
    };
    strings.LOADING = {
        HEADER: {name: "loading.header"},
        RESOURCES_START: {name: "loading.resourcesStart"},
        RESOURCE_READY: {name: "loading.resourceReady"},
        INIT_WEBGL: {name: "loading.initWebGL"},
        READY: {name: "loading.ready"}
    };
    strings.SPACECRAFT_STATS = {
        ARMOR: {name: "spacecraftStats.armor"},
        ARMOR_RATING: {name: "spacecraftStats.armorRating"}
    };
    strings.MISSION = {
        PREFIX: {name: "mission.", optional: true},
        NAME_SUFFIX: {name: ".name", optional: true},
        DESCRIPTION_SUFFIX: {name: ".description", optional: true},
        MESSAGES_SUFFIX: {name: ".messages.", optional: true}
    };
    strings.FACTION = {
        PREFIX: {name: "faction.", optional: true}
    };
    strings.SQUAD = {
        PREFIX: {name: "squad.", optional: true}
    };
    strings.BATTLE = {
        DEVELOPMENT_VERSION_NOTICE: {name: "battle.developmentVersionNotice"},
        SPECTATOR_MODE: {name: "battle.spectatorMode"},
        SCORE: {name: "battle.score"},
        HUD_FIREPOWER: {name: "battle.hud.firepower"},
        HUD_DISTANCE: {name: "battle.hud.distance"},
        HUD_VELOCITY: {name: "battle.hud.velocity"},
        HUD_SPACECRAFT_NAME_UNKNOWN: {name: "battle.hud.spacecraftNameUnknown"},
        HUD_TEAM_UNKNOWN: {name: "battle.hud.teamUnknown"},
        HUD_WINGMEN_HEADER: {name: "battle.hud.wingmenHeader"},
        HUD_FLIGHT_MODE: {name: "battle.hud.flightMode"},
        HUD_MISSILES: {name: "battle.hud.missiles"},
        HUD_OBJECTIVES: {name: "battle.hud.objectives"},
        HUD_ESCORTED_SHIPS_HEADER: {name: "battle.hud.escortedShipsHeader"},
        OBJECTIVE_SUBJECTS_SPACECRAFTS: {name: "battle.objectiveSubjects.spacecrafts"},
        OBJECTIVE_SUBJECTS_SQUADS: {name: "battle.objectiveSubjects.squads"},
        OBJECTIVE_SUBJECTS_TEAMS: {name: "battle.objectiveSubjects.teams"},
        OBJECTIVE_WIN_PREFIX: {name: "battle.winObjective.", optional: true},
        OBJECTIVE_LOSE_PREFIX: {name: "battle.loseObjective.", optional: true},
        LOADING_BOX_LOADING_MISSION: {name: "battle.loadingBox.loadingMission"},
        LOADING_BOX_BUILDING_SCENE: {name: "battle.loadingBox.buildingScene"},
        MESSAGE_READY: {name: "battle.message.ready"},
        MESSAGE_PAUSED: {name: "battle.message.paused"},
        MESSAGE_VICTORY: {name: "battle.message.victory"},
        MESSAGE_FAIL: {name: "battle.message.fail"},
        MESSAGE_DEFEAT_HEADER: {name: "battle.message.defeat.header"},
        MESSAGE_DEFEAT_MESSAGE: {name: "battle.message.defeat.message"},
        MESSAGE_DEFEAT_DEBRIEFING: {name: "battle.message.defeat.debriefingButton"},
        MESSAGE_DEFEAT_RESTART: {name: "battle.message.defeat.restartButton"},
        MESSAGE_DEFEAT_SPECTATE: {name: "battle.message.defeat.spectateButton"},
        MESSAGE_JUMP_ENGAGED: {name: "battle.message.jump.engaged"},
        MESSAGE_JUMP_PREPARING: {name: "battle.message.jump.preparing"},
        MESSAGE_NEW_HOSTILES: {name: "battle.message.newHostiles"}
    };
    strings.PERFORMANCE_LEVEL = {
        PREFIX: {name: "performanceLevel.", optional: true}
    };
    strings.DEBRIEFING = {
        BACK: {name: "debriefing.backButton"},
        VICTORY_TITLE: {name: "debriefing.victoryTitle"},
        DEFEAT_TITLE: {name: "debriefing.defeatTitle"},
        GENERIC_TITLE: {name: "debriefing.genericTitle"},
        SCORE: {name: "debriefing.score"},
        NEW_RECORD: {name: "debriefing.newRecord"},
        DESCRIPTION_VICTORY: {name: "debriefing.description.victory"},
        DESCRIPTION_NEXT_PERFORMANCE: {name: "debriefing.description.nextPerformance"},
        DESCRIPTION_FAIL: {name: "debriefing.description.fail"},
        DESCRIPTION_DEFEAT: {name: "debriefing.description.defeat"},
        DESCRIPTION_LEFT_EARLY: {name: "debriefing.description.leftEarly"},
        DESCRIPTION_GENERIC: {name: "debriefing.description.generic"},
        OBJECTIVES_HEADER: {name: "debriefing.objectivesHeader"},
        COMPLETED: {name: "debriefing.completed"},
        FAILED: {name: "debriefing.failed"},
        STATISTICS_HEADER: {name: "debriefing.statisticsHeader"},
        TIME_LABEL_CELL: {name: "debriefing.timeLabelCell"},
        KILLS_LABEL_CELL: {name: "debriefing.killsLabelCell"},
        DAMAGE_LABEL_CELL: {name: "debriefing.damageLabelCell"},
        HIT_RATIO_LABEL_CELL: {name: "debriefing.hitRatioLabelCell"},
        HULL_INTEGRITY_LABEL_CELL: {name: "debriefing.hullIntegrityLabelCell"},
        TEAM_SURVIVAL_LABEL_CELL: {name: "debriefing.teamSurvivalLabelCell"},
        BASE_SCORE_LABEL_CELL: {name: "debriefing.baseScoreLabelCell"},
        HIT_RATIO_BONUS_LABEL_CELL: {name: "debriefing.hitRatioBonusLabelCell"},
        HULL_INTEGRITY_BONUS_LABEL_CELL: {name: "debriefing.hullIntegrityBonusLabelCell"},
        TEAM_SURVIVAL_BONUS_LABEL_CELL: {name: "debriefing.teamSurvivalBonusLabelCell"},
        SCORE_BREAKDOWN_HEADER: {name: "debriefing.scoreBreakdownHeader"},
        RESTART_BUTTON: {name: "debriefing.restartButton"}
    };
    strings.DATABASE = {
        BACK: {name: "database.backButton"},
        TITLE: {name: "database.title"},
        PREV_BUTTON: {name: "database.prevButton"},
        NEXT_BUTTON: {name: "database.nextButton"},
        LOADING_BOX_INITIALIZING: {name: "database.loadingBox.initializing"},
        LENGTH: {name: "database.length"},
        WEAPON_SLOTS: {name: "database.weaponSlots"},
        MISSILE_LAUNCHERS: {name: "database.missileLaunchers"},
        LOCK_RESIST: {name: "database.lockResist"},
        MISSING_SPACECRAFT_TYPE_DESCRIPTION: {name: "database.missingSpacecraftTypeDescription"},
        MISSING_SPACECRAFT_CLASS_DESCRIPTION: {name: "database.missingSpacecraftClassDescription"}
    };
    strings.ABOUT = {
        BACK: {name: "about.backButton"},
        TITLE: {name: "about.title"},
        VERSION_PARAGRAPH: {name: "about.versionParagraph"},
        ABOUT_GAME_PARAGRAPH: {name: "about.aboutGameParagraph"},
        ABOUT_GAME_DEV_PARAGRAPH: {name: "about.aboutGameDevParagraph"},
        LICENSE_NOTE: {name: "about.licenseNote"},
        CREDITS_HEADER: {name: "about.creditsHeader"},
        CREDITS_GAME_DESIGN: {name: "about.creditsGameDesign"},
        CREDITS_PROGRAMMING: {name: "about.creditsProgramming"},
        CREDITS_REQUIREJS_NOTE: {name: "about.creditsRequireJSNote"},
        CREDITS_FONTS: {name: "about.creditsFonts"},
        CREDITS_MODELS: {name: "about.credits3DModels"},
        CREDITS_TEXTURES: {name: "about.creditsTextures"},
        CREDITS_MUSIC: {name: "about.creditsMusic"},
        CREDITS_SFX: {name: "about.creditsSoundEffects"},
        CREDITS_FREESOUND_NOTE: {name: "about.creditsFreesoundNote"},
        CREDITS_OTHER_SOUNDS_NOTE: {name: "about.creditsOtherSoundsNote"},
        CREDITS_SOUND_LICENSE_NOTE: {name: "about.creditsSoundLicenseNote"},
        CREDITS_TESTING: {name: "about.creditsTesting"},
        USED_SOFTWARE_HEADER: {name: "about.usedSoftwareHeader"},
        USED_SOFTWARE_PARAGRAPH: {name: "about.usedSoftwareParagraph"},
        LICENSE_HEADER: {name: "about.licenseHeader"},
        LICENSE_PARAGRAPH: {name: "about.licenseParagraph"},
        REQUIRE_JS_LICENSE: {name: "about.requireJSLicense"},
        HERE: {name: "about.here"}
    };
    strings.SETTING = {
        PREFIX: {name: "setting.", optional: true},
        ON: {name: "setting.on"},
        OFF: {name: "setting.off"},
        VERY_LOW: {name: "setting.veryLow"},
        LOW: {name: "setting.low"},
        MEDIUM: {name: "setting.medium"},
        HIGH: {name: "setting.high"},
        VERY_HIGH: {name: "setting.veryHigh"},
        NORMAL: {name: "setting.normal"},
        MINIMUM: {name: "setting.minimum"},
        MAXIMUM: {name: "setting.maximum"},
        FEW: {name: "setting.few"},
        MANY: {name: "setting.many"},
        EASY: {name: "setting.easy"},
        HARD: {name: "setting.hard"},
        CUSTOM: {name: "setting.custom"}
    };
    strings.GENERAL_SETTINGS = {
        BACK: {name: "generalSettings.backButton"},
        TITLE: {name: "generalSettings.title"},
        LANGUAGE: {name: "generalSettings.language"},
        ANALYTICS: {name: "generalSettings.analytics"},
        ANALYTICS_NOTE: {name: "generalSettings.analyticsNote"}
    };
    strings.GRAPHICS = {
        PREFIX: {name: "graphics.", optional: true},
        BACK: {name: "graphics.backButton"},
        TITLE: {name: "graphics.title"},
        GENERAL_LEVEL: {name: "graphics.generalLevel"},
        ANTIALIASING: {name: "graphics.antialiasing"},
        FILTERING: {name: "graphics.filtering"},
        BILINEAR: {name: "graphics.bilinear"},
        TRILINEAR: {name: "graphics.trilinear"},
        ANISOTROPIC: {name: "graphics.anisotropic"},
        TEXTURE_QUALITY: {name: "graphics.textureQuality"},
        BACKGROUND_QUALITY: {name: "graphics.backgroundQuality"},
        MODEL_DETAILS: {name: "graphics.modelDetails"},
        MISSILES_IN_LAUNCHERS: {name: "graphics.missilesInLaunchers"},
        SHADERS: {name: "graphics.shaders"},
        SHADOWS: {name: "graphics.shadows"},
        SHADOW_QUALITY: {name: "graphics.shadowQuality"},
        SHADOW_DISTANCE: {name: "graphics.shadowDistance"},
        MAX_DYNAMIC_LIGHTS: {name: "graphics.maxDynamicLights"},
        PARTICLE_AMOUNT: {name: "graphics.particleAmount"},
        DUST_PARTICLE_AMOUNT: {name: "graphics.dustParticleAmount"}
    };
    strings.GAMEPLAY_SETTINGS = {
        PREFIX: {name: "gameplaySettings.", optional: true},
        BACK: {name: "gameplaySettings.backButton"},
        TITLE: {name: "gameplaySettings.title"},
        HUD_TITLE: {name: "gameplaySettings.hudTitle"},
        CAMERA_TITLE: {name: "gameplaySettings.cameraTitle"},
        CONTROLS_TITLE: {name: "gameplaySettings.controlsTitle"},
        TARGET_HEALTH_AT_CENTER: {name: "gameplaySettings.targetHealthAtCenter"},
        OFFSET_IMPACT_INDICATORS: {name: "gameplaySettings.offsetImpactIndicators"},
        RELATIVE_TARGET_ORIENTATION: {name: "gameplaySettings.relativeTargetOrientation"},
        PREFERRED_FIGHTER_VIEW: {name: "gameplaySettings.preferredFighterView"},
        PREFERRED_SHIP_VIEW: {name: "gameplaySettings.preferredShipView"},
        DEMO_VIEW_SWITCHING: {name: "gameplaySettings.demoViewSwitching"},
        DEFAULT_SALVO_MODE: {name: "gameplaySettings.defaultSalvoMode"}
    };
    strings.AUDIO = {
        PREFIX: {name: "audio.", optional: true},
        BACK: {name: "audio.backButton"},
        TITLE: {name: "audio.title"},
        MASTER_VOLUME: {name: "audio.masterVolume"},
        MUSIC_VOLUME: {name: "audio.musicVolume"},
        SFX_VOLUME: {name: "audio.sfxVolume"},
        UI_VOLUME: {name: "audio.uiVolume"}
    };
    strings.CONTOLLER = {
        PREFIX: {name: "controller.", optional: true},
        GENERAL: {name: "controller.general"},
        FIGHTER: {name: "controller.fighter"},
        CAMERA: {name: "controller.camera"}
    };
    strings.INPUT = {
        DEVICE_NAME_PREFIX: {name: "inputDevice.", optional: true},
        DEVICE_KEYBOARD: {name: "inputDevice.keyboard"},
        DEVICE_MOUSE: {name: "inputDevice.mouse"},
        DEVICE_JOYSTICK: {name: "inputDevice.joystick"}
    };
    strings.TOUCH_AREA = {
        PREFIX: {name: "touchArea.", optional: true},
        DEFAULT: {name: "touchArea.default"}
    };
    strings.CONTROLS = {
        BACK: {name: "controls.backButton"},
        SETTINGS_TITLE: {name: "controls.settingsTitle"},
        TITLE: {name: "controls.title"},
        MOUSE_TURN_SENSITIVITY: {name: "controls.mouseTurnSensitivity"},
        CONTROLLER_TYPE_HEADING: {name: "controls.controllerHeading"},
        ACTION: {name: "controls.action"}
    };
    strings.ACTION_DESCRIPTIONS = {
        PREFIX: {name: "actionDescriptions.", optional: true}
    };
    strings.SPACECRAFT_CLASS = {
        PREFIX: {name: "spacecraftClass.", optional: true},
        NAME_SUFFIX: {name: ".name", optional: true},
        DESCRIPTION_SUFFIX: {name: ".description", optional: true}
    };
    strings.SPACECRAFT_TYPE = {
        PREFIX: {name: "spacecraftType.", optional: true},
        NAME_SUFFIX: {name: ".name", optional: true},
        DESCRIPTION_SUFFIX: {name: ".description", optional: true}
    };
    strings.WEAPON_CLASS = {
        PREFIX: {name: "weaponClass.", optional: true},
        NAME_SUFFIX: {name: ".name", optional: true},
        DESCRIPTION_SUFFIX: {name: ".description", optional: true}
    };
    strings.MISSILE_CLASS = {
        PREFIX: {name: "missileClass.", optional: true},
        NAME_SUFFIX: {name: ".name", optional: true},
        DESCRIPTION_SUFFIX: {name: ".description", optional: true}
    };
    strings.PROPULSION_CLASS = {
        PREFIX: {name: "propulsionClass.", optional: true},
        NAME_SUFFIX: {name: ".name", optional: true},
        DESCRIPTION_SUFFIX: {name: ".description", optional: true}
    };
    strings.SHIELD_CLASS = {
        PREFIX: {name: "shieldClass.", optional: true},
        NAME_SUFFIX: {name: ".name", optional: true},
        DESCRIPTION_SUFFIX: {name: ".description", optional: true}
    };
    strings.MISSILE_SIZE = {
        PREFIX: {name: "missileSize.", optional: true}
    };
    strings.OBJECT_VIEW = {
        PREFIX: {name: "objectView.", optional: true}
    };
    strings.FLIGHT_MODE = {
        PREFIX: {name: "flightMode.", optional: true}
    };
    strings.TIP = {
        PREFIX: {name: "tip.", optional: true}
    };
    /**
     * Returns whether the passed word start with a vowel (one that is recognized)
     * @param {String} word
     * @returns {Boolean}
     */
    function startsWithVowel(word) {
        var char = word[0].toLowerCase();
        return (char === "a") || (char === "e") || (char === "u") || (char === "i") || (char === "o") ||
                (char === "á") || (char === "é") || (char === "ú") || (char === "ü") || (char === "ű") || (char === "í") || (char === "ó") || (char === "ö") || (char === "ő");
    }
    /**
     * Returns the translated definite article that should be used with the passed (translated) word
     * @param {String} word
     * @returns {String}
     */
    strings.getDefiniteArticleForWord = function (word) {
        return strings.get(startsWithVowel(word) ? strings.GRAMMAR.DEFINITE_ARTICLE_BEFORE_VOWEL : strings.GRAMMAR.DEFINITE_ARTICLE_BEFORE_CONSONANT);
    };
    /**
     * Returns a string that can be used to display the list of the passed translated items in the current language.
     * @param {String[]} items
     * @returns {String}
     */
    strings.getList = function (items) {
        var result, i;
        result = items[0];
        for (i = 1; i < items.length - 1; i++) {
            result += (", " + items[i]);
        }
        if (items.length > 1) {
            result += (" " + strings.get(strings.GRAMMAR.AND) + " " + items[items.length - 1]);
        }
        return result;
    };
    return strings;
});

/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides functionality for loading the definitions for in-game classes from a JSON file and then accessing the loaded classes by
 * type and name. Also provides constructors for those classes of which custom instances can be created.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define */

/**
 * @param utils Required for managing enums
 * @param types Used for type checking
 * @param vec Required for calculating vectors when initializing certain classes
 * @param mat Required for parsing matrices and determining rotation angles
 * @param application Required for error displaying and file loading functionality
 * @param resourceManager All the loadable classes are subclassed from GenericResource, and the module manages the loaded classes with a ResourceManager
 * @param egomModel Required for default basic (e.g. particle) models
 * @param physics Required for loading Body instances for the physical model of the spacecrafts
 * @param resources This module accesses media resources to assign them to classes when they are initialized
 * @param camera Required for parsing camera related enums
 * @param renderableObjects Required for creating particle states
 * @param graphics Required to access resources according to current graphics settings
 * @param strings Used for translation support
 */
define('armada/logic/classes',[
    "utils/utils",
    "utils/types",
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/resource-manager",
    "modules/egom-model",
    "modules/physics",
    "modules/media-resources",
    "modules/scene/camera",
    "modules/scene/renderable-objects",
    "armada/graphics",
    "armada/strings"
], function (
        utils, types, vec, mat,
        application, resourceManager, egomModel, physics, resources,
        camera, renderableObjects,
        graphics, strings) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // enums
            ParticleEmitterType = {
                OMNIDIRECTIONAL: "omnidirectional",
                UNIDIRECTIONAL: "unidirectional",
                PLANAR: "planar"
            },
            ObjectViewLookAtMode = {
                NONE: "none",
                SELF: "self",
                TARGET: "target"
            },
            SceneViewLookAtMode = {
                NONE: "none",
                ALL: "all"
            },
            /**
             * @enum {String}
             * Determines whether a missile can be equipped in a launcher (size of the missile
             * has to be the same as size of the launcher)
             * @type Object
             */
            MissileSize = {
                SMALL: "small",
                MEDIUM: "medium",
                LARGE: "large"
            },
            /**
             * @enum {Number}
             * Determines the way the missile homes in on its target
             * @type Object
             */
            MissileHomingMode = {
                /**
                 * The missile has no homing capabilities (i.e. no maneuvering thrusters), it flies
                 * straight in the way it was launched
                 */
                NONE: 0,
                /**
                 * The missile orients itself towards the target's expected position after launch,
                 * and flies straight from then onwards
                 */
                INITIAL: 1,
                /**
                 * The missile continuously uses its maneuvering thrusters to orient itself towards
                 * the target's expected position
                 */
                CONTINUOUS: 2
            },
            /**
             * @enum {String}
             * Determines how to translate a direction to rotation angles for a weapon.
             * @type Object
             */
            WeaponRotationStyle = {
                /**
                 * The weapon cannot be rotated, it is pointing in a fix direction: the positive Y.
                 */
                NONE: "none",
                /**
                 * The weapon has two rotators. The first one rotates around axis Z starting from the positive Y direction, clockwise.
                 * The second one further rotates the direction around the rotated X axis, clockwise.
                 */
                YAW_PITCH: "yawPitch",
                /**
                 * The weapon has two rotators. The first one rotates around axis Y starting from the positive X direction, counter-clockwise.
                 * The second one further rotates the direction around the rotated Z axis, counter-clockwise.
                 */
                ROLL_YAW: "rollYaw"
            },
            /**
             * @enum {String}
             * Spacecrafts controlled by the AI can use one of these styles when orienting themselves.
             * @type Object
             */
            SpacecraftTurnStyle = {
                /**
                 * The spacecraft is turning by changing its yaw and pitch (that is, turning its positive Y vector left/right/up/down)
                 */
                YAW_PITCH: "yawPitch",
                /**
                 * The spacecraft is turning by changing its roll and yaw (that is, rolling around its positive Y vector and turning it left/right)
                 */
                ROLL_YAW: "rollYaw",
                /**
                 * The spacecraft is turning by changing its roll and pitch (that is, rolling around its positive Y vector and turning it up/down)
                 */
                ROLL_PITCH: "rollPitch"
            },
            // ------------------------------------------------------------------------------
            // constants
            /**
             * In the class description file, skybox classes will be initialized from the array with this name
             * @type String
             */
            SKYBOX_CLASS_ARRAY_NAME = "skyboxClasses",
            /**
             * In the class description file, background object classes will be initialized from the array with this name
             * @type String
             */
            BACKGROUND_OBJECT_CLASS_ARRAY_NAME = "backgroundObjectClasses",
            /**
             * In the class description file, dust cloud classes will be initialized from the array with this name
             * @type String
             */
            DUST_CLOUD_CLASS_ARRAY_NAME = "dustCloudClasses",
            /**
             * In the class description file, explosion classes will be initialized from the array with this name
             * @type String
             */
            EXPLOSION_CLASS_ARRAY_NAME = "explosionClasses",
            /**
             * In the class description file, projectile classes will be initialized from the array with this name
             * @type String
             */
            PROJECTILE_CLASS_ARRAY_NAME = "projectileClasses",
            /**
             * In the class description file, missile classes will be initialized from the array with this name
             * @type String
             */
            MISSILE_CLASS_ARRAY_NAME = "missileClasses",
            /**
             * In the class description file, weapon classes will be initialized from the array with this name
             * @type String
             */
            WEAPON_CLASS_ARRAY_NAME = "weaponClasses",
            /**
             * In the class description file, propulsion classes will be initialized from the array with this name
             * @type String
             */
            PROPULSION_CLASS_ARRAY_NAME = "propulsionClasses",
            /**
             * In the class description file, jump engine classes will be initialized from the array with this name
             * @type String
             */
            JUMP_ENGINE_CLASS_ARRAY_NAME = "jumpEngineClasses",
            /**
             * In the class description file, shield classes will be initialized from the array with this name
             * @type String
             */
            SHIELD_CLASS_ARRAY_NAME = "shieldClasses",
            /**
             * In the class description file, spacecraft types will be initialized from the array with this name
             * @type String
             */
            SPACECRAFT_TYPE_ARRAY_NAME = "spacecraftTypes",
            /**
             * In the class description file, spacecraft classes will be initialized from the array with this name
             * @type String
             */
            SPACECRAFT_CLASS_ARRAY_NAME = "spacecraftClasses",
            /**
             * Used in names of generated models when separating array elements
             * @type String
             */
            MODEL_NAME_SEPARATOR = "-",
            /**
             * When a model is created for skyboxes, this ID will be given to it, so that all skyboxes can refer to the same model
             * @type String
             */
            SKYBOX_MODEL_NAME = "fvqModel",
            /**
             * When a model is created for particles, this ID will be given to it, so that all particles can refer to the same model
             * @type String
             */
            PARTICLE_MODEL_NAME = "squareModel",
            /**
             * When a model is created for trail segments, this ID will be given to it, so that all trail segments can refer to the same model
             * @type String
             */
            TRAIL_SEGMENT_MODEL_NAME = "squareModel",
            /**
             * When a model is created for dust particles, this ID will be given to it, so that all dust particles can refer to the same model
             * @type String
             */
            DUST_MODEL_NAME = "dust",
            /**
             * When a model is created for projectiles, this ID will be used as a prefix to the model ID with the following part being dependent of
             * the parameters of the model, so that projectiles having models with the same parameters can use the same model
             * @type String
             */
            PROJECTILE_MODEL_NAME_PREFIX = "projectileModel-",
            /**
             * Used on the names of models generated for projectiles between the parameters.
             * @type String
             */
            PROJECTILE_MODEL_NAME_INFIX = "-width-",
            /**
             * The name (ID) of shader variants to be used (if available) for shaders when instancing is turned on
             * @type String
             */
            SHADER_VARIANT_INSTANCED_NAME = "instanced",
            /**
             * A definition object with the structure of a non-spatialized sound effect descriptors, used for type verification.
             * @type Object
             */
            SOUND_EFFECT = {
                NAME: {
                    name: "name",
                    type: "string"
                },
                VOLUME: {
                    name: "volume",
                    type: "number",
                    range: [0, 10],
                    defaultValue: 1
                },
                RESOURCE: {
                    name: "resource",
                    type: "object",
                    optional: true
                }
            },
            /**
             * A definition object with the structure of 3D sound effect descriptors, used for type verification.
             * @type Object
             */
            SOUND_EFFECT_3D = {
                NAME: {
                    name: "name",
                    type: "string"
                },
                VOLUME: {
                    name: "volume",
                    type: "number",
                    range: [0, 50],
                    defaultValue: 1
                },
                RESOURCE: {
                    name: "resource",
                    type: "object",
                    optional: true
                }
            },
            // ------------------------------------------------------------------------------
            // module variables
            /**
             * This resource manager will be used to load and access class definitions.
             * @type ResourceManager
             */
            _classManager,
            /**
             * Holds the folder ID (not the URL) where the class definition file(s) reside
             * @type String
             */
            _classFolder;
    // freezing enum objects
    Object.freeze(ParticleEmitterType);
    Object.freeze(ObjectViewLookAtMode);
    Object.freeze(SceneViewLookAtMode);
    Object.freeze(MissileHomingMode);
    Object.freeze(WeaponRotationStyle);
    Object.freeze(SpacecraftTurnStyle);
    // ------------------------------------------------------------------------------
    // public functions to access the classes
    /**
     * Return the skybox class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {SkyboxClass}
     */
    function getSkyboxClass(name) {
        return _classManager.getResource(SKYBOX_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the background object class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {BackgroundObjectClass}
     */
    function getBackgroundObjectClass(name) {
        return _classManager.getResource(BACKGROUND_OBJECT_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the dust cloud class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {DustCloudClass}
     */
    function getDustCloudClass(name) {
        return _classManager.getResource(DUST_CLOUD_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the explosion class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {ExplosionClass}
     */
    function getExplosionClass(name) {
        return _classManager.getResource(EXPLOSION_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the projectile class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {ProjectileClass}
     */
    function getProjectileClass(name) {
        return _classManager.getResource(PROJECTILE_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the missile class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {MissileClass}
     */
    function getMissileClass(name) {
        return _classManager.getResource(MISSILE_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the weapon class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {WeaponClass}
     */
    function getWeaponClass(name) {
        return _classManager.getResource(WEAPON_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the propulsion class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {PropulsionClass}
     */
    function getPropulsionClass(name) {
        return _classManager.getResource(PROPULSION_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the jump engine class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {JumpEngineClass}
     */
    function getJumpEngineClass(name) {
        return _classManager.getResource(JUMP_ENGINE_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the shield class with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {ShieldClass}
     */
    function getShieldClass(name) {
        return _classManager.getResource(SHIELD_CLASS_ARRAY_NAME, name);
    }
    /**
     * Return the spacecraft type with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {SpacecraftType}
     */
    function getSpacecraftType(name) {
        return _classManager.getResource(SPACECRAFT_TYPE_ARRAY_NAME, name);
    }
    /**
     * Return the spacecraft class with the given name if it exists, otherwise null.
     * @param {String} name
     * @param {Boolean} [allowNullResult=false] If false, an error message will be displayed if null is returned.
     * @returns {SpacecraftClass|null}
     */
    function getSpacecraftClass(name, allowNullResult) {
        return _classManager.getResource(SPACECRAFT_CLASS_ARRAY_NAME, name, {allowNullResult: allowNullResult});
    }
    /**
     * Returns all the available spacecraft classes in an array.
     * @param {Boolean} forDatabase Whether to return only those classes that should show up in the database
     * @returns {SpacecraftClass[]}
     */
    function getSpacecraftClassesInArray(forDatabase) {
        var
                i,
                result = [],
                names = _classManager.getResourceNames(SPACECRAFT_CLASS_ARRAY_NAME);
        for (i = 0; i < names.length; i++) {
            if (!forDatabase || getSpacecraftClass(names[i]).shouldShowInDatabase()) {
                result.push(getSpacecraftClass(names[i]));
            }
        }
        return result;
    }
    /**
     * Returns the list of the names of the various categories (types) of classes that are stored (e.g. SPACECRAFT_CLASS_ARRAY_NAME 
     * ("spacecraftClasses"))
     * @returns {String[]}
     */
    function getClassCategories() {
        return _classManager.getResourceTypes();
    }
    /**
     * Returns the list of names (IDs) of the stored classes belonging to the given category (type - e.g. SPACECRAFT_CLASS_ARRAY_NAME 
     * ("spacecraftClasses")).
     * @param {String} category
     * @returns {String[]}
     */
    function getClassNames(category) {
        return _classManager.getResourceNames(category);
    }
    /**
     * Returns the stored class belonging to the given category (type - e.g. SPACECRAFT_CLASS_ARRAY_NAME ("spacecraftClasses")) that has
     * the given name (id).
     * @param {String} category
     * @param {String} name
     * @param {Object} [params]
     * @returns {}
     */
    function getClass(category, name, params) {
        return _classManager.getResource(category, name, params);
    }
    // ------------------------------------------------------------------------------
    // private functions
    /**
     * Shows an error message explaining that a certain property was not specified when initializing a class, that would be
     * needed for it.
     * @param {Object} classInstance
     * @param {String} propertyName
     */
    function _showMissingPropertyError(classInstance, propertyName) {
        application.showError(
                "Cannot initialize " + classInstance.constructor.name + " without correctly specifying its property '" + propertyName + "'!",
                application.ErrorSeverity.SEVERE,
                "The property was either not specified, or it was specified with a wrong type or an invalid value." +
                (((typeof classInstance._name) === "string") ?
                        "The error happened while initializing '" + classInstance._name + "'" : ""));
    }
    function _missingNumber(classInstance, propertyName) {
        _showMissingPropertyError(classInstance, propertyName);
        return 0;
    }
    function _missingString(classInstance, propertyName) {
        _showMissingPropertyError(classInstance, propertyName);
        return "";
    }
    function _missingVector2(classInstance, propertyName) {
        _showMissingPropertyError(classInstance, propertyName);
        return [0, 0];
    }
    function _missingVector3(classInstance, propertyName) {
        _showMissingPropertyError(classInstance, propertyName);
        return [0, 0, 0];
    }
    function _missingArray(classInstance, propertyName) {
        _showMissingPropertyError(classInstance, propertyName);
        return [];
    }
    function _missingObject(classInstance, propertyName) {
        _showMissingPropertyError(classInstance, propertyName);
        return null;
    }
    /**
     * Marks the sound effect resource corresponding to the passed descriptor for loading and saves a reference to it within the descriptor
     * @param {Object} soundEffectDescriptor An object with the structure defined by SOUND_EFFECT_3D
     */
    function _loadSoundEffect(soundEffectDescriptor) {
        soundEffectDescriptor.resource = resources.getSoundEffect(soundEffectDescriptor.name);
    }
    /**
     * Plays one of the sound samples corresponding to the sound effect described by the passed descriptor (needs to be loaded), without 
     * creating a reference to it
     * @param {Object} soundEffectDescriptor An object with the structure defined by SOUND_EFFECT_3D
     * @param {Number[3]} [position] The camera-space position in case of spatialized 3D sounds
     */
    function _playSoundEffect(soundEffectDescriptor, position) {
        soundEffectDescriptor.resource.play(soundEffectDescriptor.volume, position);
    }
    /**
     * Creates a sound clip for a (randomly chosen) sound sample corresponding to the sound effect described by the passed descriptor 
     * (needs to be loaded), and returns the reference to it.
     * @param {Object} soundEffectDescriptor An object with the structure defined by SOUND_EFFECT or SOUND_EFFECT_3D
     * @param {Boolean} [loop=false] Whether to create a looping sound source
     * @param {SoundSource} [soundSource] The sound source to be used for 3D spatial positioning of the clip
     * @param {Boolean} [shouldStack=false] If true, the sound clip will be created with stacking enabled
     * @param {Number} [stackTimeThreshold=0] The time threshold for stacking in case it is enabled
     * @param {Number} [stackVolumeFactor=1] The volume factor for stacking in case it is enabled
     * @returns {SoundClip}
     */
    function _createSoundClip(soundEffectDescriptor, loop, soundSource, shouldStack, stackTimeThreshold, stackVolumeFactor) {
        return soundEffectDescriptor.resource ?
                soundEffectDescriptor.resource.createSoundClip(
                        resources.SoundCategory.SOUND_EFFECT,
                        soundEffectDescriptor.volume,
                        loop,
                        shouldStack, stackTimeThreshold, stackVolumeFactor,
                        soundSource) :
                null;
    }
    /**
     * Load the thruster slot configuration data from the passed JSON into the passed ThrusterSlot array
     * @param {Object} dataJSON
     * @param {MissileClass|SpacecraftClass} object The class to load the thrusterslots for - used 
     * for displaying error messages
     * @param {ThrusterSlot[]} thrusterSlots
     */
    function _loadThrusterSlots(dataJSON, object, thrusterSlots) {
        var i, j, groupIndex, uses, startPosition, translationVector, size, count, jsonObject;
        for (i = 0; i < dataJSON.thrusterSlots.length; i++) {
            groupIndex = dataJSON.thrusterSlots[i].group;
            uses = dataJSON.thrusterSlots[i].uses;
            if (dataJSON.thrusterSlots[i].count > 0) {
                startPosition = dataJSON.thrusterSlots[i].position || _missingVector3(object, "thrusterSlot array position");
                translationVector = dataJSON.thrusterSlots[i].vector || _missingVector3(object, "thrusterSlot array vector");
                size = dataJSON.thrusterSlots[i].size || _missingNumber(object, "thrusterSlot array size");
                count = dataJSON.thrusterSlots[i].count;
                for (j = 0; j < count; j++) {
                    thrusterSlots.push(new ThrusterSlot({//eslint-disable-line no-use-before-define
                        position: vec.sum3(startPosition, vec.scaled3(translationVector, j)),
                        size: size,
                        groupIndex: groupIndex,
                        uses: uses
                    }));
                }
            }
            if (dataJSON.thrusterSlots[i].thrusters) {
                for (j = 0; j < dataJSON.thrusterSlots[i].thrusters.length; j++) {
                    jsonObject = Object.assign({}, dataJSON.thrusterSlots[i].thrusters[j]);
                    jsonObject.groupIndex = groupIndex;
                    jsonObject.uses = uses;
                    thrusterSlots.push(new ThrusterSlot(jsonObject)); //eslint-disable-line no-use-before-define
                }
            }
        }
    }
    // ##############################################################################
    /**
     * @class
     * @extends JSONResource
     * @param {Object} dataJSON
     * @param {Boolean} [nameIsOptional=false] If true, no error message will be given in case there is no name defined in the data JSON
     */
    function GenericClass(dataJSON, nameIsOptional) {
        resourceManager.JSONResource.call(this, dataJSON, _classFolder, nameIsOptional);
    }
    GenericClass.prototype = new resourceManager.JSONResource();
    GenericClass.prototype.constructor = GenericClass;
    /**
     * @param {String} resourceType
     * @param {String} resourceName
     */
    GenericClass.prototype.showResourceAccessError = function (resourceType, resourceName) {
        application.showError("Attempting to access " + resourceType + " ('" + resourceName + "') of class '" + this._name + "' before it has been loaded!");
    };
    /**
     * Updates the properties for the case when the graphics settings have been changed.
     */
    GenericClass.prototype.handleGraphicsSettingsChanged = function () {
        return;
    };
    // ##############################################################################
    /**
     * @class
     * @augments GenericClass
     * @param {Object} dataJSON
     * @param {Boolean} [nameIsOptional=false]
     */
    function ShadedClass(dataJSON, nameIsOptional) {
        GenericClass.call(this, dataJSON, nameIsOptional);
    }
    ShadedClass.prototype = new GenericClass();
    ShadedClass.prototype.constructor = ShadedClass;
    /**
     * @override
     * Initializes the properties of this class from another instance and then overrides the ones specified in the JSON object.
     * @param {ShadedClass} [otherShadedClass] If no class is given, the properties will be simply initialized from the JSON object
     * @param {Object} [dataJSON] If not given, properties will not be overriden / will be initialized to null
     */
    ShadedClass.prototype._overrideData = function (otherShadedClass, dataJSON) {
        GenericClass.prototype._loadData.call(this, dataJSON);
        /**
         * @type String
         */
        this._shaderName = otherShadedClass ?
                ((dataJSON && dataJSON.shader) ? dataJSON.shader : otherShadedClass._shaderName) :
                (dataJSON ? (dataJSON.shader || _missingString(this, "shader")) : null);
        /**
         * @type ShaderResource
         */
        this._shader = null;
        /**
         * @type String
         */
        this._instancedShaderName = null;
        /**
         * @type ShaderResource
         */
        this._instancedShader = null;
        /**
         * @type ManagedShader
         */
        this._managedShader = null;
        /**
         * @type ManagedShader
         */
        this._managedInstancedShader = null;
    };
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    ShadedClass.prototype._loadData = function (dataJSON) {
        this._overrideData(null, dataJSON);
        return true;
    };
    /**
     * @typedef {Object} ShadedClass~ResourceParams
     * @property {Boolean} [omitShader=false]
     */
    /**
     * @param {ShadedClass~ResourceParams} params
     */
    ShadedClass.prototype.acquireResources = function (params) {
        params = params || utils.EMPTY_OBJECT;
        if (!params.omitShader) {
            this._shader = graphics.getShader(this._shaderName);
            this._instancedShaderName = resources.getShader(this._shaderName).getVariantShaderName(SHADER_VARIANT_INSTANCED_NAME);
            if (this._instancedShaderName) {
                this._instancedShader = graphics.getShader(this._instancedShaderName);
            }
        }
    };
    /**
     * 
     * @returns {ManagedShader}
     */
    ShadedClass.prototype.getShader = function () {
        if (this._shader === null) {
            this.showResourceAccessError("shader", this._shaderName);
            return null;
        }
        if (!this._managedShader) {
            this._managedShader = graphics.getManagedShader(this._shaderName);
        }
        return this._managedShader;
    };
    /**
     * 
     * @returns {ManagedShader}
     */
    ShadedClass.prototype.getInstancedShader = function () {
        if (this._instancedShader === null) {
            application.showError("Attempting to access the instanced shader of '" + this._name + "', which does not exist (or is not loaded)!");
            return null;
        }
        if (!this._managedInstancedShader) {
            this._managedInstancedShader = graphics.getManagedShader(this._instancedShaderName);
        }
        return this._managedInstancedShader;
    };
    /**
     * Updates the properties for the case when the graphics settings have been changed.
     */
    ShadedClass.prototype.handleGraphicsSettingsChanged = function () {
        this._managedShader = null;
        this._managedInstancedShader = null;
    };
    // ##############################################################################
    /**
     * @class
     * @augments ShadedClass
     * @param {Object} dataJSON
     * @param {Boolean} [nameIsOptional=false]
     */
    function ShadedModelClass(dataJSON, nameIsOptional) {
        ShadedClass.call(this, dataJSON, nameIsOptional);
    }
    ShadedModelClass.prototype = new ShadedClass();
    ShadedModelClass.prototype.constructor = ShadedModelClass;
    /**
     * @override
     * Initializes the properties of this class from another instance and then overrides the ones specified in the JSON object.
     * @param {ShadedModelClass} [otherShadedModelClass] If no class is given, the properties will be simply initialized from the JSON object
     * @param {Object} [dataJSON] If not given, properties will not be overriden / will be initialized to null
     */
    ShadedModelClass.prototype._overrideData = function (otherShadedModelClass, dataJSON) {
        ShadedClass.prototype._overrideData.call(this, otherShadedModelClass, dataJSON);
        /**
         * @type String
         */
        this._modelName = otherShadedModelClass ?
                ((dataJSON && dataJSON.model) ? dataJSON.model : otherShadedModelClass._modelName) :
                (dataJSON ? (dataJSON.model || null) : null);
        /**
         * @type ModelResource
         */
        this._model = null;
    };
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    ShadedModelClass.prototype._loadData = function (dataJSON) {
        this._overrideData(null, dataJSON);
        return true;
    };
    /**
     * @typedef {ShadedClass~ResourceParams} ShadedModelClass~ResourceParams
     * @property {Model} [model]
     */
    /**
     * @override
     * @param {ShadedModelClass~ResourceParams} params
     */
    ShadedModelClass.prototype.acquireResources = function (params) {
        ShadedClass.prototype.acquireResources.call(this, params);
        if (params && params.model) {
            this._model = resources.getOrAddModel(params.model);
            this._modelName = this._model.getName();
        } else {
            this._model = graphics.getModel(this._modelName);
        }
    };
    /**
     * 
     * @returns {Model}
     */
    ShadedModelClass.prototype.getModel = function () {
        if (this._model === null) {
            this.showResourceAccessError("model", this._modelName);
            return null;
        }
        return this._model.getEgomModel();
    };
    // ##############################################################################
    /**
     * @class A skybox represents the background picture rendered for the 
     * environment using a cubemap sampler and a full viewport quad. Skybox classes 
     * can be defined with different properties (in classes.json) for different 
     * backgrounds, and then the right one can be instantiated for each mission.
     * @augments ShadedModelClass
     * @param {Object} [dataJSON] 
     */
    function SkyboxClass(dataJSON) {
        ShadedModelClass.call(this, dataJSON);
    }
    SkyboxClass.prototype = new ShadedModelClass();
    SkyboxClass.prototype.constructor = SkyboxClass;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    SkyboxClass.prototype._loadData = function (dataJSON) {
        ShadedModelClass.prototype._loadData.call(this, dataJSON);
        /**
         * @type String
         */
        this._cubemapName = dataJSON ? (dataJSON.cubemap || _missingString(this, "cubemap")) : null;
        /**
         * @type CubemapResource
         */
        this._cubemap = null;
        return true;
    };
    /**
     * @override
     */
    SkyboxClass.prototype.acquireResources = function () {
        ShadedModelClass.prototype.acquireResources.call(this, {model: egomModel.fvqModel(SKYBOX_MODEL_NAME)});
        if (this._cubemap === null) {
            this._cubemap = graphics.getCubemap(this._cubemapName);
        }
    };
    /**
     * @param {String[]} qualityPreferenceList
     * @returns {ManagedCubemap}
     */
    SkyboxClass.prototype.getCubemap = function (qualityPreferenceList) {
        if (this._cubemap === null) {
            this.showResourceAccessError("cubemap", this._cubemapName);
            return null;
        }
        return this._cubemap.getManagedCubemap(qualityPreferenceList);
    };
    /**
     * @override
     */
    SkyboxClass.prototype.handleGraphicsSettingsChanged = function () {
        ShadedModelClass.prototype.handleGraphicsSettingsChanged.call(this);
        this._cubemap = null;
    };
    // ##############################################################################
    /**
     * @class
     * @augments ShadedModelClass
     * @param {Object} dataJSON
     * @param {Boolean} [nameIsOptional=false]
     */
    function TexturedModelClass(dataJSON, nameIsOptional) {
        ShadedModelClass.call(this, dataJSON, nameIsOptional);
    }
    TexturedModelClass.prototype = new ShadedModelClass();
    TexturedModelClass.prototype.constructor = TexturedModelClass;
    /**
     * @override
     * Initializes the properties of this class from another instance and then overrides the ones specified in the JSON object.
     * @param {TexturedModelClass} [otherTexturedModelClass] If no class is given, the properties will be simply initialized from the JSON object
     * @param {Object} [dataJSON] If not given, properties will not be overriden / will be initialized to null
     */
    TexturedModelClass.prototype._overrideData = function (otherTexturedModelClass, dataJSON) {
        var i, j, n;
        ShadedModelClass.prototype._overrideData.call(this, otherTexturedModelClass, dataJSON);
        /**
         * @type String
         */
        this._textureName = otherTexturedModelClass ?
                ((dataJSON && dataJSON.texture) ? dataJSON.texture : otherTexturedModelClass._textureName) :
                (dataJSON ? (dataJSON.texture || _missingString(this, "texture")) : null);
        /**
         * @type TextureResource
         */
        this._texture = null;
        /**
         * What should the luminosity of vertices belonging to different groups be set to after creating a visual model for an instance of 
         * this class. (convert from format in the JSON given in assignment pairs e.g. to set luminosity of group 3 to 0.5 and group 12 
         * to 0.9: [[3, 0.5], [12, 0.9]], to a simple array storing the default luminosities for all groups)
         * @type Number[]
         */
        this._defaultLuminosityFactors = [];
        for (i = 0, n = graphics.getMaxLuminosityFactors(); i < n; i++) {
            this._defaultLuminosityFactors.push(0.0);
        }
        if (dataJSON.defaultLuminosityFactors) {
            for (i = 0; i < dataJSON.defaultLuminosityFactors.length; i++) {
                j = dataJSON.defaultLuminosityFactors[i][0];
                if (j < graphics.getMaxLuminosityFactors()) {
                    this._defaultLuminosityFactors[j] = dataJSON.defaultLuminosityFactors[i][1];
                } else {
                    application.showError("Attempting to set luminosity of group with index " + j + ", while there are only " +
                            graphics.getMaxLuminosityFactors() + " luminosity groups available. (and indices start with 0)",
                            application.ErrorSeverity.MINOR,
                            "Happened while creating textured model class '" + this.getName() + "'.");
                }
            }
        } else if (otherTexturedModelClass) {
            this._defaultLuminosityFactors = otherTexturedModelClass._defaultLuminosityFactors.slice();
        }
    };
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    TexturedModelClass.prototype._loadData = function (dataJSON) {
        this._overrideData(null, dataJSON);
        return true;
    };
    /**
     * @override
     * @param {ShadedModelClass~ResourceParams} params
     */
    TexturedModelClass.prototype.acquireResources = function (params) {
        ShadedModelClass.prototype.acquireResources.call(this, params);
        if (this._texture === null) {
            this._texture = graphics.getTexture(this._textureName);
        }
    };
    /**
     * @param {String} type
     * @param {String} quality
     * @returns {ManagedTexture}
     */
    TexturedModelClass.prototype.getTexture = function (type, quality) {
        if (this._texture === null) {
            this.showResourceAccessError("texture", this._textureName);
            return null;
        }
        return this._texture.getManagedTexture(type, quality);
    };
    /**
     * @param {String[]} types
     * @param {String[]} qualityPreferenceList
     * @returns {Object.<String, ManagedTexture>} 
     */
    TexturedModelClass.prototype.getTexturesOfTypes = function (types, qualityPreferenceList) {
        if (this._texture === null) {
            this.showResourceAccessError("texture", this._textureName);
            return null;
        }
        return this._texture.getManagedTexturesOfTypes(types, qualityPreferenceList);
    };
    /**
     * @param {Number} groupIndex
     * @returns {Number}
     */
    TexturedModelClass.prototype.getDefaultGroupLuminosity = function (groupIndex) {
        return this._defaultLuminosityFactors[groupIndex];
    };
    /**
     * @returns {Number[]}
     */
    TexturedModelClass.prototype.getDefaultGroupLuminosityFactors = function () {
        return this._defaultLuminosityFactors;
    };
    /**
     * @override
     */
    TexturedModelClass.prototype.handleGraphicsSettingsChanged = function () {
        ShadedModelClass.prototype.handleGraphicsSettingsChanged.call(this);
        this._texture = null;
    };
    // ##############################################################################
    /**
     * @class A simple class capable of loading the descriptor of a particle (a simple
     * 2D billboard rendered with a suitable shader)
     * @augments TexturedModelClass
     * @param {Object} [dataJSON] 
     */
    function ParticleDescriptor(dataJSON) {
        TexturedModelClass.call(this, dataJSON, true);
    }
    ParticleDescriptor.prototype = new TexturedModelClass();
    ParticleDescriptor.prototype.constructor = ParticleDescriptor;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    ParticleDescriptor.prototype._loadData = function (dataJSON) {
        TexturedModelClass.prototype._loadData.call(this, dataJSON);
        /**
         * The size to scale the particle with when rendering.
         * @type Number
         */
        this._size = dataJSON ? (dataJSON.size || 1) : 0;
        /**
         * The color that can be passed to the shader to modulate the texture with
         * while rendering. [red,green,blue, alpha]
         * @type Number[4]
         */
        this._color = dataJSON ? (dataJSON.color || [1, 1, 1, 1]) : null;
        /**
         * If given, this can represent the length of time for which a simple (e.g. shrinking) particle is shown
         * @type Number
         */
        this._duration = dataJSON ? dataJSON.duration : null;
        return true;
    };
    /**
     * @override
     */
    ParticleDescriptor.prototype.acquireResources = function () {
        TexturedModelClass.prototype.acquireResources.call(this, {model: egomModel.squareModel(PARTICLE_MODEL_NAME)});
    };
    /**
     * @returns {Number}
     */
    ParticleDescriptor.prototype.getSize = function () {
        return this._size;
    };
    /**
     * @returns {Number[3]}
     */
    ParticleDescriptor.prototype.getColor = function () {
        return this._color;
    };
    /**
     * @returns {Number}
     */
    ParticleDescriptor.prototype.getDuration = function () {
        return this._duration;
    };
    // ##############################################################################
    /**
     * @class A simple class capable of loading the descriptor of a trail (storing the
     * common properties of a trail made up of connected segments)
     * @augments TexturedModelClass
     * @param {Object} [dataJSON] 
     */
    function TrailDescriptor(dataJSON) {
        TexturedModelClass.call(this, dataJSON, true);
    }
    TrailDescriptor.prototype = new TexturedModelClass();
    TrailDescriptor.prototype.constructor = TrailDescriptor;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    TrailDescriptor.prototype._loadData = function (dataJSON) {
        TexturedModelClass.prototype._loadData.call(this, dataJSON);
        /**
         * The thickness of the trail (scaling perpendicular to the scale path)
         * @type Number
         */
        this._size = dataJSON ? (dataJSON.size || 1) : 0;
        /**
         * The color that can be passed to the shader to modulate the texture with
         * while rendering. [red,green,blue, alpha]
         * @type Number[4]
         */
        this._color = dataJSON ? (dataJSON.color || [1, 1, 1, 1]) : null;
        /**
         * The duration of any given point of the trail (the trail will end where the object leaving
         * it passed this much time ago), in milliseconds
         * @type Number
         */
        this._duration = dataJSON ? (dataJSON.duration || _missingNumber(this, "duration")) : null;
        /**
         * Determines how fast does a newly created trail section grow to full duration / length
         * @type Number
         */
        this._growthRate = dataJSON ? (dataJSON.growthRate || _missingNumber(this, "growthRate")) : null;
        return true;
    };
    /**
     * @override
     */
    TrailDescriptor.prototype.acquireResources = function () {
        TexturedModelClass.prototype.acquireResources.call(this, {model: egomModel.turningBillboardModel(TRAIL_SEGMENT_MODEL_NAME, utils.EMPTY_ARRAY, 1)});
    };
    /**
     * @returns {Number}
     */
    TrailDescriptor.prototype.getSize = function () {
        return this._size;
    };
    /**
     * @returns {Number[3]}
     */
    TrailDescriptor.prototype.getColor = function () {
        return this._color;
    };
    /**
     * @returns {Number}
     */
    TrailDescriptor.prototype.getDuration = function () {
        return this._duration;
    };
    /**
     * @returns {Number}
     */
    TrailDescriptor.prototype.getGrowthRate = function () {
        return this._growthRate;
    };
    // ##############################################################################
    /**
     * @class Environments in the game can have several background objects,
     * like stars or nebulae, which provide the lighting for the environment.
     * @augments GenericClass
     * @param {Object} [dataJSON] 
     */
    function BackgroundObjectClass(dataJSON) {
        GenericClass.call(this, dataJSON);
    }
    BackgroundObjectClass.prototype = new GenericClass();
    BackgroundObjectClass.prototype.constructor = BackgroundObjectClass;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    BackgroundObjectClass.prototype._loadData = function (dataJSON) {
        var i;
        GenericClass.prototype._loadData.call(this, dataJSON);
        /**
         * The color of the light this object emits. If given, a directional light source with
         * this color will be added to environments where this object it present, coming
         * from the object's direction.
         * @type Number[3]
         */
        this._lightColor = dataJSON ? dataJSON.lightColor : null;
        /**
         * To draw the object on the background, the layers defined in this array
         * will be rendered on top of each other in order.
         * @type ParticleDescriptor[]
         */
        this._layers = [];
        if (dataJSON) {
            if (dataJSON.layers && (dataJSON.layers.length > 0)) {
                for (i = 0; i < dataJSON.layers.length; i++) {
                    this._layers.push(new ParticleDescriptor(dataJSON.layers[i]));
                }
            } else {
                _showMissingPropertyError(this, "layers");
            }
        }
        return true;
    };
    /**
     * 
     */
    BackgroundObjectClass.prototype.acquireResources = function () {
        var i;
        for (i = 0; i < this._layers.length; i++) {
            this._layers[i].acquireResources();
        }
    };
    /**
     * @returns {Number[3]}
     */
    BackgroundObjectClass.prototype.getLightColor = function () {
        return this._lightColor;
    };
    /**
     * @returns {ParticleDescriptor[]}
     */
    BackgroundObjectClass.prototype.getLayers = function () {
        return this._layers;
    };
    /**
     * @override
     * Updates the properties for the case when the graphics settings have been changed.
     */
    BackgroundObjectClass.prototype.handleGraphicsSettingsChanged = function () {
        var i;
        GenericClass.prototype.handleGraphicsSettingsChanged.call(this);
        for (i = 0; i < this._layers.length; i++) {
            this._layers[i].handleGraphicsSettingsChanged();
        }
    };
    // ##############################################################################
    /**
     * @class Dust clouds represent a big group of tiny dust particles that are
     * rendered when the camera (the player) is moving around of space, to give a
     * visual clue about the velocity. Dust cloud classes can be defined (in 
     * classes.json) for different environments (such as denser in an asteroid field 
     * or the rings of a planet, or having different color), and then the right one 
     * instantiated (with the DustCloud class) for the environment.
     * @param {Object} [dataJSON]
     */
    function DustCloudClass(dataJSON) {
        ShadedModelClass.call(this, dataJSON);
    }
    DustCloudClass.prototype = new ShadedModelClass();
    DustCloudClass.prototype.constructor = DustCloudClass;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    DustCloudClass.prototype._loadData = function (dataJSON) {
        ShadedModelClass.prototype._loadData.call(this, dataJSON);
        /**
         * The number of dust particles that should be created when such a dust 
         * class is instantiated.
         * @type Number
         */
        this._numberOfParticles = dataJSON ? (dataJSON.numberOfParticles || _missingNumber(this, "numberOfParticles")) : 0;
        /**
         * The color of the particles in the dust clouds of this class.
         * @type Number[3]
         */
        this._color = dataJSON ? (dataJSON.color || [1, 1, 1]) : null;
        /**
         * The maximum distance of the particles in the dust clouds of this class
         * from the camera along any axis.
         * @type Number
         */
        this._range = dataJSON ? (dataJSON.range || _missingNumber(this, "range")) : 0;
        return true;
    };
    /**
     * @override
     */
    DustCloudClass.prototype.acquireResources = function () {
        ShadedModelClass.prototype.acquireResources.call(this, {model: egomModel.lineModel(DUST_MODEL_NAME, [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0])});
    };
    /**
     * @returns {Number}
     */
    DustCloudClass.prototype.getNumberOfParticles = function () {
        return this._numberOfParticles * graphics.getDustParticleCountFactor();
    };
    /**
     * @returns {Number[3]}
     */
    DustCloudClass.prototype.getColor = function () {
        return this._color;
    };
    /**
     * @returns {Number}
     */
    DustCloudClass.prototype.getRange = function () {
        return this._range;
    };
    // ##############################################################################
    /**
     * @class A simple class capable of loading the descriptor of a particle emitter 
     * @extends TexturedModelClass
     * @param {Object} [dataJSON] If given, all properties of the descriptor will be initialized
     * from this JSON object.
     */
    function ParticleEmitterDescriptor(dataJSON) {
        // this will call the overridden _loadData function and thus initialize all fields
        TexturedModelClass.call(this, dataJSON, true);
    }
    ParticleEmitterDescriptor.prototype = new TexturedModelClass();
    ParticleEmitterDescriptor.prototype.constructor = ParticleEmitterDescriptor;
    /**
     * @override
     * Loads and sets all properties of the emitter descriptor based on the passed JSON object.
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    ParticleEmitterDescriptor.prototype._loadData = function (dataJSON) {
        var i;
        TexturedModelClass.prototype._loadData.call(this, dataJSON);
        /**
         * (enum ParticleEmitterType) The string description of the type of the described particle emitter. Based on this the proper class
         * can be instantiated when the emitter object is created.
         * @type String
         */
        this._type = dataJSON ? utils.getSafeEnumValue(ParticleEmitterType, dataJSON.type, ParticleEmitterType.OMNIDIRECTIONAL) : null;
        /**
         * If true, a projectile model will be created for the particles emitted by this emitter instead of a simple square model
         * @type Boolean
         */
        this._hasProjectileModel = dataJSON ? (dataJSON.hasProjectileModel || false) : false;
        /**
         * If the emitter is set to have a projectile model, this property specifies the width to use (to cut off the sides)
         * @type Number
         */
        this._projectileModelWidth = dataJSON ? (dataJSON.projectileModelWidth || 1) : 0;
        /**
         * If the emitter is set to have a projectile model, this property specifies where to put the intersection when creating the model
         * (it only ever has one intersection)
         * @type Number
         */
        this._projectileModelIntersection = dataJSON ? (dataJSON.projectileModelIntersection || 0) : 0;
        /**
         * The size of the area where the new particles are generated. (meters, [x,y,z])
         * @type Number[3]
         */
        this._dimensions = dataJSON ? (dataJSON.dimensions || [0, 0, 0]) : null;
        /**
         * The maximum angle that the velocity vector of the emitted particles can differ from the main direction / plane.
         * @type Number
         */
        this._directionSpread = (dataJSON && ((this._type === ParticleEmitterType.UNIDIRECTIONAL) || (this._type === ParticleEmitterType.PLANAR))) ? (dataJSON.directionSpread || 0) : 0;
        /**
         * The (average) starting velocity of the emitted particles. m/s
         * @type Number
         */
        this._velocity = dataJSON ? (dataJSON.velocity || 0) : 0;
        /**
         * The size of the random range within the particle velocities are generated. m/s
         * @type Number
         */
        this._velocitySpread = dataJSON ? (dataJSON.velocitySpread || 0) : 0;
        /**
         * The number of particles emitted right after the creation of the emitter
         * @type Number
         */
        this._initialNumber = dataJSON ? (dataJSON.initialNumber || 0) : 0;
        /**
         * The number of particles emitted at the end of each spawning round
         * @type Number
         */
        this._spawnNumber = dataJSON ? (dataJSON.spawnNumber || 0) : 0;
        /**
         * The duration of one spawning round (milliseconds)
         * @type Number
         */
        this._spawnTime = dataJSON ? (dataJSON.spawnTime || 1) : 0;
        /**
         * The duration while new particles are emitted after the initial particle spawning. (milliseconds)
         * @type Number
         */
        this._duration = dataJSON ? (dataJSON.duration || 0) : 0;
        /**
         * The duration to wait before the initial particle spawning. (milliseconds)
         * @type Number
         */
        this._delay = dataJSON ? (dataJSON.delay || 0) : 0;
        /**
         * The list of states that the generated particles should go through.
         * @type ParticleState[]
         */
        this._particleStates = null;
        if (dataJSON) {
            this._particleStates = [];
            if (dataJSON.particleStates && (dataJSON.particleStates.length > 0)) {
                for (i = 0; i < dataJSON.particleStates.length; i++) {
                    this._particleStates.push(new renderableObjects.ParticleState(
                            dataJSON.particleStates[i].color,
                            dataJSON.particleStates[i].size,
                            dataJSON.particleStates[i].timeToReach));
                }
            } else {
                _showMissingPropertyError(this, "particleStates");
            }
        }
        return true;
    };
    /**
     * @override
     */
    ParticleEmitterDescriptor.prototype.acquireResources = function () {
        TexturedModelClass.prototype.acquireResources.call(this, {model:
                    this._hasProjectileModel ?
                    egomModel.turningBillboardModel(
                            PROJECTILE_MODEL_NAME_PREFIX + this._projectileModelIntersection + PROJECTILE_MODEL_NAME_INFIX + this._projectileModelWidth,
                            [this._projectileModelIntersection], this._projectileModelWidth) :
                    egomModel.squareModel(PARTICLE_MODEL_NAME)});
    };
    /**
     * Returns the string description of the type of the described particle emitter. Based on this the proper class
     * can be instantiated when the emitter object is created. Possible values at the moment:
     * omnidirectional, unidirectional, planar
     * @returns {String}
     */
    ParticleEmitterDescriptor.prototype.getType = function () {
        return this._type;
    };
    /**
     * Returns the size of the area where the new particles are generated. (meters, [x,y,z])
     * @returns {Number[3]}
     */
    ParticleEmitterDescriptor.prototype.getDimensions = function () {
        return this._dimensions;
    };
    /**
     * Returns the maximum angle that the velocity vector of the emitted particles can differ from the main direction / plane.
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getDirectionSpread = function () {
        return this._directionSpread;
    };
    /**
     * Returns the (average) starting velocity of the emitted particles. m/s
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getVelocity = function () {
        return this._velocity;
    };
    /**
     * Returns the size of the random range within the particle velocities are generated. m/s
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getVelocitySpread = function () {
        return this._velocitySpread;
    };
    /**
     * Returns the number of particles emitted right after the creation of the emitter
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getInitialNumber = function () {
        return this._initialNumber;
    };
    /**
     * Returns the number of particles emitted at the end of  each spawning round
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getSpawnNumber = function () {
        return this._spawnNumber;
    };
    /**
     * Returns the duration of one spawning round (milliseconds)
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getSpawnTime = function () {
        return this._spawnTime;
    };
    /**
     * Returns the duration for which new particles are emitted after the initial particle spawning. (milliseconds)
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getDuration = function () {
        return this._duration;
    };
    /**
     * Whether this emitter keeps emitting particles continuously in a looping fashion
     * @returns {Boolean}
     */
    ParticleEmitterDescriptor.prototype.isContinuous = function () {
        return (this._spawnNumber > 0) && (this._duration === 0);
    };
    /**
     * Returns the duration to wait before the initial particle spawning. (milliseconds)
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getDelay = function () {
        return this._delay;
    };
    /**
     * Returns the list of states that the generated particles should go through.
     * @returns {ParticleState[]}
     */
    ParticleEmitterDescriptor.prototype.getParticleStates = function () {
        return this._particleStates;
    };
    /**
     * Returns the duration of the life of particles emitted by this emitter, in milliseconds.
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getParticleDuration = function () {
        var result = 0, i;
        for (i = 1; i < this._particleStates.length; i++) {
            result += this._particleStates[i].timeToReach;
        }
        return result;
    };
    /**
     * Returns the duration it takes from the creation of this emitter until the last particle emitted by this emitter (except for looping) 
     * diminishes, in milliseconds.
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getTotalDuration = function () {
        var result = this._delay;
        // calculating last spawning time
        if (this._spawnNumber && this._spawnTime) {
            result += Math.floor(this._duration / this._spawnTime) * this._spawnTime;
        }
        result += this.getParticleDuration();
        return result;
    };
    /**
     * Returns the maximum number of particles that might be simultaneously used (be alive) by this emitter during its lifetime.
     * @returns {Number}
     */
    ParticleEmitterDescriptor.prototype.getMaxParticleCount = function () {
        var result, maxSpawnsPresent, spawnCount,
                particleDuration = this.getParticleDuration();
        spawnCount = Math.floor(this._duration / this._spawnTime) + 1; // how many spawnings happen at all in case the emitter is not 
        // looping - including the initial spawning
        maxSpawnsPresent = Math.ceil(particleDuration / this._spawnTime); // from maximum how many spawnings are particles present together
        // calculate the maximum number of spawned particles that exist together (for non-looping and looping) based on (general) spawning number and count
        result = this._spawnNumber * (this._duration ? Math.min(spawnCount, maxSpawnsPresent) : maxSpawnsPresent);
        // consider that the initial spawning number might be different
        if (this._initialNumber > this._spawnNumber) {
            // if it is greater, add the difference
            result += (this._initialNumber - this._spawnNumber);
        } else if ((this._initialNumber < this._spawnNumber) && this._duration && (spawnCount <= maxSpawnsPresent)) {
            // if it is less, the difference only counts for non-looping emitters where all spawnings live long enough to exist together
            // (otherwise the peak happens after the initially spawned particles disappear)
            result -= (this._spawnNumber - this._initialNumber);
        }
        return result;
    };
    // ##############################################################################
    /**
     * @class Stores the general properties of a class of explosions (or fires), that can be
     * used to create instances of that class of explosion or fire.
     * Since explosions and fires are represented visually using partice systems, the
     * properties of this class are the ones needed to set up such a particle system.
     * @extends GenericClass
     * @param {Object} dataJSON The JSON object to load the properties from.
     */
    function ExplosionClass(dataJSON) {
        // This will call the overridden _loadData method
        GenericClass.call(this, dataJSON);
    }
    ExplosionClass.prototype = new GenericClass();
    ExplosionClass.prototype.constructor = ExplosionClass;
    /**
     * @override
     * Initializes all properties from the passed JSON object
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    ExplosionClass.prototype._loadData = function (dataJSON) {
        var i;
        GenericClass.prototype._loadData.call(this, dataJSON);
        /**
         * The list of descriptors of the particle emitters that the visual model of the explosion
         * will consist of.
         * @type ParticleEmitterDescriptor[]
         */
        this._particleEmitterDescriptors = null;
        if (dataJSON && dataJSON.particleEmitters) {
            this._particleEmitterDescriptors = [];
            for (i = 0; i < dataJSON.particleEmitters.length; i++) {
                this._particleEmitterDescriptors.push(new ParticleEmitterDescriptor(dataJSON.particleEmitters[i]));
            }
        }
        /**
         * The point-like light source associated with this explosion will go through the states defined in this list. If the value is undefined
         * or null, there will be no light-source associated with this explosion.
         * @type PointLightSource~LightState[]
         */
        this._lightStates = dataJSON ? dataJSON.lightStates : null;
        /**
         * The descriptor of the sound effect to be played when this explosion is shown
         * @type Object
         */
        this._soundEffect = (dataJSON && dataJSON.soundEffect) ? (types.getVerifiedObject("explosionClasses['" + this._name + "'].soundEffect", dataJSON.soundEffect, SOUND_EFFECT_3D)) : null;
        return true;
    };
    /**
     * @typedef {Object} ExplosionClass~ResourceParams
     * @property {Boolean} [sound=false] Whether to load resources for sound effects
     */
    /**
     * Sets up the references to all required resource objects and marks them for loading.
     * @param {ExplosionClass~ResourceParams} params
     */
    ExplosionClass.prototype.acquireResources = function (params) {
        var i;
        for (i = 0; i < this._particleEmitterDescriptors.length; i++) {
            this._particleEmitterDescriptors[i].acquireResources();
        }
        if (params.sound) {
            if (this._soundEffect) {
                _loadSoundEffect(this._soundEffect);
            }
        }
    };
    /**
     * Returns the list of descriptors of the particle emitters that the visual model of the explosion
     * shall consist of.
     * @returns {ParticleEmitterDescriptor[]}
     */
    ExplosionClass.prototype.getParticleEmitterDescriptors = function () {
        return this._particleEmitterDescriptors;
    };
    /**
     * Returns the states that the light source associated with this explosion goes through.
     * @returns {PointLightSource~LightState[]}
     */
    ExplosionClass.prototype.getLightStates = function () {
        return this._lightStates;
    };
    /**
     * Returns the duration while the particle system representing this explosion would display particles (milliseconds)
     * (including for how long would it generate them and after that for how long would the generated particles last)
     * @returns {Number}
     */
    ExplosionClass.prototype.getTotalDuration = function () {
        var i, emitterDuration, result = 0;
        for (i = 0; i < this._particleEmitterDescriptors.length; i++) {
            emitterDuration = this._particleEmitterDescriptors[i].getTotalDuration();
            if (emitterDuration > result) {
                result = emitterDuration;
            }
        }
        return result;
    };
    /**
     * Returns the maximum number of particles used simultaneously by this explosion.
     * @returns {Number}
     */
    ExplosionClass.prototype.getMaxParticleCount = function () {
        var i, result = 0;
        for (i = 0; i < this._particleEmitterDescriptors.length; i++) {
            result += this._particleEmitterDescriptors[i].getMaxParticleCount();
        }
        return result;
    };
    /**
     * Returns whether a particle system representing an instance of an explosion of this kind
     * would produce particles continuously until it is explicitly stopped (or finish on its
     * own after some duration, accessed via getDuration())
     * @returns {Boolean}
     */
    ExplosionClass.prototype.isContinuous = function () {
        var i;
        for (i = 0; i < this._particleEmitterDescriptors.length; i++) {
            if (this._particleEmitterDescriptors[i].isContinuous()) {
                return true;
            }
        }
        return false;
    };
    /**
     * Plays the sound effect for this explosion
     * @param {SoundSource} soundSource The sound source to be used for 3D spatial positioning of the clip
     * @param {Boolean} [shouldStack=false] Whether to enable stacking for this sound effect (e.g. for stacking
     * the sounds of multiple prpojectiles hitting a spacecraft at the same time into one node with increased
     * volume)
     * @param {Number} [stackTimeThreshold=0] The time threshold for stacking (maximum time difference, in seconds)
     * @param {Number} [stackVolumeFactor=1] The factor to multiply the volume of stacked sound clips by
     */
    ExplosionClass.prototype.playSound = function (soundSource, shouldStack, stackTimeThreshold, stackVolumeFactor) {
        var clip;
        if (this._soundEffect) {
            clip = _createSoundClip(
                    this._soundEffect,
                    false,
                    soundSource, shouldStack, stackTimeThreshold, stackVolumeFactor);
            if (clip) {
                clip.play();
            }
        }
    };
    /**
     * @override
     * Updates the properties for the case when the graphics settings have been changed.
     */
    ExplosionClass.prototype.handleGraphicsSettingsChanged = function () {
        var i;
        GenericClass.prototype.handleGraphicsSettingsChanged.call(this);
        for (i = 0; i < this._particleEmitterDescriptors.length; i++) {
            this._particleEmitterDescriptors[i].handleGraphicsSettingsChanged();
        }
    };
    // ##############################################################################
    /**
     * @class Projectiles such as bullets or plasma bursts can belong to different
     * classes that can be described in classes.json. This class represents such a 
     * projectile class, defining the common properties of the projectiles belonging
     * to the class.
     * @augments TexturedModelClass
     * @param {Object} [dataJSON]
     */
    function ProjectileClass(dataJSON) {
        TexturedModelClass.call(this, dataJSON);
    }
    ProjectileClass.prototype = new TexturedModelClass();
    ProjectileClass.prototype.constructor = ProjectileClass;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    ProjectileClass.prototype._loadData = function (dataJSON) {
        TexturedModelClass.prototype._loadData.call(this, dataJSON);
        /**
         * The amount of damage this projectile causes when it hits a spacecraft.
         * @type Number
         */
        this._damage = dataJSON ? (dataJSON.damage || 0) : 0;
        /**
         * The size by which the model representing the projectile will be scaled.
         * @type Number
         */
        this._size = dataJSON ? (dataJSON.size || 1) : 0;
        /**
         * How many perpendicular planes should be part of the projectile model, and 
         * where are they positioned. (the array of positions)
         * @type Number[]
         */
        this._intersectionPositions = dataJSON ? (dataJSON.intersectionPositions || []) : null;
        /**
         * The projectile model will be created based on this width, by "trimming" it along the X and Z axes, both in terms of vertex and
         * texture coordinates. Should be between 0 and 1.
         * @type Number
         */
        this._width = dataJSON ? (dataJSON.width || 1) : 0;
        /**
         * Mass of the projectile in kilograms. Determines how fast will it fly when 
         * shot from weapons.
         * @type Number
         */
        this._mass = dataJSON ? (dataJSON.mass || _missingNumber(this, "mass")) : 0;
        /**
         * If there is drag in the environment, its effect on this projectile will be multiplied by this factor
         * @type Number
         */
        this._dragFactor = dataJSON ? (dataJSON.dragFactor || 0) : 0;
        /**
         * The length of life of the projectile in milliseconds, after which it will 
         * disappear. In milliseconds.
         * @type Number
         */
        this._duration = dataJSON ? (dataJSON.duration || _missingNumber(this, "duration")) : 0;
        /**
         * The length of time while the projetile dissipates at the end of its duration, bringing down its power linearly to zero, in milliseconds.
         * @type Number
         */
        this._dissipationDuration = dataJSON ? (dataJSON.dissipationDuration || _missingNumber(this, "dissipationDuration")) : 0;
        /**
         * A descriptor for the properties of the muzzle flash particle which is 
         * created when this projectile is shot from a weapon. 
         * @type ParticleDescriptor
         */
        this._muzzleFlash = null;
        if (dataJSON) {
            if (dataJSON.muzzleFlash) {
                this._muzzleFlash = new ParticleDescriptor(dataJSON.muzzleFlash);
            } else {
                _showMissingPropertyError(this, "muzzleFlash");
            }
        }
        /**
         * The color of the light this projectile emits as a light source.
         * @type Number[3]
         */
        this._lightColor = dataJSON ? (dataJSON.lightColor || null) : null;
        /**
         * The intensity of the light this projectile emits as a light source.
         * @type Number
         */
        this._lightIntensity = dataJSON ? (dataJSON.lightColor ? dataJSON.lightIntensity || _missingNumber(this, "lightIntensity") : 0) : 0;
        /**
         * The class of the explosion this projectile creates when it hits the armor of a spacecraft.
         * @type ExplosionClass
         */
        this._explosionClass = dataJSON ? (getExplosionClass(dataJSON.explosion || _missingString(this, "explosion")) || application.crash()) : null;
        /**
         * The class of the explosion this projectile creates when it hits the shield of a spacecraft.
         * @type ExplosionClass
         */
        this._shieldExplosionClass = dataJSON ? (getExplosionClass(dataJSON.shieldExplosion || _missingString(this, "shieldExplosion")) || application.crash()) : null;
        return true;
    };
    /**
     * @typedef {Object} ProjectileClass~ResourceParams
     * @property {Boolean} [projectileOnly=false] Whether to load resources for
     * displaying the projectile itself only (not it hitting things or being fired)
     * @property {Boolean} [sound=false] Whether to load resources for sound effects
     */
    /**
     * @override
     * @param {ProjectileClass~ResourceParams} params 
     */
    ProjectileClass.prototype.acquireResources = function (params) {
        TexturedModelClass.prototype.acquireResources.call(this, {
            model: egomModel.turningBillboardModel(
                    PROJECTILE_MODEL_NAME_PREFIX + this._intersectionPositions.join(MODEL_NAME_SEPARATOR) + PROJECTILE_MODEL_NAME_INFIX + this._width,
                    this._intersectionPositions, this._width)});
        if (!params.projectileOnly) {
            this._muzzleFlash.acquireResources();
            this._explosionClass.acquireResources({sound: params.sound});
            this._shieldExplosionClass.acquireResources({sound: params.sound});
        }
    };
    /**
     * @returns {Number}
     */
    ProjectileClass.prototype.getDamage = function () {
        return this._damage;
    };
    /**
     * @returns {Number}
     */
    ProjectileClass.prototype.getSize = function () {
        return this._size;
    };
    /**
     * @returns {Number}
     */
    ProjectileClass.prototype.getMass = function () {
        return this._mass;
    };
    /**
     * @returns {Number}
     */
    ProjectileClass.prototype.getDragFactor = function () {
        return this._dragFactor;
    };
    /**
     * @returns {Number}
     */
    ProjectileClass.prototype.getDuration = function () {
        return this._duration;
    };
    /**
     * @returns {Number}
     */
    ProjectileClass.prototype.getDissipationDuration = function () {
        return this._dissipationDuration;
    };
    /**
     * @returns {ParticleDescriptor}
     */
    ProjectileClass.prototype.getMuzzleFlash = function () {
        return this._muzzleFlash;
    };
    /**
     * @returns {Number[3]}
     */
    ProjectileClass.prototype.getLightColor = function () {
        return this._lightColor;
    };
    /**
     * @returns {Number}
     */
    ProjectileClass.prototype.getLightIntensity = function () {
        return this._lightIntensity;
    };
    /**
     * @returns {ExplosionClass}
     */
    ProjectileClass.prototype.getExplosionClass = function () {
        return this._explosionClass;
    };
    /**
     * @returns {ExplosionClass}
     */
    ProjectileClass.prototype.getShieldExplosionClass = function () {
        return this._shieldExplosionClass;
    };
    /**
     * @override
     * Updates the properties for the case when the graphics settings have been changed.
     */
    ProjectileClass.prototype.handleGraphicsSettingsChanged = function () {
        TexturedModelClass.prototype.handleGraphicsSettingsChanged.call(this);
        this._muzzleFlash.handleGraphicsSettingsChanged();
    };
    // ##############################################################################
    /**
     * @class Missiles such as rockets, homing missiles or torpedoes can belong 
     * to different classes that can be described in classes.json. This class 
     * represents such a missile class, defining the common properties of the 
     * missiles belonging to the class.
     * @augments TexturedModelClass
     * @param {Object} [dataJSON]
     */
    function MissileClass(dataJSON) {
        TexturedModelClass.call(this, dataJSON);
    }
    MissileClass.prototype = new TexturedModelClass();
    MissileClass.prototype.constructor = MissileClass;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    MissileClass.prototype._loadData = function (dataJSON) {
        var t;
        TexturedModelClass.prototype._loadData.call(this, dataJSON);
        /**
         * The full name of this class as displayed in the game.
         * @type String
         */
        this._fullName = dataJSON ? (dataJSON.fullName || this.getName()) : null;
        /**
         * The short name of this class to be displayed on the HUD showing the missile info
         * @type String
         */
        this._shortName = dataJSON ? (dataJSON.shortName || (this._fullName && this._fullName.split(" ")[0].substring(0, 5))) : null;
        /**
         * Whether this missile is supposed to be used against ships (and not fighters)
         * @type Boolean
         */
        this._antiShip = dataJSON ? (dataJSON.antiShip || false) : false;
        /**
         * The amount of damage this missile causes when it hits a spacecraft.
         * @type Number
         */
        this._damage = dataJSON ? (dataJSON.damage || 0) : 0;
        /**
         * The amount by which the model representing the missile will be scaled.
         * @type Number
         */
        this._modelScale = dataJSON ? (dataJSON.modelScale || 1) : 0;
        /**
         * (enum MissileSize) A missile can only be loaded in a launch tube that 
         * has the same size (i.e. this represents the radius category of the missile)
         * @type String
         */
        this._size = dataJSON ? utils.getSafeEnumValue(MissileSize, dataJSON.size, null) || _missingString(this, "size") : null;
        /**
         * How much capacity is taken up by one missile of this class, when put
         * in a launch tube (i.e. this represents the length of the missile)
         * @type Number
         */
        this._capacity = dataJSON ? (dataJSON.capacity || 1) : 0;
        /**
         * The actual length of a missile, i.e. the offset between two missiles behind each other
         * in the same launch tube, in meters.
         * @type Number
         */
        this._length = dataJSON ? (dataJSON.length || _missingNumber(this, "length")) : 0;
        /**
         * (enum MissileHomingMode) Determines the homing mechanism of the missile
         * @type Number
         */
        this._homingMode = dataJSON ? utils.getSafeEnumValueForKey(MissileHomingMode, dataJSON.homingMode, MissileHomingMode.NONE) : null;
        /**
         * Mass of the missile in kilograms. Determines the forces / torques it
         * exerts when launching and hitting targets and its acceleration.
         * @type Number
         */
        this._mass = dataJSON ? (dataJSON.mass || _missingNumber(this, "mass")) : 0;
        /**
         * If there is drag in the environment, its effect on this missile will be multiplied by this factor
         * @type Number
         */
        this._dragFactor = dataJSON ? ((dataJSON.dragFactor !== undefined) ? dataJSON.dragFactor : 1) : 0;
        /**
         * The velocity at which the missile is ejected from its launch tube, in m/s
         * @type Number
         */
        this._launchVelocity = dataJSON ? (dataJSON.launchVelocity || 0) : 0;
        /**
         * The thrusters of the missile are ignited this much time after launching, in milliseconds
         * @type Number
         */
        this._ignitionTime = dataJSON ? (dataJSON.ignitionTime || 0) : 0;
        /**
         * The forward acceleration of the missile when the main thruster is firing, in m/s^2
         * @type Number
         */
        this._acceleration = dataJSON ? (dataJSON.acceleration || _missingNumber(this, "acceleration")) : 0;
        /**
         * The thrust that the main thruster of the missile exerts for accelerating the missile towards
         * the target, in newtons (kg*m/s^2)
         * @type Number
         */
        this._thrust = dataJSON ? ((this._mass * dataJSON.acceleration) || _missingNumber(this, "acceleration")) : 0;
        /**
         * The maximum angular acceleration the maneuvering thrusters of the missile can achieve in their
         * respective direction (yaw / pitch), in rad/s^2
         * @type Number
         */
        this._angularAcceleration = (this._homingMode !== MissileHomingMode.NONE) ? (dataJSON ? (Math.radians(dataJSON.angularAcceleration) || _missingNumber(this, "angularAcceleration")) : 0) : 0;
        /**
         * Determines the amount of torque the maneuvering thrusters can exert on the missile in their 
         * respective direction (yaw / pitch), in kg*rad/s^2
         * @type Number
         */
        this._angularThrust = dataJSON ? (this._mass * this._angularAcceleration) : 0;
        /**
         * If the missile is homing, the main thruster of the missile is fired whenever both the yaw 
         * and pitch angles towards the target are within this threshold (radians)
         * @type Number
         */
        this._mainBurnAngleThreshold = (this._homingMode !== MissileHomingMode.NONE) ? (dataJSON ? (Math.radians(dataJSON.mainBurnAngleThreshold) || _missingNumber(this, "mainBurnAngleThreshold")) : 0) : 0;
        /**
         * The length of life of the missile in milliseconds, after which it will explode (harmlessly),
         * counted right from the launch.
         * @type Number
         */
        this._duration = dataJSON ? (dataJSON.duration || _missingNumber(this, "duration")) : 0;
        /**
         * The amount of waiting time needed before being locked to the target while in range and within locking angle, in ms.
         * @type Number
         */
        this._lockingTime = (this._homingMode !== MissileHomingMode.NONE) ? (dataJSON ? (dataJSON.lockingTime || 0) : 0) : 0;
        /**
         * The targeting computer can only lock on to the target (for homing missiles) while its bearing, both yaw and pitch is within this angle, 
         * measured from the estimated position of the missile when it will ignite, in radians.
         * @type Number
         */
        this._lockingAngle = (this._lockingTime > 0) ? (dataJSON ? (Math.radians(dataJSON.lockingAngle || 0)) : 0) : 0;
        /**
         * The amount of waiting time needed between launching two missiles, in ms.
         * @type Number
         */
        this._cooldown = dataJSON ? (dataJSON.cooldown || _missingNumber(this, "cooldown")) : 0;
        /**
         * The amount of waiting time needed between launching two missiles in the same salvo, in ms.
         * @type Number
         */
        this._salvoCooldown = dataJSON ? (dataJSON.salvoCooldown || this._cooldown) : 0;
        /**
         * The missile will explode and deal damage within this range of enemy ships, in meters.
         * @type Number
         */
        this._proximityRange = dataJSON ? (dataJSON.proximityRange || 0) : 0;
        /**
         * The ratio of kinetic energy of the missile to transfer to the target upon exploding.
         * (the force and torque exerted on the target will be based on the momentum/angular momentum 
         * multiplied by this factor)
         * @type Number
         */
        this._kineticFactor = dataJSON ? (dataJSON.kineticFactor || 1) : 0;
        /**
         * The color of the light this missile emits as a light source.
         * @type Number[3]
         */
        this._lightColor = dataJSON ? (dataJSON.lightColor || null) : null;
        /**
         * The intensity of the light this missile emits as a light source.
         * @type Number
         */
        this._lightIntensity = dataJSON ? (dataJSON.lightColor ? dataJSON.lightIntensity || _missingNumber(this, "lightIntensity") : 0) : 0;
        /**
         * The characteristics of the trail the missile leaves behind when using its main engine
         * @type TrailDescriptor
         */
        this._trailDescriptor = dataJSON ? (dataJSON.trail ? new TrailDescriptor(dataJSON.trail) : _missingObject(this, "trail")) : null;
        /**
         * The class of the explosion this missile creates when it hits the armor of a spacecraft or
         * when it explodes harmlessly because of exceeding maximum duration.
         * @type ExplosionClass
         */
        this._explosionClass = dataJSON ? (getExplosionClass(dataJSON.explosion || _missingString(this, "explosion")) || application.crash()) : null;
        /**
         * The class of the explosion this missile creates when it hits the shield of a spacecraft.
         * @type ExplosionClass
         */
        this._shieldExplosionClass = dataJSON ? (getExplosionClass(dataJSON.shieldExplosion || _missingString(this, "shieldExplosion")) || application.crash()) : null;
        /**
         * The amount of score points to be added to the total score value of spacecrafts for each missile of this class equipped
         * @type Number
         */
        this._scoreValue = dataJSON ? (dataJSON.scoreValue || 0) : 0;
        /**
         * The descriptor of the sound effect to be played when this missile launches.
         * @type Object
         */
        this._launchSound = dataJSON ? (types.getVerifiedObject("missileClasses['" + this._name + "'].launchSound", dataJSON.launchSound, SOUND_EFFECT_3D)) : null;
        /**
         * The descriptor of the sound effect to be played when this missile first ignites its main engine.
         * @type Object
         */
        this._startSound = dataJSON ? (types.getVerifiedObject("missileClasses['" + this._name + "'].startSound", dataJSON.startSound, SOUND_EFFECT_3D)) : null;
        /**
         * The propulsion class to use for initializing thruster visuals (the missile class has its own thrust values, the ones from the propulsion are ignored)
         * @type PropulsionClass
         */
        this._propulsionClass = dataJSON ? (getPropulsionClass(dataJSON.propulsion || _missingString(this, "propulsion")) || application.crash()) : null;
        /**
         * The thruster slots for creating and managing thruster visuals
         * @type ThrusterSlot[]
         */
        this._thrusterSlots = dataJSON ? [] : null;
        if (dataJSON && dataJSON.thrusterSlots) {
            _loadThrusterSlots(dataJSON, this, this._thrusterSlots);
        } else if (dataJSON) {
            _showMissingPropertyError(this, "thrusterSlots");
        }
        /**
         * @type Number[3]
         */
        this._enginePosition = (this._thrusterSlots && (this._thrusterSlots.length > 0)) ? this._thrusterSlots[0].positionVector : [0, 0, 0];
        t = 0.001 * (this._duration - this._ignitionTime);
        /**
         * Cached calculated value of the missile's nominal range
         * @type Number
         */
        this._nominalRange = (0.001 * this._duration * this._launchVelocity) + (this._acceleration * 0.5 * t * t); // s = v0 * t + a/2 * t^2
        return true;
    };
    /**
     * @typedef {ShadedModelClass~ResourceParams} MissileClass~ResourceParams
     * @property {Boolean} [missileOnly=false] Whether to load resources for
     * displaying the missile itself only (not its thrusters or it hitting things 
     * or being launched)
     * @property {Boolean} [sound=false] Whether to load resources for sound effects
     * @property {Boolean} [trail=false] Whether to load resources for the trail the 
     * missile leaves behind when its main engine is on
     */
    /**
     * @override
     * @param {MissileClass~ResourceParams} params
     */
    MissileClass.prototype.acquireResources = function (params) {
        TexturedModelClass.prototype.acquireResources.call(this, params);
        if (!params.missileOnly) {
            this._explosionClass.acquireResources({sound: params.sound});
            this._shieldExplosionClass.acquireResources({sound: params.sound});
            this._propulsionClass.acquireResources({sound: false});
            if (params.sound) {
                _loadSoundEffect(this._launchSound);
                _loadSoundEffect(this._startSound);
            }
            if (params.trail) {
                this._trailDescriptor.acquireResources();
            }
        }
    };
    /**
     * @returns {String}
     */
    MissileClass.prototype.getDisplayName = function () {
        return strings.get(
                strings.MISSILE_CLASS.PREFIX, this.getName() + strings.MISSILE_CLASS.NAME_SUFFIX.name,
                this._fullName);
    };
    /**
     * @returns {String}
     */
    MissileClass.prototype.getShortName = function () {
        return this._shortName;
    };
    /**
     * @returns {Boolean}
     */
    MissileClass.prototype.isAntiShip = function () {
        return this._antiShip;
    };
    /**
     * @param {Number} [armorRating=0]
     * @returns {Number}
     */
    MissileClass.prototype.getDamage = function (armorRating) {
        return Math.max(0, this._damage - armorRating);
    };
    /**
     * Returns the range of the missile fired from a still fighter if it flies
     * straight forward. (actual effective range will depend on the relative 
     * velocity of the fighter and the maneuvering of the missile if homing)
     * In meters.
     * @returns {Number}
     */
    MissileClass.prototype.getNominalRange = function () {
        return this._nominalRange;
    };
    /**
     * Launches / second
     * @returns {Number}
     */
    MissileClass.prototype.getFireRate = function () {
        return 1000 / this._cooldown;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getLockingTime = function () {
        return this._lockingTime;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getLockingAngle = function () {
        return this._lockingAngle;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getModelScale = function () {
        return this._modelScale;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getSize = function () {
        return this._size;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getCapacity = function () {
        return this._capacity;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getLength = function () {
        return this._length;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getHomingMode = function () {
        return this._homingMode;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getMass = function () {
        return this._mass;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getDragFactor = function () {
        return this._dragFactor;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getThrust = function () {
        return this._thrust;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getAngularAcceleration = function () {
        return this._angularAcceleration;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getAngularThrust = function () {
        return this._angularThrust;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getMainBurnAngleThreshold = function () {
        return this._mainBurnAngleThreshold;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getLaunchVelocity = function () {
        return this._launchVelocity;
    };
    /**
     * The force the launch of the missile exerts on the launching spacecraft
     * @param {Number} duration In milliseconds
     * @returns {Number} In newtons (kg*m/s^2)
     */
    MissileClass.prototype.getForceForDuration = function (duration) {
        return this._launchVelocity * this._mass / (duration * 0.001); // ms -> s
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getIgnitionTime = function () {
        return this._ignitionTime;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getDuration = function () {
        return this._duration;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getCooldown = function () {
        return this._cooldown;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getSalvoCooldown = function () {
        return this._salvoCooldown;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getProximityRange = function () {
        return this._proximityRange;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getKineticFactor = function () {
        return this._kineticFactor;
    };
    /**
     * @returns {Number[3]}
     */
    MissileClass.prototype.getLightColor = function () {
        return this._lightColor;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getLightIntensity = function () {
        return this._lightIntensity;
    };
    /**
     * @returns {TrailDescriptor}
     */
    MissileClass.prototype.getTrailDescriptor = function () {
        return this._trailDescriptor;
    };
    /**
     * @returns {ExplosionClass}
     */
    MissileClass.prototype.getExplosionClass = function () {
        return this._explosionClass;
    };
    /**
     * @returns {ExplosionClass}
     */
    MissileClass.prototype.getShieldExplosionClass = function () {
        return this._shieldExplosionClass;
    };
    /**
     * @returns {PropulsionClass}
     */
    MissileClass.prototype.getPropulsionClass = function () {
        return this._propulsionClass;
    };
    /**
     * Returns the highest number of missiles that might be simultaneously used in one battle fired from one launcher
     * @returns {Number}
     */
    MissileClass.prototype.getMaxCount = function () {
        return Math.ceil(this._duration / this._cooldown);
    };
    /**
     * The amount of partices needed to render a missile of this class
     * @returns {Number}
     */
    MissileClass.prototype.getParticleCount = function () {
        return this._thrusterSlots.length;
    };
    /**
     * @returns {Number}
     */
    MissileClass.prototype.getScoreValue = function () {
        return this._scoreValue;
    };
    /**
     * Plays the sound effect corresponding to a missile of this class launching, at the given world position
     * @param {Number[3]} [position] The camera-space position where to put the sound source, if the sound
     * is not to be stacked to the sound source of the spacecraft (the spacecraft is close and the different
     * weapons should have their own sound sources created)
     * @param {SoundSource} [soundSource] The sound source belonging to the spacecraft it the launch sound effect
     * is to be stacked to it (for spacecrafts that are farther away to simplify the sound graph)
     * @param {Number} [stackTimeThreshold=0] The time threshold for stacking (maximum time difference, in seconds)
     * @param {Number} [stackVolumeFactor=1] The factor to multiply the volume of stacked sound clips by
     */
    MissileClass.prototype.playLaunchSound = function (position, soundSource, stackTimeThreshold, stackVolumeFactor) {
        if (position) {
            _playSoundEffect(this._launchSound, position);
        } else {
            _createSoundClip(this._launchSound, false, soundSource, true, stackTimeThreshold, stackVolumeFactor).play();
        }
    };
    /**
     * Plays the sound effect corresponding to the missile igniting its main thruster for the first time
     * @param {SoundSource} soundSource The sounds source belonging to the missile
     * @returns {SoundClip}
     */
    MissileClass.prototype.playStartSound = function (soundSource) {
        var clip = _createSoundClip(this._startSound, false, soundSource);
        clip.play();
        return clip;
    };
    /**
     * @returns {ThrusterSlot[]}
     */
    MissileClass.prototype.getThrusterSlots = function () {
        return this._thrusterSlots;
    };
    /**
     * 4D position of the main thruster, in model space.
     * @returns {Number[4]}
     */
    MissileClass.prototype.getEnginePosition = function () {
        return this._enginePosition;
    };
    /**
     * Returns the estimated time it would take for a missile of this class to reach
     * a target at targetPosition from position, assuming the passed initial relative 
     * velocity of the target, accelerating in a straight line towards it. In seconds.
     * @param {Number[3]} position
     * @param {Number[3]} targetPosition
     * @param {Number[3]} relativeTargetVelocity
     * @returns {Number}
     */
    MissileClass.prototype.getTargetHitTime = function (position, targetPosition, relativeTargetVelocity) {
        var a, c, d, e, i;
        a = this._acceleration * this._acceleration * 0.25;
        c = -(relativeTargetVelocity[0] * relativeTargetVelocity[0] + relativeTargetVelocity[1] * relativeTargetVelocity[1] + relativeTargetVelocity[2] * relativeTargetVelocity[2]);
        d = 0;
        for (i = 0; i < 3; i++) {
            d += (2 * relativeTargetVelocity[i] * (position[i] - targetPosition[i]));
        }
        e = 0;
        for (i = 0; i < 3; i++) {
            e += (-targetPosition[i] * targetPosition[i] - position[i] * position[i] + 2 * targetPosition[i] * position[i]);
        }
        return utils.getSmallestPositiveSolutionOf4thDegreeEquationWithoutDegree3(a, c, d, e);
    };
    /**
     * @override
     * Updates the properties for the case when the graphics settings have been changed.
     */
    MissileClass.prototype.handleGraphicsSettingsChanged = function () {
        TexturedModelClass.prototype.handleGraphicsSettingsChanged.call(this);
        this._trailDescriptor.handleGraphicsSettingsChanged();
    };
    // ##############################################################################
    /**
     * @class Every weapon can have multiple barrels, each of which shoot one 
     * projectile. Barrels are defined for each weapon class.
     * @param {Object} [dataJSON]
     */
    function Barrel(dataJSON) {
        /**
         * The class of the projectile being shot from this barrel.
         * @type ProjectileClass
         */
        this._projectileClass = dataJSON ? (getProjectileClass(dataJSON.projectile || _missingString(this, "projectile")) || application.crash()) : null;
        /**
         * The relative velocity that a projectile shot from this barrel should gain from the force of firing.
         * @type Number
         */
        this._projectileVelocity = dataJSON ? (dataJSON.projectileVelocity || _missingNumber(this, "projectileVelocity")) : 0;
        /**
         * The coordinates of the barrel's position relative to the weapon itself. Reading a 3 element vector and complementing it with a 
         * 1.0 to make it 4 element, as it is used in multiplication with 4x4 matrices.
         * @type Number[4]
         */
        this._positionVector = dataJSON ? (dataJSON.position ? dataJSON.position.slice() : _missingVector3(this, "position")) : null;
        if (this._positionVector) {
            this._positionVector.push(1);
        }
    }
    /**
     * @returns {ProjectileClass}
     */
    Barrel.prototype.getProjectileClass = function () {
        return this._projectileClass;
    };
    /**
     * Returns the velocity (m/s) at which this barrel is firing projectiles.
     * @returns {Number}
     */
    Barrel.prototype.getProjectileVelocity = function () {
        return this._projectileVelocity;
    };
    /**
     * @param {Number} duration In milliseconds
     * @returns {Number} In newtons (kg*m/s^2)
     */
    Barrel.prototype.getForceForDuration = function (duration) {
        return this._projectileVelocity * this._projectileClass.getMass() / (duration * 0.001); // ms -> s
    };
    /**
     * @returns {Number[4]}
     */
    Barrel.prototype.getPositionVector = function () {
        return this._positionVector;
    };
    /**
     * @param {ProjectileClass~ResourceParams} params 
     */
    Barrel.prototype.acquireResources = function (params) {
        this._projectileClass.acquireResources(params);
    };
    /**
     * Returns the highest number of projectiles that might be used for this barrel simultaneously in one battle, given the passed cooldown.
     * @param {Number} cooldown The cooldown determining the firing rate, in milliseconds.
     * @returns {Number}
     */
    Barrel.prototype.getMaxProjectileCount = function (cooldown) {
        return Math.ceil(this._projectileClass.getDuration() / cooldown);
    };
    /**
     * Returns the highest number of explosions that might be used for this barrel simultaneously in one battle, given the passed cooldown.
     * @param {Number} cooldown The cooldown determining the firing rate, in milliseconds.
     * @returns {Number}
     */
    Barrel.prototype.getMaxExplosionCount = function (cooldown) {
        return Math.ceil(Math.max(this._projectileClass.getExplosionClass().getTotalDuration(), this._projectileClass.getShieldExplosionClass().getTotalDuration()) / cooldown);
    };
    /**
     * Returns the highest number of particles that might be used for this barrel simultaneously in one battle, given the passed cooldown.
     * @param {Number} cooldown The cooldown determining the firing rate, in milliseconds.
     * @returns {Number}
     */
    Barrel.prototype.getMaxParticleCount = function (cooldown) {
        // one for the muzzle flash
        return 1 + this.getMaxExplosionCount(cooldown) * Math.max(this._projectileClass.getExplosionClass().getMaxParticleCount(), this._projectileClass.getShieldExplosionClass().getMaxParticleCount());
    };
    // ##############################################################################
    /**
     * @struct
     * Describes a rotator joint of a weapon, based on which the weapon (and part of its visual model) can be rotated around a given axis
     * to aim it towards a specific direction.
     * @param {Object} dataJSON The object defining the properties of the rotator
     */
    function WeaponRotator(dataJSON) {
        /**
         * The direction of the axis around which to rotate the weapon.
         * @type Number[3]
         */
        this.axis = types.getValueOfType("WeaponRotator.axis", types.VECTOR3, dataJSON.axis);
        /**
         * A point of the axis around which to rotate the weapon, in object-space coordinates.
         * @type Number[3]
         */
        this.center = types.getValueOfType("WeaponRotator.center", types.VECTOR3, dataJSON.center);
        /**
         * If given, the angle of the weapon corresponding to this rotator is restricted to lie within this range ([min, max], radians)
         * @type Number[2]
         */
        this.range = types.getValueOfType("WeaponRotator.range", types.VECTOR2, dataJSON.range, null, true);
        if (this.range) {
            this.range[0] = Math.radians(this.range[0]);
            this.range[1] = Math.radians(this.range[1]);
        }
        /**
         * The weapon should rotate to this angle by default (when not aiming), in radians.
         * @type Number
         */
        this.defaultAngle = Math.radians(types.getValueOfType("WeaponRotator.defaultAngle", types.NUMBER, dataJSON.defaultAngle, 0, true));
        /**
         * A shortcut flag indicating whether the angle of rotation is restricted to a specific range for this rotator (if false, the weapon 
         * can rotate freely around in 360 degrees)
         * @type Boolean
         */
        this.restricted = !!this.range;
        /**
         * The weapon can rotate at this rate (speed), in radians / second.
         * @type Number
         */
        this.rotationRate = Math.radians(types.getValueOfType("WeaponRotator.rotationRate", types.NUMBER, dataJSON.rotationRate));
        /**
         * When rotating using this rotator, the vertices belonging to the transform group with this index should be rotated.
         * @type Number
         */
        this.transformGroupIndex = types.getValueOfType("WeaponRotator.transformGroupIndex", types.NUMBER, dataJSON.transformGroupIndex);
    }
    // ##############################################################################
    /**
     * @class Each spacecraft can have weapons, all of which belong to a certain
     * weapon class. This class represent one of such classes, describing the 
     * general properties of all weapons in that class.
     * @augments TexturedModelClass
     * @param {Object} [dataJSON] 
     */
    function WeaponClass(dataJSON) {
        TexturedModelClass.call(this, dataJSON);
    }
    WeaponClass.prototype = new TexturedModelClass();
    WeaponClass.prototype.constructor = WeaponClass;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    WeaponClass.prototype._loadData = function (dataJSON) {
        var i;
        TexturedModelClass.prototype._loadData.call(this, dataJSON);
        /**
         * The full name of this class as displayed in the game.
         * @type String
         */
        this._fullName = dataJSON ? (dataJSON.fullName || this.getName()) : null;
        /**
         * The time the weapon needs between two shots to "cool down", in milliseconds.
         * @type Number
         */
        this._cooldown = dataJSON ? (dataJSON.cooldown || _missingNumber(this, "cooldown")) : 0;
        /**
         * The list of barrels of this weapon.
         * @type Barrel[]
         */
        this._barrels = [];
        if (dataJSON) {
            if (dataJSON.barrels) {
                for (i = 0; i < dataJSON.barrels.length; i++) {
                    this._barrels.push(new Barrel(dataJSON.barrels[i]));
                }
            } else {
                _showMissingPropertyError(this, "barrels");
            }
        }
        /**
         * The position of the point in model space where the weapon should be attached to the weapon slot it is equipped to.
         * @type Number[3]
         */
        this._attachmentPoint = dataJSON ? (dataJSON.attachmentPoint || [0, 0, 0]) : null;
        /**
         * Indicates the number and role of rotators of the weapon, based on which a direction to point the weapon towards can be translated
         * to rotation angles corresponding to its rotators.
         * @type String
         */
        this._rotationStyle = dataJSON ? utils.getSafeEnumValue(WeaponRotationStyle, dataJSON.rotationStyle, WeaponRotationStyle.NONE) : null;
        /**
         * A shortcut flag indicating whether the weapon is pointing in a fix direction (true) or can be rotated in some way (false).
         * @type Boolean
         */
        this._fixed = this._rotationStyle === WeaponRotationStyle.NONE;
        /**
         * The position of the point which should be taken into account as a basis when aiming the weapon: rotation angles need to be 
         * determined based on the vectors pointing from this point towards the target. In object-space coordinates. It is transformed
         * considering all the rotators. In 4D, with a 1.0 appended to make it easier to multiply it with 4x4 matrices.
         * @type Number[4]
         */
        this._basePoint = (dataJSON && !this._fixed) ? (dataJSON.basePoint && dataJSON.basePoint.slice() || [0, 0, 0]) : null;
        if (this._basePoint) {
            this._basePoint.push(1);
        }
        /**
         * The list of rotators, containing the detailed information about each.
         * @type WeaponRotator[]
         */
        this._rotators = [];
        if (dataJSON && !this._fixed) {
            if (dataJSON.rotators) {
                for (i = 0; i < dataJSON.rotators.length; i++) {
                    this._rotators.push(new WeaponRotator(dataJSON.rotators[i]));
                }
            } else {
                _showMissingPropertyError(this, "rotators");
            }
        }
        /**
         * The descriptor of the sound effect to be played when this weapon fires.
         * @type Object
         */
        this._fireSound = dataJSON ? (types.getVerifiedObject("weaponClasses['" + this._name + "'].fireSound", dataJSON.fireSound, SOUND_EFFECT_3D)) : null;
        /**
         * The amount of score points to be added to the total score value of spacecrafts that have a weapon of this class equipped
         * @type Number
         */
        this._scoreValue = dataJSON ? (dataJSON.scoreValue || 0) : 0;
        return true;
    };
    /**
     * @typedef {ShadedModelClass~ResourceParams} WeaponClass~ResourceParams
     * @property {Boolean} [projectileResources=false] Whether to load resources
     * for this weapon firing its projectiles (and them hitting things) as well
     * @property {Boolean} [sound=false] Whether to load resources for sound effects
     */
    /**
     * @override
     * @param {WeaponClass~ResourceParams} params
     */
    WeaponClass.prototype.acquireResources = function (params) {
        var i, projectileParams;
        TexturedModelClass.prototype.acquireResources.call(this, params);
        if (params.projectileResources) {
            projectileParams = {projectileOnly: false, sound: params.sound};
            for (i = 0; i < this._barrels.length; i++) {
                this._barrels[i].acquireResources(projectileParams);
            }
        }
        if (params.sound) {
            _loadSoundEffect(this._fireSound);
        }
    };
    /**
     * @returns {String}
     */
    WeaponClass.prototype.getDisplayName = function () {
        return strings.get(
                strings.WEAPON_CLASS.PREFIX, this.getName() + strings.WEAPON_CLASS.NAME_SUFFIX.name,
                this._fullName);
    };
    /**
     * @returns {Number}
     */
    WeaponClass.prototype.getCooldown = function () {
        return this._cooldown;
    };
    /**
     * @param {Number} index
     * @returns {Barrel}
     */
    WeaponClass.prototype.getBarrel = function (index) {
        return this._barrels[index];
    };
    /**
     * @returns {Barrel[]}
     */
    WeaponClass.prototype.getBarrels = function () {
        return this._barrels;
    };
    /**
     * @returns {Number[3]}
     */
    WeaponClass.prototype.getAttachmentPoint = function () {
        return this._attachmentPoint;
    };
    /**
     * @returns {String}
     */
    WeaponClass.prototype.getRotationStyle = function () {
        return this._rotationStyle;
    };
    /**
     * @returns {Boolean}
     */
    WeaponClass.prototype.isFixed = function () {
        return this._fixed;
    };
    /**
     * @returns {Number[4]}
     */
    WeaponClass.prototype.getBasePoint = function () {
        return this._basePoint;
    };
    /**
     * @returns {WeaponRotator[]}
     */
    WeaponClass.prototype.getRotators = function () {
        return this._rotators;
    };
    /**
     * Returns the class of projectiles the first barrel of this weapon class fires.
     * @returns {ProjectileClass}
     */
    WeaponClass.prototype.getProjectileClass = function () {
        return this._barrels[0].getProjectileClass();
    };
    /**
     * Returns the velocity (m/s) at which the first barrel of this weapon class fires projectiles.
     * @returns {Number}
     */
    WeaponClass.prototype.getProjectileVelocity = function () {
        return this._barrels[0].getProjectileVelocity();
    };
    /**
     * Returns the damage one shot (from all barrels) of a weapon of this class deals to a target with the passed armor rating.
     * @param {Number} [armorRating=0]
     * @returns {Number}
     */
    WeaponClass.prototype.getDamage = function (armorRating) {
        var result = 0, i;
        armorRating = armorRating || 0;
        for (i = 0; i < this._barrels.length; i++) {
            result += Math.max(0, this._barrels[i].getProjectileClass().getDamage() - armorRating);
        }
        return result;
    };
    /**
     * Returns the damage per second dealt by a weapon of this class to a target with the passed armor rating.
     * @param {Number} [armorRating=0]
     * @returns {Number}
     */
    WeaponClass.prototype.getFirepower = function (armorRating) {
        return this.getDamage(armorRating) * 1000 / this._cooldown; // cooldown is in milliseconds
    };
    /**
     * Returns the rate of fire of weapons of this class, in shots per second
     * @returns {Number}
     */
    WeaponClass.prototype.getFireRate = function () {
        return 1000 / this._cooldown; // cooldown is in milliseconds
    };
    /**
     * Plays the sound effect corresponding to a weapon of this class firing, at the given world position
     * @param {Number[3]} [position] The camera-space position where to put the sound source, if the sound
     * is not to be stacked to the sound source of the spacecraft (the spacecraft is close and the different
     * weapons should have their own sound sources created)
     * @param {SoundSource} [soundSource] The sound source belonging to the spacecraft it the fire sound effect
     * is to be stacked to it (for spacecrafts that are farther away to simplify the sound graph)
     * @param {Number} [stackTimeThreshold=0] The time threshold for stacking (maximum time difference, in seconds)
     * @param {Number} [stackVolumeFactor=1] The factor to multiply the volume of stacked sound clips by
     */
    WeaponClass.prototype.playFireSound = function (position, soundSource, stackTimeThreshold, stackVolumeFactor) {
        if (position) {
            _playSoundEffect(this._fireSound, position);
        } else {
            _createSoundClip(this._fireSound, false, soundSource, true, stackTimeThreshold, stackVolumeFactor).play();
        }
    };
    /**
     * Returns the amount of score points to be added to the total score value of spacecrafts that have a weapon of this class equipped
     * @returns {Number}
     */
    WeaponClass.prototype.getScoreValue = function () {
        return this._scoreValue;
    };
    /**
     * Returns the highest number of projectiles that might be used for weapons of this class simultaneously in one battle.
     * @returns {Number}
     */
    WeaponClass.prototype.getMaxProjectileCount = function () {
        var result = 0, i;
        for (i = 0; i < this._barrels.length; i++) {
            result += this._barrels[i].getMaxProjectileCount(this._cooldown);
        }
        return result;
    };
    /**
     * Returns the highest number of explosions that might be used for weapons of this class simultaneously in one battle.
     * @returns {Number}
     */
    WeaponClass.prototype.getMaxExplosionCount = function () {
        var result = 0, i;
        for (i = 0; i < this._barrels.length; i++) {
            result += this._barrels[i].getMaxExplosionCount(this._cooldown);
        }
        return result;
    };
    /**
     * Returns the highest number of particles that might be used for weapons of this class simultaneously in one battle.
     * @returns {Number}
     */
    WeaponClass.prototype.getMaxParticleCount = function () {
        var result = 0, i;
        for (i = 0; i < this._barrels.length; i++) {
            result += this._barrels[i].getMaxParticleCount(this._cooldown);
        }
        return result;
    };
    // ##############################################################################
    /**
     * @class Each spacecraft can be equipped with a propulsion system. This class
     * represents one of the classes to which such a system can belong, describing
     * the properties of such a propulsion system.
     * @augments GenericClass
     * @param {Object} [dataJSON]
     */
    function PropulsionClass(dataJSON) {
        GenericClass.call(this, dataJSON);
    }
    PropulsionClass.prototype = new GenericClass();
    PropulsionClass.prototype.constructor = PropulsionClass;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    PropulsionClass.prototype._loadData = function (dataJSON) {
        var referenceMass;
        GenericClass.prototype._loadData.call(this, dataJSON);
        referenceMass = dataJSON ? (dataJSON.referenceMass || 1) : null;
        /**
         * The full name of this class as displayed in the game.
         * @type String
         */
        this._fullName = dataJSON ? (dataJSON.fullName || this.getName()) : null;
        /**
         * A descriptor for rendering the particles shown when thrusters of the ship 
         * fire.
         * @type ParticleDescriptor
         */
        this._thrusterBurnParticle = new ParticleDescriptor(dataJSON);
        /**
         * The strength of the force applied to the ship when the thrusters are 
         * fired in one direction, measured in newtons.
         * @type Number
         */
        this._thrust = dataJSON ? ((referenceMass * dataJSON.thrust) || _missingNumber(this, "thrust")) : 0;
        /**
         * The strength of the torque applied to the ship when the thrusters are 
         * used to turn it, in kg*rad/s^2 (mass is considered instead of a
         * calculated coefficient based on shape, for simplicity)
         * @type Number
         */
        this._angularThrust = dataJSON ? ((referenceMass * Math.radians(dataJSON.angularThrust)) || _missingNumber(this, "angularThrust")) : 0;
        /**
         * Maximum thrust for acceleration is applied at this burn level.
         * @type Number
         */
        this._maxMoveBurnLevel = dataJSON ? (dataJSON.maxMoveBurnLevel || _missingNumber(this, "maxMoveBurnLevel")) : 0;
        /**
         * Maximum angular thrust for turning is applied at this burn level.
         * @type Number
         */
        this._maxTurnBurnLevel = dataJSON ? (dataJSON.maxTurnBurnLevel || _missingNumber(this, "maxTurnBurnLevel")) : 0;
        /**
         * The descriptor of the sound effect to be played when the thrusters of this propulsion fire.
         * @type Object
         */
        this._thrusterSound = dataJSON ? types.getVerifiedObject("propulsionClasses['" + this._name + "'].thrusterSound", dataJSON.thrusterSound, SOUND_EFFECT_3D) : null;
        /**
         * The amount of score points to be added to the total score value of spacecrafts that have a propulsion of this class equipped
         * @type Number
         */
        this._scoreValue = dataJSON ? (dataJSON.scoreValue || 0) : 0;
        return true;
    };
    /**
     * @typedef {Object} PropulsionClass~ResourceParams
     * @property {Boolean} [sound=false] Whether to load resources for sound effects
     */
    /**
     * @param {PropulsionClass~ResourceParams} params 
     */
    PropulsionClass.prototype.acquireResources = function (params) {
        this._thrusterBurnParticle.acquireResources();
        if (params.sound) {
            _loadSoundEffect(this._thrusterSound);
        }
    };
    /**
     * @returns {String}
     */
    PropulsionClass.prototype.getDisplayName = function () {
        return strings.get(
                strings.PROPULSION_CLASS.PREFIX, this.getName() + strings.PROPULSION_CLASS.NAME_SUFFIX.name,
                this._fullName);
    };
    /**
     * @returns {ParticleDescriptor}
     */
    PropulsionClass.prototype.getThrusterBurnParticle = function () {
        return this._thrusterBurnParticle;
    };
    /**
     * @returns {Number}
     */
    PropulsionClass.prototype.getThrust = function () {
        return this._thrust;
    };
    /**
     * @returns {Number}
     */
    PropulsionClass.prototype.getAngularThrust = function () {
        return this._angularThrust;
    };
    /**
     * Return the level of burn at which maximum thrust is applied.
     * @returns {Number}
     */
    PropulsionClass.prototype.getMaxMoveBurnLevel = function () {
        return this._maxMoveBurnLevel;
    };
    /**
     * Return the level of burn at which maximum angular thrust is applied.
     * @returns {Number}
     */
    PropulsionClass.prototype.getMaxTurnBurnLevel = function () {
        return this._maxTurnBurnLevel;
    };
    /**
     * @override
     * Updates the properties for the case when the graphics settings have been changed.
     */
    PropulsionClass.prototype.handleGraphicsSettingsChanged = function () {
        GenericClass.prototype.handleGraphicsSettingsChanged.call(this);
        this._thrusterBurnParticle.handleGraphicsSettingsChanged();
    };
    /**
     * Creates a sound clip for the thruster sound effect for this propulsion in looping mode, and returns a reference to it.
     * @param {SoundSource} soundSource The sound source to be used for 3D spatial positioning of the clip
     * @returns {SoundClip}
     */
    PropulsionClass.prototype.createThrusterSoundClip = function (soundSource) {
        return _createSoundClip(this._thrusterSound, true, soundSource);
    };
    /**
     * Returns the nominal volume to use for thruster sound effects for this propulsion class (tha actual volume can be set based on the
     * burn level of the thrusters)
     * @returns {Number}
     */
    PropulsionClass.prototype.getThrusterSoundVolume = function () {
        return this._thrusterSound.volume;
    };
    /**
     * Returns the amount of score points to be added to the total score value of spacecrafts that have a propulsion of this class equipped
     * @returns {Number}
     */
    PropulsionClass.prototype.getScoreValue = function () {
        return this._scoreValue;
    };
    // ##############################################################################
    /**
     * @class Each spacecraft can be equipped with a jump engine. This class
     * represents one of the classes to which such an engine can belong, describing
     * the properties of such a jump engine.
     * @augments GenericClass
     * @param {Object} [dataJSON]
     */
    function JumpEngineClass(dataJSON) {
        GenericClass.call(this, dataJSON);
    }
    JumpEngineClass.prototype = new GenericClass();
    JumpEngineClass.prototype.constructor = JumpEngineClass;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    JumpEngineClass.prototype._loadData = function (dataJSON) {
        GenericClass.prototype._loadData.call(this, dataJSON);
        /**
         * The descriptor of the sound effect to be played when a jump engine of this class is engaged. (i.e. computer blips)
         * @type Object
         */
        this._engageSound = dataJSON ? types.getVerifiedObject("JumpEngineClasses['" + this._name + "'].engageSound", dataJSON.engageSound, SOUND_EFFECT) : null;
        /**
         * The descriptor of the sound effect to be played when a jump engine of this class is disengaged. (i.e. computer blips)
         * @type Object
         */
        this._disengageSound = dataJSON ? types.getVerifiedObject("JumpEngineClasses['" + this._name + "'].disengageSound", dataJSON.disengageSound, SOUND_EFFECT) : null;
        /**
         * The forward velocity that should be set as the speed target for the spacecraft for the jump preparation, in m/s.
         * @type Number
         */
        this._prepareVelocity = dataJSON ? ((dataJSON.prepareVelocity !== undefined) ? dataJSON.prepareVelocity : _missingNumber(this, "prepareVelocity")) : 0;
        /**
         * The duration such a jump engine takes to initiate the jump, after eliminating drift vectors, in milliseconds.
         * @type Number
         */
        this._prepareDuration = dataJSON ? ((dataJSON.prepareDuration !== undefined) ? dataJSON.prepareDuration : _missingNumber(this, "prepareDuration")) : 0;
        /**
         * The descriptor of the sound effect to be played when a jump engine of this class is preparing to jump out.
         * @type Object
         */
        this._prepareSound = dataJSON ? types.getVerifiedObject("JumpEngineClasses['" + this._name + "'].prepareSound", dataJSON.prepareSound, SOUND_EFFECT_3D) : null;
        /**
         * The descriptor of the sound effect to be played when the jump preparation is cancelled.
         * @type Object
         */
        this._cancelSound = dataJSON ? types.getVerifiedObject("JumpEngineClasses['" + this._name + "'].cancelSound", dataJSON.cancelSound, SOUND_EFFECT_3D) : null;
        /**
         * The forward acceleration that is added to the spacecraft (by exerting an appropriate force) when initiating a jump out, in m/s.
         * @type Number
         */
        this._jumpOutAcceleration = dataJSON ? (dataJSON.jumpOutAcceleration || _missingNumber(this, "jumpOutAcceleration")) : 0;
        /**
         * The factor by which to stretch the jumping spacecraft along the Y axis at the end of the jump out sequence (linearly increasing from 1.0)
         * @type Number
         */
        this._jumpOutScaling = dataJSON ? (dataJSON.jumpOutScaling || 1) : 0;
        /**
         * The duration of the outward jump itself (from initiating the jump to the particle effect), in milliseconds.
         * @type Number
         */
        this._jumpOutDuration = dataJSON ? (dataJSON.jumpOutDuration || _missingNumber(this, "jumpOutDuration")) : 0;
        /**
         * The descriptor of the sound effect to be played when the outward jump is initiated.
         * @type Object
         */
        this._jumpOutSound = dataJSON ? types.getVerifiedObject("JumpEngineClasses['" + this._name + "'].jumpOutSound", dataJSON.jumpOutSound, SOUND_EFFECT_3D) : null;
        /**
         * The class of the explosion that is created when the jump out is finished.
         * @type ExplosionClass
         */
        this._jumpOutExplosionClass = dataJSON ? (getExplosionClass(dataJSON.jumpOutExplosion || _missingString(this, "jumpOutExplosion")) || application.crash()) : null;
        /**
         * The backward acceleration that is added to the spacecraft (by exerting an appropriate force) when initiating a jump in, in m/s.
         * @type Number
         */
        this._jumpInDeceleration = dataJSON ? (dataJSON.jumpInDeceleration || this._jumpOutAcceleration) : 0;
        /**
         * The forward velocity that should the spacecraft should arrive to at the end of the jump in sequence, in m/s.
         * @type Number
         */
        this._jumpInVelocity = dataJSON ? ((dataJSON.jumpInVelocity !== undefined) ? dataJSON.jumpInVelocity : this._prepareVelocity) : 0;
        /**
         * The factor by which to stretch the jumping spacecraft along the Y axis at the beginning of the jump in sequence (linearly decreasing to 1.0)
         * @type Number
         */
        this._jumpInScaling = dataJSON ? (dataJSON.jumpInScaling || this._jumpOutScaling) : 0;
        /**
         * The duration of the inward jump itself (from the particle effect to arrival), in milliseconds.
         * @type Number
         */
        this._jumpInDuration = dataJSON ? (dataJSON.jumpInDuration || this._jumpOutDuration) : 0;
        /**
         * The descriptor of the sound effect to be played when the inward jump is initiated.
         * @type Object
         */
        this._jumpInSound = dataJSON ? (dataJSON.jumpInSound ? types.getVerifiedObject("JumpEngineClasses['" + this._name + "'].jumpInSound", dataJSON.jumpInSound, SOUND_EFFECT_3D) : this._jumpOutSound) : null;
        /**
         * The class of the explosion that is created at the beginning of the jump in sequence.
         * @type ExplosionClass
         */
        this._jumpInExplosionClass = dataJSON ? (dataJSON.jumpInExplosion ? getExplosionClass(dataJSON.jumpInExplosion) || application.crash() : this._jumpOutExplosionClass) : null;
        return true;
    };
    /**
     * @typedef {Object} JumpEngineClass~ResourceParams
     * @property {Boolean} [sound=false] Whether to load resources for sound effects
     */
    /**
     * Call before resource loading to ensure all resources required for jump engines of this class will be loaded
     * @param {JumpEngineClass~ResourceParams} params 
     */
    JumpEngineClass.prototype.acquireResources = function (params) {
        if (params.sound) {
            _loadSoundEffect(this._engageSound);
            _loadSoundEffect(this._disengageSound);
            _loadSoundEffect(this._prepareSound);
            _loadSoundEffect(this._cancelSound);
            _loadSoundEffect(this._jumpOutSound);
            _loadSoundEffect(this._jumpInSound);
        }
        this._jumpOutExplosionClass.acquireResources({sound: params.sound});
        this._jumpInExplosionClass.acquireResources({sound: params.sound});
    };
    /**
     * Creates a sound clip for the engage sound effect and returns a reference to it.
     * @returns {SoundClip}
     */
    JumpEngineClass.prototype.createEngageSoundClip = function () {
        return _createSoundClip(this._engageSound, false);
    };
    /**
     * Creates a sound clip for the disengage sound effect and returns a reference to it.
     * @returns {SoundClip}
     */
    JumpEngineClass.prototype.createDisengageSoundClip = function () {
        return _createSoundClip(this._disengageSound, false);
    };
    /**
     * @returns {Number}
     */
    JumpEngineClass.prototype.getPrepareVelocity = function () {
        return this._prepareVelocity;
    };
    /**
     * @returns {Number}
     */
    JumpEngineClass.prototype.getPrepareDuration = function () {
        return this._prepareDuration;
    };
    /**
     * Creates a sound clip for the prepare sound effect and returns a reference to it.
     * @param {SoundSource} soundSource The sound source to be used for 3D spatial positioning of the clip
     * @returns {SoundClip}
     */
    JumpEngineClass.prototype.createPrepareSoundClip = function (soundSource) {
        return _createSoundClip(this._prepareSound, false, soundSource);
    };
    /**
     * Creates a sound clip for the cancel sound effect and returns a reference to it.
     * @param {SoundSource} soundSource The sound source to be used for 3D spatial positioning of the clip
     * @returns {SoundClip}
     */
    JumpEngineClass.prototype.createCancelSoundClip = function (soundSource) {
        return _createSoundClip(this._cancelSound, false, soundSource);
    };
    /**
     * @returns {Number}
     */
    JumpEngineClass.prototype.getJumpOutDuration = function () {
        return this._jumpOutDuration;
    };
    /**
     * @returns {Number}
     */
    JumpEngineClass.prototype.getJumpOutAcceleration = function () {
        return this._jumpOutAcceleration;
    };
    /**
     * @returns {Number}
     */
    JumpEngineClass.prototype.getJumpOutScaling = function () {
        return this._jumpOutScaling;
    };
    /**
     * Creates a sound clip for the jump out sound effect and returns a reference to it.
     * @param {SoundSource} soundSource The sound source to be used for 3D spatial positioning of the clip
     * @returns {SoundClip}
     */
    JumpEngineClass.prototype.createJumpOutSoundClip = function (soundSource) {
        return _createSoundClip(this._jumpOutSound, false, soundSource);
    };
    /**
     * 
     * @returns {ExplosionClass}
     */
    JumpEngineClass.prototype.getJumpOutExplosionClass = function () {
        return this._jumpOutExplosionClass;
    };
    /**
     * @returns {Number}
     */
    JumpEngineClass.prototype.getJumpInDuration = function () {
        return this._jumpInDuration;
    };
    /**
     * @returns {Number}
     */
    JumpEngineClass.prototype.getJumpInDeceleration = function () {
        return this._jumpInDeceleration;
    };
    /**
     * @returns {Number}
     */
    JumpEngineClass.prototype.getJumpInVelocity = function () {
        return this._jumpInVelocity;
    };
    /**
     * @returns {Number}
     */
    JumpEngineClass.prototype.getJumpInScaling = function () {
        return this._jumpInScaling;
    };
    /**
     * Creates a sound clip for the jump in sound effect and returns a reference to it.
     * @param {SoundSource} soundSource The sound source to be used for 3D spatial positioning of the clip
     * @returns {SoundClip}
     */
    JumpEngineClass.prototype.createJumpInSoundClip = function (soundSource) {
        return _createSoundClip(this._jumpInSound, false, soundSource);
    };
    /**
     * 
     * @returns {ExplosionClass}
     */
    JumpEngineClass.prototype.getJumpInExplosionClass = function () {
        return this._jumpInExplosionClass;
    };
    // ##############################################################################
    /**
     * @class Each spacecraft can be equipped with a shield. This class
     * represents one of the classes to which such a shield can belong, describing
     * the properties of such a shield.
     * @augments GenericClass
     * @param {Object} [dataJSON]
     */
    function ShieldClass(dataJSON) {
        GenericClass.call(this, dataJSON);
    }
    ShieldClass.prototype = new GenericClass();
    ShieldClass.prototype.constructor = ShieldClass;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    ShieldClass.prototype._loadData = function (dataJSON) {
        GenericClass.prototype._loadData.call(this, dataJSON);
        /**
         * The full name of this class as displayed in the game.
         * @type String
         */
        this._fullName = dataJSON ? (dataJSON.fullName || this.getName()) : null;
        /**
         * The overall maximum capacity (amount of damage absorbed when fully charged)
         * @type Number
         */
        this._capacity = dataJSON ? (dataJSON.capacity || _missingNumber(this, "capacity")) : 0;
        /**
         * The shield starts recharging this much time after it gets hit, in milliseconds.
         * @type Number
         */
        this._rechargeDelay = dataJSON ? ((dataJSON.rechargeDelay !== undefined) ? dataJSON.rechargeDelay : _missingNumber(this, "rechargeDelay")) : 0;
        /**
         * While recharging, the shield regains this much capacity over one second.
         * @type Number
         */
        this._rechargeRate = dataJSON ? (dataJSON.rechargeRate || _missingNumber(this, "rechargeRate")) : 0;
        /**
         * Color of the recharge start animation.
         * @type Number[3]
         */
        this._rechargeColor = dataJSON ? (dataJSON.rechargeColor || [1, 1, 1]) : null;
        /**
         * The duration of the animation displayed at the start of shield recharge.
         * @type Number
         */
        this._rechargeAnimationDuration = dataJSON ? (dataJSON.rechargeAnimationDuration || _missingNumber(this, "rechargeAnimationDuration")) : 0;
        /**
         * The descriptor of the sound effect to be played when a shield of this class starts to recharge.
         * @type Object
         */
        this._rechargeStartSound = dataJSON ? types.getVerifiedObject("ShieldClasses['" + this._name + "'].rechargeStartSound", dataJSON.rechargeStartSound, SOUND_EFFECT_3D) : null;
        /**
         * The amount of score points to be added to the total score value of spacecrafts that have a shield of this class equipped
         * @type Number
         */
        this._scoreValue = dataJSON ? (dataJSON.scoreValue || 0) : 0;
        return true;
    };
    /**
     * @typedef {Object} ShieldClass~ResourceParams
     * @property {Boolean} [sound=false] Whether to load resources for sound effects
     */
    /**
     * Call before resource loading to ensure all resources required for shields of this class will be loaded
     * @param {ShieldClass~ResourceParams} params
     */
    ShieldClass.prototype.acquireResources = function (params) {
        if (params.sound) {
            _loadSoundEffect(this._rechargeStartSound);
        }
    };
    /**
     * @returns {String}
     */
    ShieldClass.prototype.getDisplayName = function () {
        return strings.get(
                strings.SHIELD_CLASS.PREFIX, this.getName() + strings.SHIELD_CLASS.NAME_SUFFIX.name,
                this._fullName);
    };
    /**
     * @returns {Number}
     */
    ShieldClass.prototype.getCapacity = function () {
        return this._capacity;
    };
    /**
     * @returns {Number}
     */
    ShieldClass.prototype.getRechargeDelay = function () {
        return this._rechargeDelay;
    };
    /**
     * @returns {Number}
     */
    ShieldClass.prototype.getRechargeRate = function () {
        return this._rechargeRate;
    };
    /**
     * @returns {Number[3]}
     */
    ShieldClass.prototype.getRechargeColor = function () {
        return this._rechargeColor;
    };
    /**
     * @returns {Number}
     */
    ShieldClass.prototype.getRechargeAnimationDuration = function () {
        return this._rechargeAnimationDuration;
    };
    /**
     * Creates a sound clip for the recharge start sound effect and returns a reference to it.
     * @param {SoundSource} soundSource The sound source to be used for 3D spatial positioning of the clip
     * @returns {SoundClip}
     */
    ShieldClass.prototype.createRechargeStartSoundClip = function (soundSource) {
        return _createSoundClip(this._rechargeStartSound, false, soundSource);
    };
    /**
     * Returns the amount of score points to be added to the total score value of spacecrafts that have a shield of this class equipped
     * @returns {Number}
     */
    ShieldClass.prototype.getScoreValue = function () {
        return this._scoreValue;
    };
    // ##############################################################################
    /**
     * @class A type of spacecraft. This a more general classification of 
     * spacecraft than a class. An example would be shuttle, interceptor, cruiser, 
     * space station or freighter.
     * @param {Object} [dataJSON]
     */
    function SpacecraftType(dataJSON) {
        GenericClass.call(this, dataJSON);
    }
    SpacecraftType.prototype = new GenericClass();
    SpacecraftType.prototype.constructor = SpacecraftType;
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    SpacecraftType.prototype._loadData = function (dataJSON) {
        GenericClass.prototype._loadData.call(this, dataJSON);
        /**
         * @type Boolean
         */
        this._isFighterType = dataJSON ? (dataJSON.isFighterType === true) : false;
        /**
         * The full name of this type as displayed in the game.
         * @type String
         */
        this._fullName = dataJSON ? (dataJSON.fullName || this.getName()) : null;
        /**
         * @type String
         */
        this._description = dataJSON ? ((typeof dataJSON.description) === "string" ? dataJSON.description : _missingString(this, "description")) : null;
        /**
         * @type String[]
         */
        this._goodAgainstTypeNames = dataJSON ? (dataJSON.goodAgainst || []) : null;
        /**
         * @type String[]
         */
        this._badAgainstTypeNames = dataJSON ? (dataJSON.badAgainst || []) : null;
        return true;
    };
    /**
     * @returns {Boolean}
     */
    SpacecraftType.prototype.isFighterType = function () {
        return this._isFighterType;
    };
    /**
     * @returns {String}
     */
    SpacecraftType.prototype.getDisplayName = function () {
        return strings.get(
                strings.SPACECRAFT_TYPE.PREFIX, this.getName() + strings.SPACECRAFT_TYPE.NAME_SUFFIX.name,
                this._fullName);
    };
    /**
     * @returns {String}
     */
    SpacecraftType.prototype.getDisplayDescription = function () {
        return strings.get(
                strings.SPACECRAFT_TYPE.PREFIX, this.getName() + strings.SPACECRAFT_TYPE.DESCRIPTION_SUFFIX.name,
                utils.formatString(strings.get(strings.DATABASE.MISSING_SPACECRAFT_TYPE_DESCRIPTION), {
                    spacecraftType: this.getDisplayName(),
                    originalDescription: this._description
                }));
    };
    /**
     * @returns {SpacecraftType[]}
     */
    SpacecraftType.prototype.getGoodAgainstTypes = function () {
        var i, result;
        result = [];
        for (i = 0; i < this._goodAgainstTypeNames.length; i++) {
            result.push(getSpacecraftType(this._goodAgainstTypeNames[i]));
        }
    };
    /**
     * @returns {SpacecraftType[]}
     */
    SpacecraftType.prototype.getBadAgainstTypes = function () {
        var i, result;
        result = [];
        for (i = 0; i < this._badAgainstTypeNames.length; i++) {
            result.push(getSpacecraftType(this._badAgainstTypeNames[i]));
        }
    };
    /**
     * Returns whether this spacecraft type is supposed to be effective against the passed spacecraft type
     * @param {SpacecraftType} otherType
     * @returns {Boolean}
     */
    SpacecraftType.prototype.isGoodAgainst = function (otherType) {
        return (this._goodAgainstTypeNames.indexOf(otherType.getName()) >= 0);
    };
    /**
     * Returns whether this spacecraft type is supposed to be particularly non-effective against the passed spacecraft type
     * @param {SpacecraftType} otherType
     * @returns {Boolean}
     */
    SpacecraftType.prototype.isBadAgainst = function (otherType) {
        return (this._badAgainstTypeNames.indexOf(otherType.getName()) >= 0);
    };
    // ##############################################################################
    /**
     * @struct Every ship (class) can have several slots where its weapons can be
     * equipped. The weapons are rendered and shot from these slots. This class 
     * represents such a slot.
     * @param {Object} [dataJSON]
     */
    function WeaponSlot(dataJSON) {
        /**
         * The translation matrix for the position of the slot relative to the ship.
         * @type Float32Array
         */
        this.positionMatrix = dataJSON ? (mat.translation4v(dataJSON.position || _missingVector3(this, "position"))) : null;
        /**
         * The rotation matrix describing the orientation of the weapon slot 
         * relative to the ship.
         * @type Float32Array
         */
        this.orientationMatrix = dataJSON ? (mat.rotation4FromJSON(dataJSON.rotations || [])) : null;
    }
    // ##############################################################################
    /**
     * @struct Every ship (class) can have several launchers (with fixed launch 
     * tubes) where its missiles can be equipped and launched from. This struct
     * describes such a launcher.
     * @param {Object} [dataJSON]
     */
    function MissileLauncherDescriptor(dataJSON) {
        var i, j, tube;
        /**
         * The translation vectors for the positions of the tubes of the launcher,
         * relative to the ship.
         * This determines where the currently loaded missile will spawn for 
         * each tube (as well as the total capacity of the launcher, as each tube
         * has the amount of capacity defined for the launcher)
         * @type Array.<Number[3]>
         */
        this.tubePositions = dataJSON ? ((dataJSON.tubes ? [] : _missingArray(this, "tubes"))) : null;
        if (this.tubePositions) {
            for (i = 0; i < dataJSON.tubes.length; i++) {
                tube = dataJSON.tubes[i];
                if (tube.count > 1) {
                    for (j = 0; j < tube.count; j++) {
                        this.tubePositions.push(vec.sum3(tube.position, vec.scaled3Aux(tube.vector, j)));
                    }
                } else {
                    this.tubePositions.push(tube.position);
                }
            }
        }
        /**
         * The rotation matrix describing the orientation of the missile 
         * launcher's tubes (all of them) relative to the ship.
         * @type Float32Array
         */
        this.orientationMatrix = dataJSON ? (mat.rotation4FromJSON(dataJSON.rotations || [])) : null;
        /**
         * (enum MissileSize) The size (i.e. radius category) of missiles that can 
         * be loaded into this launcher.
         * @type String
         */
        this.size = dataJSON ? utils.getSafeEnumValue(MissileSize, dataJSON.size, null) || _missingString(this, "size") : null;
        /**
         * Determines the maximum amout of missiles that can be loaded into a single tube of this launcher.
         * (i.e. the length of a launching tube)
         * Different missile classes can have different amounts of capacity used up by one missile.
         * @type Number
         */
        this.capacity = dataJSON ? (dataJSON.capacity || _missingNumber(this, "capacity")) : 0;
        /**
         * The amount of missiles to launch on one salvo
         * @type Number
         */
        this.salvo = dataJSON ? (dataJSON.salvo || 1) : 0;
    }
    // ##############################################################################
    /**
     * @struct Every ship (class) has slots for its thrusters. The fire of the
     * thrusters is represented by showing particles at these thruster slots with
     * a size proportional to the thruster burn.
     * @param {Object} [dataJSON]
     */
    function ThrusterSlot(dataJSON) {
        /**
         * The coordinates of the position of the slot relative to the ship.
         * @type Number[4]
         */
        this.positionVector = dataJSON ? (dataJSON.position.slice() || _missingVector3(this, "position")) : null;
        if (this.positionVector) {
            this.positionVector.push(1.0);
        }
        /**
         * The thruster particle at this slot will be shown scaled to this size.
         * @type Number
         */
        this.size = dataJSON ? (dataJSON.size || 1.0) : 0;
        /**
         * The list of uses this thruster has. Possible uses are: 
         * (direction:) 
         * forward,reverse,strafeLeft,strafeRight,raise,lower;
         * (turn:)
         * yawLeft,yawRight,pitchUp,pitchDown,rollLeft,rollRight
         * @type String[]
         */
        this.uses = dataJSON ? (dataJSON.uses || _missingArray(this, "uses")) : null;
        /**
         * The index of the thruster group this slot belongs to.
         * Members of the same group should have the same uses list. The parts of the
         * ship model representing thrusters of a group should bear the same group 
         * index, allowing to manipulate their appearance using uniform arrays.
         * @type Number
         */
        this.group = dataJSON ? ((typeof dataJSON.groupIndex) === "number" ? dataJSON.groupIndex : _missingNumber(this, "groupIndex")) : 0;
    }
    // ##############################################################################
    /**
     * @struct A weapon descriptor can be used to equip a weapon on a spacecraft, by
     * describing the parameters of the equipment. (such as ammunition, targeting
     * mechanics)
     * @param {Object} [dataJSON]
     */
    function WeaponDescriptor(dataJSON) {
        /**
         * The name of the class of the weapon to be equipped.
         * @type String
         */
        this.className = dataJSON ? (dataJSON.class || _missingString(this, "class")) : null;
        /**
         * The index of the weapon slot the weapon should be equipped to. (not given or -1 means to equip to the next free slot)
         * @type Number
         */
        this.slotIndex = dataJSON ? dataJSON.slotIndex : -1;
    }
    // ##############################################################################
    /**
     * @struct A missile descriptor can be used to equip missiles on a spacecraft, by
     * describing the parameters of the equipment. (such as amount)
     * @param {Object} [dataJSON]
     */
    function MissileDescriptor(dataJSON) {
        /**
         * The name of the class of the missiles to be equipped.
         * @type String
         */
        this.className = dataJSON ? (dataJSON.class || _missingString(this, "class")) : null;
        /**
         * The index of the missile launcher the missiles should be equipped to.
         * (not given or -1 means to equip into the next free and suitable launcher)
         * @type Number
         */
        this.launcherIndex = dataJSON ? dataJSON.launcherIndex : -1;
        /**
         * The amount of missiles to be equipped
         * @Number
         */
        this.amount = dataJSON ? (dataJSON.amount || _missingNumber(this, "amount")) : 0;
    }
    // ##############################################################################
    /**
     * @struct A propulsion descriptor can be used to equip a propulsion system on a 
     * spacecraft, by describing the parameters of the equipment. (such as fuel, 
     * integrity)
     * @param {Object} [dataJSON]
     */
    function PropulsionDescriptor(dataJSON) {
        /**
         * The name of the class of the propulsion to be equipped.
         * @type String
         */
        this.className = dataJSON ? (dataJSON.class || _missingString(this, "class")) : null;
    }
    // ##############################################################################
    /**
     * @struct A jump engine descriptor can be used to equip a jump engine on a 
     * spacecraft, by describing the parameters of the equipment. 
     * @param {Object} [dataJSON]
     */
    function JumpEngineDescriptor(dataJSON) {
        /**
         * The name of the class of the jump engine to be equipped.
         * @type String
         */
        this.className = dataJSON ? (dataJSON.class || _missingString(this, "class")) : null;
    }
    // ##############################################################################
    /**
     * @struct A shield descriptor can be used to equip a shield on a 
     * spacecraft, by describing the parameters of the equipment. 
     * @param {Object} [dataJSON]
     */
    function ShieldDescriptor(dataJSON) {
        /**
         * The name of the class of the shield to be equipped.
         * @type String
         */
        this.className = dataJSON ? (dataJSON.class || _missingString(this, "class")) : null;
    }
    // ##############################################################################
    /**
     * @class Every ship (class) can have several predefined loadouts, each defining a
     * specific set of equipment. These can then be used to more easily equip the
     * ships, by only referencing the loadout to equip all the different pieces of
     * equipment stored in it.
     * @param {Object} [dataJSON]
     */
    function Loadout(dataJSON) {
        var i;
        /**
         * @type String
         */
        this._name = dataJSON.name || "custom";
        /**
         * The list of descriptors of the weapons in this loadout to be equipped.
         * @type WeaponDescriptor[]
         */
        this._weaponDescriptors = [];
        if (dataJSON.weapons) {
            for (i = 0; i < dataJSON.weapons.length; i++) {
                this._weaponDescriptors.push(new WeaponDescriptor(dataJSON.weapons[i]));
            }
        }
        /**
         * The list of descriptors of the missiles in this loadout to be equipped.
         * @type MissileDescriptor[]
         */
        this._missileDescriptors = [];
        if (dataJSON.missiles) {
            for (i = 0; i < dataJSON.missiles.length; i++) {
                this._missileDescriptors.push(new MissileDescriptor(dataJSON.missiles[i]));
            }
        }
        /**
         * The descriptor of the propulsion system for this loadout to be equipped.
         * @type PropulsionDescriptor
         */
        this._propulsionDescriptor = dataJSON.propulsion ? new PropulsionDescriptor(dataJSON.propulsion) : null;
        /**
         * The descriptor of the jump engine for this loadout to be equipped.
         * @type JumpEngineDescriptor
         */
        this._jumpEngineDescriptor = dataJSON.jumpEngine ? new JumpEngineDescriptor(dataJSON.jumpEngine) : null;
        /**
         * The descriptor of the shield for this loadout to be equipped.
         * @type ShieldDescriptor
         */
        this._shieldDescriptor = dataJSON.shield ? new ShieldDescriptor(dataJSON.shield) : null;
    }
    /**
     * Returns the name of this loadout.
     * @returns {String}
     */
    Loadout.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the list of the descriptors for the weapons to be equipped with this
     * loadout.
     * @returns {WeaponDescriptor[]}
     */
    Loadout.prototype.getWeaponDescriptors = function () {
        return this._weaponDescriptors;
    };
    /**
     * Returns the list of the descriptors for the missiles to be equipped with this
     * loadout.
     * @returns {MissileDescriptor[]}
     */
    Loadout.prototype.getMissileDescriptors = function () {
        return this._missileDescriptors;
    };
    /**
     * Returns the propulsion descriptor of this loadout.
     * @returns {PropulsionDescriptor}
     */
    Loadout.prototype.getPropulsionDescriptor = function () {
        return this._propulsionDescriptor;
    };
    /**
     * Returns the jump engine descriptor of this loadout.
     * @returns {JumpEngineDescriptor}
     */
    Loadout.prototype.getJumpEngineDescriptor = function () {
        return this._jumpEngineDescriptor;
    };
    /**
     * Returns the shield descriptor of this loadout.
     * @returns {ShieldDescriptor}
     */
    Loadout.prototype.getShieldDescriptor = function () {
        return this._shieldDescriptor;
    };
    // ##############################################################################
    /**
     * @class A common superclass for views, that store information to create camera configurations for scenes / objects.
     * @param {Object} [dataJSON] If none give, the properties are initialized to null (to allow subclassing)
     */
    function GenericView(dataJSON) {
        /**
         * A desciptive name for the view, e.g. "cockpit"
         * @type String
         */
        this._name = dataJSON ? (dataJSON.name || _missingString(this, "name")) : null;
        /**
         * Whether turning the view should happen in FPS mode (around axes relative to the followed object / world, and not the camera itself)
         * @type Boolean
         */
        this._fps = dataJSON ? ((typeof dataJSON.fps) === "boolean" ? dataJSON.fps : false) : false;
        /**
         * The initial (horizontal) Field Of View of the view in degrees. If null, the default value will be acquired from the logic module
         * upon the creation of a camera configuration based on this view.
         * @type Number
         */
        this._fov = dataJSON ? (dataJSON.fov || 0) : 0;
        /**
         * The minimum and maximum field of view that this view (camera configurations based on it) can be set to. If null, the default 
         * value will be acquired from the logic module upon the creation of a camera configuration based on this view.
         * @type Number[2]
         */
        this._fovRange = dataJSON ? (dataJSON.fovRange || null) : null;
        /**
         * Whether the position of the view is changeable by the player.
         * @type Boolean
         */
        this._movable = dataJSON ? (dataJSON.movable === true) : false;
        /**
         * Whether the direction of the view is changeable by the player.
         * @type Boolean
         */
        this._turnable = dataJSON ? (dataJSON.turnable === true) : false;
        /**
         * The translation matrix describing the relative position to the object.
         * @type Float32Array
         */
        this._positionMatrix = dataJSON ? (mat.translation4v(dataJSON.position || _missingVector3(this, "position"))) : null;
        /**
         * The rotation matrix describing the relative orientation to the object. 
         * @type Float32Array
         */
        this._orientationMatrix = dataJSON ? mat.rotation4FromJSON(dataJSON.rotations) : null;
        /**
         * The minimum and maximum alpha angle that this view (camera configurations based on it) can be set to, if in FPS-mode, in degrees.
         * @type Number[2]
         */
        this._alphaRange = (dataJSON && this._fps) ? (dataJSON.alphaRange || [-360, 360]) : [0, 0];
        /**
         * The minimum and maximum beta angle that this view (camera configurations based on it) can be set to, if in FPS-mode, in degrees.
         * @type Number[2]
         */
        this._betaRange = (dataJSON && this._fps) ? (dataJSON.betaRange || [-90, 90]) : [0, 0];
        /**
         * The initial (horizontal) span of the view in degrees. Zero value means that a default value should be asked from the logic module
         * upon the creation of a camera configuration.
         * @type Number
         */
        this._span = dataJSON ? (dataJSON.span || 0) : 0;
        /**
         * If given, the movement of the camera using a configuration created based on this view will be limited to the specified ranges on 
         * the 3 axes, respectively. It is possible to specify confinement on select axes only, in which case null should be passed as range 
         * for the other axes.
         * @type Number[3][2]
         */
        this._confines = dataJSON ? (dataJSON.confines || null) : null;
        /**
         * Whether the camera configurations based on these view should reset to defaults whenever their camera leaves their confined area
         * @type Boolean
         */
        this._resetsWhenLeavingConfines = dataJSON ? ((typeof dataJSON.resetsWhenLeavingConfines) === "boolean" ? dataJSON.resetsWhenLeavingConfines : false) : false;
        /**
         * (enum CameraOrientationConfiguration.BaseOrientation) The base orientation for FPS-mode views, the axes of which will be used 
         * for turning around. If null, the default setting will be acquired from the logic module upon the creation of a camera configuration
         * based on this view.
         * @type String 
         */
        this._baseOrientation = dataJSON ? (dataJSON.baseOrientation ?
                (utils.getSafeEnumValue(camera.CameraOrientationConfiguration.BaseOrientation, dataJSON.baseOrientation) ||
                        application.showError(
                                "Invalid value '" + dataJSON.baseOrientation + "' specified for view baseOrientation!",
                                application.ErrorSeverity.MINOR,
                                "Valid values are: " + utils.getEnumValues(camera.CameraOrientationConfiguration.BaseOrientation).join(", ") + ".")) :
                null) : null;
        /**
         * (enum CameraOrientationConfiguration.PointToFallback) The basis of orientation calculation if the view is set to "look at" mode,
         * but the object to look at has been destroyed. If null, the default setting will be acquired from the logic module upon the creation of a 
         * camera configuration based on this view.
         * @type String
         */
        this._pointToFallback = dataJSON ? (dataJSON.pointToFallback ?
                (utils.getSafeEnumValue(camera.CameraOrientationConfiguration.PointToFallback, dataJSON.pointToFallback) ||
                        application.showError(
                                "Invalid value '" + dataJSON.pointToFallback + "' specified for view pointToFallback!",
                                application.ErrorSeverity.MINOR,
                                "Valid values are: " + utils.getEnumValues(camera.CameraOrientationConfiguration.PointToFallback).join(", ") + ".")) :
                null) : null;
        /**
         * When true, this view should be skipped when switching between views using cycling (switching to next / previous views), and should
         * only be possible to invoke it by switching to it explicitly
         * @type Boolean
         */
        this._excludeFromCycle = dataJSON ? ((typeof dataJSON.excludeFromCycle) === "boolean" ? dataJSON.excludeFromCycle : false) : false;
    }
    /**
     * @returns {String}
     */
    GenericView.prototype.getName = function () {
        return this._name;
    };
    /**
     * @returns {Boolean}
     */
    GenericView.prototype.isFPS = function () {
        return this._fps;
    };
    /**
     * @returns {Number}
     */
    GenericView.prototype.getFOV = function () {
        return this._fov;
    };
    /**
     * @returns {Number[2]|null}
     */
    GenericView.prototype.getFOVRange = function () {
        return this._fovRange;
    };
    /**
     * @returns {Number}
     */
    GenericView.prototype.getSpan = function () {
        return this._span;
    };
    /**
     * @returns {Boolean}
     */
    GenericView.prototype.isMovable = function () {
        return this._movable;
    };
    /**
     * @returns {Boolean}
     */
    GenericView.prototype.isTurnable = function () {
        return this._turnable;
    };
    /**
     * @returns {Float32Array}
     */
    GenericView.prototype.getPositionMatrix = function () {
        return this._positionMatrix;
    };
    /**
     * @returns {Float32Array}
     */
    GenericView.prototype.getOrientationMatrix = function () {
        return this._orientationMatrix;
    };
    /**
     * @returns {Number[2]}
     */
    GenericView.prototype.getAlphaRange = function () {
        return this._alphaRange;
    };
    /**
     * @returns {Number[2]}
     */
    GenericView.prototype.getBetaRange = function () {
        return this._betaRange;
    };
    /**
     * @returns {Number[3][2]|null}
     */
    GenericView.prototype.getConfines = function () {
        return this._confines;
    };
    /**
     * @returns {Boolean}
     */
    GenericView.prototype.resetsWhenLeavingConfines = function () {
        return this._resetsWhenLeavingConfines;
    };
    /**
     * (enum CameraOrientationConfiguration.BaseOrientation)
     * @returns {String}
     */
    GenericView.prototype.getBaseOrientation = function () {
        return this._baseOrientation;
    };
    /**
     * (enum CameraOrientationConfiguration.PointToFallback)
     * @returns {String}
     */
    GenericView.prototype.getPointToFallback = function () {
        return this._pointToFallback;
    };
    /**
     * @returns {Boolean}
     */
    GenericView.prototype.shouldExcludeFromCycle = function () {
        return this._excludeFromCycle;
    };
    /*
     * Removes all references from the object
     */
    GenericView.prototype.destroy = function () {
        this._fovRange = null;
        this._positionMatrix = null;
        this._orientationMatrix = null;
        this._alphaRange = null;
        this._betaRange = null;
        this._confines = null;
    };
    // ##############################################################################
    /**
     * @class Describes the parameters of a certain view of an object, based on which a camera can be created if that object is deployed in 
     * a scene.
     * @extends GenericView
     * @param {Object} dataJSON
     */
    function ObjectView(dataJSON) {
        var lookAt;
        GenericView.call(this, dataJSON);
        lookAt = utils.getSafeEnumValue(ObjectViewLookAtMode, dataJSON.lookAt, ObjectViewLookAtMode.NONE);
        /**
         * Whether this view is an aiming view, meaning it points towards the same direction as the weapons of the followed object (spacecraft).
         * @type Boolean
         */
        this._isAimingView = dataJSON.aimingView === true;
        /**
         * Whether the position of the view should follow the position of the object it is associated with (making the set position relative
         * to it)
         * @type Boolean
         */
        this._followsPosition = (dataJSON.followsPosition !== undefined) ? dataJSON.followsPosition : (lookAt !== ObjectViewLookAtMode.SELF);
        /**
         * Whether the orienration of the view should follow the orientation of the object it is associated with (making the set orientation relative
         * to it). It defaults to true, however, the default changes to false if a lookAt mode is set.
         * @type Boolean
         */
        this._followsOrientation = (dataJSON.followsOrientation !== undefined) ? dataJSON.followsOrientation : (lookAt === ObjectViewLookAtMode.NONE);
        /**
         * Whether the view's orientation should always be centered on the associated object
         * @type Boolean
         */
        this._lookAtSelf = (lookAt === ObjectViewLookAtMode.SELF) ?
                ((this._followsPosition || this._followsOrientation || this._turnable) ?
                        application.showError("Invalid view configuration ('" + this._name + "'): lookAt mode cannot be 'self' if followsPosition, followsOrientation or turnable are true!") :
                        true) :
                false;
        /**
         * Whether the view's orientation should always be centered on the target of the associated object
         * @type Boolean
         */
        this._lookAtTarget = (lookAt === ObjectViewLookAtMode.TARGET) ?
                ((this._followsOrientation || this._turnable) ?
                        application.showError("Invalid view configuration ('" + this._name + "'): lookAt mode cannot be 'target' if followsOrientation or turnable are true!") :
                        true) :
                false;
        /**
         * Whether the rotation of the camera has to be executed around the followed object.
         * @type Boolean
         */
        this._rotationCenterIsObject = (typeof dataJSON.rotationCenterIsObject) === "boolean" ?
                (dataJSON.rotationCenterIsObject ?
                        ((this._lookAtSelf || !this._followsPosition) ?
                                application.showError("Invalid view configuration ('" + this._name + "'): rotationCenterIsObject with lookAtSelf or without followsPosition!") :
                                true) :
                        false) :
                false;
        /**
         * Whether instead of continuously following the object's position, it should only be considered when creating or resetting a camera
         * configuration, and the configuration should have absolute position afterwards
         * @type Boolean
         */
        this._startsWithRelativePosition = (dataJSON.startsWithRelativePosition === true) ?
                ((this._followsPosition || this._rotationCenterIsObject) ?
                        application.showError("Invalid view configuration ('" + this._name + "'): startsWithRelativePosition cannot be set to true if followsPosition or rotationCenterIsObject are true!") :
                        true) :
                false;
        /**
         * The minimum and maximum distance this view can be moved to from the object it turns around.
         * @type Number[2]
         */
        this._distanceRange = ((this._rotationCenterIsObject || this._lookAtSelf || this._lookAtTarget) && this._movable) ?
                (dataJSON.distanceRange || _missingVector2(this, "distanceRange")) :
                (dataJSON.distanceRange || null);
        /**
         * Whether movement of the camera should happen along the axes of the followed object instead of its own
         * @type Boolean
         */
        this._movesRelativeToObject = (dataJSON.movesRelativeToObject === true) ?
                ((this._rotationCenterIsObject || !this._followsPosition || !this._followsOrientation) ?
                        application.showError("Invalid view configuration ('" + this._name + "'): movesRelativeToObject can only be set if both position and orientation is followed and rotationCenterIsObject is false!") :
                        true) :
                false;
        /**
         * An indicator whether this view should reset to default state when the camera controls are not in focus anymore (after being in focus)
         * @type Boolean
         */
        this._resetsOnFocusChange = (typeof dataJSON.resetsOnFocusChange) === "boolean" ? dataJSON.resetsOnFocusChange : false;
        // further invalid configuration errors
        if (!this._followsPosition && !this._startsWithRelativePosition && (this._lookAtSelf || this._lookAtTarget) && this._confines && this._distanceRange) {
            application.showError(
                    "Invalid view configuration ('" + this._name + "'): A lookAt configuration with absolute position cannot have both position and distance confines!",
                    application.ErrorSeverity.SEVERE,
                    "Setting this configuration will likely cause a crash as position confines are absolute (if the position is absolute) but distance confines are relative to the lookAt object.");
        }
        if (!this._followsPosition && !this._startsWithRelativePosition && this._resetsWhenLeavingConfines) {
            application.showError("Invalid view configuration ('" + this._name + "'): resetsWhenLeavingConfines cannot be set if position is absolute!");
        }
    }
    ObjectView.prototype = new GenericView();
    ObjectView.prototype.constructor = ObjectView;
    /**
     * @returns {Boolean}
     */
    ObjectView.prototype.isAimingView = function () {
        return this._isAimingView;
    };
    /**
     * @returns {Boolean}
     */
    ObjectView.prototype.turnsAroundObjects = function () {
        return this._rotationCenterIsObject;
    };
    /**
     * @returns {Boolean}
     */
    ObjectView.prototype.movesRelativeToObject = function () {
        return this._movesRelativeToObject;
    };
    /**
     * @param {Object3D} followedObject
     * @returns {Object3D[]}
     */
    ObjectView.prototype.getPositionFollowedObjectsForObject = function (followedObject) {
        return (this._followsPosition || this._startsWithRelativePosition) ? [followedObject] : [];
    };
    /**
     * @returns {Boolean}
     */
    ObjectView.prototype.startsWithRelativePosition = function () {
        return this._startsWithRelativePosition;
    };
    /**
     * @returns {Number[2]|null}
     */
    ObjectView.prototype.getDistanceRange = function () {
        return this._distanceRange;
    };
    /**
     * @returns {Boolean}
     */
    ObjectView.prototype.pointsTowardsObjects = function () {
        return this._lookAtSelf || this._lookAtTarget;
    };
    /**
     * @param {Object3D} followedObject
     * @returns {Object3D[]}
     */
    ObjectView.prototype.getOrientationFollowedObjectsForObject = function (followedObject) {
        return (this._lookAtSelf || this._followsOrientation) ? [followedObject] : [];
    };
    /**
     * @returns {Boolean}
     */
    ObjectView.prototype.resetsOnFocusChange = function () {
        return this._resetsOnFocusChange;
    };
    /**
     * Creates and returns a camera configuration set up for following the passed object according to the view's parameters.
     * Specify the default values to use for those settings which are not obligatory to set for views!
     * The configuration module stores values for these defaults, but that module itself builds on the classes module.
     * For specific game objects (e.g. Spacecrafts), use the method of that object that will create the camera 
     * configuration with the proper defaults.
     * @param {RenderableObject3D} model
     * @param {String} defaultCameraBaseOrientation (enum CameraOrientationConfiguration.BaseOrientation)
     * @param {String} defaultCameraPointToFallback (enum CameraOrientationConfiguration.PointToFallback)
     * @param {Number} defaultFOV
     * @param {Number} defaultSpan
     * @returns {CameraConfiguration} The created camera configuration.
     */
    ObjectView.prototype.createCameraConfiguration = function (model, defaultCameraBaseOrientation,
            defaultCameraPointToFallback, defaultFOV, defaultSpan) {
        var positionConfiguration, orientationConfiguration, angles = mat.getYawAndPitch(this.getOrientationMatrix());
        positionConfiguration = new camera.CameraPositionConfiguration(
                !this.isMovable(),
                this.turnsAroundObjects(),
                this.movesRelativeToObject(),
                this.getPositionFollowedObjectsForObject(model),
                this.startsWithRelativePosition(),
                mat.matrix4(this.getPositionMatrix()),
                this.getDistanceRange(),
                this.getConfines(),
                this.resetsWhenLeavingConfines());
        orientationConfiguration = new camera.CameraOrientationConfiguration(
                !this.isTurnable(),
                this.pointsTowardsObjects(),
                this.isFPS(),
                this.getOrientationFollowedObjectsForObject(model),
                mat.matrix4(this.getOrientationMatrix()),
                Math.degrees(angles.yaw), Math.degrees(angles.pitch),
                this.getAlphaRange(),
                this.getBetaRange(),
                this.getBaseOrientation() || defaultCameraBaseOrientation,
                this.getPointToFallback() || defaultCameraPointToFallback);
        return new camera.CameraConfiguration(
                this.getName(),
                positionConfiguration, orientationConfiguration,
                this.getFOV() || defaultFOV,
                this.getFOVRange(),
                this.getSpan() || defaultSpan,
                this.resetsOnFocusChange(),
                this.shouldExcludeFromCycle());
    };
    /**
     * @override
     */
    ObjectView.prototype.destroy = function () {
        GenericView.prototype.destroy.call(this);
        this._distanceRange = null;
    };
    // ##############################################################################
    /**
     * @class Describes the parameters of a certain view of a scene, based on which a camera configuration can be created and added to the
     * scene
     * @extends GenericView
     * @param {Object} dataJSON The JSON object containing the properties of this view to initialize from.
     */
    function SceneView(dataJSON) {
        GenericView.call(this, dataJSON);
        /**
         * Whether the object orientation should always point towards the center of all objects in the scene
         * @type Boolean
         */
        this._turnAroundAll = (typeof dataJSON.turnAroundAll) === "boolean" ? dataJSON.turnAroundAll : false;
        /**
         * Whether the view's orientation should always be centered on the average position of all objects in the scene
         * @type Boolean
         */
        this._lookAtAll = (utils.getSafeEnumValue(SceneViewLookAtMode, dataJSON.lookAt, SceneViewLookAtMode.NONE) === SceneViewLookAtMode.ALL) ?
                ((this._turnAroundAll || this._turnable) ?
                        application.showError("Invalid view configuration ('" + this._name + "'): lookAt mode cannot be 'all' if turnAroundAll or turnable are true!") :
                        true) :
                false;
        /**
         * The minimum and maximum distance this view can be moved to from the objects it turns around.
         * @type Number[2]
         */
        this._distanceRange = ((this._turnAroundAll || this._lookAtAll) && this._movable) ? (dataJSON.distanceRange || _missingVector2(this, "distanceRange")) : (dataJSON.distanceRange || null);
        /**
         * Whether instead of continuously following the object's position, it should only be considered when creating or resetting a camera
         * configuration, and the configuration should have absolute position afterwards
         * @type Boolean
         */
        this._startsWithRelativePosition = (dataJSON.startsWithRelativePosition === true) ?
                (this._turnAroundAll ?
                        application.showError("Invalid view configuration ('" + this._name + "'): startsWithRelativePosition cannot be true if the view is set to turn around the objects!") :
                        true) :
                false;
        // further invalid configuration errors
        if (!this._turnAroundAll && !this._startsWithRelativePosition && this._lookAtAll && this._confines && this._distanceRange) {
            application.showError(
                    "Invalid view configuration ('" + this._name + "'): A lookAt configuration with absolute position cannot have both position and distance confines!",
                    application.ErrorSeverity.SEVERE,
                    "Setting this configuration will likely cause a crash as position confines are absolute (if the position is absolute) but distance confines are relative to the lookAt object.");
        }
        if (!this._turnAroundAll && !this._startsWithRelativePosition && this._resetsWhenLeavingConfines) {
            application.showError("Invalid view configuration ('" + this._name + "'): resetsWhenLeavingConfines cannot be set if position is absolute!");
        }
    }
    SceneView.prototype = new GenericView();
    SceneView.prototype.constructor = SceneView;
    /**
     * @returns {Boolean}
     */
    SceneView.prototype.turnsAroundObjects = function () {
        return this._turnAroundAll;
    };
    /**
     * @returns {Boolean}
     */
    SceneView.prototype.movesRelativeToObject = function () {
        return false;
    };
    /**
     * @param {Scene} scene
     * @returns {Object3D[]}
     */
    SceneView.prototype.getPositionFollowedObjectsForScene = function (scene) {
        return this._turnAroundAll || this._startsWithRelativePosition ? scene.getAll3DObjects() : [];
    };
    /**
     * @returns {Boolean}
     */
    SceneView.prototype.startsWithRelativePosition = function () {
        return this._startsWithRelativePosition;
    };
    /**
     * @returns {Number[2]|null}
     */
    SceneView.prototype.getDistanceRange = function () {
        return this._distanceRange;
    };
    /**
     * @returns {Boolean}
     */
    SceneView.prototype.pointsTowardsObjects = function () {
        return this._lookAtAll;
    };
    /**
     * @param {Scene} scene
     * @returns {Object3D[]}
     */
    SceneView.prototype.getOrientationFollowedObjectsForScene = function (scene) {
        return this._lookAtAll ? scene.getAll3DObjects() : [];
    };
    /**
     * @returns {Boolean}
     */
    SceneView.prototype.resetsOnFocusChange = function () {
        return false;
    };
    /**
     * @override
     */
    SceneView.prototype.destroy = function () {
        GenericView.prototype.destroy.call(this);
        this._distanceRange = null;
    };
    // ##############################################################################
    /**
     * @struct Damage indicators are explosions or fires that are created on a spacecraft
     * when its hitpoints fall below a certain level.
     * This struct holds the information necessary to create one such indicator.
     * Each spacecraft has a list of these.
     * @param {Object} dataJSON The JSON object that hold the data of this indicator to be loaded.
     */
    function DamageIndicator(dataJSON) {
        /**
         * The amount of hull integrity below which this indicator should be presented. (percentage)
         * @type Number
         */
        this.hullIntegrity = dataJSON ? (dataJSON.hullIntegrity || _missingNumber(this, "hullIntegrity")) : 0;
        /**
         * The class of the explosion that should be created to display this indicator.
         * @type ExplosionClass
         */
        this.explosionClass = dataJSON ? (getExplosionClass(dataJSON.class || _missingString(this, "class")) || application.crash()) : null;
    }
    /**
     * @struct Describes the properties of a light source based on which an actual light source object can be added to a scene.
     * (simple of spot point-like light source)
     * @param {Object} dataJSON Th object holdin the values of the properties
     */
    function LightSourceDescriptor(dataJSON) {
        /**
         * @type Number[3]
         */
        this.position = dataJSON ? (dataJSON.position || _missingVector3(this, "position")) : null;
        /**
         * @type Number[3]
         */
        this.color = dataJSON ? (dataJSON.color || [1, 1, 1]) : null;
        /**
         * @type Number
         */
        this.intensity = dataJSON ? (dataJSON.intensity || _missingNumber(this, "intensity")) : 0;
        // spot light properties are optional
        /**
         * @type Number[3]
         */
        this.spotDirection = dataJSON ? (dataJSON.spotDirection || null) : null;
        /**
         * @type Number
         */
        this.spotCutoffAngle = dataJSON ? (dataJSON.spotCutoffAngle || 0) : 0;
        /**
         * @type Number
         */
        this.spotFullIntensityAngle = dataJSON ? (dataJSON.spotFullIntensityAngle || 0) : 0;
    }
    /**
     * @class Stores the information about a "blinker": a lamp giving a binking light on a spacecraft. It is simulated by the combination of
     * a dynamic particle and a point-like light source.
     * @param {Object} dataJSON The object to load the properties from.
     */
    function BlinkerDescriptor(dataJSON) {
        /**
         * The descriptor for the particle that will be used for the blinking light effect. The states of the particle will be automatically
         * calculated, here (only) the maximum size needs to be set.
         * @type ParticleDescriptor
         */
        this._particle = null;
        if (dataJSON.particle) {
            this._particle = new ParticleDescriptor(dataJSON.particle);
        } else {
            _showMissingPropertyError(this, "particle");
        }
        /**
         * The relative position on the spacecraft.
         * @type Number[3]
         */
        this._position = dataJSON ? (dataJSON.position || _missingVector3(this, "position")) : null;
        /**
         * The duration of one cycle that keeps repeating, in milliseconds.
         * @type Number
         */
        this._period = dataJSON ? (dataJSON.period || _missingNumber(this, "period")) : 0;
        /**
         * Within one cycle, there can be several blinks, that starting times of which are stored in this array.
         * @type Number[]
         */
        this._blinks = dataJSON ? (dataJSON.blinks || _missingArray(this, "blinks")) : null;
        /**
         * The intensity of the light emitted by the associated light source. If zero, there will be no light source added for this blinker.
         * @type Number
         */
        this._intensity = dataJSON ? (dataJSON.intensity || _missingNumber(this, "intensity")) : 0;
        /**
         * The particle color needs an alpha component but the light color does not
         * @type Number[3]
         */
        this._lightColor = this._particle ? [
            this._particle.getColor()[0],
            this._particle.getColor()[1],
            this._particle.getColor()[2]
        ] : null;
    }
    /**
     * Marks the resources needed to render this blinking light for loading.
     */
    BlinkerDescriptor.prototype.acquireResources = function () {
        this._particle.acquireResources();
    };
    /**
     * @returns {ParticleDescriptor}
     */
    BlinkerDescriptor.prototype.getParticle = function () {
        return this._particle;
    };
    /**
     * @returns {Number[3]}
     */
    BlinkerDescriptor.prototype.getPosition = function () {
        return this._position;
    };
    /**
     * @returns {Number}
     */
    BlinkerDescriptor.prototype.getPeriod = function () {
        return this._period;
    };
    /**
     * @returns {Number}
     */
    BlinkerDescriptor.prototype.getIntensity = function () {
        return this._intensity;
    };
    /**
     * Returns the color to be used for the light source.
     * @returns {Number[3]}
     */
    BlinkerDescriptor.prototype.getLightColor = function () {
        return this._lightColor;
    };
    /**
     * Calculated and returns the particle state list to be applied for particles representing this blinking light.
     * @returns {ParticleState[]}
     */
    BlinkerDescriptor.prototype.getParticleStates = function () {
        var i, time = 0, result = [];
        if (this._blinks.length > 0) {
            if (this._blinks[0] > 0) {
                result.push(new renderableObjects.ParticleState(this._particle.getColor(), 0, 0));
                result.push(new renderableObjects.ParticleState(this._particle.getColor(), 0, this._blinks[0]));
            }
            for (i = 0; i < this._blinks.length; i++) {
                result.push(new renderableObjects.ParticleState(this._particle.getColor(), this._particle.getSize(), 0));
                result.push(new renderableObjects.ParticleState(this._particle.getColor(), 0, this._particle.getDuration()));
                time = this._blinks[i] + this._particle.getDuration();
                result.push(new renderableObjects.ParticleState(this._particle.getColor(), 0, (i < (this._blinks.length - 1)) ? (this._blinks[i + 1] - time) : (this._period - time)));
            }
        } else {
            result.push(new renderableObjects.ParticleState(this._particle.getColor(), this._particle.getSize(), 0));
        }
        return result;
    };
    /**
     * Calculated and returns the light state list to be applied for light sources representing this blinking light.
     * @returns {PointLightSource~LightState[]}
     */
    BlinkerDescriptor.prototype.getLightStates = function () {
        var i, time = 0, result = [];
        if (this._blinks.length > 0) {
            if (this._blinks[0] > 0) {
                result.push({
                    color: this.getLightColor(),
                    intensity: 0,
                    timeToReach: 0
                });
                result.push({
                    color: this.getLightColor(),
                    intensity: 0,
                    timeToReach: this._blinks[0]
                });
            }
            for (i = 0; i < this._blinks.length; i++) {
                result.push({
                    color: this.getLightColor(),
                    intensity: this._intensity,
                    timeToReach: 0
                });
                result.push({
                    color: this.getLightColor(),
                    intensity: 0,
                    timeToReach: this._particle.getDuration()
                });
                time = this._blinks[i] + this._particle.getDuration();
                result.push({
                    color: this.getLightColor(),
                    intensity: 0,
                    timeToReach: (i < (this._blinks.length - 1)) ? (this._blinks[i + 1] - time) : (this._period - time)
                });
            }
        } else {
            result.push({
                color: this.getLightColor(),
                intensity: this._intensity,
                timeToReach: 0
            });
        }
        return result;
    };
    /**
     * @override
     * Updates the properties for the case when the graphics settings have been changed.
     */
    BlinkerDescriptor.prototype.handleGraphicsSettingsChanged = function () {
        this._particle.handleGraphicsSettingsChanged();
    };
    // ##############################################################################
    /**
     * @class A spacecraft, such as a shuttle, fighter, bomber, destroyer, a trade 
     * ship or a space station all belong to a certain class that determines their
     * general properties such as appearance, mass and so on. This class represent
     * such a spacecraft class.
     * @augments TexturedModelClass
     * @param {Object} [dataJSON]
     */
    function SpacecraftClass(dataJSON) {
        TexturedModelClass.call(this, dataJSON);
    }
    SpacecraftClass.prototype = new TexturedModelClass();
    SpacecraftClass.prototype.constructor = SpacecraftClass;
    /**
     * @override
     * @param {SpacecraftClass} otherSpacecraftClass
     * @param {Object} dataJSON 
     */
    SpacecraftClass.prototype._overrideData = function (otherSpacecraftClass, dataJSON) {
        var i, j, startPosition, translationVector, rotations, count, angles;
        TexturedModelClass.prototype._overrideData.call(this, otherSpacecraftClass, dataJSON);
        /**
         * The type of spacecraft this class belongs to.
         * @type SpacecraftType
         */
        this._spacecraftType = otherSpacecraftClass ?
                (dataJSON.type ? getSpacecraftType(dataJSON.type) : otherSpacecraftClass._spacecraftType) :
                getSpacecraftType(dataJSON.type || _missingString(this, "type"));
        /**
         * The full name of this class as displayed in the game.
         * @type String
         */
        this._fullName = otherSpacecraftClass ?
                (dataJSON.fullName || otherSpacecraftClass._fullName) :
                (dataJSON.fullName || this.getName());
        /**
         * Whether this spacecraft class should show up in the database
         * @type Boolean
         */
        this._showInDatabase = otherSpacecraftClass ?
                (((typeof dataJSON.showInDatabase) === "boolean") ? dataJSON.showInDatabase : otherSpacecraftClass._showInDatabase) :
                (((typeof dataJSON.showInDatabase) === "boolean") ? dataJSON.showInDatabase : true);
        /**
         * The description of this class as can be viewed in the game.
         * @type String
         */
        this._description = otherSpacecraftClass ?
                (dataJSON.description || otherSpacecraftClass._description) :
                (dataJSON.description || (this._showInDatabase ? _missingString(this, "description") : ""));
        /**
         * The amount of damage a ship of this class can take before being destroyed.
         * @type Number
         */
        this._hitpoints = otherSpacecraftClass ?
                (dataJSON.hitpoints || otherSpacecraftClass._hitpoints) :
                (dataJSON.hitpoints || _missingNumber(this, "hitpoints"));
        /**
         * The thickness of the armor of this spacecraft, which is subtracted from the damage every time the spacecraft is hit.
         * @type Number
         */
        this._armor = ((typeof dataJSON.armor) === "number") ? dataJSON.armor :
                (otherSpacecraftClass ? otherSpacecraftClass._armor : 0);
        /**
         * The color stored in the spacecraft model that corresponds to the faction color (and is to be replaced by the actual faction color
         * of the teams spacecrafts of this class belong to)
         * @type Number[4]
         */
        this._factionColor = otherSpacecraftClass ?
                (dataJSON.factionColor || otherSpacecraftClass._factionColor) :
                (dataJSON.factionColor || null);
        /**
         * When controlled by the AI, the spacecraft should orient itself into specific position using this turning style.
         * (enum SpacecraftTurnStyle)
         * @type String
         */
        this._turnStyle = dataJSON.turnStyle ? utils.getSafeEnumValue(SpacecraftTurnStyle, dataJSON.turnStyle, SpacecraftTurnStyle.YAW_PITCH) :
                (otherSpacecraftClass ?
                        otherSpacecraftClass._turnStyle : SpacecraftTurnStyle.YAW_PITCH);
        /**
         * When controlled by the AI and attacking another spacecraft, the ship should orient itself so that this vector (relative to the 
         * ship) points roughly towards the enemy craft (the angle between this vector and the vector pointing towards the enemy has a 
         * specified maximum, see below)
         * @type Number[3]
         */
        this._attackVector = dataJSON.attackVector ? vec.normal3(dataJSON.attackVector) : (otherSpacecraftClass ? otherSpacecraftClass._attackVector : [0, 1, 0]);
        /**
         * Precalculated values of the angles corresponding to the attack vector of the spacecraft, according to its turning style.
         * In radians, relative to positive Y.
         * @type Number[2]
         */
        this._attackVectorAngles = [0, 0];
        switch (this._turnStyle) {
            case SpacecraftTurnStyle.YAW_PITCH:
                angles = vec.getYawAndPitch(this._attackVector);
                this._attackVectorAngles[0] = angles.yaw;
                this._attackVectorAngles[1] = angles.pitch;
                break;
            case SpacecraftTurnStyle.ROLL_YAW:
                angles = vec.getRollAndYaw(this._attackVector);
                this._attackVectorAngles[0] = angles.roll;
                this._attackVectorAngles[1] = angles.yaw;
                break;
            case SpacecraftTurnStyle.ROLL_PITCH:
                angles = vec.getRollAndPitch(this._attackVector);
                this._attackVectorAngles[0] = angles.roll;
                this._attackVectorAngles[1] = angles.pitch;
                break;
            default:
                application.crash();
        }
        /**
         * When controlled by the AI and attacking another spacecraft, the angles between the attack vector of this ship and the vector
         * pointing towards the enemy craft should be within these limit. The turning style of the craft determines how to calculate the
         * angles. In radians.
         * @type Number
         */
        this._attackThresholdAngle = Math.radians(dataJSON.attackThresholdAngle) || (otherSpacecraftClass ? otherSpacecraftClass._attackThresholdAngle : 0);
        /**
         * The mass of the spacecraft in kilograms.
         * @type Number
         */
        this._mass = otherSpacecraftClass ?
                (dataJSON.mass || otherSpacecraftClass._mass) :
                (dataJSON.mass || _missingNumber(this, "mass"));
        /**
         * If there is drag in the environment, its effect on this spacecraft will be multiplied by this factor
         * @type Number
         */
        this._dragFactor = otherSpacecraftClass ?
                ((dataJSON.dragFactor !== undefined) ? dataJSON.dragFactor : otherSpacecraftClass._dragFactor) :
                ((dataJSON.dragFactor !== undefined) ? dataJSON.dragFactor : 1);
        /**
         * The physical bodies that model the spacecraft's shape for hit checks.
         * @type Body[]
         */
        this._bodies = (otherSpacecraftClass && !dataJSON.bodies) ? otherSpacecraftClass._bodies : [];
        if (dataJSON.bodies) {
            for (i = 0; i < dataJSON.bodies.length; i++) {
                this._bodies.push(new physics.Body(
                        mat.translation4v(dataJSON.bodies[i].position || _missingVector3(this, "bodies[i].position")),
                        mat.rotation4FromJSON(dataJSON.bodies[i].rotations),
                        dataJSON.bodies[i].size));
            }
        } else if (!otherSpacecraftClass) {
            _showMissingPropertyError(this, "bodies");
        }
        /**
         * The slots where weapons can be equipped on the ship.
         * @type WeaponSlot[]
         */
        this._weaponSlots = (otherSpacecraftClass && !dataJSON.weaponSlots) ? otherSpacecraftClass._weaponSlots : [];
        if (dataJSON.weaponSlots) {
            for (i = 0; i < dataJSON.weaponSlots.length; i++) {
                if (dataJSON.weaponSlots[i].count > 1) {
                    startPosition = dataJSON.weaponSlots[i].position || _missingVector3(this, "weaponSlot array position");
                    translationVector = dataJSON.weaponSlots[i].vector || _missingVector3(this, "weaponSlot array vector");
                    rotations = dataJSON.weaponSlots[i].rotations;
                    count = dataJSON.weaponSlots[i].count;
                    for (j = 0; j < count; j++) {
                        this._weaponSlots.push(new WeaponSlot({
                            position: vec.sum3(startPosition, vec.scaled3(translationVector, j)),
                            rotations: rotations
                        }));
                    }
                } else {
                    this._weaponSlots.push(new WeaponSlot(dataJSON.weaponSlots[i]));
                }
            }
        }
        /**
         * The fixed tube missile launchers where missiles can be equipped on the ship.
         * @type MissileLauncherDescriptor[]
         */
        this._missileLaunchers = (otherSpacecraftClass && !dataJSON.missileLaunchers) ? otherSpacecraftClass._missileLaunchers : [];
        if (dataJSON.missileLaunchers) {
            for (i = 0; i < dataJSON.missileLaunchers.length; i++) {
                this._missileLaunchers.push(new MissileLauncherDescriptor(dataJSON.missileLaunchers[i]));
            }
        }
        /**
         * The slots where the thrusters are located on the ship.
         * @type ThrusterSlot[]
         */
        this._thrusterSlots = (otherSpacecraftClass && !dataJSON.thrusterSlots) ? otherSpacecraftClass._thrusterSlots : [];
        if (dataJSON.thrusterSlots) {
            _loadThrusterSlots(dataJSON, this, this._thrusterSlots);
        }
        /**
         * The available views of the ship (e.g. front, cockpit) where cameras can
         * be positioned.
         * @type ObjectView[]
         */
        this._views = (otherSpacecraftClass && !dataJSON.views) ? otherSpacecraftClass._views : [];
        if (dataJSON.views) {
            for (i = 0; i < dataJSON.views.length; i++) {
                this._views.push(new ObjectView(dataJSON.views[i]));
            }
        } else if (!otherSpacecraftClass) {
            _showMissingPropertyError(this, "views");
        }
        /**
         * The available loadouts (possible sets of equipment that can be
         * equipped by default) for this ship, stored in an associative array
         * (the loadout names are keys)
         * @type Object
         */
        this._loadouts = (otherSpacecraftClass && !dataJSON.loadouts) ? otherSpacecraftClass._loadouts : {};
        if (dataJSON.loadouts) {
            for (i = 0; i < dataJSON.loadouts.length; i++) {
                this._loadouts[dataJSON.loadouts[i].name] = new Loadout(dataJSON.loadouts[i]);
            }
        }
        /**
         * The name of the loadout to be used by default (e.g. in the database)
         * @type String
         */
        this._defaultLoadout = otherSpacecraftClass ?
                (dataJSON.defaultLoadout || otherSpacecraftClass._defaultLoadout) :
                (dataJSON.defaultLoadout || null);
        if (this._defaultLoadout && !this._loadouts[this._defaultLoadout]) {
            application.showError(
                    "Non-existing default loadout '" + this._defaultLoadout + "' specified for spacecraft class " + this.getName() + "!",
                    application.ErrorSeverity.MINOR);
            this._defaultLoadout = null;
        }
        /**
         * The descriptor of the sound effect to be played continuously at the position of this spacecraft.
         * @type Object
         */
        this._humSound = dataJSON.humSound ?
                types.getVerifiedObject("spacecraftClasses['" + this._name + "'].humSound", dataJSON.humSound, SOUND_EFFECT_3D) :
                (otherSpacecraftClass ? otherSpacecraftClass._humSound : null);
        /**
         * The class of the explosion this spacecraft creates when it is destroyed and explodes.
         * @type ExplosionClass
         */
        this._explosionClass = otherSpacecraftClass ?
                (dataJSON.explosion ? getExplosionClass(dataJSON.explosion) : otherSpacecraftClass._explosionClass) :
                getExplosionClass(dataJSON.explosion || _missingString(this, "explosion"));
        /**
         * How long should spacecraft be displayed during its explosion (as a ratio compared to the explosion duration)
         * @type Number
         */
        this._showTimeRatioDuringExplosion = (dataJSON.showTimeRatioDuringExplosion !== undefined) ?
                dataJSON.showTimeRatioDuringExplosion :
                (otherSpacecraftClass ? otherSpacecraftClass._showTimeRatioDuringExplosion : _missingNumber(this, "showTimeRatioDuringExplosion"));
        /**
         * The damage indicators (fires, sparks) that progressively appear as the ship loses hull integrity
         * @type DamageIndicator[]
         */
        this._damageIndicators = (otherSpacecraftClass && !dataJSON.damageIndicators) ? otherSpacecraftClass._damageIndicators : [];
        if (dataJSON.damageIndicators) {
            for (i = 0; i < dataJSON.damageIndicators.length; i++) {
                this._damageIndicators.push(new DamageIndicator(dataJSON.damageIndicators[i]));
            }
        }
        /**
         * The light sources that can be added to a scene along with this spacecraft.
         * @type LightSourceDescriptor[]
         */
        this._lightSources = (otherSpacecraftClass && !dataJSON.lights) ? otherSpacecraftClass._lightSources : [];
        if (dataJSON.lights) {
            for (i = 0; i < dataJSON.lights.length; i++) {
                this._lightSources.push(new LightSourceDescriptor(dataJSON.lights[i]));
            }
        }
        /**
         * The descriptors for the blinking lights that can be added to the scene along with this spacecraft.
         * @type BlinkerDescriptor[]
         */
        this._blinkerDescriptors = (otherSpacecraftClass && !dataJSON.blinkers) ? otherSpacecraftClass._blinkerDescriptors : [];
        if (dataJSON.blinkers) {
            for (i = 0; i < dataJSON.blinkers.length; i++) {
                this._blinkerDescriptors.push(new BlinkerDescriptor(dataJSON.blinkers[i]));
            }
        }
        /**
         * When locking on to this spacecraft with a missile, the time it takes to achieve lock is multiplied by this factor
         * (smaller for larger ships, larger for more stealthy ships)
         * @type Number
         */
        this._lockingTimeFactor = (dataJSON.lockingTimeFactor !== undefined) ?
                dataJSON.lockingTimeFactor :
                (otherSpacecraftClass ? otherSpacecraftClass._lockingTimeFactor : 1);
        /**
         * The basic (without any equipment) amount of score points destroying a spacecraft of this type is worth 
         * @type Number
         */
        this._scoreValue = otherSpacecraftClass ?
                (dataJSON.scoreValue || otherSpacecraftClass._scoreValue) :
                (dataJSON.scoreValue || 0);
    };
    /**
     * @override
     * @param {Object} dataJSON
     * @returns {Boolean}
     */
    SpacecraftClass.prototype._loadData = function (dataJSON) {
        var baseClass;
        if (dataJSON.basedOn) {
            baseClass = getSpacecraftClass(dataJSON.basedOn);
            baseClass.executeWhenReady(function () {
                this._overrideData(baseClass, dataJSON);
            }.bind(this));
        } else {
            this._overrideData(null, dataJSON);
        }
        return true;
    };
    /**
     * @returns {SpacecraftType}
     */
    SpacecraftClass.prototype.getSpacecraftType = function () {
        return this._spacecraftType;
    };
    /**
     * 
     * @returns {Boolean}
     */
    SpacecraftClass.prototype.isFighterClass = function () {
        return this._spacecraftType.isFighterType();
    };
    /**
     * @returns {String}
     */
    SpacecraftClass.prototype.getDisplayName = function () {
        return strings.get(
                strings.SPACECRAFT_CLASS.PREFIX, this.getName() + strings.SPACECRAFT_CLASS.NAME_SUFFIX.name,
                this._fullName);
    };
    /**
     * @returns {String}
     */
    SpacecraftClass.prototype.getDisplayDescription = function () {
        return strings.get(
                strings.SPACECRAFT_CLASS.PREFIX, this.getName() + strings.SPACECRAFT_CLASS.DESCRIPTION_SUFFIX.name,
                utils.formatString(strings.get(strings.DATABASE.MISSING_SPACECRAFT_CLASS_DESCRIPTION), {
                    spacecraftClass: this.getDisplayName(),
                    originalDescription: this._description
                }));
    };
    /**
     * @returns {Boolean}
     */
    SpacecraftClass.prototype.shouldShowInDatabase = function () {
        return this._showInDatabase;
    };
    /**
     * @returns {Number}
     */
    SpacecraftClass.prototype.getHitpoints = function () {
        return this._hitpoints;
    };
    /**
     * 
     * @returns {Number}
     */
    SpacecraftClass.prototype.getArmor = function () {
        return this._armor;
    };
    /**
     * 
     * @returns {Number[4]}
     */
    SpacecraftClass.prototype.getFactionColor = function () {
        return this._factionColor;
    };
    /**
     * @returns {String}
     */
    SpacecraftClass.prototype.getTurnStyle = function () {
        return this._turnStyle;
    };
    /**
     * @returns {Number[2]}
     */
    SpacecraftClass.prototype.getAttackVectorAngles = function () {
        return this._attackVectorAngles;
    };
    /**
     * @returns {Number}
     */
    SpacecraftClass.prototype.getAttackThresholdAngle = function () {
        return this._attackThresholdAngle;
    };
    /**
     * @returns {Number}
     */
    SpacecraftClass.prototype.getMass = function () {
        return this._mass;
    };
    /**
     * @returns {Number}
     */
    SpacecraftClass.prototype.getDragFactor = function () {
        return this._dragFactor;
    };
    /**
     * @returns {Body[]}
     */
    SpacecraftClass.prototype.getBodies = function () {
        return this._bodies;
    };
    /**
     * @returns {WeaponSlot[]}
     */
    SpacecraftClass.prototype.getWeaponSlots = function () {
        return this._weaponSlots;
    };
    /**
     * @returns {MissileLauncherDescriptor[]}
     */
    SpacecraftClass.prototype.getMissileLaunchers = function () {
        return this._missileLaunchers;
    };
    /**
     * Returns an associative object where the keys are the size IDs and the 
     * values are arrays of the missile launcher with that size
     * @returns {Object}
     */
    SpacecraftClass.prototype.getMissileLaunchersBySize = function () {
        var result = {}, i;
        for (i = 0; i < this._missileLaunchers.length; i++) {
            if (!result[this._missileLaunchers[i].size]) {
                result[this._missileLaunchers[i].size] = [this._missileLaunchers[i]];
            } else {
                result[this._missileLaunchers[i].size].push(this._missileLaunchers[i]);
            }
        }
        return result;
    };
    /**
     * @returns {ThrusterSlot[]}
     */
    SpacecraftClass.prototype.getThrusterSlots = function () {
        return this._thrusterSlots;
    };
    /**
     * @param {String} name
     */
    SpacecraftClass.prototype.getLoadout = function (name) {
        return this._loadouts[name];
    };
    /**
     * @returns {String[]}
     */
    SpacecraftClass.prototype.getLoadoutNames = function () {
        return Object.keys(this._loadouts);
    };
    /**
     * @returns {String}
     */
    SpacecraftClass.prototype.getDefaultLoadout = function () {
        return this._defaultLoadout;
    };
    /**
     * @returns {ObjectView[]}
     */
    SpacecraftClass.prototype.getViews = function () {
        return this._views;
    };
    /**
     * @param {String} name
     * @returns {ObjectView}
     */
    SpacecraftClass.prototype.getView = function (name) {
        var i;
        for (i = 0; i < this._views.length; i++) {
            if (this._views[i].getName() === name) {
                return this._views[i];
            }
        }
        return null;
    };
    /**
     * @returns {ExplosionClass}
     */
    SpacecraftClass.prototype.getExplosionClass = function () {
        return this._explosionClass;
    };
    /**
     * @returns {Number}
     */
    SpacecraftClass.prototype.getShowTimeRatioDuringExplosion = function () {
        return this._showTimeRatioDuringExplosion;
    };
    /**
     * @returns {DamageIndicator[]}
     */
    SpacecraftClass.prototype.getDamageIndicators = function () {
        return this._damageIndicators;
    };
    /**
     * @returns {LightSourceDescriptor[]}
     */
    SpacecraftClass.prototype.getLightSources = function () {
        return this._lightSources;
    };
    /**
     * @returns {BlinkerDescriptor[]}
     */
    SpacecraftClass.prototype.getBlinkerDescriptors = function () {
        return this._blinkerDescriptors;
    };
    /**
     * @returns {Number}
     */
    SpacecraftClass.prototype.getLockingTimeFactor = function () {
        return this._lockingTimeFactor;
    };
    /**
     * @typedef {ShadedModelClass~ResourceParams} SpacecraftClass~ResourceParams
     * @property {Boolean} [explosion=false]
     * @property {Boolean} [damageIndicators=false]
     * @property {Boolean} [blinkers=false]
     * @property {Boolean} [sound=false]
     */
    /**
     * @override
     * @param {SpacecraftClass~ResourceParams} params
     */
    SpacecraftClass.prototype.acquireResources = function (params) {
        var i;
        TexturedModelClass.prototype.acquireResources.call(this, params);
        if (params.explosion) {
            this._explosionClass.acquireResources({sound: params.sound});
        }
        if (params.damageIndicators) {
            for (i = 0; i < this._damageIndicators.length; i++) {
                this._damageIndicators[i].explosionClass.acquireResources({sound: params.sound});
            }
        }
        if (params.blinkers) {
            for (i = 0; i < this._blinkerDescriptors.length; i++) {
                this._blinkerDescriptors[i].acquireResources();
            }
        }
        if (params.sound) {
            if (this._humSound) {
                _loadSoundEffect(this._humSound);
            }
        }
    };
    /**
     * @override
     * Updates the properties for the case when the graphics settings have been changed.
     */
    SpacecraftClass.prototype.handleGraphicsSettingsChanged = function () {
        var i;
        TexturedModelClass.prototype.handleGraphicsSettingsChanged.call(this);
        if (this._blinkerDescriptors) {
            for (i = 0; i < this._blinkerDescriptors.length; i++) {
                this._blinkerDescriptors[i].handleGraphicsSettingsChanged();
            }
        }
    };
    /**
     * Returns whether a humming sound effect (to be played continuously at the position of the spacecraft) is associated with this 
     * spacecraft class.
     * @returns {Boolean}
     */
    SpacecraftClass.prototype.hasHumSound = function () {
        return !!this._humSound;
    };
    /**
     * Creates a sound clip for playing the humming sound effect for this spacecraft in looping mode, and returns a reference to it.
     * @param {SoundSource} soundSource The sound source to be used for 3D spatial positioning of the clip
     * @returns {SoundClip}
     */
    SpacecraftClass.prototype.createHumSoundClip = function (soundSource) {
        if (this._humSound) {
            return _createSoundClip(this._humSound, true, soundSource);
        }
        return null;
    };
    /**
     * Returns the basic (without any equipment) amount of score points destroying a spacecraft of this type is worth 
     * @returns {Number}
     */
    SpacecraftClass.prototype.getScoreValue = function () {
        return this._scoreValue;
    };
    /**
     * Sends an asynchronous request to grab the file containing the in-game
     * class descriptions and sets a callback to load those descriptions and
     * initiate the loading of reusable environments when ready.
     * @param {{folder: String, filename: String}} classSourceFileDescriptor
     * @param {Function} callback
     */
    function requestLoad(classSourceFileDescriptor, callback) {
        var classAssignment = {};
        classAssignment[SKYBOX_CLASS_ARRAY_NAME] = SkyboxClass;
        classAssignment[BACKGROUND_OBJECT_CLASS_ARRAY_NAME] = BackgroundObjectClass;
        classAssignment[DUST_CLOUD_CLASS_ARRAY_NAME] = DustCloudClass;
        classAssignment[EXPLOSION_CLASS_ARRAY_NAME] = ExplosionClass;
        classAssignment[PROJECTILE_CLASS_ARRAY_NAME] = ProjectileClass;
        classAssignment[WEAPON_CLASS_ARRAY_NAME] = WeaponClass;
        classAssignment[PROPULSION_CLASS_ARRAY_NAME] = PropulsionClass;
        classAssignment[MISSILE_CLASS_ARRAY_NAME] = MissileClass;
        classAssignment[JUMP_ENGINE_CLASS_ARRAY_NAME] = JumpEngineClass;
        classAssignment[SHIELD_CLASS_ARRAY_NAME] = ShieldClass;
        classAssignment[SPACECRAFT_TYPE_ARRAY_NAME] = SpacecraftType;
        classAssignment[SPACECRAFT_CLASS_ARRAY_NAME] = SpacecraftClass;
        _classManager.requestConfigLoad(
                classSourceFileDescriptor.filename,
                classSourceFileDescriptor.folder,
                classAssignment, function () {
                    _classManager.requestAllResources();
                    _classManager.requestResourceLoad();
                    if (callback) {
                        callback();
                    }
                });
        _classFolder = classSourceFileDescriptor.folder;
    }
    _classManager = new resourceManager.ResourceManager();
    // Update all classes for the case when the graphics settings have been changed (i.e. clear cached values depending on graphics settings)
    graphics.onSettingsChange(function () {
        _classManager.executeForAllResources(function (resource) {
            resource.handleGraphicsSettingsChanged();
        });
    });
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        SHADER_VARIANT_INSTANCED_NAME: SHADER_VARIANT_INSTANCED_NAME,
        SOUND_EFFECT: SOUND_EFFECT,
        ParticleEmitterType: ParticleEmitterType,
        ObjectViewLookAtMode: ObjectViewLookAtMode,
        SceneViewLookAtMode: SceneViewLookAtMode,
        MissileSize: MissileSize,
        MissileHomingMode: MissileHomingMode,
        WeaponRotationStyle: WeaponRotationStyle,
        SpacecraftTurnStyle: SpacecraftTurnStyle,
        TexturedModelClass: TexturedModelClass,
        getSkyboxClass: getSkyboxClass,
        getBackgroundObjectClass: getBackgroundObjectClass,
        getDustCloudClass: getDustCloudClass,
        getExplosionClass: getExplosionClass,
        getMissileClass: getMissileClass,
        getWeaponClass: getWeaponClass,
        getPropulsionClass: getPropulsionClass,
        getJumpEngineClass: getJumpEngineClass,
        getShieldClass: getShieldClass,
        getSpacecraftType: getSpacecraftType,
        getSpacecraftClass: getSpacecraftClass,
        getSpacecraftClassesInArray: getSpacecraftClassesInArray,
        getClassCategories: getClassCategories,
        getClassNames: getClassNames,
        getClass: getClass,
        createClass: _classManager.createResource.bind(_classManager),
        Loadout: Loadout,
        ObjectView: ObjectView,
        SceneView: SceneView,
        requestLoad: requestLoad,
        executeWhenReady: _classManager.executeWhenReady.bind(_classManager),
        executeForAllClasses: _classManager.executeForAllResources.bind(_classManager),
        renameClass: _classManager.renameResource.bind(_classManager),
        moveClassAfter: _classManager.moveResourceAfter.bind(_classManager)
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Stores the current game configuration and settings and provides functions to load and access them.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define */

/**
 * @param utils Used for accessing the ScaleMode enum
 * @param types Used for verifying the types of settings loaded from JSON
 * @param asyncResource ConfigurationContext is a subclass of AsyncResource
 * @param camera Used for accessing the enum types in this module
 * @param classes Loading the game configuration initiates loading the classes.
 * @param constants Used to access common game constants
 */
define('armada/configuration',[
    "utils/utils",
    "utils/types",
    "modules/async-resource",
    "modules/scene/camera",
    "armada/logic/classes",
    "armada/constants"
], function (utils, types, asyncResource, camera, classes, constants) {
    "use strict";
    var
            // --------------------------------------------------------------------------------------------
            /**
             * All location IDs where setting values are stored in local storage are prefixed by this value.
             * @type String
             */
            MODULE_LOCAL_STORAGE_PREFIX = constants.LOCAL_STORAGE_PREFIX + "settings_",
            /**
             * The separator character used in local storage IDs which are joined together from multiple parts
             * @type String
             */
            LOCAL_STORAGE_SEPARATOR = "_",
            // --------------------------------------------------------------------------------------------
            /**
             * This object holds the definition objects for custom types that are used for object property verification
             * @type Object
             */
            _customTypes = {},
            /**
             * Definition object for cofiguration settings that can be used to verify the data loaded from JSON
             * @type Object
             */
            CONFIGURATION,
            /**
             * The definition object for general settings that can be used to verify the data loaded from JSON as well as refer to the 
             * individual settings later.
             * @type Object
             */
            GENERAL_SETTINGS,
            /**
             * The definition object for database settings that can be used to verify the data loaded from JSON as well as refer to the 
             * individual settings later.
             * @type Object
             */
            DATABASE_SETTINGS,
            /**
             * The definition object for battle settings that can be used to verify the data loaded from JSON as well as refer to the 
             * individual settings later.
             * @type Object
             */
            BATTLE_SETTINGS,
            /**
             * The definition object for camera settings that can be used to verify the data loaded from JSON as well as refer to the 
             * individual settings later.
             * @type Object
             */
            CAMERA_SETTINGS,
            /**
             * The full prefix to use for local storage IDs of HUD settings
             * @type String
             */
            LOCAL_STORAGE_HUD_PREFIX,
            /**
             * The full prefix to use for local storage IDs of battle settings
             * @type String
             */
            LOCAL_STORAGE_BATTLE_PREFIX,
            /**
             * The context storing the current settings and game data that can be accessed through the interface of this module
             * @type ConfigurationContext
             */
            _context;
    _customTypes.FILE_DESCRIPTOR = {
        baseType: "object",
        properties: {
            FILENAME: {
                name: "filename",
                type: "string"
            },
            FOLDER: {
                name: "folder",
                type: "string"
            }
        }
    };
    _customTypes.LIGHT_SOURCE = {
        baseType: "object",
        properties: {
            COLOR: {
                name: "color",
                type: types.COLOR3
            },
            DIRECTION: {
                name: "direction",
                type: types.VECTOR3
            }
        }
    };
    _customTypes.LAYOUT_DESCRIPTOR = {
        baseType: "object",
        properties: {
            LEFT: {
                name: "left",
                type: "number",
                optional: true
            },
            CENTER_X: {
                name: "centerX",
                type: "number",
                optional: true
            },
            RIGHT: {
                name: "right",
                type: "number",
                optional: true
            },
            TOP: {
                name: "top",
                type: "number",
                optional: true
            },
            CENTER_Y: {
                name: "centerY",
                type: "number",
                optional: true
            },
            BOTTOM: {
                name: "bottom",
                type: "number",
                optional: true
            },
            WIDTH: {
                name: "width",
                type: "number",
                optional: true
            },
            HEIGHT: {
                name: "height",
                type: "number",
                optional: true
            },
            SCALE_MODE: {
                name: "scaleMode",
                type: "enum",
                values: utils.ScaleMode
            },
            X_SCALE_MODE: {
                name: "xScaleMode",
                type: "enum",
                values: utils.ScaleMode,
                optional: true
            },
            Y_SCALE_MODE: {
                name: "yScaleMode",
                type: "enum",
                values: utils.ScaleMode,
                optional: true
            }
        }
    };
    /**
     * Defines the coordinates for the top-left and bottom-right corners (or other corners if flipped horizontally or vertically) of a
     * texture within an image, in texture space ((0;0) is top-left, (1;1) is bottom-right of the image)
     * @type Object
     */
    _customTypes.TEXTURE_MAPPING = {
        baseType: "array",
        elementType: types.VECTOR2,
        length: 2
    };
    _customTypes.UI_IMAGE_DESCRIPTOR = {
        baseType: "object",
        properties: {
            TEXTURE: {
                name: "texture",
                type: "string"
            },
            MAPPING: {
                name: "mapping",
                type: _customTypes.TEXTURE_MAPPING,
                optional: true
            },
            SIZE: {
                name: "size",
                type: types.VECTOR2
            },
            SCALE_MODE: {
                name: "scaleMode",
                type: "enum",
                values: utils.ScaleMode
            },
            COLOR: {
                name: "color",
                type: types.COLOR4
            }
        }
    };
    _customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR = {
        baseType: "object",
        properties: {
            TEXTURE: {
                name: "texture",
                type: "string"
            },
            MAPPING: {
                name: "mapping",
                type: _customTypes.TEXTURE_MAPPING
            },
            LAYOUT: {
                name: "layout",
                type: _customTypes.LAYOUT_DESCRIPTOR
            },
            COLOR: {
                name: "color",
                type: types.COLOR4
            }
        }
    };
    _customTypes.TEXT_DESCRIPTOR = {
        baseType: "object",
        properties: {
            COLOR: {
                name: "color",
                type: types.COLOR4
            },
            FONT_SIZE: {
                name: "fontSize",
                type: "number"
            },
            FONT_NAME: {
                name: "fontName",
                type: "string"
            },
            POSITION: {
                name: "position",
                type: types.VECTOR2
            },
            LAYOUT: {
                name: "layout",
                type: _customTypes.LAYOUT_DESCRIPTOR,
                optional: true
            }
        }
    };
    _customTypes.CRAFT_INDICATOR_POSITIONS = {
        baseType: "array", // how many crafts are in the wing
        elementType: {
            baseType: "array", // which craft is it within the wing
            elementType: types.VECTOR2 // relative position (within the wing layout) of the craft on the wingmen indicator panel
        }
    };
    _customTypes.STRING_ARRAY = {
        baseType: "array",
        elementType: "string"
    };
    /**
     * Creates and returns a new type descriptor based on the passed one, changing some of its property descriptors
     * @param {Object} baseDescriptor
     * @param {Object.<String, String[]>} customProperties Changes the given simple property descriptors e.g. passing 
     * {COLOR: ["active", "passive"]} will make the COLOR property descriptor in such way that if it expected "color": [r,g,b,a] properties,
     * now it will expect "colors": {"active": [r,g,b,a], "passive": [r,g,b,a]} properties instead
     * @param {String[]} [missingProperties] These properties will be deleted from the descriptor
     * @returns {Object}
     */
    _customTypes.getCustomDescriptor = function (baseDescriptor, customProperties, missingProperties) {
        var i, j, result = utils.deepCopy(baseDescriptor), customPropDescNames, propertyDescriptor;
        customPropDescNames = Object.keys(customProperties);
        for (i = 0; i < customPropDescNames.length; i++) {
            propertyDescriptor = result.properties[customPropDescNames[i]];
            result.properties[customPropDescNames[i] + "S"] = {
                name: propertyDescriptor.name + "s",
                type: {
                    baseType: "object",
                    properties: {}
                }
            };
            for (j = 0; j < customProperties[customPropDescNames[i]].length; j++) {
                result.properties[customPropDescNames[i] + "S"].type.properties[customProperties[customPropDescNames[i]][j].toUpperCase()] = {
                    name: customProperties[customPropDescNames[i]][j],
                    type: propertyDescriptor.type
                };
            }
            delete result.properties[customPropDescNames[i]];
        }
        if (missingProperties) {
            for (i = 0; i < missingProperties.length; i++) {
                delete result.properties[missingProperties[i]];
            }
        }
        return result;
    };
    CONFIGURATION = {
        CLASSES_SOURCE_FILE: {
            name: "classes",
            type: _customTypes.FILE_DESCRIPTOR
        },
        ENVIRONMENTS_SOURCE_FILE: {
            name: "environments",
            type: _customTypes.FILE_DESCRIPTOR
        },
        MISSION_FILES: {
            name: "missions",
            type: {
                baseType: "object",
                properties: {
                    FILENAME: {
                        name: "filename",
                        type: "string"
                    },
                    FOLDER: {
                        name: "folder",
                        type: "string"
                    }
                }
            }
        }
    };
    GENERAL_SETTINGS = {
        /**
         * Whether the RequestAnimationFrame API should be used for the render loops (as opposed to setInterval)
         */
        USE_REQUEST_ANIM_FRAME: {
            name: "useRequestAnimFrame",
            type: "boolean",
            defaultValue: true
        },
        /**
         * Default seed to use for generating random numbers to allow consistent and comparable testing.
         */
        DEFAULT_RANDOM_SEED: {
            name: "defaultRandomSeed",
            type: "number",
            defaultValue: 4718
        },
        /**
         * The uniform with the corresponding (pre- and suffixed) name will be used in the spacecraft shader to pass the luminosity
         * factor values of the various triangle groups.
         */
        UNIFORM_LUMINOSITY_FACTORS_ARRAY_NAME: {
            name: "luminosityFactorsArrayName",
            type: "string",
            defaultValue: "luminosityFactors"
        },
        /**
         * The uniform with the corresponding (pre- and suffixed) name will be used in the spacecraft shader to pass the group transform
         * values of the various triangle groups.
         */
        UNIFORM_GROUP_TRANSFORMS_ARRAY_NAME: {
            name: "groupTransformsArrayName",
            type: "string",
            defaultValue: "groupTransforms"
        },
        /**
         * Whether to interpret given field of view, span and other camera property values as vertical or horizontal.
         */
        USE_VERTICAL_CAMERA_VALUES: {
            name: "useVerticalCameraValues",
            type: "boolean",
            defaultValue: true
        },
        /**
         * The ID (resource name) of the song (MusicResource) that should play when the menus are shown.
         */
        MENU_MUSIC: {
            name: "menuMusic",
            type: "string"
        },
        /**
         * The default duration of the fade in of music themes (when no theme is playing), in seconds
         */
        MUSIC_FADE_IN_DURATION: {
            name: "musicFadeInDuration",
            type: "number"
        },
        /**
         * The default duration of the crossfade between different music themes (e.g. anticipation -> combat), in seconds
         */
        THEME_CROSSFADE_DURATION: {
            name: "themeCrossfadeDuration",
            type: "number"
        },
        /**
         * The default duration of the fade out of music themes (when no theme is following), in seconds
         */
        MUSIC_FADE_OUT_DURATION: {
            name: "musicFadeOutDuration",
            type: "number"
        },
        /**
         * The descriptor for the sound effect that should play when the player selects a button on a screen (hover over / navigates to it
         * with the keyboard)
         */
        BUTTON_SELECT_SOUND: {
            name: "buttonSelectSound",
            type: classes.SOUND_EFFECT
        },
        /**
         * The descriptor for the sound effect that should play when the player clicks / activates a button on a screen 
         */
        BUTTON_CLICK_SOUND: {
            name: "buttonClickSound",
            type: classes.SOUND_EFFECT
        }
    };
    DATABASE_SETTINGS = {
        /**
         * Whether to show the loading box when loading the first item after navigating to the database screen
         */
        SHOW_LOADING_BOX_FIRST_TIME: {
            name: "showLoadingBoxFirstTime",
            type: "boolean",
            defaultValue: true
        },
        /**
         * Whether to show the loading box when switching to another item on the database screen
         */
        SHOW_LOADING_BOX_ON_ITEM_CHANGE: {
            name: "showLoadingBoxOnItemChange",
            type: "boolean",
            defaultValue: true
        },
        /**
         * The background color for the canvas that shows the models in the database
         */
        BACKGROUND_COLOR: {
            name: "backgroundColor",
            type: types.COLOR4,
            defaultValue: [0, 0, 0, 0]
        },
        /**
         * The view distance of the scene in which the current item is displayed
         */
        ITEM_VIEW_DISTANCE: {
            name: "itemViewDistance",
            type: "number",
            defaultValue: 2000
        },
        /**
         * The field of view of the camera of the scene in which the current item is displayed (in degrees)
         */
        ITEM_VIEW_FOV: {
            name: "itemViewFOV",
            type: "number",
            defaultValue: 60
        },
        /**
         * The span of the camera of the scene in which the current item is displayed (in degrees)
         */
        ITEM_VIEW_SPAN: {
            name: "itemViewSpan",
            type: "number",
            defaultValue: 0.2
        },
        /**
         * If true, the wireframe model will be visible in the database unless the shaders can only show one model and the solid model is also set to show
         */
        SHOW_WIREFRAME_MODEL: {
            name: "showWireframeModel",
            type: "boolean",
            defaultValue: true
        },
        /**
         * The name of the shader to use when rendering the wireframe model
         */
        WIREFRAME_SHADER_NAME: {
            name: "wireframeShaderName",
            type: "string",
            defaultValue: "oneColorReveal"
        },
        /**
         * If the wireframe model is visible, it will be colored (homogenously) with this color
         */
        WIREFRAME_COLOR: {
            name: "wireframeColor",
            type: types.COLOR4,
            defaultValue: [1, 0, 0, 1]
        },
        /**
         * If true, the solid model will be visible in the database (it will face in after the wireframe model, if that is also visible and reveal is active)
         */
        SHOW_SOLID_MODEL: {
            name: "showSolidModel",
            type: "boolean",
            defaultValue: true
        },
        /**
         * The name of the shader to use when rendering the solid model
         */
        SOLID_SHADER_NAME: {
            name: "solidShaderName",
            type: "string",
            defaultValue: "shadowMapReveal"
        },
        /**
         * The light sources that will be added to the item view scene in the database
         */
        LIGHT_SOURCES: {
            name: "lightSources",
            type: "array",
            elementType: _customTypes.LIGHT_SOURCE,
            minLength: 1,
            maxLength: 2
        },
        /**
         * The size of every model shown will be multiplied by this factor in the database when switching to it
         */
        START_SIZE_FACTOR: {
            name: "startSizeFactor",
            type: "number",
            defaultValue: "1"
        },
        /**
         * If the model size is changed by the user in the database, it cannot go below the original size multiplied by this factor
         */
        MIN_SIZE_FACTOR: {
            name: "minimumSizeFactor",
            type: "number",
            defaultValue: "0.9"
        },
        /**
         * If the model size is changed by the user in the database, it cannot go above the original size multiplied by this factor
         */
        MAX_SIZE_FACTOR: {
            name: "maximumSizeFactor",
            type: "number",
            defaultValue: "1.6"
        },
        /**
         * If true, the models in the database will be rotated automatically
         */
        MODEL_AUTO_ROTATION: {
            name: "modelAutoRotation",
            type: "boolean",
            defaultValue: true
        },
        /**
         * If true, the models in the database can be rotated by the mouse
         */
        MODEL_MOUSE_ROTATION: {
            name: "modelMouseRotation",
            type: "boolean",
            defaultValue: true
        },
        /**
         * The rotation animation (if turned on) will be carried out at this many frames per second
         */
        ROTATION_FPS: {
            name: "rotationFPS",
            type: "number",
            defaultValue: 60
        },
        /**
         * When starting the rotation and the review animations at the same time, the rotation angle will initially be set to this (in degrees)
         */
        ROTATION_REVEAL_START_ANGLE: {
            name: "rotationRevealStartAngle",
            type: types.ANGLE_DEGREES,
            defaultValue: 90
        },
        /**
         * When starting the rotation animation without the reveal animation, the rotation angle will initially be set to this (in degrees)
         */
        ROTATION_START_ANGLE: {
            name: "rotationStartAngle",
            type: types.ANGLE_DEGREES,
            defaultValue: 180
        },
        /**
         * The viewing angle that remains constant as the models rotate in the database (in degrees)
         */
        ROTATION_VIEW_ANGLE: {
            name: "rotationViewAngle",
            type: types.ANGLE_DEGREES,
            defaultValue: 60
        },
        /**
         * If the automatic rotation is turned on, the model will rotate 360 degrees during this much time, in milliseconds
         */
        ROTATION_DURATION: {
            name: "rotationDuration",
            type: "number",
            defaultValue: 4000
        },
        /**
         * If the user rotates the model in the database using the mouse, this will determine the rate or the rotation in degrees / pixels
         */
        ROTATION_MOUSE_SENSITIVITY: {
            name: "rotationMouseSensitivity",
            type: "number",
            defaultValue: 1
        },
        /**
         * If the shaders are not simplified, this setting will toggle the fade-in reveal animation
         */
        MODEL_REVEAL_ANIMATION: {
            name: "modelRevealAnimation",
            type: "boolean",
            defaultValue: true
        },
        /**
         * The models will fade in from this color while being revealed
         */
        REVEAL_COLOR: {
            name: "revealColor",
            type: types.COLOR4,
            defaultValue: [1.0, 1.0, 1.0, 1.0]
        },
        /**
         * The reveal animation will be carried out at this many frames per second
         */
        REVEAL_FPS: {
            name: "revealFPS",
            type: "number",
            defaultValue: 60
        },
        /**
         * The amount of time needed for the reveal animation to fully reveal a (wireframe/solid) model, in milliseconds
         */
        REVEAL_DURATION: {
            name: "revealDuration",
            type: types.DURATION,
            defaultValue: 2000
        },
        /**
         * This much delay will be applied between the revealing of the wireframe and the solid models, in milliseconds
         */
        REVEAL_SOLID_DELAY_DURATION: {
            name: "revealSolidDelayDuration",
            type: types.DURATION,
            defaultValue: 2000
        },
        /**
         * The transition from the reveal color to the model color will this much part of the model's length
         */
        REVEAL_TRANSITION_LENGTH_FACTOR: {
            name: "revealTransitionLengthFactor",
            type: "number",
            defaultValue: 0.15
        },
        /**
         * The rendering of the item view scene will happen at this many frames per second
         */
        RENDER_FPS: {
            name: "databaseRenderFPS",
            type: "number",
            defaultValue: 60
        }
    };
    BATTLE_SETTINGS = {
        /**
         * The rendering of the battle scene will happen at this many frames per second
         */
        RENDER_FPS: {
            name: "battleRenderFPS",
            type: "number",
            defaultValue: 60
        },
        /**
         * The simulation loop will be executed this many times per second during the battle
         */
        SIMULATION_STEPS_PER_SECOND: {
            name: "simulationStepsPerSecond",
            type: "number",
            defaultValue: 60
        },
        /**
         * When prefilling the particle pool at the start of a battle, the size of the pool will be set to the maximum possible amount of 
         * particles multiplied by this factor.
         */
        PARTICLE_POOL_PREFILL_FACTOR: {
            name: "particlePoolPrefillFactor",
            type: "number"
        },
        /**
         * When prefilling the projectile pool at the start of a battle, the size of the pool will be set to the maximum possible amount of 
         * projectiles multiplied by this factor.
         */
        PROJECTILE_POOL_PREFILL_FACTOR: {
            name: "projectilePoolPrefillFactor",
            type: "number"
        },
        /**
         * When prefilling the missile pool at the start of a battle, the size of the pool will be set to the maximum possible amount of 
         * missiles multiplied by this factor.
         */
        MISSILE_POOL_PREFILL_FACTOR: {
            name: "missilePoolPrefillFactor",
            type: "number"
        },
        /**
         * When prefilling the trail segment pool at the start of a battle, the size of the pool will be set to the maximum possible amount of 
         * missiles multiplied by the missile prefill factor multipled by this factor.
         */
        TRAIL_SEGMENT_POOL_PREFILL_FACTOR: {
            name: "trailSegmentPoolPrefillFactor",
            type: "number"
        },
        /**
         * When prefilling the explosion pool at the start of a battle, the size of the pool will be set to the maximum possible amount of 
         * explosions multiplied by this factor.
         */
        EXPLOSION_POOL_PREFILL_FACTOR: {
            name: "explosionPoolPrefillFactor",
            type: "number"
        },
        MINIMUM_DUST_PARTICLE_COUNT_FOR_INSTANCING: {
            name: "minimumDustParticleCountForInstancing",
            type: "number",
            defaultValue: 1
        },
        MINIMUM_PARTICLE_COUNT_FOR_INSTANCING: {
            name: "minimumParticleCountForInstancing",
            type: "number",
            defaultValue: 1
        },
        MINIMUM_PROJECTILE_COUNT_FOR_INSTANCING: {
            name: "minimumProjectileCountForInstancing",
            type: "number",
            defaultValue: 1
        },
        MINIMUM_TRAIL_SEGMENT_COUNT_FOR_INSTANCING: {
            name: "minimumTrailSegmentCountForInstancing",
            type: "number",
            defaultValue: 1
        },
        MINIMUM_THRUSTER_PARTICLE_COUNT_FOR_INSTANCING: {
            name: "minimumThrusterParticleCountForInstancing",
            type: "number",
            defaultValue: 1
        },
        MINIMUM_BLINKER_PARTICLE_COUNT_FOR_INSTANCING: {
            name: "minimumBlinkerParticleCountForInstancing",
            type: "number",
            defaultValue: 1
        },
        /**
         * The view distance in the battle scene
         */
        VIEW_DISTANCE: {
            name: "viewDistance",
            type: "number",
            defaultValue: 5000
        },
        /**
         * When one of the coordinates of the player's ship exceeds this number, the whole scene is moved so that the player's ship is in the origo.
         */
        MOVE_TO_ORIGO_DISTANCE: {
            name: "moveToOrigoDistance",
            type: "number"
        },
        /**
         * The default duration of camera transitions for the battle scene (will be overridden by specific settings for specific transition cases)
         */
        CAMERA_DEFAULT_TRANSITION_DURATION: {
            name: "cameraDefaultTransitionDuration",
            type: "number",
            defaultValue: 1000
        },
        /**
         * The default style of camera transitions for the battle scene (will be overridden by specific settings for specific transition cases)
         */
        CAMERA_DEFAULT_TRANSITION_STYLE: {
            name: "cameraDefaultTransitionStyle",
            type: "enum",
            values: camera.Camera.TransitionStyle,
            defaultValue: camera.Camera.TransitionStyle.SMOOTH
        },
        /**
         * The duration of camera transitions happening when the user switches to piloting mode
         */
        CAMERA_PILOTING_SWITCH_TRANSITION_DURATION: {
            name: "cameraPilotingSwitchTransitionDuration",
            type: "number",
            defaultValue: 1000
        },
        /**
         * The style of camera transitions happening when the user switches to piloting mode
         */
        CAMERA_PILOTING_SWITCH_TRANSITION_STYLE: {
            name: "cameraPilotingSwitchTransitionStyle",
            type: "enum",
            values: camera.Camera.TransitionStyle,
            defaultValue: camera.Camera.TransitionStyle.SMOOTH
        },
        /**
         * The length of impulse-like events (like firing a projectile or hitting a ship) in milliseconds
         */
        MOMENT_DURATION: {
            name: "momentDuration",
            type: types.DURATION,
            defaultValue: 1
        },
        /**
         * Background objects will be rendered at a point this distance from the camera-space origo, in their set direction.
         */
        BACKGROUND_OBJECT_DISTANCE: {
            name: "backgroundObjectDistance",
            type: "number",
            defaultValue: 4500
        },
        /**
         * When turning, (maneuvering computers of) spacecrafts allow the turn rate to accelerate for a maximum of this duration 
         * (around each axis), in seconds.
         */
        TURN_ACCELERATION_DURATION_S: {
            name: "turnAccelerationDurationInSeconds",
            type: types.DURATION
        },
        /**
         * When moving forward in combat flight mode, the controlled spacecraft will accelerate to maximum a speed 
         * that equals its acceleration multiplied by this factor.
         */
        MAX_COMBAT_FORWARD_SPEED_FACTOR: {
            name: "maxCombatForwardSpeedFactor",
            type: "number"
        },
        /**
         * When moving backward in combat flight mode, the controlled spacecraft will accelerate to maximum a reverse speed 
         * that equals its acceleration multiplied by this factor.
         */
        MAX_COMBAT_REVERSE_SPEED_FACTOR: {
            name: "maxCombatReverseSpeedFactor",
            type: "number"
        },
        /**
         * When moving forward in cruise flight mode, the controlled spacecraft will accelerate to maximum a speed 
         * that equals its acceleration multiplied by this factor.
         */
        MAX_CRUISE_FORWARD_SPEED_FACTOR: {
            name: "maxCruiseForwardSpeedFactor",
            type: "number"
        },
        /**
         * When moving backward in cruise flight mode, the controlled spacecraft will accelerate to maximum a reverse speed 
         * that equals its acceleration multiplied by this factor.
         */
        MAX_CRUISE_REVERSE_SPEED_FACTOR: {
            name: "maxCruiseReverseSpeedFactor",
            type: "number"
        },
        /**
         * When strafing, the controlled spacecraft will accelerate to maximum a speed (along the strafing axis) that equals its acceleration 
         * multiplied by this factor.
         */
        STRAFE_SPEED_FACTOR: {
            name: "strafeSpeedFactor",
            type: "number"
        },
        /**
         * If a muzzle flash particle has no set duration (by its projectile class), this duration will be applied. In milliseconds
         */
        DEFAULT_MUZZLE_FLASH_DURATION: {
            name: "defaultMuzzleFlashDuration",
            type: types.DURATION,
            defaultValue: 500
        },
        /**
         * If true, spacecrafts can hit themselves with their own projectiles
         */
        SELF_FIRE: {
            name: "selfFire",
            type: "boolean",
            defaultValue: true
        },
        /**
         * When displayed, hitboxes will be modulated with this color.
         */
        HITBOX_COLOR: {
            name: "hitboxColor",
            type: types.COLOR4,
            defaultValue: [0.0, 0.5, 0.5, 0.5]
        },
        /**
         * The texture resource with this name will be applied to hitboxes when they are displayed.
         */
        HITBOX_TEXTURE_NAME: {
            name: "hitboxTexture",
            type: "string",
            defaultValue: "white"
        },
        /**
         * The shader resource with this name will be used for hitboxes when they are displayed.
         */
        HITBOX_SHADER_NAME: {
            name: "hitboxShader",
            type: "string",
            defaultValue: "oneColor"
        },
        /**
         * When true, those hitboxes are visible, for which actual hitchecks are calculated (and manual toggling of hitbox visibility
         * is disabled)
         */
        SHOW_HITBOXES_FOR_HITCHECKS: {
            name: "showHitboxesForHitchecks",
            type: "boolean"
        },
        /**
         * When a mission is started with a fighter, the camera will be set to this view of the fighter
         */
        DEFAULT_FIGHTER_VIEW_NAME: {
            name: "defaultFighterViewName",
            type: "string"
        },
        /**
         * These options will be offered in the gameplay settings as possible preferred fighter views
         */
        DEFAULT_FIGHTER_VIEW_NAME_OPTIONS: {
            name: "defaultFighterViewNameOptions",
            type: _customTypes.STRING_ARRAY
        },
        /**
         * When a mission is started with a ship (not fighter), the camera will be set to this view of the ship
         */
        DEFAULT_SHIP_VIEW_NAME: {
            name: "defaultShipViewName",
            type: "string"
        },
        /**
         * These options will be offered in the gameplay settings as possible preferred ship views
         */
        DEFAULT_SHIP_VIEW_NAME_OPTIONS: {
            name: "defaultShipViewNameOptions",
            type: _customTypes.STRING_ARRAY
        },
        /**
         * Views (camera configurations) with this name will be treated as target views (and set to face the current target of the 
         * spacecraft)
         */
        TARGET_VIEW_NAME: {
            name: "targetViewName",
            type: "string",
            defaultValue: "target"
        },
        /**
         * The duration of camera transitions of target views when the target is changed, in milliseconds
         */
        TARGET_CHANGE_TRANSITION_DURATION: {
            name: "targetChangeTransitonDuration",
            type: types.DURATION,
            defaultValue: 300
        },
        /**
         * The style of camera transitions of target views when the target is changed
         */
        TARGET_CHANGE_TRANSITION_STYLE: {
            name: "targetChangeTransitionStyle",
            type: "enum",
            values: camera.Camera.TransitionStyle
        },
        /**
         * The amount of time while the same order in which targets are cycled through is kept valid, in milliseconds.
         * If the player is switching to the next target after this time has elapsed, a new target order is established.
         */
        TARGET_ORDER_DURATION: {
            name: "targetOrderDuration",
            type: "number"
        },
        /**
         * When preparing to jump out with the piloted spacecraft, the camera will switch to the spacecraft's first view (camera 
         * configuration) with this name, if any.
         */
        JUMP_PREPARE_VIEW_NAME: {
            name: "jumpPrepareViewName",
            type: "string"
        },
        /**
         * When jumping out with the piloted spacecraft, the camera will switch to the spacecraft's first view (camera configuration) with 
         * this name, if any. (otherwise switch to free camera)
         */
        JUMP_OUT_VIEW_NAME: {
            name: "jumpOutViewName",
            type: "string"
        },
        /**
         * The amount of time to wait after the game state changes to victory or defeat before actually displaying the result. (as for
         * example incoming projectiles destroying the player's ship right after victory can change the state to defeat)
         */
        GAME_STATE_DISPLAY_DELAY: {
            name: "gameStateDisplayDelay",
            type: "number"
        },
        /**
         * The amount of time to wait between the player jumping out and showing the mission debriefing screen, in milliseconds.
         */
        QUIT_DELAY_AFTER_JUMP_OUT: {
            name: "quitDelayAfterJumpOut",
            type: "number"
        },
        HUD: {
            name: "hud",
            /**
             * If true, the target hull integrity quick view bar is shown above the center of the HUD regardless of whether the target is
             * visible on screen, otherwise it is shown above the target when the target is visible on screen (and above the center when not)
             */
            ALWAYS_SHOW_TARGET_HULL_BAR_AT_CENTER: {
                name: "alwaysShowTargetHullBarAtCenter",
                type: "boolean"
            },
            /**
             * If true, instead of showing a separate aim assist indicator next to the crosshairs, the crosshairs (weapon impact indicators)
             * themselves are offset to compensate for the relative movement of the target and assist the aiming.
             */
            AIM_ASSIST_CROSSHAIRS: {
                name: "aimAssistCrosshairs",
                type: "boolean"
            },
            /**
             * If true, the view (model) of the target on the HUD will be display in the orientation relative to the player ship, otherwise
             * simply top-down
             */
            RELATIVE_TARGET_ORIENTATION: {
                name: "relativeTargetOrientation",
                type: "boolean"
            },
            HIGHLIGHT_INTERVAL: {
                name: "highlightInterval",
                type: "number"
            },
            TARGET_SWITCH_ANIMATION_DURATION: {
                name: "targetSwitchAnimationDuration",
                type: "number"
            },
            AIM_ASSIST_APPEAR_ANIMATION_DURATION: {
                name: "aimAssistAppearAnimationDuration",
                type: "number"
            },
            HULL_INTEGRITY_DECREASE_ANIMATION_DURATION: {
                name: "hullIntegrityDecreaseAnimationDuration",
                type: "number"
            },
            SHIELD_DECREASE_ANIMATION_DURATION: {
                name: "shieldDecreaseAnimationDuration",
                type: "number"
            },
            TARGET_HULL_INTEGRITY_DECREASE_ANIMATION_DURATION: {
                name: "targetHullIntegrityDecreaseAnimationDuration",
                type: "number"
            },
            TARGET_SHIELD_DECREASE_ANIMATION_DURATION: {
                name: "targetShieldDecreaseAnimationDuration",
                type: "number"
            },
            SHIP_INDICATOR_HIGHLIGHT_ANIMATION_INTERVAL: {
                name: "shipIndicatorHighlightAnimationInterval",
                type: "number"
            },
            CENTER_CROSSHAIR: {
                name: "centerCrosshair",
                type: _customTypes.UI_IMAGE_DESCRIPTOR
            },
            CURSOR: {
                name: "cursor",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_IMAGE_DESCRIPTOR, {MAPPING: ["still", "turn"]})
            },
            SHIP_ARROW: {
                name: "shipArrow",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_IMAGE_DESCRIPTOR, {COLOR: ["hostile", "friendly", "hostileHighlight", "friendlyHighlight", "newHostile", "hostileTarget", "friendlyTarget", "transmission"], SIZE: ["default", "target"]})
            },
            SHIP_ARROW_POSITION_RADIUS: {
                name: "shipArrowPositionRadius",
                type: "number"
            },
            TARGET_ARROW_SWITCH_SCALE: {
                name: "targetArrowSwitchScale",
                type: "number"
            },
            SHIP_INDICATOR: {
                name: "shipIndicator",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_IMAGE_DESCRIPTOR, {COLOR: ["hostile", "friendly", "hostileHighlight", "friendlyHighlight", "newHostile", "hostileTarget", "friendlyTarget", "transmission"], SIZE: ["minimum", "targetMinimum", "maximum"]})
            },
            SHIP_INDICATOR_SIZE_FACTOR: {
                name: "shipIndicatorSizeFactor",
                type: "number"
            },
            TARGET_INDICATOR_SWITCH_SCALE: {
                name: "targetIndicatorSwitchScale",
                type: "number"
            },
            MISSILE_LOCK_INDICATOR: {
                name: "missileLockIndicator",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_IMAGE_DESCRIPTOR, {COLOR: ["hostileTarget", "friendlyTarget"]}, ["SIZE"])
            },
            MISSILE_LOCK_INDICATOR_COUNT: {
                name: "missileLockIndicatorCount",
                type: "number"
            },
            MISSILE_LOCK_INDICATOR_RADIUS: {
                name: "missileLockIndicatorRadius",
                type: "number"
            },
            MISSILE_LOCK_INDICATOR_SIZE: {
                name: "missileLockIndicatorSize",
                type: "number"
            },
            MISSILE_LOCK_INDICATOR_ANGLE: {
                name: "missileLockIndicatorAngle",
                type: "number"
            },
            MISSILE_LOCK_INDICATOR_ROTATION_SPEED: {
                name: "missileLockIndicatorRotationSpeed",
                type: "number"
            },
            MISSILE_LOCK_INDICATOR_BLINK_INTERVAL: {
                name: "missileLockIndicatorBlinkInterval",
                type: "number"
            },
            DISTANCE_TEXT_LAYER_LAYOUT: {
                name: "distanceTextLayerLayout",
                type: _customTypes.LAYOUT_DESCRIPTOR
            },
            DISTANCE_TEXT: {
                name: "distanceText",
                type: _customTypes.getCustomDescriptor(_customTypes.TEXT_DESCRIPTOR, {COLOR: ["hostile", "friendly"]})
            },
            SHIP_STATUS_INDICATOR: {
                name: "shipStatusIndicator",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_IMAGE_DESCRIPTOR, {MAPPING: ["protect", "destroy", "transmission"], COLOR: ["protect", "destroy", "transmission"], SIZE: ["reticle", "arrow"]})
            },
            AIM_ASSIST_INDICATOR: {
                name: "aimAssistIndicator",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_IMAGE_DESCRIPTOR, {COLOR: ["hostile", "friendly", "appear"]})
            },
            AIM_ASSIST_INDICATOR_APPEAR_SCALE: {
                name: "aimAssistIndicatorAppearScale",
                type: "number"
            },
            WEAPON_IMPACT_INDICATOR: {
                name: "weaponImpactIndicator",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_IMAGE_DESCRIPTOR, {COLOR: ["normal", "outOfRange"]})
            },
            WEAPON_IMPACT_INDICATOR_SWITCH_SCALE: {
                name: "weaponImpactIndicatorSwitchScale",
                type: "number"
            },
            TARGET_VIEW_LAYOUT: {
                name: "targetViewLayout",
                type: _customTypes.LAYOUT_DESCRIPTOR
            },
            TARGET_VIEW_CAMERA_DISTANCE: {
                name: "targetViewCameraDistance",
                type: "number"
            },
            TARGET_VIEW_VIEW_DISTANCE: {
                name: "targetViewViewDistance",
                type: "number"
            },
            TARGET_VIEW_FOV: {
                name: "targetViewFOV",
                type: "number"
            },
            TARGET_VIEW_TARGET_ITEM_SHADER: {
                name: "targetViewTargetItemShader",
                type: "string"
            },
            TARGET_VIEW_TARGET_ITEM_FULL_INTEGRITY_COLOR: {
                name: "targetViewTargetItemFullIntegrityColor",
                type: types.COLOR4
            },
            TARGET_VIEW_TARGET_ITEM_HALF_INTEGRITY_COLOR: {
                name: "targetViewTargetItemHalfIntegrityColor",
                type: types.COLOR4
            },
            TARGET_VIEW_TARGET_ITEM_ZERO_INTEGRITY_COLOR: {
                name: "targetViewTargetItemZeroIntegrityColor",
                type: types.COLOR4
            },
            TARGET_INFO_BACKGROUND: {
                name: "targetInfoBackground",
                type: _customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR
            },
            TARGET_HULL_INTEGRITY_BAR: {
                name: "targetHullIntegrityBar",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR, {COLOR: ["filled", "empty"]})
            },
            TARGET_SHIELD_BAR: {
                name: "targetShieldBar",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR, {COLOR: ["filled", "empty"]})
            },
            TARGET_INFO_TEXT_LAYER_LAYOUT: {
                name: "targetInfoTextLayerLayout",
                type: _customTypes.LAYOUT_DESCRIPTOR
            },
            TARGET_INFO_TEXT: {
                name: "targetInfoText",
                type: _customTypes.getCustomDescriptor(_customTypes.TEXT_DESCRIPTOR, {COLOR: ["hostile", "friendly"], FONT_SIZE: ["name", "others"], POSITION: ["name", "class", "team", "firepower", "distance", "velocity"]})
            },
            WINGMEN_STATUS_BACKGROUND: {
                name: "wingmenStatusBackground",
                type: _customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR
            },
            WINGMEN_STATUS_HEADER_TEXT: {
                name: "wingmenStatusHeaderText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            /**
             * Information based on which the indicators for the individual spacecrafts within squads can be created for the wingmen status indicator
             */
            WINGMEN_STATUS_CRAFT_INDICATOR: {
                name: "wingmenStatusCraftIndicator",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_IMAGE_DESCRIPTOR, {MAPPING: ["player", "shield", "general", "interceptor", "bomber", "heavyFighter"], COLOR: ["fullIntegrity", "halfIntegrity", "zeroIntegrity", "destroyed", "away", "fullShieldIntegrity", "halfShieldIntegrity", "zeroShieldIntegrity"]})
            },
            /**
             * Stores the relative positions (within the area described by the squad layouts) of the individual spacecraft indicators for
             * each squad size and craft index
             * (-1,-1): bottom left, (1,1): top right
             */
            WINGMEN_STATUS_CRAFT_POSITIONS: {
                name: "wigmenStatusCraftPositions",
                type: _customTypes.CRAFT_INDICATOR_POSITIONS
            },
            /**
             * This is a virtual layout that is used indirectly (by dynamically creating layouts based on it) to lay out the individual 
             * spacecraft indicators within the squad and the squad texts
             */
            WINGMEN_STATUS_SQUAD_LAYOUT: {
                name: "wigmenStatusSquadLayout",
                type: _customTypes.LAYOUT_DESCRIPTOR
            },
            WINGMEN_STATUS_SQUAD_TEXT: {
                name: "wingmenStatusSquadText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            SPEED_BAR: {
                name: "speedBar",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR, {COLOR: ["combatFilled", "combatEmpty", "combatReverseFilled", "combatReverseEmpty", "cruiseFilled", "cruiseEmpty", "cruiseReverseFilled", "cruiseReverseEmpty", "freeFilled", "freeEmpty", "freeReverseFilled", "freeReverseEmpty"]})
            },
            SPEED_BAR_BASE_MAX_SPEED_FACTOR: {
                name: "speedBarBaseMaxSpeedFactor",
                type: "number"
            },
            SPEED_BAR_DEFAULT_BASE_MAX_SPEED: {
                name: "speedBarDefaultBaseMaxSpeed",
                type: "number"
            },
            SPEED_BAR_MAX_SPEED_STEP_FACTOR: {
                name: "speedBarMaxSpeedStepFactor",
                type: "number"
            },
            SPEED_BAR_MAX_SPEED_STEP_BUFFER: {
                name: "speedBarMaxSpeedStepBuffer",
                type: "number"
            },
            SPEED_TEXT_LAYER_LAYOUT: {
                name: "speedTextLayerLayout",
                type: _customTypes.LAYOUT_DESCRIPTOR
            },
            SPEED_TEXT: {
                name: "speedText",
                type: _customTypes.getCustomDescriptor(_customTypes.TEXT_DESCRIPTOR, {COLOR: ["combatForward", "combatReverse", "cruiseForward", "cruiseReverse", "freeForward", "freeReverse"], POSITION: ["maxForward", "maxReverse"]})
            },
            SPEED_TARGET_INDICATOR: {
                name: "speedTargetIndicator",
                type: _customTypes.UI_IMAGE_DESCRIPTOR
            },
            MISSILE_INDICATOR: {
                name: "missileIndicator",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR, {MAPPING: ["single", "salvo"], COLOR: ["ready", "locking", "loading"]})
            },
            MISSILE_INDICATOR_TEXT_LAYOUT: {
                name: "missileIndicatorTextLayout",
                type: _customTypes.LAYOUT_DESCRIPTOR
            },
            MISSILE_INDICATOR_TEXT: {
                name: "missileIndicatorText",
                type: _customTypes.getCustomDescriptor(_customTypes.TEXT_DESCRIPTOR, {COLOR: ["ready", "locking", "loading"]})
            },
            HULL_INTEGRITY_BAR: {
                name: "hullIntegrityBar",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR, {COLOR: ["filled", "empty", "filledWhenDecreasing", "emptyWhenDecreasing"]})
            },
            SHIELD_BAR: {
                name: "shieldBar",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR, {COLOR: ["filled", "empty", "filledWhenDecreasing", "emptyWhenDecreasing"]})
            },
            FLIGHT_MODE_INDICATOR_BACKGROUND: {
                name: "flightModeIndicatorBackground",
                type: _customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR
            },
            FLIGHT_MODE_HEADER_TEXT: {
                name: "flightModeHeaderText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            FLIGHT_MODE_TEXT: {
                name: "flightModeText",
                type: _customTypes.getCustomDescriptor(_customTypes.TEXT_DESCRIPTOR, {COLOR: ["free", "combat", "cruise"]})
            },
            MISSILE_INFO_BACKGROUND: {
                name: "missileInfoBackground",
                type: _customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR
            },
            MISSILE_INFO_HEADER_TEXT: {
                name: "missileInfoHeaderText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            MISSILE_INFO_TEXT: {
                name: "missileInfoText",
                type: _customTypes.getCustomDescriptor(_customTypes.TEXT_DESCRIPTOR, {COLOR: ["readySelected", "lockingSelected", "loadingSelected", "notSelected", "empty"], POSITION: ["name", "count"]})
            },
            MISSILE_INFO_TEXT_OFFSET: {
                name: "missileInfoTextOffset",
                type: "number"
            },
            MAX_MISSILE_INFO_DISPLAYED: {
                name: "maxMissileInfoDisplayed",
                type: "number"
            },
            DRIFT_ARROW: {
                name: "driftArrow",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_IMAGE_DESCRIPTOR, {COLOR: ["minSpeed", "maxSpeed"]})
            },
            DRIFT_ARROW_POSITION_RADIUS: {
                name: "driftArrowPositionRadius",
                type: "number"
            },
            DRIFT_ARROW_MIN_SPEED: {
                name: "driftArrowMinSpeed",
                type: "number"
            },
            DRIFT_ARROW_MAX_SPEED_FACTOR: {
                name: "driftArrowMaxSpeedFactor",
                type: "number"
            },
            TARGET_HULL_INTEGRITY_QUICK_VIEW_BAR: {
                name: "targetHullIntegrityQuickViewBar",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR, {COLOR: ["hostileFilled", "hostileEmpty", "friendlyFilled", "friendlyEmpty", "filledWhenDecreasing"]})
            },
            TARGET_SHIELD_QUICK_VIEW_BAR: {
                name: "targetShieldQuickViewBar",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR, {COLOR: ["filled", "empty", "filledWhenDecreasing"]})
            },
            HEADER_TEXT_LAYER_LAYOUT: {
                name: "headerTextLayerLayout",
                type: _customTypes.LAYOUT_DESCRIPTOR
            },
            SMALL_HEADER_TEXT: {
                name: "smallHeaderText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            BIG_HEADER_TEXT: {
                name: "bigHeaderText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            SUBHEADER_TEXT: {
                name: "subheaderText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            MESSAGE_BACKGROUND: {
                name: "messageBackground",
                type: _customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR
            },
            MESSAGE_TEXT: {
                name: "messageText",
                type: _customTypes.getCustomDescriptor(_customTypes.TEXT_DESCRIPTOR, {COLOR: ["default", "jump", "alert", "controlString", "friendlySpacecraft", "hostileSpacecraft"]})
            },
            MESSAGE_TEXT_MARGIN: {
                name: "messageTextMargin",
                type: "number"
            },
            TOP_LEFT_TEXT_LAYER_LAYOUT: {
                name: "topLeftTextLayerLayout",
                type: _customTypes.LAYOUT_DESCRIPTOR
            },
            SCORE_TEXT: {
                name: "scoreText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            OBJECTIVES_BACKGROUND: {
                name: "objectivesBackground",
                type: _customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR
            },
            OBJECTIVES_HEADER_TEXT: {
                name: "objectivesHeaderText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            OBJECTIVES_TEXT: {
                name: "objectivesText",
                type: _customTypes.getCustomDescriptor(_customTypes.TEXT_DESCRIPTOR, {COLOR: ["inProgress", "completed", "failed"]})
            },
            OBJECTIVES_TEXT_OFFSET: {
                name: "objectivesTextOffset",
                type: "number"
            },
            MAX_OBJECTIVES_DISPLAYED: {
                name: "maxObjectivesDisplayed",
                type: "number"
            },
            ESCORTS_BACKGROUND: {
                name: "escortsBackground",
                type: _customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR
            },
            ESCORTS_HEADER_TEXT: {
                name: "escortsHeaderText",
                type: _customTypes.TEXT_DESCRIPTOR
            },
            ESCORTS_TEXT: {
                name: "escortsText",
                type: _customTypes.getCustomDescriptor(_customTypes.TEXT_DESCRIPTOR, {COLOR: ["alive", "away", "destroyed"]})
            },
            ESCORTS_INTEGRITY_BARS: {
                name: "escortsIntegrityBars",
                type: _customTypes.getCustomDescriptor(_customTypes.UI_LAID_OUT_IMAGE_DESCRIPTOR, {COLOR: ["fullHull", "halfHull", "zeroHull", "awayHull", "destroyed", "shield", "lostShield"], LAYOUT: ["hull", "shield"]})
            },
            ESCORTS_TEXT_OFFSET: {
                name: "escortsTextOffset",
                type: "number"
            },
            MAX_ESCORTS_DISPLAYED: {
                name: "maxEscortsDisplayed",
                type: "number"
            },
            TARGET_SWITCH_SOUND: {
                name: "targetSwitchSound",
                type: classes.SOUND_EFFECT
            },
            TARGET_SWITCH_DENIED_SOUND: {
                name: "targetSwitchDeniedSound",
                type: classes.SOUND_EFFECT
            },
            FLIGHT_MODE_SWITCH_SOUND: {
                name: "flightModeSwitchSound",
                type: classes.SOUND_EFFECT
            },
            MISSILE_CHANGE_SOUND: {
                name: "missileChangeSound",
                type: classes.SOUND_EFFECT
            },
            MISSILE_CHANGE_DENIED_SOUND: {
                name: "missileChangeDeniedSound",
                type: classes.SOUND_EFFECT
            },
            MISSILE_SALVO_SOUND: {
                name: "missileSalvoSound",
                type: classes.SOUND_EFFECT
            },
            MISSILE_LOADED_SOUND: {
                name: "missileLoadedSound",
                type: classes.SOUND_EFFECT
            },
            MISSILE_LOCKING_SOUND: {
                name: "missileLockingSound",
                type: classes.SOUND_EFFECT
            },
            MISSILE_LOCKING_SOUND_COUNT: {
                name: "missileLockingSoundCount",
                type: "number"
            },
            MISSILE_LOCKED_SOUND: {
                name: "missileLockedSound",
                type: classes.SOUND_EFFECT
            },
            MESSAGE_SOUND: {
                name: "messageSound",
                type: classes.SOUND_EFFECT
            },
            MESSAGE_TYPE_SOUND: {
                name: "messageTypeSound",
                type: classes.SOUND_EFFECT
            },
            NEW_HOSTILES_ALERT_SOUND: {
                name: "newHostilesAlertSound",
                type: classes.SOUND_EFFECT
            },
            NEW_HOSTILES_ALERT_DURATION: {
                name: "newHostilesAlertDuration",
                type: "number"
            },
            NEW_HOSTILES_ALERT_BLINK_INTERVAL: {
                name: "newHostilesAlertBlinkInterval",
                type: "number"
            }
        },
        WEAPON_FIRE_SOUND_STACK_MINIMUM_DISTANCE: {
            name: "weaponFireSoundStackMinimumDistance",
            type: "number"
        },
        /**
         * Two (or more) hit sound effects will be stacked if the difference between their starting time
         * is less than this amount (in seconds)
         */
        HIT_SOUND_STACKING_TIME_THRESHOLD: {
            name: "hitSoundStackingTimeThreshold",
            type: "number"
        },
        /**
         * When two (or more) hit sound effects are stacked, each additional sound effect increases the
         * volume of the first effect by its volume multiplied by this factor
         */
        HIT_SOUND_STACKING_VOLUME_FACTOR: {
            name: "hitSoundStackingVolumeFactor",
            type: "number"
        },
        /**
         * Two (or more) fire sound effects will be stacked if the difference between their starting time
         * is less than this amount (in seconds)
         */
        FIRE_SOUND_STACKING_TIME_THRESHOLD: {
            name: "fireSoundStackingTimeThreshold",
            type: "number"
        },
        /**
         * When two (or more) fire sound effects are stacked, each additional sound effect increases the
         * volume of the first effect by its volume multiplied by this factor
         */
        FIRE_SOUND_STACKING_VOLUME_FACTOR: {
            name: "fireSoundStackingVolumeFactor",
            type: "number"
        },
        DEMO_FIGHTER_AI_TYPE: {
            name: "demoFighterAI",
            type: "string"
        },
        DEMO_SHIP_AI_TYPE: {
            name: "demoShipAI",
            type: "string"
        },
        /**
         * Whether the views should automatically change every X seconds when in demo mode
         */
        DEMO_VIEW_SWITCHING: {
            name: "demoViewSwitching",
            type: "boolean"
        },
        DEMO_VIEW_SWITCH_INTERVAL: {
            name: "demoViewSwitchInterval",
            type: "number"
        },
        DEMO_DOUBLE_VIEW_SWITCH_CHANCE: {
            name: "demoDoubleViewSwitchChance",
            type: "number"
        },
        /**
         * When the ingame menu is opened (or another screen is opened from within it), the music volume will be changed by this factor
         */
        MUSIC_VOLUME_IN_MENUS: {
            name: "musicVolumeInMenus",
            type: "number"
        },
        /**
         * When the ingame menu is opened (or another screen is opened from within it), the SFX volume will be changed by this factor
         */
        SFX_VOLUME_IN_MENUS: {
            name: "sfxVolumeInMenus",
            type: "number"
        },
        /**
         * The ID (resource name) of the song (MusicResource) that should play during battles while there are no hostile spacecrafts.
         */
        AMBIENT_MUSIC: {
            name: "ambientMusic",
            type: "string"
        },
        /**
         * The IDs (resource names) of the songs (MusicResource) that can be played during battles while there are hostiles, but there is no
         * fighting. One of these is chosen randomly for each mission when it starts (unless there is a specific track set in the mission data)
         */
        ANTICIPATION_MUSIC: {
            name: "anticipationMusic",
            type: _customTypes.STRING_ARRAY
        },
        /**
         * The IDs (resource names) of the songs (MusicResources) that can be played during battles while fighting is going on.
         * One of these is chosen randomly for each mission when it starts (unless there is a specific track set in the mission data)
         */
        COMBAT_MUSIC: {
            name: "combatMusic",
            type: _customTypes.STRING_ARRAY
        },
        /**
         * The ID (resource name) of the song (MusicResource) that should play when a battle is won.
         */
        VICTORY_MUSIC: {
            name: "victoryMusic",
            type: "string"
        },
        /**
         * The ID (resource name) of the song (MusicResource) that should play when a battle is lost.
         */
        DEFEAT_MUSIC: {
            name: "defeatMusic",
            type: "string"
        },
        /**
         * The ID (resource name) of the song (MusicResource) that should play while at the mission debriefing screen, if the mission was
         * won
         */
        DEBRIEFING_VICTORY_MUSIC: {
            name: "debriefingVictoryMusic",
            type: "string"
        },
        /**
         * The ID (resource name) of the song (MusicResource) that should play while at the mission debriefing screen, if the mission has
         * been lost
         */
        DEBRIEFING_DEFEAT_MUSIC: {
            name: "debriefingDefeatMusic",
            type: "string"
        },
        /**
         * The duration while the combat theme is kept playing during battle after a spacecraft fires at a hostile target, in seconds
         */
        COMBAT_THEME_DURATION_AFTER_FIRE: {
            name: "combatThemeDurationAfterFire",
            type: "number"
        },
        /**
         * The duration of the crossfade to the ending music themes (victory / defeat) during battle, in seconds
         */
        END_THEME_CROSSFADE_DURATION: {
            name: "endThemeCrossfadeDuration",
            type: "number"
        },
        /**
         * The duration of the fade in of the debriefing music theme after exiting the battle, in seconds
         */
        DEBRIEFING_THEME_FADE_IN_DURATION: {
            name: "debriefingThemeFadeInDuration",
            type: "number"
        },
        /**
         * The ratio of score points that should be awarded for destroying an enemy. E.g. 0.2 means that 20% of score points should be 
         * awarded for the kill to the spacecraft which delivered the final hit, and 80% for the damage, proportionally to all spacecrafts
         * which dealt it
         */
        SCORE_FRACTION_FOR_KILL: {
            name: "scoreFractionForKill",
            type: {
                baseType: "number",
                range: [0, 1]
            }
        },
        /**
         * The amount of score points awarded for the player if an individual mission (no teammates) is completed with full hull integrity. 
         * If the player's ship is damaged, the bonus is proportional to the amount of hull integrity left.
         */
        SCORE_BONUS_FOR_HULL_INTEGRITY: {
            name: "scoreBonusForHullIntegrity",
            type: "number"
        },
        /**
         * The amount of score points awarded for the player if a team mission (the player has teammates) is completed with full hull 
         * integrity. If the player's ship is damaged, the bonus is proportional to the amount of hull integrity left.
         */
        SCORE_BONUS_FOR_HULL_INTEGRITY_TEAM: {
            name: "scoreBonusForHullIntegrityTeam",
            type: "number"
        },
        /**
         * If the player hasn't used primary weapons (hit ratio is 0) during the mission, the hit ratio of missiles is used for
         * hit ratio bonus calculation instead, multiplied by this factor
         */
        MISSILE_HIT_RATIO_FACTOR: {
            name: "missileHitRatioFactor",
            type: "number"
        },
        /**
         * The amount of score points awarded for the player if a team mission (the player has teammates) is completed with all teammates
         * surviving. If some teammates fall, the bonus is proportional to the ratio of surviving teammates.
         */
        SCORE_BONUS_FOR_TEAM_SURVIVAL: {
            name: "scoreBonusForTeamSurvival",
            type: "number"
        },
        /**
         * Whether missile launchers should be set to salvo mode by default (when available)
         */
        DEFAULT_SALVO_MODE: {
            name: "defaultSalvoMode",
            type: "boolean"
        },
        /**
         * When the missiles of the selected class run out and the spacecraft automatically switches to the next missile class, the
         * newly selected launcher is set to this cooldown (minimum)
         */
        MISSILE_AUTO_CHANGE_COOLDOWN: {
            name: "missileAutoChangeCooldown",
            type: "number"
        }
    };
    CAMERA_SETTINGS = {
        DEFAULT_FOV: {
            name: "defaultFOV",
            type: "number"
        },
        DEFAULT_SPAN: {
            name: "defaultSpan",
            type: "number"
        },
        DEFAULT_BASE_ORIENTATION: {
            name: "defaultBaseOrientation",
            type: "enum",
            values: camera.CameraOrientationConfiguration.BaseOrientation
        },
        DEFAULT_POINT_TO_FALLBACK: {
            name: "defaultPointToFallback",
            type: "enum",
            values: camera.CameraOrientationConfiguration.PointToFallback
        }
    };
    LOCAL_STORAGE_HUD_PREFIX = MODULE_LOCAL_STORAGE_PREFIX + BATTLE_SETTINGS.HUD.name + LOCAL_STORAGE_SEPARATOR;
    LOCAL_STORAGE_BATTLE_PREFIX = MODULE_LOCAL_STORAGE_PREFIX + "battle" + LOCAL_STORAGE_SEPARATOR;
    Object.freeze(_customTypes);
    // #########################################################################
    /**
     * @class A class responsible for loading and storing game logic related 
     * settings as well and provide an interface to access them.
     * @extends AsyncResource
     */
    function ConfigurationContext() {
        asyncResource.AsyncResource.call(this);
        /**
         * An object storing all the configuration settings. (verified against CONFIGURATION)
         * @type
         */
        this._configuration = null;
        /**
         * An object storing all the general settings. (properties verified against GENERAL_SETTINGS, BATTLE_SETTINGS, DATABASE_SETTINGS...)
         * @type Object
         */
        this._settings = null;
        /**
         * Cache storing the current HUD settings (considering both settings file and local storage) for faster access
         * @type Object
         */
        this._hudSettings = {};
    }
    ConfigurationContext.prototype = new asyncResource.AsyncResource();
    ConfigurationContext.prototype.constructor = ConfigurationContext;
    /**
     * 
     * @param {Object} configJSON
     */
    ConfigurationContext.prototype.loadConfigurationFromJSON = function (configJSON) {
        this._configuration = types.getVerifiedObject("configuration", configJSON, CONFIGURATION);
    };
    /**
     * Returns the configuration setting value for the passed setting definition object (from CONFIGURATION).
     * @param {Object} settingDefinitionObject
     */
    ConfigurationContext.prototype.getConfigurationSetting = function (settingDefinitionObject) {
        return this._configuration[settingDefinitionObject.name];
    };
    /**
     * Returns the setting value for the passed setting definition object.
     * @param {Object} settingDefinitionObject
     */
    ConfigurationContext.prototype.getSetting = function (settingDefinitionObject) {
        return this._settings[settingDefinitionObject.name];
    };
    /**
     * Returns the value for the battle setting identified by the passed setting definition object.
     * Checks locally stored settings as well as defaults.
     * @param {Object} settingDefinitionObject
     */
    ConfigurationContext.prototype.getBattleSetting = function (settingDefinitionObject) {
        var local;
        if (localStorage[LOCAL_STORAGE_BATTLE_PREFIX + settingDefinitionObject.name] !== undefined) {
            local = types.getValueOfTypeFromLocalStorage(settingDefinitionObject.type, LOCAL_STORAGE_BATTLE_PREFIX + settingDefinitionObject.name);
        }
        return (local !== undefined) ? local : this._settings[settingDefinitionObject.name];
    };
    /**
     * Overrides the local value for the battle setting identified by the passed setting definition object (storing it in local storage)
     * @param {Object} settingDefinitionObject
     * @param {} value
     */
    ConfigurationContext.prototype.setBattleSetting = function (settingDefinitionObject, value) {
        localStorage[LOCAL_STORAGE_BATTLE_PREFIX + settingDefinitionObject.name] = value;
    };
    /**
     * Returns the value for the HUD setting identified by the passed setting definition object.
     * Checks locally stored settings as well as defaults.
     * @param {Object} settingDefinitionObject
     */
    ConfigurationContext.prototype.getHUDSetting = function (settingDefinitionObject) {
        var local;
        if (this._hudSettings[settingDefinitionObject.name] === undefined) {
            if (localStorage[LOCAL_STORAGE_HUD_PREFIX + settingDefinitionObject.name] !== undefined) {
                local = types.getValueOfTypeFromLocalStorage(settingDefinitionObject.type, LOCAL_STORAGE_HUD_PREFIX + settingDefinitionObject.name);
            }
            this._hudSettings[settingDefinitionObject.name] = (local !== undefined) ? local : this._settings[BATTLE_SETTINGS.HUD.name][settingDefinitionObject.name];
        }
        return this._hudSettings[settingDefinitionObject.name];
    };
    /**
     * Overrides the local value for the HUD setting identified by the passed setting definition object (storing it in local storage)
     * @param {Object} settingDefinitionObject
     * @param {} value
     */
    ConfigurationContext.prototype.setHUDSetting = function (settingDefinitionObject, value) {
        localStorage[LOCAL_STORAGE_HUD_PREFIX + settingDefinitionObject.name] = value;
        this._hudSettings[settingDefinitionObject.name] = value;
    };
    /**
     * Removes all local overrides for HUD settings, resetting them to their default values (coming from the settings JSON)
     */
    ConfigurationContext.prototype.resetHUDSettings = function () {
        var i, name, keys = Object.keys(BATTLE_SETTINGS.HUD);
        for (i = 0; i < keys.length; i++) {
            if (typeof BATTLE_SETTINGS.HUD[keys[i]] === "object") {
                name = BATTLE_SETTINGS.HUD[keys[i]].name;
                localStorage.removeItem(LOCAL_STORAGE_HUD_PREFIX + name);
                this._hudSettings[name] = this._settings[BATTLE_SETTINGS.HUD.name][name];
            }
        }
    };
    /**
     * Removes all local overrides for battle settings, resetting them to their default values (coming from the settings JSON)
     */
    ConfigurationContext.prototype.resetBattleSettings = function () {
        var i, keys = Object.keys(BATTLE_SETTINGS);
        for (i = 0; i < keys.length; i++) {
            if (typeof BATTLE_SETTINGS[keys[i]] === "object") {
                localStorage.removeItem(LOCAL_STORAGE_BATTLE_PREFIX + BATTLE_SETTINGS[keys[i]].name);
            }
        }
    };
    /**
     * Returns the default starting field of view value for camera configurations, in degrees
     * @returns {Number}
     */
    ConfigurationContext.prototype.getDefaultCameraFOV = function () {
        return this.getSetting(CAMERA_SETTINGS.DEFAULT_FOV);
    };
    /**
     * Returns the default starting span value for camera configurations, in meters
     * @returns {Number}
     */
    ConfigurationContext.prototype.getDefaultCameraSpan = function () {
        return this.getSetting(CAMERA_SETTINGS.DEFAULT_SPAN);
    };
    /**
     * (enum CameraOrientationConfiguration.BaseOrientation) Returns the default base orientation mode to use for camera 
     * configurations
     * @returns {String}
     */
    ConfigurationContext.prototype.getDefaultCameraBaseOrientation = function () {
        return this.getSetting(CAMERA_SETTINGS.DEFAULT_BASE_ORIENTATION);
    };
    /**
     * (enum CameraOrientationConfiguration.PointToFallback) Returns the default point-to fallback mode to use for camera 
     * configurations
     * @returns {String}
     */
    ConfigurationContext.prototype.getDefaultCameraPointToFallback = function () {
        return this.getSetting(CAMERA_SETTINGS.DEFAULT_POINT_TO_FALLBACK);
    };
    /**
     * Returns the name of the camera configuration to be used for the default view when piloting the passed spacecraft
     * @param {Spacecraft} spacecraft
     * @returns {String}
     */
    ConfigurationContext.prototype.getDefaultCamerConfigurationName = function (spacecraft) {
        return spacecraft.isFighter() ?
                        this.getBattleSetting(BATTLE_SETTINGS.DEFAULT_FIGHTER_VIEW_NAME) :
                        this.getBattleSetting(BATTLE_SETTINGS.DEFAULT_SHIP_VIEW_NAME);
    };
    // methods
    /**
     * Loads all the setting and references from the passed JSON object and
     * initiates the request(s) necessary to load additional configuration from
     * referenced files.
     * @param {Object} dataJSON
     */
    ConfigurationContext.prototype.loadSettingsFromJSON = function (dataJSON) {
        this._settings = types.getVerifiedObject("general", dataJSON.general, GENERAL_SETTINGS);
        types.getVerifiedObject("database", dataJSON.database, DATABASE_SETTINGS, this._settings);
        types.getVerifiedObject("battle", dataJSON.battle, BATTLE_SETTINGS, this._settings);
        types.getVerifiedObject("camera", dataJSON.camera, CAMERA_SETTINGS, this._settings);
        classes.requestLoad(this.getConfigurationSetting(CONFIGURATION.CLASSES_SOURCE_FILE), function () {
            this.setToReady();
        }.bind(this));
    };
    _context = new ConfigurationContext();
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        CONFIGURATION: CONFIGURATION,
        GENERAL_SETTINGS: GENERAL_SETTINGS,
        BATTLE_SETTINGS: BATTLE_SETTINGS,
        DATABASE_SETTINGS: DATABASE_SETTINGS,
        CAMERA_SETTINGS: CAMERA_SETTINGS,
        loadConfigurationFromJSON: _context.loadConfigurationFromJSON.bind(_context),
        loadSettingsFromJSON: _context.loadSettingsFromJSON.bind(_context),
        getConfigurationSetting: _context.getConfigurationSetting.bind(_context),
        getSetting: _context.getSetting.bind(_context),
        getHUDSetting: _context.getHUDSetting.bind(_context),
        setHUDSetting: _context.setHUDSetting.bind(_context),
        getBattleSetting: _context.getBattleSetting.bind(_context),
        setBattleSetting: _context.setBattleSetting.bind(_context),
        resetHUDSettings: _context.resetHUDSettings.bind(_context),
        resetBattleSettings: _context.resetBattleSettings.bind(_context),
        getDefaultCameraFOV: _context.getDefaultCameraFOV.bind(_context),
        getDefaultCameraSpan: _context.getDefaultCameraSpan.bind(_context),
        getDefaultCameraBaseOrientation: _context.getDefaultCameraBaseOrientation.bind(_context),
        getDefaultCameraPointToFallback: _context.getDefaultCameraPointToFallback.bind(_context),
        getDefaultCamerConfigurationName: _context.getDefaultCamerConfigurationName.bind(_context),
        executeWhenReady: _context.executeWhenReady.bind(_context)
    };
});
/**
 * Copyright 2014-2017, 2020 Krisztián Nagy
 * @file Provides a pool class that can be used to minimize the creation of object from which many are created and destroyed.
 * Also provides a way to create and access common pools for different types of objects.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Element, Float32Array, performance */

define('modules/pools',[],function () {
    "use strict";
    var
            /**
             * Stores common pools for classes by the names of the constructors of the classes so they can be accessed by any module 
             * depending on this module
             * @type Object.<String, Pool>
             */
            _pools = {};
    // #########################################################################
    /**
     * @class
     * Stores an array of reusable objects and provides quick mechanisms to mark objects free for reuse and obtain references to objects 
     * marked free. Used to decrease the number of new objects created, as object creation can be an expensive operation.
     * @param {Function} objectConstructor The constructor for objects stored in this pool - needs to work without any arguments given!
     */
    function Pool(objectConstructor) {
        /**
         * The constructor for objects stored in this pool 
         * @type Function
         */
        this._objectConstructor = objectConstructor;
        /**
         * The array of reusable objects that are stored in this pool.
         * @type Object[]
         */
        this._objects = [];
        /**
         * An array of flags storing whether the reusable objects with the same indices are currently free for reuse.
         * @type Boolean[]
         */
        this._objectsFree = [];
        /**
         * An array storing the indices of the objects that were marked free. Filled in a rotating fashion, with the first and last valid
         * indices being stored.
         * @type Number[]
         */
        this._freeIndices = [];
        /**
         * The index of the first valid entry in the array storing the free object indices.
         * @type Number
         */
        this._firstFreeIndex = 0;
        /**
         * The index of the first invalid entry (one referring to a currently locked object) in the array storing the free object indices.
         * @type Number
         */
        this._firstLockedIndex = 0;
    }
    /**
     * Marks the object stored at the passed index as free for reuse.
     * @param {Number} index
     */
    Pool.prototype.markAsFree = function (index) {
        if (!this._objectsFree[index]) {
            this._freeIndices[this._firstLockedIndex] = index;
            this._objectsFree[index] = true;
            this._firstLockedIndex++;
            if (this._firstLockedIndex >= this._freeIndices.length) {
                this._firstLockedIndex = 0;
            }
        }
    };
    /**
     * Returns a reference to a stored reusable object that is currently marked as free for reuse. Returns null if no objects are currently
     * free.
     * @returns {Object}
     */
    Pool.prototype.getFreeObject = function () {
        var result;
        if (!this._objectsFree[this._freeIndices[this._firstFreeIndex]]) {
            return null;
        }
        this._objectsFree[this._freeIndices[this._firstFreeIndex]] = false;
        result = this._objects[this._freeIndices[this._firstFreeIndex]];
        this._firstFreeIndex++;
        if (this._firstFreeIndex >= this._freeIndices.length) {
            this._firstFreeIndex = 0;
        }
        return result;
    };
    /**
     * Adds the passed object to the pool (in locked state)
     * @param {Object} newObject
     */
    Pool.prototype.addObject = function (newObject) {
        this._objects.push(newObject);
        this._objectsFree.push(false);
        if ((this._firstFreeIndex < this._firstLockedIndex) ||
                ((this._firstFreeIndex === this._firstLockedIndex) && !this._objectsFree[this._freeIndices[this._firstFreeIndex]])) {
            this._freeIndices.push(-1);
        } else {
            this._freeIndices.splice(this._firstLockedIndex, 0, -1);
            this._firstFreeIndex++;
            if (this._firstFreeIndex >= this._freeIndices.length) {
                this._firstFreeIndex = 0;
            }
        }
    };
    /**
     * Returns the array of stored objects.
     * @returns {Object[]}
     */
    Pool.prototype.getObjects = function () {
        return this._objects;
    };
    /**
     * Returns a usable object of the stored type - if there are free ones, one of those, otherwise creates and adds a new one and returns 
     * that
     * @returns {Object}
     */
    Pool.prototype.getObject = function () {
        var result = this.getFreeObject();
        if (!result) {
            result = new this._objectConstructor();
            this.addObject(result);
        }
        return result;
    };
    /**
     * Returns whether there are locked (in-use) object within this pool
     * @returns {Boolean}
     */
    Pool.prototype.hasLockedObjects = function () {
        return (this._firstFreeIndex !== this._firstLockedIndex) || !this._objectsFree[this._freeIndices[this._firstFreeIndex]];
    };
    /**
     * Returns the number of locked object within this pool
     * @returns {Number}
     */
    Pool.prototype.getLockedObjectCount = function () {
        if (this._firstFreeIndex === this._firstLockedIndex) {
            return this._objectsFree[this._freeIndices[this._firstFreeIndex]] ? 0 : this._objects.length;
        }
        if (this._firstFreeIndex < this._firstLockedIndex) {
            return this._objects.length - (this._firstLockedIndex - this._firstFreeIndex);
        }
        return this._firstFreeIndex - this._firstLockedIndex;
    };
    /**
     * Executes the passed function on all of the stored locked (in-use) objects, passing the object and its index within the pool as the
     * two arguments
     * @param {Function} callback
     */
    Pool.prototype.executeForLockedObjects = function (callback) {
        var i, n = this._freeIndices.length;
        if (n > 0) {
            for (i = 0; i < n; i++) {
                if (!this._objectsFree[i]) {
                    callback(this._objects[i], i);
                }
            }
        }
    };
    /**
     * Removes the references to all the stored objects and resets the state of the pool.
     * @returns {undefined}
     */
    Pool.prototype.clear = function () {
        this._objects = [];
        this._objectsFree = [];
        this._freeIndices = [];
        this._firstFreeIndex = 0;
        this._firstLockedIndex = 0;
    };
    /**
     * Prefills the pool with newly created objects that are all considered free. Call this before using the pool to avoid creating new
     * objects during the usage. If the pool is not empty when called, it is first cleared.
     * @param {Number} count The size of the pool to prefill
     * @param {Function} [callback] If given, this callback will be executed for each newly created object in the pool, passing the object
     * and its index in the pool as the two arguments.
     */
    Pool.prototype.prefill = function (count, callback) {
        var i;
        if (this._objects.length > 0) {
            this.clear();
        }
        this._objects = new Array(count);
        this._objectsFree = new Array(count);
        this._freeIndices = new Array(count);
        for (i = 0; i < count; i++) {
            this._objects[i] = new this._objectConstructor();
            this._objectsFree[i] = true;
            this._freeIndices[i] = i;
        }
        if (callback) {
            for (i = 0; i < count; i++) {
                callback(this._objects[i], i);
            }
        }
        this._firstFreeIndex = 0;
        this._firstLockedIndex = 0;
    };
    // -------------------------------------------------------------------------
    // Public functions
    /**
     * Returns the common pool for the string id passed. Creates a new pool if necessary. 
     * @param {String} name The string to identify this pool
     * @param {Function} objectConstructor The constructor function of the type of objects to store in the pool
     * @returns {Pool}
     */
    function getPool(name, objectConstructor) {
        var result = _pools[name] || new Pool(objectConstructor);
        _pools[name] = result;
        return result;
    }
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        Pool: Pool,
        getPool: getPool
    };
});
/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides a particle system class that can be added to scenes.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Float32Array, Int32Array */

/**
 * @param utils Used for Pi related constants
 * @param vec Used for 3D (and 4D) vector operations.
 * @param mat Used for 3D (and 4D) matrix operations.
 * @param renderableObjects ParticleSystem is a subclass of RenderableObject3D
 * @param sceneGraph The particle systems edit the scene graph to add their particles
 */
define('modules/scene/particle-system',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/scene/renderable-objects",
    "modules/scene/scene-graph"
], function (utils, vec, mat, renderableObjects, sceneGraph) {
    "use strict";
    // #########################################################################
    /**
     * @class Generates new particles in rounds using a particle constructor function, serving as the basic
     * element of a particle system.
     * @param {Float32Array} positionMatrix The position of the center of the emitter area, 
     * relative to the center of the particle system
     * @param {Float32Array} orientationMatrix The orienation relative to the center of the particle system
     * @param {Number[3]} dimensions The size of the area in which the new particles are generated
     * @param {Number} velocity The starting velocity of the emitted particles is randomly generated within a range.
     * This number is the middle of that range. (m/s)
     * @param {Number} velocitySpread The starting velocity of the emitted particles is randomly generated within a range.
     * This number is the size of the range (difference between smallest and biggest possible velocity, m/s)
     * @param {Number} initialNumber The number of particles generated right after the creation of the emitter
     * @param {Number} spawnNumber The number of particles generated at the end of each spawn round
     * @param {Number} spawnTime The duration of one spawn round in milliseconds
     * @param {Number} duration The duration of particle generation in milliseconds. If zero, particle generation
     * will go on as long as the emitter exists.
     * @param {Number} [delay=0] The amount of time to elapse from the activation of the emitter until the initial spawning
     * @param {Function} createParticleFunction The function that will be called to generate new particles. Must
     * have no parameters and return a new instance of the Particle class
     */
    function ParticleEmitter(positionMatrix, orientationMatrix, dimensions, velocity, velocitySpread, initialNumber, spawnNumber, spawnTime, duration, delay, createParticleFunction) {
        /**
         * The position of the center of the emitter area, relative to the center of the particle system
         * @type Float32Array
         */
        this._positionMatrix = positionMatrix;
        /**
         * The orienation relative to the center of the particle system
         * @type Float32Array
         */
        this._orientationMatrix = orientationMatrix;
        /**
         * The size of the area in which the new particles are generated
         * @type Number[3]
         */
        this._dimensions = dimensions;
        /**
         * The starting velocity of the emitted particles is randomly generated within a range.
         * This number is the middle of that range. (m/s)
         * @type Number
         */
        this._velocity = velocity;
        /**
         * The starting velocity of the emitted particles is randomly generated within a range.
         * This number is the size of the range (difference between smallest and biggest possible velocity, m/s)
         * @type Number
         */
        this._velocitySpread = velocitySpread;
        /**
         * The number of particles generated right after the creation of the emitter
         * @type Number
         */
        this._initialNumber = initialNumber;
        /**
         * The number of particles generated at the end of each spawn round
         * @type Number
         */
        this._spawnNumber = spawnNumber;
        /**
         * The duration of one spawn round in milliseconds
         * @type Number
         */
        this._spawnTime = spawnTime;
        /**
         * The time passed since the creation of this emitter in milliseconds
         * @type Number
         */
        this._age = 0;
        /**
         * The duration of particle generation in milliseconds. If zero, particle generation will 
         * go on as long as the emitter exists.
         * @type Number
         */
        this._duration = duration;
        /**
         * The amount of time to elapse from the activation of the emitter until the initial spawning
         * @type Number
         */
        this._delay = delay || 0;
        /**
         * The time that passed between the creation of this emitter and the end of the last spawning round,
         * in milliseconds
         * @type Number
         */
        this._lastSpawn = 0;
        /**
         * The function that will be called to generate new particles. Has no parameters and returns a new 
         * instance of the Particle class
         * @type Function
         */
        this._createParticleFunction = createParticleFunction;
        /**
         * The duration of the life of the emitted particles (milliseconds). This is a cache variable.
         * @type Number
         */
        this._particleDuration = -1;
        /**
         * The (calculated) size of this emitter, i.e. how far an emitted particle could reach (including with its own size) from the center
         * @type Number
         */
        this._size = 0;
        if (positionMatrix) {
            this._calculateSize();
        }
    }
    /**
     * Calculates the size of the emitter, considering its specific properties
     */
    ParticleEmitter.prototype._calculateSize = function () {
        var
                /** @type Particle */
                particle = this._createParticleFunction();
        // conversion as duration is in ms, velocity in m/s
        this._size = mat.translationLength(this._positionMatrix) + vec.length3(this._dimensions) +
                Math.max((this._velocity + this._velocitySpread * 0.5) * particle.getDuration() * 0.001 + particle.getFinalSize(), particle.getMaxSize());
        particle.markAsReusable(true);
    };
    /**
     * Returns the (calculated) size of this emitter, i.e. how far an emitted particle could reach (including with its own size) from the center
     * @returns {Number}
     */
    ParticleEmitter.prototype.getSize = function () {
        return this._size;
    };
    /**
     * Returns the duration of particle generation in milliseconds. If zero, particle generation will 
     * go on as long as the emitter exists.
     * @returns {Number}
     */
    ParticleEmitter.prototype.getDuration = function () {
        return this._duration;
    };
    /**
     * Returns the duration of life of the particles generated by this emitter.
     * @returns {Number}
     */
    ParticleEmitter.prototype.getParticleDuration = function () {
        var particle;
        if (this._particleDuration === -1) {
            this._particleDuration = 0;
            particle = this._createParticleFunction();
            this._particleDuration = particle.getDuration();
            // make sure the particle pool will be cleaned up
            particle.markAsReusable(true);
        }
        return this._particleDuration;
    };
    /**
     * Returns one new particle generated according to the attributes of this emitter. Override this in
     * subclasses to add customization to the created particle.
     * @returns {Particle}
     */
    ParticleEmitter.prototype._emitParticle = function () {
        var particle, positionVector;
        particle = this._createParticleFunction();
        positionVector = [
            this._positionMatrix[12] + (Math.random() - 0.5) * this._dimensions[0],
            this._positionMatrix[13] + (Math.random() - 0.5) * this._dimensions[1],
            this._positionMatrix[14] + (Math.random() - 0.5) * this._dimensions[2]];
        particle.setPositionv(vec.prodVec3Mat4Aux(positionVector, this._orientationMatrix));
        return particle;
    };
    /**
     * Returns the array of particles emitted by this emitter in the past dt milliseconds 
     * @param {Number} dt The time passed since this function was last called, in milliseconds
     * @param {Number} [particleCountFactor=1] The number of created particles will be multiplied by this factor
     * @returns {Particle[]} The array of the emitted particles
     */
    ParticleEmitter.prototype.emitParticles = function (dt, particleCountFactor) {
        var particles, i, n;
        particles = [];
        if (particleCountFactor === undefined) {
            particleCountFactor = 1;
        }
        if (this._delay > 0) {
            this._delay -= dt;
            if (this._delay <= 0) {
                dt = -this._delay;
                this._delay = 0;
            }
        }
        if (this._delay === 0) {
            if (this._age === 0) {
                n = Math.round(this._initialNumber * particleCountFactor);
                if ((this._initialNumber > 0) && (n < 1)) {
                    n = 1;
                }
                for (i = 0; i < n; i++) {
                    particles.push(this._emitParticle());
                }
            }
            this._age += dt;
            while (((this._age - this._lastSpawn) > this._spawnTime) && ((this._lastSpawn < this._duration) || (this._duration === 0))) {
                n = Math.round(this._spawnNumber * particleCountFactor);
                if ((this._spawnNumber > 0) && (n < 1)) {
                    n = 1;
                }
                for (i = 0; i < n; i++) {
                    particles.push(this._emitParticle());
                }
                this._lastSpawn += this._spawnTime;
            }
        }
        return particles;
    };
    /**
     * Adds the resources needed to render this particle emitter to the passed managed context
     * @param {ManagedGLContext} context
     */
    ParticleEmitter.prototype.addToContext = function (context) {
        var particle = this._createParticleFunction();
        particle.addToContext(context);
        // make sure the particle pool will be cleaned up
        particle.markAsReusable(true);
    };
    // #########################################################################
    /**
     * @class A particle emitter that emits particles that move in all directions with a velocity within a given range
     * @extends ParticleEmitter
     * @param {Float32Array} positionMatrix The position of the center of the emitter area, 
     * relative to the center of the particle system
     * @param {Float32Array} orientationMatrix The orienation relative to the center of the particle system
     * @param {Number[3]} dimensions The size of the area in which the new particles are generated
     * @param {Number} velocity The starting velocity of the emitted particles is randomly generated within a range.
     * This number is the middle of that range. (m/s)
     * @param {Number} velocitySpread The starting velocity of the emitted particles is randomly generated within a range.
     * This number is the size of the range (difference between smallest and biggest possible velocity, m/s)
     * @param {Number} initialNumber The number of particles generated right after the creation of the emitter
     * @param {Number} spawnNumber The number of particles generated at the end of each spawn round
     * @param {Number} spawnTime The duration of one spawn round in milliseconds
     * @param {Number} duration The duration of particle generation in milliseconds. If zero, particle generation
     * will go on as long as the emitter exists.
     * @param {Number} [delay=0] The amount of time to elapse from the activation of the emitter until the initial spawning
     * @param {Function} particleConstructor The function that will be called to generate new particles. Must
     * have no parameters and return a new instance of the Particle class
     */
    function OmnidirectionalParticleEmitter(positionMatrix, orientationMatrix, dimensions, velocity, velocitySpread, initialNumber, spawnNumber, spawnTime, duration, delay, particleConstructor) {
        ParticleEmitter.call(this, positionMatrix, orientationMatrix, dimensions, velocity, velocitySpread, initialNumber, spawnNumber, spawnTime, duration, delay, particleConstructor);
        this._calculateSize();
    }
    OmnidirectionalParticleEmitter.prototype = new ParticleEmitter();
    OmnidirectionalParticleEmitter.prototype.constructor = OmnidirectionalParticleEmitter;
    /**
     * @override
     * Sets the random velocity of the created particle before returning it
     * @returns {Particle}
     */
    OmnidirectionalParticleEmitter.prototype._emitParticle = function () {
        var v, a, b, sinA, cosA, sinB, cosB, particle = ParticleEmitter.prototype._emitParticle.call(this);
        v = this._velocity + (Math.random() - 0.5) * this._velocitySpread;
        a = Math.random() * utils.DOUBLE_PI;
        b = Math.random() * utils.DOUBLE_PI;
        sinA = Math.sin(a);
        cosA = Math.cos(a);
        sinB = Math.sin(b);
        cosB = Math.cos(b);
        particle.setVelocity(v * cosA * cosB, v * cosA * sinB, v * sinA);
        return particle;
    };
    // #########################################################################
    /**
     * @class A particle emitter that emits particles that move within a given angle around given direction with a velocity within a given range
     * @extends ParticleEmitter
     * @param {Float32Array} positionMatrix The position of the center of the emitter area, 
     * relative to the center of the particle system 
     * @param {Float32Array} orientationMatrix The orienation relative to the center of the particle system
     * @param {Number[3]} dimensions The size of the area in which the new particles are generated
     * @param {Number[3]} direction The direction of the starting velocity of the particles will be generated
     * around this vector
     * @param {Number} directionSpread The maximum angle that the random generated direction of the generated
     * particles can deviate from the main direction (degrees)
     * @param {Number} velocity The starting velocity of the emitted particles is randomly generated within a range.
     * This number is the middle of that range. (m/s)
     * @param {Number} velocitySpread The starting velocity of the emitted particles is randomly generated within a range.
     * This number is the size of the range (difference between smallest and biggest possible velocity, m/s)
     * @param {Number} initialNumber The number of particles generated right after the creation of the emitter
     * @param {Number} spawnNumber The number of particles generated at the end of each spawn round
     * @param {Number} spawnTime The duration of one spawn round in milliseconds
     * @param {Number} duration The duration of particle generation in milliseconds. If zero, particle generation
     * will go on as long as the emitter exists.
     * @param {Number} [delay=0] The amount of time to elapse from the activation of the emitter until the initial spawning
     * @param {Function} particleConstructor The function that will be called to generate new particles. Must
     * have no parameters and return a new instance of the Particle class
     */
    function UnidirectionalParticleEmitter(positionMatrix, orientationMatrix, dimensions, direction, directionSpread, velocity, velocitySpread, initialNumber, spawnNumber, spawnTime, duration, delay, particleConstructor) {
        ParticleEmitter.call(this, positionMatrix, orientationMatrix, dimensions, velocity, velocitySpread, initialNumber, spawnNumber, spawnTime, duration, delay, particleConstructor);
        /**
         * The direction of the starting velocity of the particles will be generated around this vector
         * @type Number[3]
         */
        this._direction = direction;
        /**
         * The maximum angle that the random generated direction of the generated
         * particles can deviate from the main direction (radians)
         * @type Number
         */
        this._directionSpread = directionSpread * utils.RAD;
    }
    UnidirectionalParticleEmitter.prototype = new ParticleEmitter();
    UnidirectionalParticleEmitter.prototype.constructor = UnidirectionalParticleEmitter;
    /**
     * @override
     * Sets the random velocity of the created particle before returning it
     * @returns {Particle}
     */
    UnidirectionalParticleEmitter.prototype._emitParticle = function () {
        var velocity, velocityVector, axis, particle = ParticleEmitter.prototype._emitParticle.call(this);
        velocity = this._velocity + (Math.random() - 0.5) * this._velocitySpread;
        velocityVector = vec.scaled3Aux(this._direction, velocity);
        axis = (Math.abs(this._direction[0]) < 0.75) ? vec.x3Aux() : ((Math.abs(this._direction[1]) < 0.75) ? vec.y3Aux() : vec.z3Aux());
        vec.mulCross3(axis, this._direction);
        vec.normalize3(axis);
        vec.mulVec3Mat3(velocityVector, mat.rotation3Aux(axis, Math.random() * this._directionSpread));
        vec.mulVec3Mat3(velocityVector, mat.rotation3Aux(this._direction, Math.random() * utils.DOUBLE_PI));
        particle.setVelocity(velocityVector[0], velocityVector[1], velocityVector[2]);
        return particle;
    };
    // #########################################################################
    /**
     * @class A particle emitter that emits particles with a random velocity vector falling into a given plane,
     * or deviating from it within a given angle 
     * @extends ParticleEmitter
     * @param {Float32Array} positionMatrix The position of the center of the emitter area, 
     * relative to the center of the particle system
     * @param {Float32Array} orientationMatrix The orienation relative to the center of the particle system
     * @param {Number[3]} dimensions The size of the area in which the new particles are generated
     * @param {Number[3]} planeNormal The normal vector of the plane in or around which the velocity vectors
     * of the generated particles will fall
     * @param {Number} directionSpread The maximum angle that the random generated direction of the generated
     * particles can deviate from the given plane (degrees)
     * @param {Number} velocity The starting velocity of the emitted particles is randomly generated within a range.
     * This number is the middle of that range. (m/s)
     * @param {Number} velocitySpread The starting velocity of the emitted particles is randomly generated within a range.
     * This number is the size of the range (difference between smallest and biggest possible velocity, m/s)
     * @param {Number} initialNumber The number of particles generated right after the creation of the emitter
     * @param {Number} spawnNumber The number of particles generated at the end of each spawn round
     * @param {Number} spawnTime The duration of one spawn round in milliseconds
     * @param {Number} duration The duration of particle generation in milliseconds. If zero, particle generation
     * will go on as long as the emitter exists.
     * @param {Number} [delay=0] The amount of time to elapse from the activation of the emitter until the initial spawning
     * @param {Function} particleConstructor The function that will be called to generate new particles. Must
     * have no parameters and return a new instance of the Particle class
     */
    function PlanarParticleEmitter(positionMatrix, orientationMatrix, dimensions, planeNormal, directionSpread, velocity, velocitySpread, initialNumber, spawnNumber, spawnTime, duration, delay, particleConstructor) {
        ParticleEmitter.call(this, positionMatrix, orientationMatrix, dimensions, velocity, velocitySpread, initialNumber, spawnNumber, spawnTime, duration, delay, particleConstructor);
        /**
         * The normal vector of the plane in or around which the velocity vectors
         * of the generated particles will fall
         * @type Number[3]
         */
        this._planeNormal = planeNormal;
        /**
         * The maximum angle that the random generated direction of the generated
         * particles can deviate from the given plane (radians)
         * @type Number
         */
        this._directionSpread = directionSpread * utils.RAD;
    }
    PlanarParticleEmitter.prototype = new ParticleEmitter();
    PlanarParticleEmitter.prototype.constructor = UnidirectionalParticleEmitter;
    /**
     * @override
     * Sets the random velocity of the created particle before returning it
     * @returns {Particle}
     */
    PlanarParticleEmitter.prototype._emitParticle = function () {
        var directionVector, velocity, velocityVector, particle = ParticleEmitter.prototype._emitParticle.call(this);
        velocity = this._velocity + (Math.random() - 0.5) * this._velocitySpread;
        directionVector = (Math.abs(this._planeNormal[0]) < 0.75) ? vec.x3Aux() : ((Math.abs(this._planeNormal[1]) < 0.75) ? vec.y3Aux() : vec.z3Aux());
        vec.mulCross3(directionVector, this._planeNormal);
        vec.normalize3(directionVector);
        velocityVector = vec.scaled3(directionVector, velocity);
        vec.mulVec3Mat3(velocityVector, mat.rotation3Aux(vec.cross3(directionVector, this._planeNormal), (Math.random() - 0.5) * this._directionSpread));
        vec.mulVec3Mat3(velocityVector, mat.rotation3Aux(this._planeNormal, Math.random() * utils.DOUBLE_PI));
        particle.setVelocity(velocityVector[0], velocityVector[1], velocityVector[2]);
        return particle;
    };
    // #########################################################################
    /**
     * @class Generates animated particles using its list of particle emitters.
     * @extends RenderableObject3D
     * @param {Float32Array} positionMatrix The 4x4 translation matrix describing the position of the center of the particle system (meters)
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix describing the orientation of the particle system
     * @param {Float32Array} scalingMatrix The 4x4 scaling matrix describing the scaling for the positions of the particles in this particle system
     * @param {Float32Array} velocityMatrix The 4x4 translation matrix describing the velocity of the particle system (m/s)
     * @param {ParticleEmitter[]} emitters The list of emitters that will be used to generate particles
     * @param {Number} duration For how long should the particle system be active (milliseconds)
     * @param {Boolean} [keepAlive=false] Whether to keep the particle system alive after the duration has expired.
     * Emitters that are set to produce particles forever will keep on doing so.
     * @param {Boolean} [carriesParticles=false] Whether to carry the emitted particles as subnodes in the scene graph or
     * add them directly to the scene root.
     * @param {Boolean} [relativeOrientation=false] When the particles are not carried, whether to rotate them according to
     * the orientation set for the system when created
     * @param {Number} [minimumCountForInstancing=0] If greater than zero, then having at least this many particles of the types emitted
     * by this particle system will turn on instancing for their render queue.
     * @param {Number} [particleCountFactor=1] The number of particles created by this particle system will be multiplied by this factor
     */
    function ParticleSystem(positionMatrix, orientationMatrix, scalingMatrix, velocityMatrix, emitters, duration, keepAlive, carriesParticles, relativeOrientation, minimumCountForInstancing, particleCountFactor) {
        renderableObjects.RenderableObject3D.call(this, null, false, true, positionMatrix, orientationMatrix, scalingMatrix, undefined, 1, true);
        /**
         * The 4x4 translation matrix describing the velocity of the particle system (m/s)
         * @type Float32Array
         */
        this._velocityMatrix = velocityMatrix;
        /**
         * The list of emitters that will be used to generate particles
         * @type ParticleEmitter[]
         */
        this._emitters = emitters;
        /**
         * The time passed since the creation of this particle system (milliseconds)
         * @type Number
         */
        this._age = 0;
        /**
         * For how long should the particle system be active (milliseconds)
         * @type Number
         */
        this._duration = duration;
        /**
         * Whether to keep the particle system alive after the duration has expired.
         * Emitters that are set to produce particles forever will keep on doing so.
         * @type Boolean
         */
        this._keepAlive = (keepAlive === true);
        /**
         * Whether to carry the emitted particles as subnodes in the scene graph or
         * add them directly to the scene root.
         * @type Boolean
         */
        this._carriesParticles = (carriesParticles === true);
        /**
         * When the particles are not carried, whether to rotate them according to
         * the orientation set for the system when created
         * @type Boolean
         */
        this._hasRelativeOrientation = (relativeOrientation === true);
        /**
         * If greater than zero, then having at least this many particles of the types emitted by this particle system will turn on 
         * instancing for their render queue.
         * @type Number
         */
        this._minimumCountForInstancing = minimumCountForInstancing;
        /**
         * The number of particles created by this particle system are multiplied by this factor (compared to the emitter settings)
         * @type Number
         */
        this._particleCountFactor = (particleCountFactor !== undefined) ? particleCountFactor : 1;
        this._calculateSize();
    }
    ParticleSystem.prototype = new renderableObjects.RenderableObject3D();
    ParticleSystem.prototype.constructor = ParticleSystem;
    /**
     * Initializes all properties of the particle system.
     * @param {Float32Array} positionMatrix The 4x4 translation matrix describing the position of the center of the particle system (meters)
     * @param {Float32Array} orientationMatrix The 4x4 rotation matrix describing the orientation of the particle system
     * @param {Float32Array} scalingMatrix The 4x4 scaling matrix describing the scaling for the positions of the particles in this particle system
     * @param {Float32Array} velocityMatrix The 4x4 translation matrix describing the velocity of the particle system (m/s)
     * @param {ParticleEmitter[]} emitters The list of emitters that will be used to generate particles
     * @param {Number} duration For how long should the particle system be active (milliseconds)
     * @param {Boolean} [keepAlive=false] Whether to keep the particle system alive after the duration has expired.
     * Emitters that are set to produce particles forever will keep on doing so.
     * @param {Boolean} [carriesParticles=false] Whether to carry the emitted particles as subnodes in the scene graph or
     * add them directly to the scene root.
     * @param {Boolean} [relativeOrientation=false] When the particles are not carried, whether to rotate them according to
     * the orientation set for the system when created
     * @param {Number} [minimumCountForInstancing=0] If greater than zero, then having at least this many particles of the types emitted
     * by this particle system will turn on instancing for their render queue.
     * @param {Number} [particleCountFactor=1] The number of particles created by this particle system will be multiplied by this factor
     */
    ParticleSystem.prototype.init = function (positionMatrix, orientationMatrix, scalingMatrix, velocityMatrix, emitters, duration, keepAlive, carriesParticles, relativeOrientation, minimumCountForInstancing, particleCountFactor) {
        renderableObjects.RenderableObject3D.prototype.init.call(this, null, false, true, positionMatrix, orientationMatrix, scalingMatrix, undefined, 1, true);
        this._velocityMatrix = velocityMatrix;
        this._emitters = emitters;
        this._age = 0;
        this._duration = duration;
        this._keepAlive = (keepAlive === true);
        this._carriesParticles = (carriesParticles === true);
        this._hasRelativeOrientation = (relativeOrientation === true);
        this._minimumCountForInstancing = minimumCountForInstancing;
        this._particleCountFactor = (particleCountFactor !== undefined) ? particleCountFactor : 1;
        this._calculateSize();
    };
    /**
     */
    ParticleSystem.prototype._calculateSize = function () {
        var i, result = 0;
        for (i = 0; i < this._emitters.length; i++) {
            result = Math.max(result, this._emitters[i].getSize());
        }
        this.setSize(result);
    };
    /**
     * In case the orientation changes, needs to invalidate the world velocity direction vectors of carried particles.
     */
    ParticleSystem.prototype._handleOrientationChanged = function () {
        var node;
        if (this._carriesParticles && this.getNode()) {
            for (node = this.getNode().getSubnodes().getFirst(); node; node = node.next) {
                node.getRenderableObject().invalidateWorldVelocityDirectionVector();
            }
        }
    };
    /**
     * @override
     * Always false, as particle system object itself is never rendered, only the particles it has emitted.
     * @param {RenderParameters} renderParameters
     * @returns {Boolean}
     */
    ParticleSystem.prototype.shouldBeRendered = function (renderParameters) {
        this.updateVisibleSize(renderParameters, false); // visible size needs to be updated during shouldBeRendered()
                                                         // so that based on it the particles can decide if they are to be rendered   
        return false;
    };
    /**
     * @override
     * Emits the particles and translates the position of the particle system if it has a velocity.
     * @param {Number} dt
     */
    ParticleSystem.prototype.performAnimate = function (dt) {
        var i, j, particles, modelMatrix, orientationMatrix;
        if ((!this._keepAlive) && (this._age > this._duration)) {
            this.getNode().markAsReusable(true);
            return;
        }
        this._age += dt;
        if (this._emitters) {
            for (i = 0; i < this._emitters.length; i++) {
                particles = this._emitters[i].emitParticles(dt, this._particleCountFactor);
                if (this._carriesParticles) {
                    for (j = 0; j < particles.length; j++) {
                        this.getNode().addSubnode(particles[j].getNode() || new sceneGraph.RenderableNode(particles[j], false, false, this._minimumCountForInstancing));
                    }
                } else if (this._hasRelativeOrientation) {
                    modelMatrix = this.getModelMatrix();
                    orientationMatrix = mat.matrix3from4Aux(modelMatrix);
                    for (j = 0; j < particles.length; j++) {
                        particles[j].translateByMatrix(modelMatrix);
                        particles[j].rotateByMatrix3(orientationMatrix);
                        this.getNode().getScene().addNode(particles[j].getNode() || new sceneGraph.RenderableNode(particles[j], false, false, this._minimumCountForInstancing));
                    }
                } else {
                    modelMatrix = this.getModelMatrix();
                    for (j = 0; j < particles.length; j++) {
                        particles[j].translateByMatrix(modelMatrix);
                        this.getNode().getScene().addNode(particles[j].getNode() || new sceneGraph.RenderableNode(particles[j], false, false, this._minimumCountForInstancing));
                    }
                }
            }
        }
        this.translatev(vec.scale3(mat.translationVector3(this._velocityMatrix), dt / 1000));
    };
    /**
     * Ceases emitting particles and clears the particle system for reuse when all last particles are gone.
     */
    ParticleSystem.prototype.finishEmitting = function () {
        var remainingDuration = 0, i, emitterParticleDuration;
        this._keepAlive = false;
        if (this._carriesParticles) {
            // if called multiple times, the emitter will already be deleted - no need to do anything
            if (this._emitters) {
                // set the system up to last as long as the longest particle duration, without any emitters
                this._age = 0;
                for (i = 0; i < this._emitters.length; i++) {
                    emitterParticleDuration = this._emitters[i].getParticleDuration();
                    if (emitterParticleDuration > remainingDuration) {
                        remainingDuration = emitterParticleDuration;
                    }
                }
                this._emitters = null;
                this._duration = remainingDuration;
            }
        } else {
            this._duration = 0;
            this.getNode().markAsReusable(true);
        }
    };
    /**
     * Adds the resources needed to render this particle system to the passed managed context
     * @param {ManagedGLContext} context
     */
    ParticleSystem.prototype.addToContext = function (context) {
        var i;
        for (i = 0; i < this._emitters.length; i++) {
            this._emitters[i].addToContext(context);
        }
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        ParticleEmitter: ParticleEmitter,
        OmnidirectionalParticleEmitter: OmnidirectionalParticleEmitter,
        UnidirectionalParticleEmitter: UnidirectionalParticleEmitter,
        PlanarParticleEmitter: PlanarParticleEmitter,
        ParticleSystem: ParticleSystem
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides some constants to be used in other game logic modules
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define */

define('armada/logic/constants',[],function () {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // constants
            /**
             * Static lights anchored to spacecrafts will be added to their scenes with this priority
             * @type Number
             */
            SPACECRAFT_LIGHT_PRIORITY = 0,
            /**
             * Lights sources for explosions will be added to their scenes with this priority
             * @type Number
             */
            EXPLOSION_LIGHT_PRIORITY = 1,
            /**
             * Lights sources for projectiles will be added to their scenes with this priority
             * @type Number
             */
            PROJECTILE_LIGHT_PRIORITY = 2,
            /**
             * Lights sources for missiles will be added to their scenes with this priority
             * @type Number
             */
            MISSILE_LIGHT_PRIORITY = 3,
            /**
             * Lights sources for blinking lights on spacecrafts will be added to their scenes with this priority
             * @type Number
             */
            BLINKER_LIGHT_PRIORITY = 4,
            /**
             * Name of the pool for reusable Particle instances
             * @type String
             */
            PARTICLE_POOL_NAME = "Particle",
            /**
             * Name of the pool for reusable Projectile instances
             * @type String
             */
            PROJECTILE_POOL_NAME = "Projectile",
            /**
             * Name of the pool for reusable Missile instances
             * @type String
             */
            MISSILE_POOL_NAME = "Missile",
            /**
             * Name of the pool for reusable TrailSegment instances
             * @type String
             */
            TRAIL_SEGMENT_POOL_NAME = "TrailSegment",
            /**
             * Name of the pool for reusable Explosion instances
             * @type String
             */
            EXPLOSION_POOL_NAME = "Explosion";
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        SPACECRAFT_LIGHT_PRIORITY: SPACECRAFT_LIGHT_PRIORITY,
        EXPLOSION_LIGHT_PRIORITY: EXPLOSION_LIGHT_PRIORITY,
        PROJECTILE_LIGHT_PRIORITY: PROJECTILE_LIGHT_PRIORITY,
        MISSILE_LIGHT_PRIORITY: MISSILE_LIGHT_PRIORITY,
        BLINKER_LIGHT_PRIORITY: BLINKER_LIGHT_PRIORITY,
        PARTICLE_POOL_NAME: PARTICLE_POOL_NAME,
        PROJECTILE_POOL_NAME: PROJECTILE_POOL_NAME,
        MISSILE_POOL_NAME: MISSILE_POOL_NAME,
        TRAIL_SEGMENT_POOL_NAME: TRAIL_SEGMENT_POOL_NAME,
        EXPLOSION_POOL_NAME: EXPLOSION_POOL_NAME
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Implementation of the Explosion game-logic-level class
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Element, Float32Array, performance */

/**
 * @param vec Vector operations are needed for several logic functions
 * @param mat Matrices are widely used for 3D simulation
 * @param application Used for file loading and logging functionality
 * @param resources Used to access the loaded media (graphics and sound) resources
 * @param pools Used to access the common pool of particles
 * @param renderableObjects Used for creating visual models for game objects
 * @param lights Used for creating light sources for game objects
 * @param sceneGraph Creating and managing the scene graph for visual simulation is done using this module
 * @param particleSystem Used for creating particle systems for explosions
 * @param graphics Used to access graphics settings
 * @param classes Used to load and access the classes of Interstellar Armada
 * @param config Used to access game settings/configuration
 * @param constants Used to access the light priority of explosions and pool names
 */
define('armada/logic/explosion',[
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/media-resources",
    "modules/pools",
    "modules/scene/renderable-objects",
    "modules/scene/lights",
    "modules/scene/scene-graph",
    "modules/scene/particle-system",
    "armada/graphics",
    "armada/logic/classes",
    "armada/configuration",
    "armada/logic/constants",
    "utils/polyfill"
], function (
        vec, mat,
        application, resources, pools,
        renderableObjects, lights, sceneGraph, particleSystem,
        graphics, classes, config,
        constants) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // constants
            /**
             * When adding the resources of an explosion (class) to a scene, this prefix is used in the ID to avoid adding the same one multiple
             * times
             * @type String
             */
            RESOURCE_ID_PREFIX = "explosion/",
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * A cached value of whether dynamic lights are turned on / available
             * @type Boolean
             */
            _dynamicLights = false,
            /**
             * Cached value of the configuration setting of the same name (see configuration.json)
             * @type Number
             */
            _hitSoundStackingTimeThreshold,
            /**
             * Cached value of the configuration setting of the same name (see configuration.json)
             * @type Number
             */
            _hitSoundStackingVolumeFactor,
            /**
             * A pool containing dynamic particles (such as particles for muzzle flashes and explosions) for reuse, so that creation of
             * new particle objects can be decreased for optimization.
             * @type Pool
             */
            _particlePool,
            /**
             * A pool containing explosions for reuse, so that creation of new explosion objects can be decreased for optimization.
             * @type Pool
             */
            _explosionPool,
            /**
             * Cached value of the configuration setting of minimum number of particles that should trigger their instanced rendering.
             * @type Number
             */
            _minimumParticleCountForInstancing = 0;
    // ------------------------------------------------------------------------------
    // public functions
    /**
     * Needs to be executed whenever the settings in the graphics module change
     */
    function handleGraphicsSettingsChanged() {
        _dynamicLights = graphics.areDynamicLightsAvailable() && (graphics.getMaxPointLights() > 0);
    }
    /**
     * Returns an explosion object instance that can be (re)used - creating a new one only if needed.
     * @returns {Explosion}
     */
    function getExplosion() {
        return _explosionPool.getObject();
    }
    // ##############################################################################
    /**
     * @class Logic domain class used for explosions and fires. Uses a particle system for
     * the visual model.
     * @param {ExplosionClass} explosionClass The class that contains the general attributes of the
     * type of explosion the instance represents.
     * @param {Float32Array} [positionMatrix] 4x4 translation matrix used to set the position of the visual model (meters)
     * @param {Float32Array} [orientationMatrix] 4x4 rotation matrix used to set the orientation of the visual model
     * @param {Number[3]} direction This vector will be used to set the direction of the particle emitters (which can emit
     * particles towards or perpendicular to this vector)
     * @param {Boolean} carriesParticles If true, the particles emitted by the explosion will belong to it as subnodes,
     * and change position and/or orientation with it, even after they have been emitted
     * @param {Boolean} [relativeOrientation=false] When the particles are not carried, whether to rotate them according to
     * the orientation set for the system when created
     * @param {Float32Array} [velocityMatrix] A 4x4 translation matrix describing the velocity of this explosion in world space, m/s.
     * @param {Boolean} [ignoreParticleCountFactor=false] Whether to always emit the number of particles defined by the emitters,
     * ignoring the particleCountFactor setting value
     */
    function Explosion(explosionClass, positionMatrix, orientationMatrix, direction, carriesParticles, relativeOrientation, velocityMatrix, ignoreParticleCountFactor) {
        /**
         * The class that contains the general attributes of the type of explosion the instance represents.
         * @type ExplosionClass
         */
        this._class = explosionClass;
        /**
         * 4x4 translation matrix used to set the position of the visual model (meters)
         * @type Float32Array
         */
        this._positionMatrix = positionMatrix || mat.identity4();
        /**
         * 4x4 rotation matrix used to set the orientation of the visual model
         * @type Float32Array
         */
        this._orientationMatrix = orientationMatrix || mat.identity4();
        /**
         * This vector is used to set the direction of the particle emitters (which can emit
         * particles towards ("unidirectional") or perpendicular ("planar") to this vector)
         * @type Number[3]
         */
        this._direction = direction;
        /**
         * If true, the particles emitted by the explosion will belong to it as subnodes,
         * and change position and/or orientation with it, even after they have been emitted
         * @type Boolean
         */
        this._carriesParticles = (carriesParticles === true);
        /**
         * When the particles are not carried, whether to rotate them according to
         * the orientation set for the system when created
         * @type Boolean
         */
        this._hasRelativeOrientation = (relativeOrientation === true);
        /**
         * A 4x4 translation matrix describing the velocity of this explosion in world space, m/s.
         * @type Float32Array
         */
        this._velocityMatrix = velocityMatrix || mat.identity4();
        /**
         * Whether to always emit the number of particles defined by the emitters,
         * ignoring the particleCountFactor setting value
         * @type Boolean
         */
        this._ignoreParticleCountFactor = (ignoreParticleCountFactor === true);
        /**
         * Holds a reference to the particle system that is used to visualize the explosion.
         * @type ParticleSystem
         */
        this._visualModel = null;
    }
    /**
     * Initializes all properties of this explosion.
     * @param {ExplosionClass} explosionClass The class that contains the general attributes of the
     * type of explosion the instance represents.
     * @param {Float32Array} positionMatrix 4x4 translation matrix used to set the position of the visual model (meters)
     * @param {Float32Array} orientationMatrix 4x4 rotation matrix used to set the orientation of the visual model
     * @param {Number[3]} direction This vector will be used to set the direction of the particle emitters (which can emit
     * particles towards or perpendicular to this vector)
     * @param {Boolean} carriesParticles If true, the particles emitted by the explosion will belong to it as subnodes,
     * and change position and/or orientation with it, even after they have been emitted
     * @param {Boolean} [relativeOrientation=false] When the particles are not carried, whether to rotate them according to
     * the orientation set for the system when created
     * @param {Float32Array} [velocityMatrix] A 4x4 translation matrix describing the velocity of this explosion in world space, m/s.
     * @param {Boolean} [ignoreParticleCountFactor=false] Whether to always emit the number of particles defined by the emitters,
     * ignoring the particleCountFactor setting value
     */
    Explosion.prototype.init = function (explosionClass, positionMatrix, orientationMatrix, direction, carriesParticles, relativeOrientation, velocityMatrix, ignoreParticleCountFactor) {
        this._class = explosionClass;
        mat.copyTranslation4(this._positionMatrix, positionMatrix);
        mat.setMatrix4(this._orientationMatrix, orientationMatrix);
        this._direction = direction;
        this._carriesParticles = (carriesParticles === true);
        this._hasRelativeOrientation = (relativeOrientation === true);
        this._ignoreParticleCountFactor = (ignoreParticleCountFactor === true);
        mat.copyTranslation4(this._velocityMatrix, velocityMatrix || mat.IDENTITY4);
    };
    /**
     * Creates a new particle system to be used as the visual model for this explosion. Safe to be called on Explosion objects that have not
     * been set up yet, so that the visual model objects can be created in advance.
     * @param {Number} [scale] For the scaling of the visual model
     * @param {ParticleEmitter[]} [particleEmitters] 
     */
    Explosion.prototype.createVisualModel = function (scale, particleEmitters) {
        this._visualModel = new particleSystem.ParticleSystem(
                this._positionMatrix,
                this._orientationMatrix,
                scale ? mat.scaling4(scale) : mat.identity4(),
                this._velocityMatrix,
                particleEmitters || [],
                this._class ? this._class.getTotalDuration() : 0,
                this._class ? this._class.isContinuous() : false,
                this._carriesParticles,
                this._hasRelativeOrientation,
                _minimumParticleCountForInstancing,
                this._ignoreParticleCountFactor ? 1 : graphics.getParticleCountFactor());
    };
    /**
     * Returns whether this explosion object instance is no longer needed for its current use, and can be reused.
     * @returns {Boolean}
     */
    Explosion.prototype.canBeReused = function () {
        return this._visualModel && this._visualModel.canBeReused();
    };
    /**
     * Returns a function that constructs and returns a particle object based on the 
     * particle emitter descriptor of the given index.
     * @param {Number} index The index of the particle emitter descriptor to use
     * @returns {Function} A function that takes no parameters and returns a new instance of 
     * a Particle, and can be used as the particle constructor function for the particle
     * emitter created based on the particle emitter descriptor of the given index.
     */
    Explosion.prototype.getEmitterParticleConstructor = function (index) {
        var emitterDescriptor = this._class.getParticleEmitterDescriptors()[index],
                model = emitterDescriptor.getModel(),
                shader = emitterDescriptor.getShader(),
                textures = emitterDescriptor.getTexturesOfTypes(emitterDescriptor.getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                states = emitterDescriptor.getParticleStates(),
                instancedShader = emitterDescriptor.getInstancedShader();
        return function () {
            var particle = _particlePool.getObject();
            particle.init(
                    model,
                    shader,
                    textures,
                    mat.IDENTITY4,
                    states,
                    false,
                    instancedShader);
            return particle;
        }.bind(this);
    };
    /**
     * Returns the particle system that is used to represent this explosion.
     * @returns {ParticleSystem}
     */
    Explosion.prototype.getVisualModel = function () {
        return this._visualModel;
    };
    /**
     * Sets up the renderable object that can be used to represent this explosion in a visual scene.
     * @param {Number} [scale] The scaling to use for the positions of the particles
     */
    Explosion.prototype._initVisualModel = function (scale) {
        var i, particleEmitters, emitter, particleEmitterDescriptors;
        particleEmitters = [];
        particleEmitterDescriptors = this._class.getParticleEmitterDescriptors();
        for (i = 0; i < particleEmitterDescriptors.length; i++) {
            switch (particleEmitterDescriptors[i].getType()) {
                case classes.ParticleEmitterType.OMNIDIRECTIONAL:
                    emitter = new particleSystem.OmnidirectionalParticleEmitter(
                            mat.IDENTITY4, // as of now, cannot be modified (no setter), so no problem - later could be initialised from JSON
                            mat.IDENTITY4, // as of now, cannot be modified (no setter), so no problem - later could be initialised from JSON
                            particleEmitterDescriptors[i].getDimensions(),
                            particleEmitterDescriptors[i].getVelocity(),
                            particleEmitterDescriptors[i].getVelocitySpread(),
                            particleEmitterDescriptors[i].getInitialNumber(),
                            particleEmitterDescriptors[i].getSpawnNumber(),
                            particleEmitterDescriptors[i].getSpawnTime(),
                            particleEmitterDescriptors[i].getDuration(),
                            particleEmitterDescriptors[i].getDelay(),
                            this.getEmitterParticleConstructor(i));
                    break;
                case classes.ParticleEmitterType.UNIDIRECTIONAL:
                    emitter = new particleSystem.UnidirectionalParticleEmitter(
                            mat.IDENTITY4, // see above
                            mat.IDENTITY4, // see above
                            particleEmitterDescriptors[i].getDimensions(),
                            this._direction,
                            particleEmitterDescriptors[i].getDirectionSpread(),
                            particleEmitterDescriptors[i].getVelocity(),
                            particleEmitterDescriptors[i].getVelocitySpread(),
                            particleEmitterDescriptors[i].getInitialNumber(),
                            particleEmitterDescriptors[i].getSpawnNumber(),
                            particleEmitterDescriptors[i].getSpawnTime(),
                            particleEmitterDescriptors[i].getDuration(),
                            particleEmitterDescriptors[i].getDelay(),
                            this.getEmitterParticleConstructor(i));
                    break;
                case classes.ParticleEmitterType.PLANAR:
                    emitter = new particleSystem.PlanarParticleEmitter(
                            mat.IDENTITY4, // see above
                            mat.IDENTITY4, // see above
                            particleEmitterDescriptors[i].getDimensions(),
                            this._direction,
                            particleEmitterDescriptors[i].getDirectionSpread(),
                            particleEmitterDescriptors[i].getVelocity(),
                            particleEmitterDescriptors[i].getVelocitySpread(),
                            particleEmitterDescriptors[i].getInitialNumber(),
                            particleEmitterDescriptors[i].getSpawnNumber(),
                            particleEmitterDescriptors[i].getSpawnTime(),
                            particleEmitterDescriptors[i].getDuration(),
                            particleEmitterDescriptors[i].getDelay(),
                            this.getEmitterParticleConstructor(i));
                    break;
                default:
                    application.crash();
            }
            particleEmitters.push(emitter);
        }
        if (!this._visualModel) {
            this.createVisualModel(scale, particleEmitters);
        } else {
            this._visualModel.init(
                    this._positionMatrix,
                    this._orientationMatrix,
                    scale ? mat.scaling4Aux(scale) : mat.IDENTITY4,
                    this._velocityMatrix,
                    particleEmitters,
                    this._class.getTotalDuration(),
                    this._class.isContinuous(),
                    this._carriesParticles,
                    this._hasRelativeOrientation,
                    _minimumParticleCountForInstancing,
                    this._ignoreParticleCountFactor ? 1 : graphics.getParticleCountFactor());
        }
    };
    /**
     * Adds the explosion to a scene immediately (assuming its resources have already been loaded)
     * @param {RenderableNode} parentNode See addToScene()
     * @param {SoundSource} [soundSource] See addToScene()
     * @param {Boolean} [isHit=false] See addToScene()
     * @param {Function} [callback] See addToScene()
     */
    Explosion.prototype.addToSceneNow = function (parentNode, soundSource, isHit, callback) {
        var lightStates, scene = parentNode.getScene();
        this._initVisualModel(1 / parentNode.getRenderableObject().getCascadeScalingMatrix()[0]);
        parentNode.addSubnode(this._visualModel.getNode() || new sceneGraph.RenderableNode(this._visualModel, false));
        if (_dynamicLights) {
            lightStates = this._class.getLightStates();
            if (lightStates) {
                scene.addPointLightSource(
                        new lights.PointLightSource(lightStates[0].color, lightStates[0].intensity, vec.NULL3, [this._visualModel], lightStates),
                        constants.EXPLOSION_LIGHT_PRIORITY);
            }
        }
        this._class.playSound(soundSource, isHit, _hitSoundStackingTimeThreshold, _hitSoundStackingVolumeFactor);
        if (callback) {
            callback(this._visualModel);
        }
    };
    /**
     * Adds a renderable node and light source representing this explosion and plays the sound of the explosion.
     * @param {RenderableNode} parentNode The explosion will be added to the scene graph as the subnode of this node
     * @param {SoundSource} [soundSource] If the sound of the explosion should be played by a 3D sound source, pass it here
     * @param {Boolean} [isHit=false] Whether this explosion is marking a hit - which will enable stacking of the sound effect
     * @param {Function} [callback] Called after the explosion has been added to the scene, with the created visual model passed in as its 
     * single argument
     */
    Explosion.prototype.addToScene = function (parentNode, soundSource, isHit, callback) {
        resources.executeWhenReady(this.addToSceneNow.bind(this, parentNode, soundSource, isHit, callback));
    };
    /**
     * Adds the resources required to render this explosion to the passed scene,
     * so they get loaded at the next resource load as well as added to any context
     * the scene is added to.
     * @param {Scene} scene
     */
    Explosion.prototype.addResourcesToScene = function (scene) {
        var resourceID = RESOURCE_ID_PREFIX + this._class.getName();
        this._class.acquireResources({sound: true});
        resources.executeWhenReady(function () {
            if (!scene.hasResourcesOfObject(resourceID)) {
                this._initVisualModel();
                scene.addResourcesOfObject(this._visualModel, resourceID);
            }
        }.bind(this));
    };
    /**
     * Cancels the explosion without deleting the already created particles.
     */
    Explosion.prototype.finish = function () {
        this._visualModel.finishEmitting();
    };
    /**
     * Cancels the held references and marks the renderable object as reusable.
     */
    Explosion.prototype.destroy = function () {
        this._class = null;
        this._positionMatrix = null;
        this._orientationMatrix = null;
        this._direction = null;
        if (this._visualModel) {
            this._visualModel.getNode().markAsReusable(true);
        }
        this._visualModel = null;
    };
    // initialization
    // obtaining pool references
    _particlePool = pools.getPool(constants.PARTICLE_POOL_NAME, renderableObjects.Particle);
    _explosionPool = pools.getPool(constants.EXPLOSION_POOL_NAME, Explosion);
    // caching configuration settings
    config.executeWhenReady(function () {
        _hitSoundStackingTimeThreshold = config.getSetting(config.BATTLE_SETTINGS.HIT_SOUND_STACKING_TIME_THRESHOLD);
        _hitSoundStackingVolumeFactor = config.getSetting(config.BATTLE_SETTINGS.HIT_SOUND_STACKING_VOLUME_FACTOR);
        _minimumParticleCountForInstancing = config.getSetting(config.BATTLE_SETTINGS.MINIMUM_PARTICLE_COUNT_FOR_INSTANCING);
        graphics.executeWhenReady(handleGraphicsSettingsChanged);
        graphics.onSettingsChange(handleGraphicsSettingsChanged);
    });
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        getExplosion: getExplosion,
        Explosion: Explosion
    };
});
/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Implementation of loading and managing environments
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Element, Float32Array, performance, localStorage */

/**
 * @param utils Used for format strings and useful constants
 * @param vec Vector operations are needed for several logic functions
 * @param mat Matrices are widely used for 3D simulation
 * @param application Used for file loading and logging functionality
 * @param asyncResource LogicContext is a subclass of AsyncResource
 * @param resources Used to access the loaded media (graphics and sound) resources
 * @param renderableObjects Used for creating visual models for game objects
 * @param lights Used for creating light sources for game objects and environments
 * @param sceneGraph Creating and managing the scene graph for visual simulation is done using this module
 * @param graphics Used to access graphics settings
 * @param classes Used to load and access the classes of Interstellar Armada
 * @param explosion Used to create particle effects
 * @param config Used to access game settings/configuration
 * @param strings Used for translation support
 */
define('armada/logic/environments',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/async-resource",
    "modules/media-resources",
    "modules/scene/renderable-objects",
    "modules/scene/lights",
    "modules/scene/scene-graph",
    "armada/graphics",
    "armada/logic/classes",
    "armada/logic/explosion",
    "armada/configuration",
    "armada/strings",
    "utils/polyfill"
], function (
        utils, vec, mat,
        application, asyncResource, resources,
        renderableObjects, lights, sceneGraph,
        graphics, classes, explosion, config, strings) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // constants
            /**
             * When executing callbacks for all environments, this string is passed as the category parameter.
             * @type String
             */
            ENVIRONMENTS_CATEGORY_NAME = "environments",
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * The context storing the current settings and game data that can be accessed through the interface of this module
             * @type EnvironmentContext
             */
            _context,
            /**
             * This string is available to other modules through a public function so that an arbitrary piece of information from this 
             * module can be exposed for debug purposes.
             * @type String
             */
            _debugInfo = "";
    // -------------------------------------------------------------------------
    // Public functions
    /**
     * Queries a module-level string for debug purposes.
     * @returns {String}
     */
    function getDebugInfo() {
        return _debugInfo;
    }
    // ##############################################################################
    /**
     * @class Represents a skybox that can be added to a scene to render the
     * background using a cube mapped texture defined by the passed class of the
     * skybox.
     * @param {SkyboxClass} skyboxClass
     */
    function Skybox(skyboxClass) {
        /**
         * The class storing the general characteristics of this skybox.
         * @type SkyboxClass
         */
        this._class = skyboxClass;
    }
    /**
     * Adds a background FVQ object to the passed scene and sets it up according
     * the properties of this skybox.
     * @param {Scene} scene
     */
    Skybox.prototype.addToScene = function (scene) {
        this._class.acquireResources();
        resources.executeWhenReady(function () {
            scene.addBackgroundObject(new renderableObjects.CubemapSampledFVQ(
                    this._class.getModel(),
                    this._class.getShader(),
                    this._class.getShader().getCubemapNames()[0],
                    this._class.getCubemap(graphics.getCubemapQualityPreferenceList()),
                    scene.getCamera()));
        }.bind(this));
    };
    /**
     * Removes all references to other objects for proper cleanup of memory.
     */
    Skybox.prototype.destroy = function () {
        this._class = null;
    };
    // ##############################################################################
    /**
     * Represents an "infinitely far away" object in space (typically a star)
     * that serves as a light source as well as is rendered as a set of 2D texture
     * layers on the background.
     * @param {BackgroundObjectClass} backgroundObjectClass
     * @param {Number} size The factor to scale the background object with
     * @param {Number} degreesAlpha The angle between the positive X axis and the
     * direction in which this object is positioned on the XZ plane in degrees.
     * @param {Number} degreesBeta The angle between the XZ plane and the
     * direction in which this object is positioned.
     * @param {Number} degreesGamma  The angle by which the object is rotated around its
     * center in 2D (in case it has a fixed orientation), in degrees.
     */
    function BackgroundObject(backgroundObjectClass, size, degreesAlpha, degreesBeta, degreesGamma) {
        /**
         * The class storing the general characteristics of this object.
         * @type BackgroundObjectClass
         */
        this._class = backgroundObjectClass;
        /**
         * The background object will be scaled by this factor
         * @type Number
         */
        this._size = size;
        /**
         * A unit length vector pointing in the direction of this object.
         * @type Number[3]
         */
        this._direction = [
            Math.cos(Math.radians(degreesAlpha)) * Math.cos(Math.radians(degreesBeta)),
            Math.sin(Math.radians(degreesAlpha)) * Math.cos(Math.radians(degreesBeta)),
            Math.sin(Math.radians(degreesBeta))
        ];
        /**
         * The angle by which the object is rotated around its center in 2D (in case it has a 
         * fixed orientation), in degrees.
         * @type Number
         */
        this._angle = Math.radians(degreesGamma) || 0;
    }
    /**
     * Adds the layered texture object and the light source belonging to this
     * object to the passed scene.
     * @param {Scene} scene
     * @param {Boolean} [withoutLight=false]
     */
    BackgroundObject.prototype.addToScene = function (scene, withoutLight) {
        if (!withoutLight && this._class.getLightColor()) {
            scene.addDirectionalLightSource(new lights.DirectionalLightSource(this._class.getLightColor(), this._direction));
        }
        this._class.acquireResources();
        resources.executeWhenReady(function () {
            var i, layers, layerParticle;
            layers = this._class.getLayers();
            for (i = 0; i < layers.length; i++) {
                layerParticle = new renderableObjects.BackgroundBillboard(
                        layers[i].getModel(),
                        layers[i].getShader(),
                        layers[i].getTexturesOfTypes(layers[i].getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                        layers[i].getColor(),
                        layers[i].getSize() * this._size,
                        mat.translation4v(vec.scaled3(this._direction, config.getSetting(config.BATTLE_SETTINGS.BACKGROUND_OBJECT_DISTANCE))),
                        this._angle);
                layerParticle.setRelativeSize(1.0);
                scene.addBackgroundObject(layerParticle);
            }
        }.bind(this));
    };
    /**
     * Removes all references to other objects for proper cleanup of memory.
     */
    BackgroundObject.prototype.destroy = function () {
        this._class = null;
        this._direction = null;
    };
    // ##############################################################################
    /**
     * Creates a dust particle object and adds it to the scene it's cloud it part
     * of right away.
     * @class A tiny piece of dust that is rendered as passing line to indicate the
     * direction and speed of movement to the player.
     * @param {DustCloud} cloud The cloud to which this dust particle belongs.
     * @param {Number[3]} positionVector
     */
    function DustParticle(cloud, positionVector) {
        /**
         * @type Number[3]
         */
        this._positionVector = positionVector;
        /**
         * The renderable object representing this particle in the scene.
         * @type PointParticle
         */
        this._visualModel = null;
        /**
         * @type DustCloud
         */
        this._cloud = cloud;
        /**
         * The distance up to how far away this particle can be from the camera.
         * @type Number
         */
        this._range = cloud.getRange();
    }
    /**
     * Adds the visual model of this particle to a scene, using the passed node
     * as its rendering parent.
     * @param {PointCloud} cloudNode
     * @param {Boolean} addOwnProperties
     */
    DustParticle.prototype.addToScene = function (cloudNode, addOwnProperties) {
        this._visualModel = new renderableObjects.PointParticle(
                this._cloud.getClass().getModel(),
                this._cloud.getClass().getShader(),
                this._cloud.getClass().getInstancedShader(),
                this._positionVector,
                addOwnProperties ? this._cloud.getClass().getColor() : null,
                addOwnProperties ? this._range : 0);
        cloudNode.addSubnode(new sceneGraph.RenderableNode(this._visualModel, false, false, config.getSetting(config.BATTLE_SETTINGS.MINIMUM_DUST_PARTICLE_COUNT_FOR_INSTANCING)));
    };
    /**
     * @returns {PointParticle}
     */
    DustParticle.prototype.getVisualModel = function () {
        return this._visualModel;
    };
    /**
     * Updates the position of the particle to be acound the camera within proper
     * range.
     * @param {Camera} camera The camera relative to which to position the
     * particles.
     */
    DustParticle.prototype.simulate = function (camera) {
        this._visualModel.fitPositionWithinRange(camera.getCameraPositionMatrix(), this._range);
    };
    /**
     * Removes all references to other objects for proper cleanup of memory.
     */
    DustParticle.prototype.destroy = function () {
        this._positionVector = null;
        if (this._visualModel) {
            this._visualModel.getNode().markAsReusable(true);
            this._visualModel = null;
        }
        this._cloud = null;
    };
    // ##############################################################################
    /**
     * @class Represents a dust cloud containing dust particles that can indicate
     * direction and speed of movement of the camera for the player.
     * @param {DustCloudClass} dustCloudClass The class of this cloud, storing
     * it's general properties.
     * @returns {DustCloud}
     */
    function DustCloud(dustCloudClass) {
        /**
         * The class storing the general characteristics of this cloud.
         * @type DustCloudClass
         */
        this._class = dustCloudClass;
        /**
         * The array of particles this cloud consists of.
         * @type DustParticle[]
         */
        this._particles = null;
        /**
         * The renderable object representing this cloud in the scene.
         * @type RenderableObject
         */
        this._visualModel = null;
    }
    /**
     * @returns {DustCloudClass}
     */
    DustCloud.prototype.getClass = function () {
        return this._class;
    };
    /**
     * Returns the range this cloud spans. (the maximum distance of particles
     * from the camera in world space coordinates on any angle)
     * @returns {Number}
     */
    DustCloud.prototype.getRange = function () {
        return this._class.getRange();
    };
    /**
     * Adds the needed objects to the scene to render this dust cloud.
     * @param {sceneGraph} scene
     */
    DustCloud.prototype.addToScene = function (scene) {
        var i, n, particle;
        this._class.acquireResources();
        this._particles = [];
        n = this._class.getNumberOfParticles();
        for (i = 0; i < n; i++) {
            particle = new DustParticle(
                    this,
                    [
                        (Math.random() - 0.5) * 2 * this._class.getRange(),
                        (Math.random() - 0.5) * 2 * this._class.getRange(),
                        (Math.random() - 0.5) * 2 * this._class.getRange()]);
            this._particles.push(particle);
        }
        resources.executeWhenReady(function () {
            var j, node;
            this._visualModel = new renderableObjects.RenderableObject(null, false, false, undefined, false);
            node = scene.addNode(new sceneGraph.RenderableNode(this._visualModel, false, true));
            for (j = 0; j < n; j++) {
                this._particles[j].addToScene(node, j === 0);
            }
        }.bind(this));
    };
    /**
     * Updates the position of the particles in the cloud.
     * @param {Camera} camera The camera around which the cloud should be rendered.
     */
    DustCloud.prototype.simulate = function (camera) {
        var i, n;
        n = this._class.getNumberOfParticles();
        this._particles[0].getVisualModel().setShift(camera.getVelocityVector()[0], camera.getVelocityVector()[1], camera.getVelocityVector()[2]);
        for (i = 0; i < n; i++) {
            this._particles[i].simulate(camera);
        }
    };
    /**
     * Removes all references to other objects for proper cleanup of memory.
     */
    DustCloud.prototype.destroy = function () {
        var i, n;
        n = this._class.getNumberOfParticles();
        this._class = null;
        if (this._particles) {
            for (i = 0; i < n; i++) {
                this._particles[i].destroy();
                this._particles[i] = null;
            }
            this._particles = null;
        }
        if (this._visualModel) {
            this._visualModel.getNode().markAsReusable(true);
            this._visualModel = null;
        }
    };
    // #########################################################################
    /**
     * @typedef {Object} ParticleEffectDescriptor
     * @property {String} class
     * @property {Number[3]} [position]
     * @property {Boolean} [relativeToCamera] Whether the position and orientation
     * of the particle effect needs to be calculated relative to the camera
     * @property {Number[3]} [direction] The direction vector passed to the particle
     * emitters (e.g. unidirectional or planar emitters will use this)
     * @property {Boolean} [relativeDirection] If the effect is relative to the camera,
     * whether to make the direction vector passed to the emitters relative as well
     */
    /**
     * @class
     * An effect that uses a particle system, part of the environment. Can be 
     * positioned relative to the camera or globally in the scene.
     * @param {ParticleEffectDescriptor} dataJSON
     */
    function ParticleEffect(dataJSON) {
        /**
         * The position vector storing the original position (whether relative or
         * absolute) of the effect.
         * @type Number[4]
         */
        this._origin = dataJSON.position ? dataJSON.position.slice() : [0, 0, 0];
        this._origin.push(1);
        /**
         * The calculated current world position of the particle effect (used if
         * the effect is relative to camera)
         * @type Number[4]
         */
        this._position = [0, 0, 0, 1];
        /**
         * If true, the effect is always positioned and oriented relative to the 
         * camera of the scene it is added to
         * @type Boolean
         */
        this._relativeToCamera = (dataJSON.relativeToCamera !== false);
        /**
         * The explosion object managing the particle system
         * @type Explosion
         */
        this._effect = new explosion.Explosion(classes.getExplosionClass(dataJSON.class), this._relativeToCamera ? undefined : mat.translation4v(this._origin), undefined, dataJSON.direction || [0, 0, 1], false, (dataJSON.relativeDirection === true), undefined, true);
    }
    /**
     * Call this before resources are loaded to make sure the resources needed for
     * this particle effect are marked for loading
     * @param {Scene} scene
     */
    ParticleEffect.prototype.addResourcesToScene = function (scene) {
        this._effect.addResourcesToScene(scene);
    };
    /**
     * Call this after the resources have been loaded to add the effect to the passed scene.
     * @param {Scene} scene
     */
    ParticleEffect.prototype.addToScene = function (scene) {
        this._effect.addToScene(scene.getRootNode());
    };
    /**
     * Updates the position and orientation of the effect based on the current state of the
     * passed camera (if relative)
     * @param {Camera} camera
     */
    ParticleEffect.prototype.simulate = function (camera) {
        var orientation;
        if (this._relativeToCamera) {
            vec.setVector4(this._position, this._origin);
            orientation = camera.getCameraOrientationMatrix();
            vec.mulVec4Mat4(this._position, orientation);
            vec.add3(this._position, camera.getCameraPositionVector());
            this._effect.getVisualModel().setPositionv(this._position);
            this._effect.getVisualModel().setOrientationM4(orientation);
        }
    };
    /**
     * Remove all object references from the effect
     */
    ParticleEffect.prototype.destroy = function () {
        this._origin = null;
        this._position = null;
        if (this._effect) {
            this._effect.destroy();
        }
        this._effect = null;
    };
    // #########################################################################
    /**
     * @class Represents an environment that can be used to build a visual 
     * representation and perform the game logic on a virtual environment where 
     * the game takes place.
     * @param {Object} dataJSON If given, the data of the environment will be
     * initialized from this JSON object.
     * @returns {Environment}
     */
    function Environment(dataJSON) {
        /**
         * Identifies the environment
         * @type String
         */
        this._name = null;
        /**
         * The name of the star system this environment is associated with
         * @type String
         */
        this._location = null;
        /**
         * The background color. The scene the environment is added to will be cleared with this color.
         * @tpye Number[4]
         */
        this._color = null;
        /**
         * The list of skyboxes this environment contains as background.
         * @type Skybox[]
         */
        this._skyboxes = null;
        /**
         * The list of background objects (stars, nebulae) this environment contains.
         * @type BackgroundObject[]
         */
        this._backgroundObjects = null;
        /**
         * The list of dust clouds this environment contains.
         * @type DustCloud[]
         */
        this._dustClouds = null;
        /**
         * The list of particle effects this environment contains.
         * @type ParticleEffect[]
         */
        this._particleEffects = null;
        /**
         * Whether the directional lights in the environments should cast shadows (if enabled
         * by the graphics settings)
         * @type Boolean
         */
        this._shadows = false;
        /**
         * The color of the ambient light in this environment
         * @type Number[3]
         */
        this._ambientColor = null;
        /**
         * The coefficient to use for drag forces reducing the velocity of objects in this environment over time.
         * @type Number
         */
        this._drag = 0;
        /**
         * The coefficient to use for drag torques forces reducing the spinning of objects in this environment over time.
         * @type Number
         */
        this._angularDrag = 0;
        /**
         * Missile locking times are multiplied by this factor within this environment
         * @type Number
         */
        this._lockingTimeFactor = 0;
        /**
         * The camera relative to which the environment is rendered.
         * @type Camera
         */
        this._camera = null;
        /**
         * Stores the object this environment was initialized from.
         * @type Object
         */
        this._dataJSON = null;
        // if given, load the data from the JSON object
        if (dataJSON !== undefined) {
            this.loadFromJSON(dataJSON);
        }
    }
    // methods
    /**
     * Loads all the data about this environment stored in the passed JSON object.
     * @param {Object} dataJSON
     */
    Environment.prototype.loadFromJSON = function (dataJSON) {
        var i, backgroundObjectClass;
        this._dataJSON = dataJSON;
        this._name = dataJSON.name;
        this._location = dataJSON.location;
        this._color = dataJSON.color || [0, 0, 0, 0];
        this._skyboxes = [];
        if (dataJSON.skyboxes) {
            for (i = 0; i < dataJSON.skyboxes.length; i++) {
                this._skyboxes.push(new Skybox(classes.getSkyboxClass(dataJSON.skyboxes[i].class)));
            }
        }
        this._backgroundObjects = [];
        if (dataJSON.backgroundObjects) {
            for (i = 0; i < dataJSON.backgroundObjects.length; i++) {
                backgroundObjectClass = classes.getBackgroundObjectClass(dataJSON.backgroundObjects[i].class);
                if (!dataJSON.backgroundObjects[i].position) {
                    application.showError("No position specified for background object of class '" + backgroundObjectClass.getName() + "' in environment '" + this._name + "'!", application.ErrorSeverity.MINOR);
                }
                this._backgroundObjects.push(new BackgroundObject(
                        backgroundObjectClass,
                        dataJSON.backgroundObjects[i].size || application.showError("No size specified for background object of class '" + backgroundObjectClass.getName() + "' in environment '" + this._name + "'!", application.ErrorSeverity.MINOR) || 0,
                        (dataJSON.backgroundObjects[i].position && dataJSON.backgroundObjects[i].position.angleAlpha) || 0,
                        (dataJSON.backgroundObjects[i].position && dataJSON.backgroundObjects[i].position.angleBeta) || 0,
                        (dataJSON.backgroundObjects[i].position && dataJSON.backgroundObjects[i].position.angleGamma) || 0
                        ));
            }
        }
        this._dustClouds = [];
        if (dataJSON.dustClouds) {
            for (i = 0; i < dataJSON.dustClouds.length; i++) {
                this._dustClouds.push(new DustCloud(classes.getDustCloudClass(dataJSON.dustClouds[i].class)));
            }
        }
        this._particleEffects = [];
        if (dataJSON.particleEffects) {
            for (i = 0; i < dataJSON.particleEffects.length; i++) {
                this._particleEffects.push(new ParticleEffect(dataJSON.particleEffects[i]));
            }
        }
        this._shadows = (dataJSON.shadows !== false);
        this._ambientColor = dataJSON.ambientColor || [0, 0, 0];
        this._drag = dataJSON.drag || 0;
        this._angularDrag = dataJSON.angularDrag || 0;
        this._lockingTimeFactor = (dataJSON.lockingTimeFactor !== undefined) ? dataJSON.lockingTimeFactor : 1;
    };
    /**
     * Returns a string that can be displayed to the player to represent this environment as a location for a mission.
     * @returns {String}
     */
    Environment.prototype.getDisplayName = function () {
        return this._location ?
                utils.formatString(strings.get(strings.LOCATION.SYSTEM), {
                    systemName: this._location
                }) :
                strings.get(strings.LOCATION.UNKNOWN);
    };
    /**
     * Whether the directional lights in the environment should cast shadows
     * @returns {Boolean}
     */
    Environment.prototype.hasShadows = function () {
        return this._shadows;
    };
    /**
     * The coefficient used for drag forces reducing the velocity of objects in this environment over time.
     * @returns {Number}
     */
    Environment.prototype.getDrag = function () {
        return this._drag;
    };
    /**
     * The coefficient used for drag torques forces reducing the spinning of objects in this environment over time.
     * @returns {Number}
     */
    Environment.prototype.getAngularDrag = function () {
        return this._angularDrag;
    };
    /**
     * Missile locking times are multiplied by this factor within this environment
     * @returns {Number}
     */
    Environment.prototype.getLockingTimeFactor = function () {
        return this._lockingTimeFactor;
    };
    /**
     * Returns the object this environment was initialized from
     * @returns {Object}
     */
    Environment.prototype.getData = function () {
        return this._dataJSON;
    };
    /**
     * Reinitializes the properties of the environment from the initialization object (use in case the object
     * has been changed - e.g. edited in a development tool - do not use within the game itself!)
     */
    Environment.prototype.reloadData = function () {
        this.loadFromJSON(this._dataJSON);
    };
    /**
     * Adds renderable objects representing all visual elements of the 
     * environment to the passed scene.
     * @param {Scene} scene
     */
    Environment.prototype.addToScene = function (scene) {
        var i;
        scene.setClearColor(this._color);
        for (i = 0; i < this._skyboxes.length; i++) {
            this._skyboxes[i].addToScene(scene);
        }
        for (i = 0; i < this._backgroundObjects.length; i++) {
            this._backgroundObjects[i].addToScene(scene, false);
        }
        for (i = 0; i < this._dustClouds.length; i++) {
            this._dustClouds[i].addToScene(scene);
        }
        for (i = 0; i < this._particleEffects.length; i++) {
            this._particleEffects[i].addResourcesToScene(scene);
        }
        this._camera = scene.getCamera();
        scene.setAmbientColor(this._ambientColor);
    };
    /**
     * This needs to be called after all loading is done and we are ready to start
     * simulating and rendering the scene. Adds the particle systems for the particle
     * effects to the scene.
     * @param {Scene} scene
     * @returns {Boolean} Whether any particle effects have been added
     */
    Environment.prototype.addParticleEffectsToScene = function (scene) {
        var i;
        for (i = 0; i < this._particleEffects.length; i++) {
            this._particleEffects[i].addToScene(scene);
        }
        return this._particleEffects.length > 0;
    };
    /**
     * Performs a simulation step to update the state of the environment.
     */
    Environment.prototype.simulate = function () {
        var i;
        if (this._camera) {
            for (i = 0; i < this._dustClouds.length; i++) {
                this._dustClouds[i].simulate(this._camera);
            }
            for (i = 0; i < this._particleEffects.length; i++) {
                this._particleEffects[i].simulate(this._camera);
            }
        }
    };
    /**
     * Removes references that are only neded while the environment is added to a scene
     */
    Environment.prototype.removeFromScene = function () {
        this._camera = null;
    };
    /*
     * Removes all references held by this environment.
     */
    Environment.prototype.destroy = function () {
        var i;
        if (this._skyboxes) {
            for (i = 0; i < this._skyboxes.length; i++) {
                this._skyboxes[i].destroy();
                this._skyboxes[i] = null;
            }
            this._skyboxes = null;
        }
        if (this._backgroundObjects) {
            for (i = 0; i < this._backgroundObjects.length; i++) {
                this._backgroundObjects[i].destroy();
                this._backgroundObjects[i] = null;
            }
            this._backgroundObjects = null;
        }
        if (this._dustClouds) {
            for (i = 0; i < this._dustClouds.length; i++) {
                this._dustClouds[i].destroy();
                this._dustClouds[i] = null;
            }
            this._dustClouds = null;
        }
        if (this._particleEffects) {
            for (i = 0; i < this._particleEffects.length; i++) {
                this._particleEffects[i].destroy();
                this._particleEffects[i] = null;
            }
            this._particleEffects = null;
        }
        this._camera = null;
    };
    // #########################################################################
    /**
     * @class A class responsible for loading and storing game logic related 
     * settings and data as well and provide an interface to access them.
     * @extends AsyncResource
     */
    function EnvironmentContext() {
        asyncResource.AsyncResource.call(this);
        /**
         * An associative array storing the reusable Environment objects that 
         * describe possible environments for missions. The keys are the names
         * of the environments.
         * @type Object.<String, Environment>
         */
        this._environments = null;
    }
    EnvironmentContext.prototype = new asyncResource.AsyncResource();
    EnvironmentContext.prototype.constructor = EnvironmentContext;
    /**
     * Return the reusable environment with the given name if it exists, otherwise null.
     * @param {String} name
     * @returns {Environment}
     */
    EnvironmentContext.prototype.getEnvironment = function (name) {
        return this._environments[name] || null;
    };
    /**
     * Returns the list of names (IDs) of the loaded environments.
     * @returns {String[]}
     */
    EnvironmentContext.prototype.getEnvironmentNames = function () {
        return Object.keys(this._environments);
    };
    /**
     * Creates a new environment and adds it to the list. Uses the passed JSON for the initialization of the environment
     * @param {Object} dataJSON
     */
    EnvironmentContext.prototype.createEnvironment = function (dataJSON) {
        this._environments[dataJSON.name] = new Environment(dataJSON);
    };
    /**
     * Executes the passed callback function for all the stored environments, passing each environment and a constant category string as the
     * two parameters
     * @param {Function} callback
     */
    EnvironmentContext.prototype.executeForAllEnvironments = function (callback) {
        var i, environmentNames = this.getEnvironmentNames();
        for (i = 0; i < environmentNames.length; i++) {
            callback(this._environments[environmentNames[i]], ENVIRONMENTS_CATEGORY_NAME);
        }
    };
    /**
     * Sends an asynchronous request to grab the file containing the reusable
     * environment descriptions and sets a callback to load those descriptions 
     * and set the resource state of this context to ready when done.
     */
    EnvironmentContext.prototype.requestLoad = function () {
        application.requestTextFile(
                config.getConfigurationSetting(config.CONFIGURATION.ENVIRONMENTS_SOURCE_FILE).folder,
                config.getConfigurationSetting(config.CONFIGURATION.ENVIRONMENTS_SOURCE_FILE).filename,
                function (responseText) {
                    this.loadEnvironmentsFromJSON(JSON.parse(responseText));
                    this.setToReady();
                }.bind(this));
    };
    /**
     * Loads the desciptions of all reusable environments from the passed JSON object,
     *  creates and stores all the objects for them.
     * @param {Object} dataJSON
     */
    EnvironmentContext.prototype.loadEnvironmentsFromJSON = function (dataJSON) {
        var i, environment;
        this._environments = {};
        for (i = 0; i < dataJSON.environments.length; i++) {
            environment = new Environment(dataJSON.environments[i]);
            this._environments[dataJSON.environments[i].name] = environment;
        }
    };
    // initializazion
    // creating the default context
    _context = new EnvironmentContext();
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        requestLoad: _context.requestLoad.bind(_context),
        executeWhenReady: _context.executeWhenReady.bind(_context),
        getDebugInfo: getDebugInfo,
        getEnvironment: _context.getEnvironment.bind(_context),
        getEnvironmentNames: _context.getEnvironmentNames.bind(_context),
        createEnvironment: _context.createEnvironment.bind(_context),
        executeForAllEnvironments: _context.executeForAllEnvironments.bind(_context),
        Skybox: Skybox,
        BackgroundObject: BackgroundObject,
        Environment: Environment
    };
});
/**
 * Copyright 2014-2017, 2020 Krisztián Nagy
 * @file Provides functions to add and access HTML screens of the application.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define */

/**
 * @param asyncResource ScreenManager is an AsyncResource as it tracks the loading state of the screens it manages
 * @param application Used to display error messages
 */
define('modules/screen-manager',[
    "modules/async-resource",
    "modules/application"
], function (asyncResource, application) {
    "use strict";
    /**
     * The screen manager instance used to store and access screens
     * @type ScreenManager
     */
    var _screenManager;
    /**
     * @class
     * @extends AsyncResource
     */
    function ScreenManager() {
        asyncResource.AsyncResource.call(this);
        /**
         * The game's available screens stored in an associative array, with the 
         * keys being the names of the screens.
         * @type Object.<String, HTMLScreen>
         * @default {}
         */
        this._screens = {};
        /**
         * The list of screens that have been covered by superimposing (instead of
         * switching to) other pages on top.
         * @type HTMLScreen[]
         * @default []
         */
        this._coveredScreens = [];
        /**
         * A reference to the currently active (displayed) screen of the game.
         * @type HTMLScreen
         * @default null
         */
        this._currentScreen = null;
        /**
         * How many screens have been loaded and are ready to use so far
         * @type Number
         */
        this._screensLoaded = 0;
        /**
         * How many screens need to be loaded total
         * @type Number
         */
        this._screensToLoad = 0;
    }
    ScreenManager.prototype = new asyncResource.AsyncResource();
    ScreenManager.prototype.constructor = ScreenManager;
    /**
     * Returns the game screen with the specified name that the game has.
     * @param {String} screenName
     * @returns {HTMLScreen}
     */
    ScreenManager.prototype.getScreen = function (screenName) {
        return screenName ?
                this._screens[screenName] :
                this._currentScreen;
    };
    /**
     * Adds a new screen to the list that can be set as current later.
     * @param {HTMLScreen} screen The new game screen to be added.
     * @param {Boolean} [addBackground=false] Whether to add a background <div>
     * next to the screen container <div> that can be used when the screen is
     * superimposed on other screens
     * @param {Boolean} [keepModelAfterAdding=false] Whether to keep storing the original DOM model
     * of the screen after adding it to the current document (so that it can be added again later)
     */
    ScreenManager.prototype.addScreen = function (screen, addBackground, keepModelAfterAdding) {
        var onScreenReadyFunction = function () {
            this._screensLoaded++;
            if (this._screensLoaded === this._screensToLoad) {
                this.setToReady();
            }
        }.bind(this);
        this.resetReadyState();
        this._screensToLoad++;
        this._screens[screen.getName()] = screen;
        screen.addScreenToPage(onScreenReadyFunction, addBackground, keepModelAfterAdding);
        if (!this._currentScreen) {
            this._currentScreen = screen;
            this._currentScreen.setActive(true);
        }
    };
    /**
     * Sets the current game screen to the one with the specified name (from the
     * list of available screens), including updating the HTML body.
     * @param {String} screenName
     * @param {Boolean} [superimpose=false] Whether the screen should be 
     * superimposed on top of the current one.
     * @param {Number[4]} [backgroundColor] The color of the background in case the
     * screen is set superimposed. @see HTMLScreen#superimposeOnPage
     */
    ScreenManager.prototype.setCurrentScreen = function (screenName, superimpose, backgroundColor) {
        var i, screen = this.getScreen(screenName);
        if (!screen) {
            application.showError("Cannot switch to screen '" + screenName + "', because it does not exist!");
            return;
        }
        if ((superimpose !== true) && (this._currentScreen !== null)) {
            this._currentScreen.hide();
            for (i = 0; i < this._coveredScreens.length; i++) {
                this._coveredScreens[i].hide();
            }
        }
        if (superimpose === true) {
            this._coveredScreens.push(this._currentScreen);
            this._currentScreen.setActive(false);
            this._currentScreen = screen;
            screen.superimposeOnPage(backgroundColor);
        } else {
            this._currentScreen = screen;
            screen.show();
        }
        // the show event handler of the screen might set/superimpose a new screen, in which case it should not be set active
        if (this._currentScreen === screen) {
            this._currentScreen.setActive(true);
        }
    };
    /**
     * Closes the topmost superimposed screen, revealing the one below.
     */
    ScreenManager.prototype.closeSuperimposedScreen = function () {
        this._currentScreen.hide();
        this._currentScreen = this._coveredScreens.pop();
        this._currentScreen.setActive(true);
    };
    /**
     * If the current screen was superimposed, closes it, otherwise simply navigates to
     * (sets) the screen with the given name.
     * @param {String} screenName
     */
    ScreenManager.prototype.closeOrNavigateTo = function (screenName) {
        if (this._currentScreen.isSuperimposed()) {
            this.closeSuperimposedScreen();
        } else {
            this.setCurrentScreen(screenName);
        }
    };
    /**
     * Updates the components on all screens to reflect the application's current state.
     */
    ScreenManager.prototype.updateAllScreens = function () {
        var screenName;
        for (screenName in this._screens) {
            if (this._screens.hasOwnProperty(screenName)) {
                this._screens[screenName].updateScreen();
            }
        }
    };
    _screenManager = new ScreenManager();
    return {
        getScreen: _screenManager.getScreen.bind(_screenManager),
        addScreen: _screenManager.addScreen.bind(_screenManager),
        setCurrentScreen: _screenManager.setCurrentScreen.bind(_screenManager),
        closeSuperimposedScreen: _screenManager.closeSuperimposedScreen.bind(_screenManager),
        closeOrNavigateTo: _screenManager.closeOrNavigateTo.bind(_screenManager),
        updateAllScreens: _screenManager.updateAllScreens.bind(_screenManager),
        executeWhenReady: _screenManager.executeWhenReady.bind(_screenManager)
    };
});
/**
 * Copyright 2014-2017, 2020 Krisztián Nagy
 * @file This module builds on Application to provide a template for creating games.
 * To use, just augment this module, calling
 * - setGameName()
 * - setStartScreenName()
 * - setConfigFolder()
 * - setConfigFileName()
 * with the appropriate parameters and overriding
 * - _loadGameSettingsAndExecuteCallback()
 * - _loadGameConfigurationAndExecuteCallback()
 * - _buildScreensAndExecuteCallback()
 * with the appropriate operations.
 * The, call initialize() to run the game.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, requirejs, location, document, JSON */

/**
 * @param application This module augments the generic application module
 * @param screenManager Used to provide and further expose screen management for the game
 * @param strings Used to provide internationalization support
 */
define('modules/game',[
    "modules/application",
    "modules/screen-manager",
    "modules/strings"
], function (application, screenManager, strings) {
    "use strict";
    // private variables
    var
            /**
             * Whether the configuration of the game has finished loading
             * @type Boolean
             */
            _configInitComplete = false,
            /**
             * Whether the settings of the game has finished loading
             * @type Boolean
             */
            _settingsInitComplete = false,
            /**
             * Whether the screens of the game has finished loading
             * @type Boolean
             */
            _screenInitComplete = false,
            /**
             * The name of the game to be displayed in logs
             * @type String
             */
            _gameName = null,
            /**
             * The name of the screen that should be displayed when loading the game has finished
             * @type String
             */
            _startScreenName = null,
            /**
             * The URL of the folder where the configuration file is located (relative to the game root folder)
             * @type String
             */
            _configFolder = null,
            /**
             * The name of the configuration JSON file which contains the game version info and folder structure
             * @type String
             */
            _configFileName = null,
            /**
             * Storing the default value for the language setting so that it can be restored if needed
             * @type String
             */
            _defaultLanguage = null,
            /**
             * The associative array of strings files descriptors, storing them by the language IDs
             * @type Object.<String, {folder: String, filename: String}>
             */
            _stringsFileDescriptors = null,
            /**
             * The default cursor style set in CSS for the game
             * @type String
             */
            _defaultCursor = null,
            // -------------------------------------------------------------------------
            // Private methods
            /**
             * Checks whether all initializations are complete and if so, removes the splash screen and displays the main menu.
             */
            _checkInitComplete = function () {
                if (_configInitComplete && _settingsInitComplete && _screenInitComplete) {
                    application.log("Initialization of " + _gameName + " completed.");
                    // hide the splash screen
                    document.body.firstElementChild.remove();
                    screenManager.setCurrentScreen(_startScreenName);
                }
            },
            /**
             * Sends a request to load the screens module and a callback to build the screens when its loading has finished.
             * @returns {undefined}
             */
            _requestScreenBuild = function () {
                application._buildScreensAndExecuteCallback(function () {
                    _screenInitComplete = true;
                    _checkInitComplete();
                });
            },
            /**
             * Sends an asynchronous request to get the JSON file describing the game
             * settings and sets the callback function to set them.
             * @param {{folder: String, filename: String}} settingsFileDescriptor
             */
            _requestSettingsLoad = function (settingsFileDescriptor) {
                application.requestTextFile(settingsFileDescriptor.folder, settingsFileDescriptor.filename, function (settingsText) {
                    var settingsJSON = JSON.parse(settingsText);
                    application.log("Loading game settings...", 1);
                    application._loadGameSettingsAndExecuteCallback(settingsJSON, function () {
                        application.log("Game settings loaded.", 1);
                        _settingsInitComplete = true;
                        _requestScreenBuild();
                    });
                });
            },
            /**
             * Sends an asynchronous request to get the JSON file describing the game
             * configuration and sets the callback function to initialize it.
             */
            _requestConfigLoad = function () {
                application.requestTextFile(_configFolder, _configFileName, function (configText) {
                    var configJSON = JSON.parse(configText);
                    application.log("Loading game configuration...");
                    application.setFolders(configJSON.folders);
                    application.setLogVerbosity(configJSON.logVerbosity);
                    application.setVersion(configJSON.version);
                    application.setDebugVersion(configJSON.debugVersion);
                    application.setReleases(configJSON.releases);
                    application.log("Game version is: " + application.getVersion(), 1);
                    _defaultLanguage = configJSON.defaultLanguage;
                    _stringsFileDescriptors = configJSON.configFiles.strings;
                    requirejs([
                        "modules/media-resources"
                    ], function (resources) {
                        application._loadGameConfigurationAndExecuteCallback(configJSON, function () {
                            resources.requestConfigLoad(configJSON.dataFiles.media.resources, function () {
                                application.log("Game configuration loaded.");
                                _configInitComplete = true;
                            });
                            _requestSettingsLoad(configJSON.configFiles.settings);
                        });
                    });
                });
            };
    // -------------------------------------------------------------------------
    // Public methods
    /**
     * Sets the name of the game that will be displayed in logs.
     * @param {String} value
     */
    application.setGameName = function (value) {
        _gameName = value;
    };
    /**
     * Sets the name of the starting screen that will be displayed after the game has finished loading.
     * @param {String} value
     */
    application.setStartScreenName = function (value) {
        _startScreenName = value;
    };
    /**
     * Sets the folder URL (relative to game root), where the game will look for the configuration file.
     * @param {String} value
     */
    application.setConfigFolder = function (value) {
        _configFolder = value;
    };
    /**
     * Sets the name of the configuration JSON file that has to contain the game version, folder structure, resource file URL and other
     * specific game configuration.
     * @param {String} value
     */
    application.setConfigFileName = function (value) {
        _configFileName = value;
    };
    /**
     * Returns the default language of the game
     * @returns {String}
     */
    application.getDefaultLanguage = function () {
        return _defaultLanguage;
    };
    /**
     * Returns the currently used language
     * @returns {String}
     */
    application.getLanguage = function () {
        return strings.getLanguage() || _defaultLanguage;
    };
    /**
     * Returns the list of languages (language ID strings) for which there is a strings file defined. (it is now checked whether the 
     * specified file exists)
     * @returns {Array}
     */
    application.getLanguages = function () {
        return Object.keys(_stringsFileDescriptors);
    };
    /**
     * 
     * @returns {String}
     */
    application.getDefaultCursor = function () {
        return _defaultCursor;
    };
    /**
     * If needed, launches an asynchronous request to load the language file for the given language and changes
     * the language of the application to it when it is loaded, then executes the callback. If the
     * language file had already been loaded previously, just switches the language and executes the
     * callback.
     * @param {String} language A string identifier of the language
     * @param {Object} stringDefinitions An object definition object for verification, that contains the 
     * (property) definitions of the strings, organized into categories. The required format:
     * stringDefinitions.(categoryName).(stringDefinitionName).name = (stringID)
     * Where categoryName and stringDefinitionName are any identifiers that can be later used to obtain the loaded
     * string value, and stringID needs to be the same string as the key for the string in the JSON file to load.
     * @param {Function} callback The callback to execute after the language has been changed. It will get one parameter,
     * which will indicate whether it is being executed in the asynchronously
     * @returns {Boolean} Whether the language change could be initiated
     */
    application.requestLanguageChange = function (language, stringDefinitions, callback) {
        if (!_stringsFileDescriptors || !_stringsFileDescriptors[language]) {
            application.showError("Cannot change application language to '" + language + "' as there is no strings file set for this langauge!");
            return false;
        }
        if (strings.languageIsLoaded(language)) {
            strings.setLanguage(language);
            screenManager.updateAllScreens();
            callback(false);
        } else {
            application.requestTextFile(
                    _stringsFileDescriptors[language].folder,
                    _stringsFileDescriptors[language].filename,
                    function (responseText) {
                        strings.loadStrings(language, JSON.parse(responseText), stringDefinitions);
                        strings.setLanguage(language);
                        screenManager.updateAllScreens();
                        callback(true);
                    });
        }
        return true;
    };
    /** 
     * Initializes the game: builds up the screens, loads settings and displays the start screen.
     * @param {Object} data
     */
    application.initialize = function (data) {
        application.log("Initializing " + _gameName + "...");
        application.useElectron(data.electron);
        if (!application.usesElectron() && (location.protocol === "file:") && !data.local) {
            this.showError("Trying to run the game from the local filesystem!",
                    application.ErrorSeverity.CRITICAL,
                    "This application can only be run through a web server. " +
                    "If you wish to run it from your own computer, you have to install, set up " +
                    "and start a web server first. You have to put the folder containing the files of this game " +
                    "(assume it is called 'game') to the HTML serving folder of the web server, then " +
                    "you can start the game by entering 'localhost/game' in your browser's address bar.");
            return;
        }
        _defaultCursor = document.body.style.cursor;
        _requestConfigLoad();
    };
    // globally available functions
    // explosing the screen manager functionality, so when using this module, it does not have to be
    // used separately as well
    application.getScreen = screenManager.getScreen;
    application.setScreen = screenManager.setCurrentScreen;
    application.addScreen = screenManager.addScreen;
    application.closeSuperimposedScreen = screenManager.closeSuperimposedScreen;
    application.closeOrNavigateTo = screenManager.closeOrNavigateTo;
    application.updateAllScreens = screenManager.updateAllScreens;
    application.executeWhenAllScreensReady = screenManager.executeWhenReady;
    return application;
});
/**
 * Copyright 2017, 2020 Krisztián Nagy
 * @file Event identifiers for spacecraft related events
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define */

define('armada/logic/SpacecraftEvents',[],function () {
    "use strict";
    /**
     * @typedef {Object} SpacecraftEvents~BeingTargetedData
     * @property {Spacecraft} spacecraft The spacecraft targeting this spacecraft
     */
    /**
     * @typedef {Object} SpacecraftEvents~BeingHitData
     * @property {Spacecraft} spacecraft The spacecraft that fired the projectile.
     * @property {Number[3]} hitPosition The position where the projectile has hit the spacecraft, in model-space.
     */
    /**
     * @typedef {Object} SpacecraftEvents~AnySpacecraftHitData
     * @property {Spacecraft} spacecraft The spacecraft that was hit.
     */
    /**
     * @typedef {Object} SpacecraftEvents~PreparingJumpData
     * @property {Number} timeLeft The amount of time left from the preparation, in milliseconds
     * @property {Number} duration The total duration of the preparation, in milliseconds
     */
    /**
     * @typedef {Object} SpacecraftEvents~JumpFormationData
     * @property {String} type What kind of formation is it (enum JumpCommandFormation defined in ai.js)
     * @property {Number[3]} spacing A vector based on which the offset position of ships in the formation can be calculated
     * Its exact meaning depends on the type of formation, but generally it influences the spacing distance / vector between neighbour ships
     */
    /**
     * @typedef {Object} SpacecraftEvents~JumpCommandData
     * @property {String} [way] Can be used to specify inward or outward jumps (if not given, the direction is chosen based on whether the
     * spacecraft is away or not)
     * @property {String} [anchor] ID of the spacecraft to use as an anchor for inward jumps. The position of the anchor spacecraft is added
     * to the position of the jumping spacecraft before inward jump.
     * @property {Boolean} [relative] When true, the position and orientation of the spacecraft should be interpreted relative to the anchor
     * (transformed by its orientation)
     * @property {Number[3]} [position] When given, overwrites the spacecraft's position before inward jump
     * @property {Array} [rotations] When given, overwrites the spacecraft's orientation before inward jump
     * @property {Number} [distance] When given, the spacecraft's position will be overridden by a new position generated randomly
     * to be this distance away from the anchor ship
     * @property {SpacecraftEvents~JumpFormationData} [formation] When given, the position and orientation is determined based on the 
     * formation data and the lead spacecraft of the command
     * @property {Spacecraft} [anchorSpacecraft] Set the first time the command is executed, so that further AIs executing the same command
     * will not have to query the anchor spacecraft
     * 
     */
    /**
     * @typedef {Object} SpacecraftEvents~TargetCommandData
     * @property {String} [single] The ID of the single spacecraft that should be targeted
     * @property {String[]} [list] The list of IDs of the spacecrafts that should be targeted and destroyed in this order
     * @property {String[]} [squads] The list of IDs of the squads the spacecrafts in which should be targeted and destroyed in this order
     * @property {Boolean} [priority] Whether the specified target(s) is/are priority targets
     * @property {Spacecraft} [targetSpacecrafts] Set the first time the command is executed, so that further AIs executing the same command
     * will not have to query the target spacecrafts
     */
    /**
     * @typedef {Object} SpacecraftEvents~CommandData
     * @property {String} command The type of command to execute
     * @property {Spacecraft} [lead] The leading (first) spacecraft that received the same command (for example to apply a formation
     * relative to it) - set when the command is executed
     * @property {Number} [index] The index of the spacecraft that received the command among the spacecrafts that received it - set when 
     * the command is executed
     * @property {Boolean} [clearCache] When true, the cached properties in the command data should be cleared when executing the command
     * @property {SpacecraftEvents~JumpCommandData} [jump] Details of the command if it is a jump command
     * @property {SpacecraftEvents~TargetCommandData} [target] Details of the command if it is a target command
     */
    /**
     * @typedef {Object} SpacecraftEvents~HUDData
     * @property {String} [section] (enum HUDSection - key in camelCase) The id of the section of the HUD to change. No value means the whole HUD
     * @property {String} state (enum HUDSectionState - key in camelCase) The state to change to
     */
    return {
        /** Another spacecraft targets the spacecraft. */
        BEING_TARGETED: "beingTargeted",
        /** A projectile hits the spacecraft. */
        BEING_HIT: "beingHit",
        /** A projectile fired by the spacecraft successfully hits its current target. */
        TARGET_HIT: "targetHit",
        /** A projectile fired by the spacecraft hits any spacecraft (including itself or its current target). */
        ANY_SPACECRAFT_HIT: "anySpacecraftHit",
        /** The current target of the spacecraft fires. */
        TARGET_FIRED: "targetFired",
        /** The spacecraft fires. */
        FIRED: "fired",
        /** The spacecraft is destructed (gets to the point in its explosion where the spacecraft should no longer be visible) */
        /** The handler of this event should return a boolean, determining whether the spacecraft object should be destroyed (true) or kept 
         * (false, in which case it can be respawned later - e.g. for the spacecraft preview in the editor)*/
        DESTRUCTED: "destructed",
        /** The spacecraft engages its jump engines. */
        JUMP_ENGAGED: "jumpEngaged",
        /** The spacecraft is preparing to jump out.  */
        PREPARING_JUMP: "preparingJump",
        /** The spacecraft is starting the outward jump. */
        JUMP_OUT_STARTED: "jumpOutStarted",
        /** The spacecraft has jumped out. */
        JUMPED_OUT: "jumpedOut",
        /** The spacecraft has jumped in. */
        JUMPED_IN: "jumpedIn",
        /** The spacecraft has finished the jump in sequence */
        ARRIVED: "arrived",
        /** The spacecraft cancelled the jump process. */
        JUMP_CANCELLED: "jumpCancelled",
        /** The spacecraft received a command (to be handled by the AI) */
        COMMAND_RECEIVED: "commandReceived",
        /** The HUD of the spacecraft should be updated */
        HUD: "hud"
    };
});
/**
 * Copyright 2016-2018, 2020 Krisztián Nagy
 * @file Provides functionality to parse and load the audio settings of Interstellar Armada from an external file as well as to save them
 * to or load from HTML5 local storage and access derived settings.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, parseFloat, window, localStorage, screen */

/**
 * @param types Used for type checking JSON settings and set values
 * @param application Using the application module for error displaying functionality
 * @param asyncResource AudioSettingsContext is an AsynchResource subclass
 * @param audio Used for actually setting the volumes
 * @param resources Used for loading music resources
 * @param constants Used to access common game constants
 * @param config Used for accessing music fading setting values
 */
define('armada/audio',[
    "utils/types",
    "modules/application",
    "modules/async-resource",
    "modules/audio",
    "modules/media-resources",
    "armada/constants",
    "armada/configuration",
    "utils/polyfill"
], function (types, application, asyncResource, audio, resources, constants, config) {
    "use strict";
    var
            // --------------------------------------------------------------------------------------------
            // Constants
            /**
             * All location IDs where setting values are stored in local storage are prefixed by this value.
             * @type String
             */
            MODULE_LOCAL_STORAGE_PREFIX = constants.LOCAL_STORAGE_PREFIX + "audio_",
            /**
             * The duration for which stopping sounds should be ramped to volume zero to avoid abrupt sound volume changes, in seconds
             * @type Number
             */
            SOUND_RAMP_DURATION = 0.1,
            // ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
            // Settings
            // ............................................................................................
            // Master volume
            /**
             * The key identifying the location where the master volume setting is stored in local storage.
             * @type String
             */
            MASTER_VOLUME_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "masterVolume",
            // ............................................................................................
            // Music volume
            /**
             * The key identifying the location where the music volume setting is stored in local storage.
             * @type String
             */
            MUSIC_VOLUME_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "musicVolume",
            // ............................................................................................
            // SFX volume
            /**
             * The key identifying the location where the SFX volume setting is stored in local storage.
             * @type String
             */
            SFX_VOLUME_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "sfxVolume",
            // ............................................................................................
            // UI volume
            /**
             * The key identifying the location where the UI volume setting is stored in local storage.
             * @type String
             */
            UI_VOLUME_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "uiVolume",
            // --------------------------------------------------------------------------------------------
            // Private variables
            /**
             * The ID of the currently playing music theme
             * @type String
             */
            _currentTheme = null,
            /**
             * An associative array storing the sound sources used to play the various tracks during battle. The keys are the theme names.
             * @type Object.<String, SoundClip>
             */
            _music = {},
            /**
             * Cached setting of the duration of fade in of music themes, in seconds
             * @type Number
             */
            _musicFadeInDuration,
            /**
             * Cached setting of the duration of the crossfade between different music themes during battle (e.g. anticipation -> combat), 
             * in seconds
             * @type Number
             */
            _themeCrossfadeDuration,
            /**
             * Cached setting of the duration of fade out of music themes, in seconds
             * @type Number
             */
            _musicFadeOutDuration,
            /**
             * Stores a default context the methods of which are exposed in the interface of this module.
             * @type AudioSettingsContext
             */
            _context;
    // ############################################################################################
    /**
     * @class Can load, store, save, and modify a set of audio settings and provide their current values for other game modules.
     * @extends AsyncResource
     */
    function AudioSettingsContext() {
        asyncResource.AsyncResource.call(this);
        /**
         * The JSON object storing the default graphics settings.
         * @type Object
         */
        this._dataJSON = null;
        /**
         * The current master volume setting.
         * @type Number
         */
        this._masterVolume = 1;
        /**
         * The current music volume setting.
         * @type Number
         */
        this._musicVolume = 1;
        /**
         * The current SFX volume setting.
         * @type Number
         */
        this._sfxVolume = 1;
        /**
         * The current UI volume setting.
         * @type Number
         */
        this._uiVolume = 1;
        /**
         * The rolloff factor to use when playing 3D spatial sound effects (not specifying it will fall back to the default of the audio module)
         * @type Number
         */
        this._rolloffFactor = 0;
        /**
         * (enum PanningModel) The panning model to use when playing 3D spatial sound effects (not specifying it will fall back to the default of the audio module)
         * See Web Audio API
         * @type String
         */
        this._panningModel = null;
    }
    AudioSettingsContext.prototype = new asyncResource.AsyncResource();
    AudioSettingsContext.prototype.constructor = AudioSettingsContext;
    /**
     * Loads all configuration information for the context from the passed JSON object. 
     * Needs to be called only once, before the settings themselves are to be loaded.
     * @param {Object} dataJSON
     */
    AudioSettingsContext.prototype.loadConfigurationFromJSON = function (dataJSON) {
        // an undefined rolloff factor will result in using the default defined in the audio module
        if (dataJSON.rolloffFactor) {
            this._rolloffFactor = types.getNumberValue("configuration.audio.rolloffFactor", dataJSON.rolloffFactor, 0);
        }
        // an undefined panning model will result in using the default defined in the audio module
        if (dataJSON.panningModel) {
            this._panningModel = types.getEnumValue(audio.PanningModel, dataJSON.panningModel, {name: "configuration.audio.panningModel"});
        }
    };
    /**
     * Loads the audio setting from the data stored in the passed JSON object.
     * @param {Object} dataJSON The JSON object storing the game settings.
     * @param {Boolean} [onlyRestoreSettings=false] Whether only the default 
     * settings should be restored or completely new settings should be initialized.
     */
    AudioSettingsContext.prototype.loadSettingsFromJSON = function (dataJSON, onlyRestoreSettings) {
        if (typeof dataJSON !== "object") {
            application.showError("Cannot initialize audio settings from JSON: audio section missing or has wrong type ('" + typeof dataJSON + "')!");
            return;
        }
        onlyRestoreSettings = onlyRestoreSettings || false;
        if (!onlyRestoreSettings) {
            this._dataJSON = dataJSON;
        }
        this.setMasterVolume(types.getNumberValue("settings.audio.masterVolume", dataJSON.masterVolume, 1), false);
        this.setMusicVolume(types.getNumberValue("settings.audio.musicVolume", dataJSON.musicVolume, 1), false);
        this.setSFXVolume(types.getNumberValue("settings.audio.sfxVolume", dataJSON.sfxVolume, 1), false);
        this.setUIVolume(types.getNumberValue("settings.audio.uiVolume", dataJSON.uiVolume, 1), false);
    };
    /**
     * Loads the custom audio settings stored in HTML5 local storage.
     */
    AudioSettingsContext.prototype.loadFromLocalStorage = function () {
        var value, params, loadSetting = function (location, type, defaultValue, setterFunction) {
            if (localStorage[location] !== undefined) {
                // settings might be saved in different formats in different game versions, so do not show errors for invalid type if the version
                // has changed since the last run
                params = {
                    silentFallback: application.hasVersionChanged(),
                    defaultValue: defaultValue
                };
                value = types.getValueOfTypeFromLocalStorage(type, location, params);
                // apply the setting if it is valid or if the game version has changed, in which case the fallback of the invalid setting 
                // (namely the default setting from the JSON) will be applied and also saved to local storage
                if (!params.error || application.hasVersionChanged()) {
                    setterFunction(value, !!params.error && (params.error !== types.Errors.INVALID_ENUM_OBJECT_ERROR));
                }
            }
        };
        loadSetting(MASTER_VOLUME_LOCAL_STORAGE_ID, "number", this.getMasterVolume(), this.setMasterVolume.bind(this));
        loadSetting(MUSIC_VOLUME_LOCAL_STORAGE_ID, "number", this.getMusicVolume(), this.setMusicVolume.bind(this));
        loadSetting(SFX_VOLUME_LOCAL_STORAGE_ID, "number", this.getSFXVolume(), this.setSFXVolume.bind(this));
        loadSetting(UI_VOLUME_LOCAL_STORAGE_ID, "number", this.getUIVolume(), this.setUIVolume.bind(this));
        this.setToReady();
    };
    /**
     * Restores the default settings that were loaded from file, and erases the custom changes that are stored in HTML5 local storage.
     */
    AudioSettingsContext.prototype.restoreDefaults = function () {
        this.loadSettingsFromJSON(this._dataJSON, true);
        localStorage.removeItem(MASTER_VOLUME_LOCAL_STORAGE_ID);
        localStorage.removeItem(MUSIC_VOLUME_LOCAL_STORAGE_ID);
        localStorage.removeItem(SFX_VOLUME_LOCAL_STORAGE_ID);
        localStorage.removeItem(UI_VOLUME_LOCAL_STORAGE_ID);
    };
    /**
     * Returns the current master volume setting.
     * @returns {Number}
     */
    AudioSettingsContext.prototype.getMasterVolume = function () {
        return this._masterVolume;
    };
    /**
     * Sets a new master volume setting.
     * @param {Number} value
     * @param {Boolean} [saveToLocalStorage=true]
     * @returns {Boolean} Whether the setting was successfully set to the passed value.
     */
    AudioSettingsContext.prototype.setMasterVolume = function (value, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        this._masterVolume = value;
        audio.setMasterVolume(this._masterVolume);
        // saving the original preference
        if (saveToLocalStorage) {
            localStorage[MASTER_VOLUME_LOCAL_STORAGE_ID] = value.toString();
        }
        return this._masterVolume === value;
    };
    /**
     * Resets the master volume to its value stored in local storage / JSON.
     */
    AudioSettingsContext.prototype.resetMasterVolume = function () {
        this.setMasterVolume((localStorage[MASTER_VOLUME_LOCAL_STORAGE_ID] !== undefined) ? localStorage[MASTER_VOLUME_LOCAL_STORAGE_ID] : this._dataJSON.masterVolume);
    };
    /**
     * Returns the current music volume setting.
     * @returns {Number}
     */
    AudioSettingsContext.prototype.getMusicVolume = function () {
        return this._musicVolume;
    };
    /**
     * Sets a new music volume setting.
     * @param {Number} value
     * @param {Boolean} [saveToLocalStorage=true]
     * @returns {Boolean} Whether the setting was successfully set to the passed value.
     */
    AudioSettingsContext.prototype.setMusicVolume = function (value, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        this._musicVolume = value;
        audio.setMusicVolume(this._musicVolume);
        // saving the original preference
        if (saveToLocalStorage) {
            localStorage[MUSIC_VOLUME_LOCAL_STORAGE_ID] = value.toString();
        }
        return this._musicVolume === value;
    };
    /**
     * Resets the music volume to its value stored in local storage / JSON.
     */
    AudioSettingsContext.prototype.resetMusicVolume = function () {
        this.setMusicVolume((localStorage[MUSIC_VOLUME_LOCAL_STORAGE_ID] !== undefined) ? localStorage[MUSIC_VOLUME_LOCAL_STORAGE_ID] : this._dataJSON.musicVolume);
    };
    /**
     * Returns the current SFX volume setting.
     * @returns {Number}
     */
    AudioSettingsContext.prototype.getSFXVolume = function () {
        return this._sfxVolume;
    };
    /**
     * Sets a new SFX volume setting.
     * @param {Number} value
     * @param {Boolean} [saveToLocalStorage=true]
     * @returns {Boolean} Whether the setting was successfully set to the passed value.
     */
    AudioSettingsContext.prototype.setSFXVolume = function (value, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        this._sfxVolume = value;
        audio.setEffectVolume(this._sfxVolume);
        // saving the original preference
        if (saveToLocalStorage) {
            localStorage[SFX_VOLUME_LOCAL_STORAGE_ID] = value.toString();
        }
        return this._sfxVolume === value;
    };
    /**
     * Resets the SFX volume to its value stored in local storage / JSON.
     */
    AudioSettingsContext.prototype.resetSFXVolume = function () {
        this.setSFXVolume((localStorage[SFX_VOLUME_LOCAL_STORAGE_ID] !== undefined) ? localStorage[SFX_VOLUME_LOCAL_STORAGE_ID] : this._dataJSON.sfxVolume);
    };
    /**
     * Returns the current UI volume setting.
     * @returns {Number}
     */
    AudioSettingsContext.prototype.getUIVolume = function () {
        return this._uiVolume;
    };
    /**
     * Sets a new UI volume setting.
     * @param {Number} value
     * @param {Boolean} [saveToLocalStorage=true]
     * @returns {Boolean} Whether the setting was successfully set to the passed value.
     */
    AudioSettingsContext.prototype.setUIVolume = function (value, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        this._uiVolume = value;
        audio.setUIVolume(this._uiVolume);
        // saving the original preference
        if (saveToLocalStorage) {
            localStorage[UI_VOLUME_LOCAL_STORAGE_ID] = value.toString();
        }
        return this._uiVolume === value;
    };
    /**
     * Resets the UI volume to its value stored in local storage / JSON.
     */
    AudioSettingsContext.prototype.resetUIVolume = function () {
        this.setUIVolume((localStorage[UI_VOLUME_LOCAL_STORAGE_ID] !== undefined) ? localStorage[UI_VOLUME_LOCAL_STORAGE_ID] : this._dataJSON.uiVolume);
    };
    /**
     * Creates and return a sound source that can be used for 3D sound effect positioning, using the configuration settings given for the
     * context.
     * @param {Number[3]} position The initial position of the sound source, in camera-space
     * @returns {SoundSource}
     */
    AudioSettingsContext.prototype.createSoundSource = function (position) {
        return new audio.SoundSource(position, this._rolloffFactor, this._panningModel);
    };
    // -------------------------------------------------------------------------
    // Public functions
    /**
     * Sets up the music resource with the passed name to be used with the passed theme ID. If necessary, marks the resource for loading
     * so after the resources are loaded the music can be played by calling playMusic() with the same theme ID.
     * @param {String} musicName The name of the music resource to associate with the theme ID
     * @param {String} theme The theme ID that can be used later to play this music
     * @param {Boolean} loop Whether the music should be set up as looping or not
     */
    function initMusic(musicName, theme, loop) {
        var m;
        if (!_music[theme] || (_music[theme].name !== musicName)) {
            m = resources.getMusic(musicName);
            if (m && !m.hasError()) {
                resources.executeWhenReady(function () {
                    _music[theme] = {
                        name: musicName,
                        clip: m.createSoundClip(1, loop)
                    };
                });
            } else {
                application.log_DEBUG("Could not initialize music from resource '" + musicName + "' for theme ID '" + theme + "'!");
            }
        }
    }
    /**
     * Starts to play the music theme previously associated with the passed theme ID, stopping the current one (if any), possibly with a 
     * crossfade.
     * @param {String} theme The ID of the theme to start playing
     * @param {String} [followupTheme] If a non-looping theme is chosen (e.g. victory / defeat), this theme will be played after it finishes
     * (with the same crossfade applied)
     * @param {Number} [fadeDuration] If greater than zero, the a linear crossfade will happen from the current theme to the new one, 
     * lasting the given duration. In seconds! If not given, a default fade in / fade out / crossfade duration is chosen from the settings
     */
    function playMusic(theme, followupTheme, fadeDuration) {
        if (fadeDuration === undefined) {
            fadeDuration = _currentTheme ?
                    (theme ? _themeCrossfadeDuration : _musicFadeOutDuration) :
                    (theme ? _musicFadeInDuration : 0);
        }
        if (theme !== _currentTheme) {
            if (_currentTheme && _music[_currentTheme]) {
                if (fadeDuration > 0) {
                    _music[_currentTheme].clip.rampVolume(0, fadeDuration);
                } else {
                    _music[_currentTheme].clip.stopPlaying();
                }
            }
            if (theme) {
                if (!_music[theme]) {
                    application.log_DEBUG("Warning: music associated with theme '" + theme + "' cannot be played, because it is not loaded!");
                } else {
                    _music[theme].clip.play(true, followupTheme ? function () {
                        // start the followup music only if we are still playing the same theme it is followup for
                        if (_currentTheme === theme) {
                            playMusic(followupTheme, null, fadeDuration);
                        }
                    } : null);
                    if (fadeDuration > 0) {
                        _music[theme].clip.setVolume(0);
                        _music[theme].clip.rampVolume(1, fadeDuration);
                    } else {
                        _music[theme].clip.setVolume(1);
                    }
                }
            }
            _currentTheme = theme;
        }
    }
    /**
     * Stops all (any) theme music tracks that are playing. The stop is instant (abrupt), use playMusic(null) for a fadeout effect
     */
    function stopMusic() {
        var themes = Object.keys(_music), i;
        for (i = 0; i < themes.length; i++) {
            if (_music[themes[i]]) {
                _music[themes[i]].clip.stopPlaying();
            }
        }
        _currentTheme = null;
    }
    /**
     * Resumes audio playback (in case auto-play was prevented, this needs to be called from the event handler
     * of user interaction, such as a button click, to start audio playback in general)
     */
    function resume() {
        audio.resume();
    }
    // -------------------------------------------------------------------------
    // Initialization
    _context = new AudioSettingsContext();
    // -------------------------------------------------------------------------
    // Caching frequently needed setting values
    config.executeWhenReady(function () {
        // music
        _musicFadeInDuration = config.getSetting(config.GENERAL_SETTINGS.MUSIC_FADE_IN_DURATION);
        _themeCrossfadeDuration = config.getSetting(config.GENERAL_SETTINGS.THEME_CROSSFADE_DURATION);
        _musicFadeOutDuration = config.getSetting(config.GENERAL_SETTINGS.MUSIC_FADE_OUT_DURATION);
    });
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        SOUND_RAMP_DURATION: SOUND_RAMP_DURATION,
        SoundCategory: audio.SoundCategory,
        loadConfigurationFromJSON: _context.loadConfigurationFromJSON.bind(_context),
        loadSettingsFromJSON: _context.loadSettingsFromJSON.bind(_context),
        loadSettingsFromLocalStorage: _context.loadFromLocalStorage.bind(_context),
        restoreDefaults: _context.restoreDefaults.bind(_context),
        getMasterVolume: _context.getMasterVolume.bind(_context),
        setMasterVolume: _context.setMasterVolume.bind(_context),
        resetMasterVolume: _context.resetMasterVolume.bind(_context),
        getMusicVolume: _context.getMusicVolume.bind(_context),
        setMusicVolume: _context.setMusicVolume.bind(_context),
        resetMusicVolume: _context.resetMusicVolume.bind(_context),
        getSFXVolume: _context.getSFXVolume.bind(_context),
        setSFXVolume: _context.setSFXVolume.bind(_context),
        resetSFXVolume: _context.resetSFXVolume.bind(_context),
        getUIVolume: _context.getUIVolume.bind(_context),
        setUIVolume: _context.setUIVolume.bind(_context),
        resetUIVolume: _context.resetUIVolume.bind(_context),
        createSoundSource: _context.createSoundSource.bind(_context),
        executeWhenReady: _context.executeWhenReady.bind(_context),
        initMusic: initMusic,
        playMusic: playMusic,
        stopMusic: stopMusic,
        resume: resume
    };
});
/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides general functionality to handle various types of user input.
 * Provides a base input interpreter class which can be subclassed for each needed input device to catch and process its inputs, 
 * translating it to actions using a list of bindings added to the interpreter.
 * Also provides a generic controller class can process the actions produced by interpreters and execute functions for each triggered /
 * non triggered action. 
 * Finally, provides a control context class to which interpreters and controllers can be added and which integrates the collection of 
 * actions from interpreters and passing it to the stored controllers.
 * To use this module, create your set of controllers, create your context, add interpreters for the needed input devices to it with your
 * bindings, add your controllers as well and then use the provided methods to start / stop listening for different devices and execute all
 * the functions bound for currently triggered / non-triggered actions by calling control() on the context.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define */

/**
 * @param utils Used for the getting key of property value utility function
 * @param application Used for logging and error displaying functionality
 * @param asyncResource ControlContext is a subclass of AsyncResource
 */
define('modules/control/control',[
    "utils/utils",
    "modules/application",
    "modules/async-resource",
    "modules/strings"
], function (utils, application, asyncResource) {
    "use strict";
    // #########################################################################
    /**
     * @class A generic superclass for classes that represent the bindig of certain controls to an action.
     * A subclass should be created for each specific input device that implements setting, loading, saving,
     * comparing control settings for the binding and checking the action trigger state.
     * @param {(Object|String)} dataJSONOrActionName
     */
    function ControlBinding(dataJSONOrActionName) {
        /**
         * Name of the action the stored control is assigned to. {@link Controller}s
         * will process this name and execute the appropriate action.
         * @type String
         */
        this._actionName = ((typeof dataJSONOrActionName) === "string" ?
                dataJSONOrActionName :
                null);
        // if a JSON object was specified, initialize the properties from there
        if ((typeof dataJSONOrActionName) === "object") {
            this.loadFromJSON(dataJSONOrActionName);
        }
    }
    /**
     * Returns the name of the action assigned in this binding. Has to be a name
     * that can be processed by the appropriate {@link Controller}s.
     * @returns {String}
     */
    ControlBinding.prototype.getActionName = function () {
        return this._actionName;
    };
    /**
     * Loads the properties of this binding from a JSON object. Needs to be overridden for each specific binding
     * subclass to load their properties.
     * @param {Object} dataJSON
     */
    ControlBinding.prototype.loadFromJSON = function (dataJSON) {
        this._actionName = dataJSON.action;
    };
    // #########################################################################
    /**
     * @class A generic common superclass for input interpreters which needs to be subclassed for each different input device.
     * This class provides the common general functionality. The subclasses need to add their model of the input device's state,
     * additional operations for saving / loading its settings and a managing the trigger state check for the stored bindings.
     * @param {Function} bindingClass The constructor function of the binding class this interpreter will use (has te be a subclass
     * of ControlBinding)
     * @param {Object} dataJSON If given, any specific interpreter settings can be loaded from this JSON object
     */
    function InputInterpreter(bindingClass, dataJSON) {
        /**
         * Whether the interpreter is currently listening for input (the event  handlers are set) and is updating
         * the internal state it holds about its input device.
         * A listening interpreter will also disable most default actions for the input device it is listening to.
         * @type Boolean
         */
        this._listening = false;
        /**
         * Whether the interpreter is currently processing the input state it maintains to trigger actions based on its
         * stored binding. If the interpreter is not listening, processing is not possible, but the enabled state can
         * be set and is stored independently.
         * @type Boolean
         */
        this._enabled = true;
        /**
         * The constructor function of the binding class this interpreter uses (a subclass of ControlBinding).
         * @type Function
         */
        this._bindingClass = bindingClass;
        /**
         * An associative array storing the active bindings by the names of the actions that they are associated to.
         * @type Object.<String, ControlBinding>
         */
        this._bindings = {};
        /**
         * Associative array of the names of disabled actions. The action names are
         * the keys, and if the corresponding action is disabled, the value is true.
         * Disabled actions are not passed to the controllers for processing, even
         * if they would be triggered user input from the device this interpreter
         * is handles.
         * @type Object
         */
        this._disabledActions = {};
        // if a JSON was specified, initialize the bindings from there
        if (dataJSON !== undefined) {
            this.loadFromJSON(dataJSON);
        }
    }
    /**
     * Returns a descriptive name of the device this interpreter handles to show for the user.
     * @returns {String}
     */
    InputInterpreter.prototype.getDeviceName = function () {
        return "Generic";
    };
    /**
     * Whether the interpreter is currently listening for input (and thus also intercepting it, preventing most default actions)
     * @returns {Boolean}
     */
    InputInterpreter.prototype.isListening = function () {
        return this._listening;
    };
    /**
     * Makes the interpreter start intercepting events related to its input device to update the internal state it stores about it as well
     * as prevent default actions for these events. If the interpreter is also enabled, it will also be able to query it for the list and
     * intensities of the actions that are triggered based on the current input state and its bindings.
     * Needs to be overridden to set add the setting of event handlers and other optional settings.
     */
    InputInterpreter.prototype.startListening = function () {
        if (!this._listening) {
            this.resetState();
            this._listening = true;
        }
    };
    /**
     * The interpreter will stop listening after calling this method, canceling any event handlers related to its input device. Since its
     * stored state of the device will not be updated any more, attempting to get the list of triggered actions will result in an empty
     * array, even if th interpeter is enabled.
     * Needs to be overridden to set add the canceling of event handlers and other optional settings.
     */
    InputInterpreter.prototype.stopListening = function () {
        if (this._listening) {
            this.resetState();
            this._listening = false;
        }
    };
    /**
     * Changes the listening state of the interpreter to its opposite.
     */
    InputInterpreter.prototype.toggleListening = function () {
        if (this._listening) {
            this.stopListening();
        } else {
            this.startListening();
        }
    };
    /**
     * Returns whether the interpreter is currently at enabled state, meaning it can be queried for triggered actions (if it is currently
     * also in listening state)
     * @returns {Boolean}
     */
    InputInterpreter.prototype.isEnabled = function () {
        return this._enabled;
    };
    /**
     * Sets the interpreter to enabled state, in which it will return the list of triggered actions and their intensities when queried,
     * but only if it is also set to listen to events.
     * @returns {Boolean}
     */
    InputInterpreter.prototype.enable = function () {
        this._enabled = true;
    };
    /**
     * Sets the interpreter to disabled state, in which it will not return any triggered actions when queried, even if it is listening
     * to events and keeping its model of the input device state updated.
     * @returns {Boolean}
     */
    InputInterpreter.prototype.disable = function () {
        this._enabled = false;
    };
    /**
     * Changes the enabled state of the interpreter to its opposite.
     */
    InputInterpreter.prototype.toggleEnabled = function () {
        if (this._enabled) {
            this.disable();
        } else {
            this.enable();
        }
    };
    /**
     * If there is no control bound yet to the action associated with the passed 
     * binding, adds the binding. If there already is a binding, overwrites it with
     * the passed binding, as there can be no two different controls bound to the
     * same action for now. This method is for setting default bindings.
     * @param {ControlBinding} binding
     */
    InputInterpreter.prototype.setBinding = function (binding) {
        this._bindings[binding.getActionName()] = binding;
    };
    /**
     * Sets (adds or overwrites) the binding associated with the action of the 
     * passed binding, and also stores the binding in HTML5 local storage. This 
     * method is for setting custom local bindings.
     * @param {ControlBinding} binding
     */
    InputInterpreter.prototype.setAndStoreBinding = function (binding) {
        this.setBinding(binding);
        binding.saveToLocalStorage();
    };
    /**
     * Loads the properties of the interpreter such as the (default) bindings
     * from the passed JSON object.
     * @param {Object} dataJSON
     */
    InputInterpreter.prototype.loadFromJSON = function (dataJSON) {
        var i;
        for (i = 0; i < dataJSON.bindings.length; i++) {
            this.setBinding(new this._bindingClass(dataJSON.bindings[i]));
        }
    };
    /**
     * Loads the properties of the interpreter such as the (custom local) bindings
     * from HTML5 local storage.
     */
    InputInterpreter.prototype.loadFromLocalStorage = function () {
        var actionName;
        for (actionName in this._bindings) {
            if (this._bindings.hasOwnProperty(actionName)) {
                this._bindings[actionName].loadFromLocalStorage();
            }
        }
    };
    /**
     * Removes custom bindings stored in HTML5 local storage.
     */
    InputInterpreter.prototype.removeFromLocalStorage = function () {
        var actionName;
        for (actionName in this._bindings) {
            if (this._bindings.hasOwnProperty(actionName)) {
                this._bindings[actionName].removeFromLocalStorage();
            }
        }
    };
    /**
     * Returns a string describing the control assigned to the action with the passed name.
     * @param {String} actionName
     * @returns {String}
     */
    InputInterpreter.prototype.getControlStringForAction = function (actionName) {
        if (this._bindings[actionName] !== undefined) {
            return this._bindings[actionName].getControlString();
        }
        return "";
    };
    /**
     * @typedef {Object} ActionTrigger
     * @property {String} name
     * @property {Number} [intensity]
     */
    /**
     * Adds a new triggered action to the group that was triggered by the same controls
     * @param {Array} actionsByBindings A list of groups of triggered actions, where each group was triggered by the same controls
     * @param {(ActionTrigger|null)} action
     * @param {Binding} binding The binding that triggered the action
     */
    InputInterpreter.prototype._addActionByBinding = function (actionsByBindings, action, binding) {
        var i;
        if (!action) {
            return;
        }
        for (i = 0; i < actionsByBindings.length; i++) {
            if (binding.bindsTheSameControls(actionsByBindings[i].binding)) {
                actionsByBindings[i].actions.push(action);
                return;
            }
        }
        actionsByBindings.push({
            binding: binding,
            actions: [action]
        });
    };
    /**
     * Disables the action with the given name. While disabled, this action will not
     * be passed to the controllers for processing, even if user input would trigger
     * it.
     * @param {String} actionName
     */
    InputInterpreter.prototype.disableAction = function (actionName) {
        this._disabledActions[actionName] = true;
    };
    /**
     * Enables the action with the given name. (if it was disabled)
     * @param {String} actionName
     */
    InputInterpreter.prototype.enableAction = function (actionName) {
        this._disabledActions[actionName] = false;
    };
    /**
     * Returns the list of currently triggered actions based on the internally stored input device state and the control bindings.
     * @param {Function} [actionFilterFunction] If given, every triggered action will be tested against this function (by passing its name
     * as a parameter), and only added to the resulting list if the function returns true.
     * @returns {Object[][]} The lists of action names and intensities, grouped by the triggering controls (if two actions were triggered
     * by the same controls, they will be in the same array, and the result itself is an array of such arrays. The name (String) property 
     * stores the action's name and the intensity (Number) property the intensity.
     */
    InputInterpreter.prototype.getTriggeredActions = function (actionFilterFunction) {
        var result = [], actionName, actionsByBindings = [], i;
        if (!this.isListening() || !this.isEnabled()) {
            return result;
        }
        for (actionName in this._bindings) {
            if (this._bindings.hasOwnProperty(actionName)) {
                if (!this._disabledActions[actionName] && (!actionFilterFunction || actionFilterFunction(actionName))) {
                    this._addActionByBinding(actionsByBindings, this.checkAction(actionName), this._bindings[actionName]);
                }
            }
        }
        for (i = 0; i < actionsByBindings.length; i++) {
            result.push(actionsByBindings[i].actions);
        }
        return result;
    };
    // #########################################################################
    /**
     * @class Represents an in-game action that can be triggered by the user and a 
     * controller can execute certain functions on methods on their controlled 
     * entities based on whether or not the action is currently triggered.
     * @param {Object} [dataJSON] If given, the properties will be initialized from
     * the data stored in this JSON object.
     */
    function Action(dataJSON) {
        /**
         * The name of the action used to identify it. Has to be unique within the
         * game. Input interpreters generate a list of action names based on what
         * is stored in their bindings, and controllers process this list to execute
         * the actions stored in their recognized action list.
         * @type String
         */
        this._name = null;
        /**
         * A longer, human readable description to be display in the control settings
         * screen.
         * @type String
         */
        this._description = null;
        /**
         * Whether the action is to be continuously executed while being triggered,
         * or only to be executed once a new trigger has been initiated.
         * @type Boolean
         */
        this._continuous = false;
        /**
         * Whether the action is currently being triggered or not.
         * @type Boolean
         */
        this._triggered = false;
        /**
         * If the action is triggered, then with what intensity. The value null
         * corresponds to a trigger without a specific intensity (such as trigger by
         * a key press)
         * @type Number
         */
        this._intensity = this.INTENSITY_NOT_SPECIFIED;
        /**
         * Whether the action has already been executed for the current trigger.
         * (non continuous actions will not fire unless this is reset to false by
         * the end of the current trigger and then a new trigger starts)
         * @type Boolean
         */
        this._executed = false;
        /**
         * Whether the non-triggered action has already been executed after the last trigger.
         * (non continuous actions will not fire their non-trigger continuously either)
         */
        this._nonTriggeredExecuted = true;
        /**
         * The function to execute when the action is triggered.
         * @type Function
         */
        this._executeTriggered = null;
        /**
         * The function to execute when the action is not being triggered.
         * @type Function
         */
        this._executeNonTriggered = null;
        /**
         * If the action is triggered, this refers to the input interpreter that triggered it.
         * @type InputInterpreter
         */
        this._source = null;
        // if a JSON was specified, initialize the properties from there
        if (dataJSON !== undefined) {
            this.loadFromJSON(dataJSON);
        }
    }
    /**
     * Value for the intensity of an action that has not been set in this round
     * @constant 
     * @type Number
     */
    Action.prototype.INTENSITY_NOT_SPECIFIED = -3;
    /**
     * Value for the intensity of an action that has been triggered by a keypress (which does not have fine grades of intensity)
     * @constant 
     * @type Number
     */
    Action.prototype.INTENSITY_KEYPRESS = -2;
    /**
     * Returns the name of this action for identification within the program.
     * @returns {String}
     */
    Action.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the human readable description of this action that can be displayed
     * to the user.
     * @returns {String}
     */
    Action.prototype.getDescription = function () {
        return this._description;
    };
    /**
     * Loads the properties of the action as stored in the passed JSON object.
     * @param {Object} dataJSON
     */
    Action.prototype.loadFromJSON = function (dataJSON) {
        this._name = dataJSON.name;
        this._description = dataJSON.description;
        this._continuous = dataJSON.continuous === true;
        this._triggered = false;
        this._intensity = this.INTENSITY_NOT_SPECIFIED;
        this._executed = false;
        this._nonTriggeredExecuted = true;
    };
    /**
     * Sets the action's trigger state and intensity.
     * @param {Boolean} triggered The new trigger state of the action to be set.
     * @param {Number} intensity The new intensity of the action to be set. Will
     * be ignored if not given. If multiple triggers try to set the intensity, 
     * the highest one or the one with the  without intensity will be considered.
     * @param {InputInterpreter} source The input interpreter that triggered
     * this action
     */
    Action.prototype.setTriggered = function (triggered, intensity, source) {
        this._triggered = triggered;
        if ((intensity !== undefined) && ((this._intensity === this.INTENSITY_NOT_SPECIFIED) || ((this._intensity >= 0) && intensity > this._intensity))) {
            this._intensity = intensity;
        } else if (intensity === undefined) {
            this._intensity = this.INTENSITY_KEYPRESS;
        }
        this._source = source;
    };
    /**
     * Sets the function to be executed when the action is triggered.
     * @param {Function} executeTriggered
     */
    Action.prototype.setExecuteTriggered = function (executeTriggered) {
        this._executeTriggered = executeTriggered;
    };
    /**
     * Sets the function to be executed when the action is not triggered. (or has
     * already been executed for this trigger, if it is not continuous)
     * @param {Function} executeNonTriggered
     */
    Action.prototype.setExecuteNonTriggered = function (executeNonTriggered) {
        this._executeNonTriggered = executeNonTriggered;
    };
    /**
     * Executes the appropriate function based on whether the action is currently
     * triggered and if it is continuous. For continuous actions, the {@link Action#_executeTriggered}
     * function is executed continuously while the trigger lasts, whereas for 
     * non-continuous actions, it is executed once a new trigger starts. In any other
     * case, the {@link Action#_executeNonTriggered} function is executed. It also
     * resets the trigger state of the action.
     */
    Action.prototype.execute = function () {
        if (this._continuous === true) {
            if (this._triggered === true) {
                if (this._executeTriggered !== null) {
                    this._executeTriggered((this._intensity >= 0) ? this._intensity : undefined, this._source);
                }
            } else {
                if (this._executeNonTriggered !== null) {
                    this._executeNonTriggered();
                }
            }
        } else {
            if ((this._triggered === true) && (this._executed === false)) {
                if (this._executeTriggered !== null) {
                    this._executeTriggered((this._intensity >= 0) ? this._intensity : undefined, this._source);
                }
                this._executed = true;
            } else {
                if ((this._triggered === false) && (this._nonTriggeredExecuted === false)) {
                    if (this._executeNonTriggered !== null) {
                        this._executeNonTriggered();
                    }
                    this._nonTriggeredExecuted = true;
                }
                if (this._triggered === false) {
                    this._executed = false;
                } else {
                    this._nonTriggeredExecuted = false;
                }
            }
        }
        // We cancel the trigger after every execution. Before calling this function
        // the appropriate triggers have to be set by checking the current inputs.
        this._triggered = false;
        this._intensity = this.INTENSITY_NOT_SPECIFIED;
    };
    // #########################################################################
    /**
     * @class The superclass for all controllers. A controller is responsible for
     * processing triggered actions sent by the input interpreters and applying
     * them to the domain (entity) it is controlling. Controllers for different
     * domains are implemented as the subclasses for this class.
     * @param {Object} [dataJSON] If given, the properties will be initialized loading
     * the data from this JSON object
     */
    function Controller(dataJSON) {
        /**
         * A reference to the control context this controller has been added to.
         * @type ControlContext
         */
        this._context = null;
        /**
         * The associative array of the actions recognized by the controller. The keys
         * are the names of the actions, while the values are the {@link Action}s
         * themselves.
         * @type Object
         */
        this._actions = {};
        // if a JSON object was specified, initialize the properties from there
        if (dataJSON !== undefined) {
            this.loadFromJSON(dataJSON);
        }
    }
    /**
     * Sets the referenced control context for this controller. Call when it is added to the context.
     * @param {ControlContext} value
     */
    Controller.prototype.setContext = function (value) {
        this._context = value;
    };
    /**
     * Returns an array containing all the actions that are recognized by this controller.
     * @returns {Action[]}
     */
    Controller.prototype.getActions = function () {
        var result = [], actionName;
        for (actionName in this._actions) {
            if (this._actions.hasOwnProperty(actionName)) {
                result.push(this._actions[actionName]);
            }
        }
        return result;
    };
    /**
     * Loads the properties of the controller as stored in the passed JSON object.
     * @param {Object} dataJSON
     */
    Controller.prototype.loadFromJSON = function (dataJSON) {
        var i, actionData;
        for (i = 0; i < dataJSON.actions.length; i++) {
            actionData = dataJSON.actions[i];
            if (!actionData.debug || application.isDebugVersion()) {
                this._actions[actionData.name] = new Action(actionData);
            }
        }
    };
    /**
     * Assigns the given function to the action with the given name. After this,
     * the function will be executed whenever the action with the given name is
     * triggered or when it is not triggered, depending on the value of the 'triggered'
     * parameter.
     * @param {String} actionName The name of the action for the function to be
     * associated with.
     * @param {Boolean} triggered The function will be executed whenever the trigger
     * state of the action is the same as this value.
     * @param {Function} actionFunction The function to be assigned to the triggered/
     * non-triggered state of the action.
     */
    Controller.prototype.setActionFunction = function (actionName, triggered, actionFunction) {
        if (this._actions[actionName]) {
            if (triggered === true) {
                this._actions[actionName].setExecuteTriggered(actionFunction);
            } else {
                this._actions[actionName].setExecuteNonTriggered(actionFunction);
            }
        } else {
            application.showError("Attempting to initialize action '" + actionName + "', but no such action was defined " +
                    "for '" + this.getType() + "' type controllers.",
                    application.ErrorSeverity.SEVERE,
                    "The action definition might be missing from the " +
                    "settings file, or the settings file has not been loaded properly. The game is still playable, " +
                    "but this action will not work until the error with the settings file is corrected and the game " +
                    "is restarted.");
        }
    };
    /**
     * Associates the given function to the on and off trigger states of the action
     * with the given name
     * @param {String} actionName The name of the action for the functions to be
     * associated with.
     * @param {Function} functionWhenTriggered The function to execute when the
     * action is triggered.
     * @param {Function} functionWhenNotTriggered The function to execute when the
     * action is not triggered.
     */
    Controller.prototype.setActionFunctions = function (actionName, functionWhenTriggered, functionWhenNotTriggered) {
        this.setActionFunction(actionName, true, functionWhenTriggered);
        this.setActionFunction(actionName, false, functionWhenNotTriggered);
    };
    /**
     * Executes the list of passed actions. If an action is passed more times, this
     * will still execute it only once.
     * @param {Object[][]} triggeredActions The grouped lists of actions in the form of objects
     * where the 'name' (String) property identifies the name of the action and the
     * (optional) 'intensity' (Number) property determines the intensity with which
     * the action is to be executed. Actions that have been triggered by the same controls should
     * be grouped together, and therefore this method expects an array of arrays.
     */
    Controller.prototype.executeActions = function (triggeredActions) {
        var i, j, actionName, actionIntensity, actionSource;
        // first we go through the groups of actions
        for (i = 0; i < triggeredActions.length; i++) {
            // in each group, if there are multiple actions that this controller can handle then choose the one with the highest intensity
            // e.g. movement or turning in opposite directions can appear here together if bound to the same axis, but one will have an
            // intensity of 0
            actionName = null;
            actionIntensity = -1;
            actionSource = null;
            for (j = 0; j < triggeredActions[i].length; j++) {
                if (this._actions[triggeredActions[i][j].name] !== undefined) {
                    // non-graded (undefined) intensity always beats the graded ones
                    if (((triggeredActions[i][j].intensity !== undefined) && (actionIntensity !== undefined) && (triggeredActions[i][j].intensity > actionIntensity)) ||
                            ((actionIntensity !== undefined) && (triggeredActions[i][j].intensity === undefined))) {
                        actionName = triggeredActions[i][j].name;
                        actionIntensity = triggeredActions[i][j].intensity;
                        actionSource = triggeredActions[i][j].source;
                    }
                }
            }
            // if an action was chosen, set its trigger, but only if it has a non-zero intensity - e.g. turning in opposite directions can
            // both appear as 0 intensity actions (if bound to the same axis), to indicate that the axis is occupied with those actions even
            // if no turning has been triggered at the moment - this is why here this action group is cleared here anyway, to ensure that lower
            // priority controllers will not receive their conflicting actions from the same group
            if (actionName) {
                if ((actionIntensity === undefined) || (actionIntensity > 0)) {
                    this._actions[actionName].setTriggered(true, actionIntensity, actionSource);
                }
                triggeredActions[i] = [];
            }
        }
        // Execute all the stored actions, each exactly once.
        for (actionName in this._actions) {
            if (this._actions.hasOwnProperty(actionName)) {
                this._actions[actionName].execute();
            }
        }
    };
    // #########################################################################
    /**
     * @class A control context holds interpreter objects that translate the user 
     * input coming from different devices (such as keyboard or mouse) into actions,
     * and the controllers that can process those actions and execute the appropriate
     * methods of in-game entities they control.
     * @extends AsyncResource
     */
    function ControlContext() {
        asyncResource.AsyncResource.call(this);
        /**
         * The JSON object wich stores the control settings.
         * @type Object
         */
        this._dataJSON = null;
        /**
         * An associative array storing the input interpreter constructor functions of the recognized interpreter types that
         * can be initialized from JSON by this context. The keys are the names by which the interpreter type has to be referred to
         * in the JSON object.
         * @type Object.<String, Function>
         */
        this._inputInterpreterTypes = {};
        /**
         * The array of input interpreters wich collect the user input from different
         * devices (each interpreter is capable of querying one device) and translate
         * them into actions that can be processed by the controllers.
         * @type InputInterpreter[]
         */
        this._inputInterpreters = null;
        /**
         * An associative array of the stored input interpreters organized by a string representation of their types so that
         * they can be accessed by it quickly.
         * @type Object.<String, InputInterpreter>
         */
        this._inputInterpretersByType = {};
        /**
         * An associative array storing the controller constructor functions of the recognized controller types that
         * can be loaded from JSON by this context. The keys are the names by which the controller type has to be referred to
         * in the JSON object.
         * @type Object.<String, Function>
         */
        this._controllerTypes = {};
        /**
         * The list of controllers, which control various entities found in the game.
         * @type Controller[]
         */
        this._controllers = null;
        /**
         * Has the same references to controllers as the _controllers field, but in the current priority order (when multiple actions are
         * triggered by the same controls, the action of the controller coming first in the priority queue will be executed)
         * @type Controller[]
         */
        this._controllersPriorityQueue = null;
        /**
         * An associative array of the stored controllers organized by a string representation of their types so that
         * they can be accessed by it quickly.
         * @type Object.<String, Controller>
         */
        this._controllersByType = {};
        /**
         * Whether the control context is currently listening for user input (through
         * its interpreter objects).
         * @type Boolean
         */
        this._listening = false;
        /**
         * Associative array of the names of disabled actions. The action names are
         * the keys, and if the corresponding action is disabled, the value is true.
         * Disabled actions are not passed to the controllers for processing, even
         * if they would be triggered user input.
         * @type Object
         */
        this._disabledActions = {};
    }
    ControlContext.prototype = new asyncResource.AsyncResource();
    ControlContext.prototype.constructor = ControlContext;
    /**
     * Registers the input interpreter constructor function of the given intepreter type so that from this point on interpreter of such type
     * can be added or initialized from JSON when loading this context. The interpreter type has to be identified by the same name
     * in the JSON as given here.
     * @param {String} inputInterpreterTypeName
     * @param {Function} inputInterpreterTypeConstructor
     */
    ControlContext.prototype.registerInputInterpreterType = function (inputInterpreterTypeName, inputInterpreterTypeConstructor) {
        this._inputInterpreterTypes[inputInterpreterTypeName] = inputInterpreterTypeConstructor;
    };
    /**
     * Adds a new input interpreter to the list of interpreters that are used to
     * collect user input from supported devices and translate it to action name /
     * intensity pairs. It is only allowed to add interpreters of previously registered
     * types.
     * @param {InputInterpreter} inputInterpreter
     */
    ControlContext.prototype.addInputInterpreter = function (inputInterpreter) {
        var interpreterTypeName = utils.getKeyOfValue(this._inputInterpreterTypes, inputInterpreter.constructor);
        if (interpreterTypeName) {
            this._inputInterpreters.push(inputInterpreter);
            // saving another reference for easier access
            this._inputInterpretersByType[interpreterTypeName] = inputInterpreter;
        } else {
            application.showError(
                    "Attempting to add an input interpreter of an unregistered type to the control context!",
                    application.ErrorSeverity.SEVERE,
                    "Interpreter type: " + inputInterpreter.constructor.name);
        }
    };
    /**
     * Returns the list of current input interpreters.
     * @returns {InputInterpreter[]}
     */
    ControlContext.prototype.getInputInterpreters = function () {
        return this._inputInterpreters;
    };
    /**
     * Returns the stored intepreter of the given type. (indicating the input device)
     * @param {String} interpreterTypeName The same name that was used when registering this type 
     * @return {InputInterpreter}
     */
    ControlContext.prototype.getInputInterpreter = function (interpreterTypeName) {
        if (this._inputInterpretersByType[interpreterTypeName]) {
            return this._inputInterpretersByType[interpreterTypeName];
        }
        application.showError("Asked for a interpreter of type '" + interpreterTypeName + "', which does not exist!");
        return null;
    };
    /**
     * Registers the constructor function of the given controller type so that from this point on controllers of such type
     * can be added or initialized from JSON when loading this context. The controller type has to be identified by the same name
     * in the JSON as given here.
     * @param {String} controllerTypeName
     * @param {Function} controllerTypeConstructor
     */
    ControlContext.prototype.registerControllerType = function (controllerTypeName, controllerTypeConstructor) {
        this._controllerTypes[controllerTypeName] = controllerTypeConstructor;
    };
    /**
     * Adds a new controller to the list of controllers that are used to process actions translated by the input interpreters. 
     * It is only allowed to add controllers of previously registered types.
     * @param {Controller} controller
     */
    ControlContext.prototype.addController = function (controller) {
        var controllerTypeName = utils.getKeyOfValue(this._controllerTypes, controller.constructor);
        if (controllerTypeName) {
            this._controllers.push(controller);
            // saving another reference for easier access
            this._controllersByType[controllerTypeName] = controller;
            controller.setContext(this);
        } else {
            application.showError(
                    "Attempting to add a controller of an unregistered type to the control context!",
                    application.ErrorSeverity.SEVERE,
                    "Controller type: " + controller.prototype.constructor.name);
        }
    };
    /**
     * Returns the list of all controllers stored in the control context. This can
     * be used to display the available controls for all controllers on the control
     * settings screen.
     * @returns {Controller[]}
     */
    ControlContext.prototype.getControllers = function () {
        return this._controllers;
    };
    /**
     * Returns the stored controller of the given type.
     * @param {String} controllerTypeName The same name that was used when registering this type 
     * @return {Controller}
     */
    ControlContext.prototype.getController = function (controllerTypeName) {
        if (this._controllersByType[controllerTypeName]) {
            return this._controllersByType[controllerTypeName];
        }
        application.showError("Asked for a controller of type '" + controllerTypeName + "', which does not exist!");
        return null;
    };
    /**
     * Makes the passed controller the first in the priority queue, so that if one control would trigger actions of two different 
     * controllers, one of them being the passed controller, the action belonging to it will be executed. Can only be used with controllers
     * that have been previously added to the context, calling it with a different controller will have no effect. The other controllers
     * remain in the default priority order.
     * @param {Controller} controller
     */
    ControlContext.prototype.makeControllerPriority = function (controller) {
        var i;
        this._controllersPriorityQueue = [];
        for (i = 0; i < this._controllers.length; i++) {
            if (this._controllers[i] === controller) {
                this._controllersPriorityQueue.push(this._controllers[i]);
                break;
            }
        }
        for (i = 0; i < this._controllers.length; i++) {
            if (this._controllers[i] !== controller) {
                this._controllersPriorityQueue.push(this._controllers[i]);
            }
        }
    };
    /**
     * Returns whether the (/ a) controller with the given type name is th first in the controller priority queue.
     * @param {String} controllerTypeName
     * @returns {Boolean}
     */
    ControlContext.prototype.isControllerPriority = function (controllerTypeName) {
        return (this._controllersPriorityQueue.length > 0) && (this._controllersPriorityQueue[0] === this.getController(controllerTypeName));
    };
    /**
     * Resets the default priority order of the stored controllers (the order in which they were added).
     */
    ControlContext.prototype.restoreDefaultControllerPriorityOrder = function () {
        this._controllersPriorityQueue = this._controllers;
    };
    /**
     * Disables the action with the given name. While disabled, this action will not
     * be passed to the controllers for processing, even if user input would trigger
     * it.
     * @param {String} actionName
     */
    ControlContext.prototype.disableAction = function (actionName) {
        this._disabledActions[actionName] = true;
    };
    /**
     * Enables the action with the given name.
     * @param {String} actionName
     */
    ControlContext.prototype.enableAction = function (actionName) {
        this._disabledActions[actionName] = false;
    };
    /**
     * Executes the main control flow: gathers all the triggered and non-disabled 
     * actions translated  by the stored input interpreters and processes them using 
     * all stored controllers.
     * @param {Number} dt The time elapsed since the last control step, in milliseconds.
     */
    ControlContext.prototype.control = function (dt) {
        var
                i,
                triggeredActions,
                actionFilterFunction = function (actionName) {
                    return !this._disabledActions[actionName];
                }.bind(this);
        if (this._listening) {
            triggeredActions = [];
            for (i = 0; i < this._inputInterpreters.length; i++) {
                triggeredActions = triggeredActions.concat(this._inputInterpreters[i].getTriggeredActions(actionFilterFunction));
            }
            for (i = 0; i < this._controllersPriorityQueue.length; i++) {
                this._controllersPriorityQueue[i].executeActions(triggeredActions, dt);
            }
        }
    };
    /**
     * Loads the control configuration (the controllers) stored in a JSON object.
     * @param {Object} dataJSON The JSON object that stores the control settings.
     */
    ControlContext.prototype.loadConfigurationFromJSON = function (dataJSON) {
        var i, n;
        this._controllers = [];
        for (i = 0, n = dataJSON.controllers.length; i < n; i++) {
            if (this._controllerTypes[dataJSON.controllers[i].type]) {
                this.addController(new this._controllerTypes[dataJSON.controllers[i].type](dataJSON.controllers[i]));
            } else {
                application.showError("Attempting to load unregistered controller type: '" + dataJSON.controllers[i].type + "'!",
                        application.ErrorSeverity.SEVERE,
                        (Object.keys(this._controllerTypes).length > 0) ?
                        ("Every controller to be loaded must be of one of the registered types: " + Object.keys(this._controllerTypes).join(", ") + ".") :
                        "There are no types registered and thus loading controllers is not possible.");
            }
        }
        this._controllersPriorityQueue = this._controllers;
    };
    /**
     * Loads the control settings (input interpreters with bindings) stored in a JSON object.
     * @param {Object} dataJSON The JSON object that stores the control settings.
     * @param {Boolean} [onlyRestoreSettings=false] Whether to only restore the
     * default settings by overwriting the changed ones from the data in the JSON,
     * or to initialize the whole context from zero, creating all the necessary
     * objects.
     */
    ControlContext.prototype.loadSettingsFromJSON = function (dataJSON, onlyRestoreSettings) {
        var i, n;
        // if a whole new initialization is needed, create and load all controllers
        // and interpreters from the JSON
        if (!onlyRestoreSettings) {
            this._dataJSON = dataJSON;
            this._inputInterpreters = [];
            for (i = 0, n = dataJSON.inputDevices.length; i < n; i++) {
                if (this._inputInterpreterTypes[dataJSON.inputDevices[i].type]) {
                    this.addInputInterpreter(new this._inputInterpreterTypes[dataJSON.inputDevices[i].type](dataJSON.inputDevices[i]));
                } else if (!dataJSON.inputDevices[i].optional) {
                    application.showError("Attempting to load unregistered input device type: '" + dataJSON.inputDevices[i].type + "'!",
                            application.ErrorSeverity.SEVERE,
                            (Object.keys(this._inputInterpreterTypes).length > 0) ?
                            ("Every input device interpreter to be loaded must be of one of the registered types: " + Object.keys(this._inputInterpreterTypes).join(", ") + ".") :
                            "There are no types registered and thus loading input interpreters is not possible.");
                }
            }
            // if only the defaults need to be restored, go through the stored interpreters 
            // and delete their custom bindings as well as reload their default from the JSON
        } else {
            for (i = 0, n = dataJSON.inputDevices.length; i < n; i++) {
                if (this._inputInterpreterTypes[dataJSON.inputDevices[i].type]) {
                    this._inputInterpreters[i].removeFromLocalStorage();
                    this._inputInterpreters[i].loadFromJSON(dataJSON.inputDevices[i]);
                }
            }
        }
    };
    /**
     * Load custom settings for the stored input interpreters from HTML5 local storage.
     */
    ControlContext.prototype.loadSettingsFromLocalStorage = function () {
        var i;
        for (i = 0; i < this._inputInterpreters.length; i++) {
            this._inputInterpreters[i].loadFromLocalStorage();
        }
        this.setToReady();
    };
    /**
     * Restore the default settings stored in the JSON object from where they were originally
     * loaded.
     */
    ControlContext.prototype.restoreDefaults = function () {
        this.loadSettingsFromJSON(this._dataJSON, true);
    };
    /**
     * Activate all event handlers that listen for user inputs for each stored input
     * interpreter.
     */
    ControlContext.prototype.startListening = function () {
        this.executeWhenReady(function () {
            var i;
            for (i = 0; i < this._inputInterpreters.length; i++) {
                this._inputInterpreters[i].startListening();
            }
            this._listening = true;
        });
    };
    /**
     * Cancel all event handlers that listen for user input for each stored input interpreter.
     */
    ControlContext.prototype.stopListening = function () {
        this.executeWhenReady(function () {
            var i;
            for (i = 0; i < this._inputInterpreters.length; i++) {
                this._inputInterpreters[i].stopListening();
            }
            this._listening = false;
        });
    };
    /**
     * Returns whether the context is currently set to listen for user input through its interpreters.
     * @returns {Boolean}
     */
    ControlContext.prototype.isListening = function () {
        return this._listening;
    };
    /**
     * Sets the screen center to the given coordinates for all input interpreters
     * that need this data (e.g. mouse control interpreter for control based on relative 
     * pointer position)
     * @param {Number} x The X coordinate of the center.
     * @param {Number} y The Y coordinate of the center.
     */
    ControlContext.prototype.setScreenCenter = function (x, y) {
        this.executeWhenReady(function () {
            var i;
            for (i = 0; i < this._inputInterpreters.length; i++) {
                if (this._inputInterpreters[i].setScreenCenter) {
                    this._inputInterpreters[i].setScreenCenter(x, y);
                }
            }
        });
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        ControlBinding: ControlBinding,
        InputInterpreter: InputInterpreter,
        Controller: Controller,
        ControlContext: ControlContext
    };
});

/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides an input interpreter subclass (based on the base class provided by the generic control module) to
 * catch and process input from the keyboard.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, localStorage, document */

/**
 * @param utils Used for the keycode utility function
 * @param application Used for logging and error displaying functionality
 * @param strings For translation support of control strings
 * @param control We build on the generic functionality and classes of this module
 */
define('modules/control/keyboard',[
    "utils/utils",
    "modules/application",
    "modules/strings",
    "modules/control/control"
], function (utils, application, strings, control) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // constants
            SHIFT_CODE = 16,
            CTRL_CODE = 17,
            ALT_CODE = 18,
            CONTROL_STRING_COMBINE = " + ",
            KEY_SUFFIX = "_key",
            SHIFT_STATE_SUFFIX = "_shift",
            CTRL_STATE_SUFFIX = "_ctrl",
            ALT_STATE_SUFFIX = "_alt",
            // ----------------------------------------------------------------------
            // string definitions for translation of control strings
            KEY_STRING_PREFIX = {name: "key" + strings.CATEGORY_SEPARATOR},
            // -------------------------------------------------------------------------
            // private variables
            /**
             * When saving to or loading from local storage, the names of any settings of this module will be prefixed by this string.
             * @type String
             */
            _modulePrefix = "";
    // -------------------------------------------------------------------------
    // functions
    /**
     * Sets a prefix string to be used before the setting names when saving to or loading from local storage.
     * @param {String} value
     */
    function setModulePrefix(value) {
        _modulePrefix = value;
    }
    // #########################################################################
    /**
     * @class Represents a key (combination) - action association.
     * @extends ControlBinding
     * @param {Object|String} [dataJSONOrActionName] If a string is given, it will
     * be taken as the name of the action to be assigned. Otherwise it is taken as
     * a JSON object storing all the properties.
     * @param {String} [key] The string representation of the key associated in this
     * binding.
     * @param {Boolean} [shiftState] Whether shift should be pressed in this key 
     * combination (next to the primary key being pressed).
     * @param {Boolean} [ctrlState] Whether ctrl should be pressed in this key 
     * combination (next to the primary key being pressed).
     * @param {Boolean} [altState] Whether alt should be pressed in this key 
     * combination (next to the primary key being pressed).
     */
    function KeyBinding(dataJSONOrActionName, key, shiftState, ctrlState, altState) {
        /**
         * The string representation of the key. 
         * @see KeyboardInputInterpreter#getKeyCodeTable
         * @type String
         */
        this._key = key || null;
        /**
         * The key code of the key, same as passed in the keyCode property of the event
         * argument of key event handlers.
         * @type Number
         */
        this._keyCode = utils.getKeyCodeOf(key);
        /**
         * Whether shift should be pressed in this key combination (next to _key being pressed).
         * @type Boolean
         */
        this._shiftState = (shiftState === undefined) ? false : (shiftState || (this._keyCode === SHIFT_CODE));
        /**
         * Whether ctrl should be pressed in this key combination (next to _key being pressed).
         * @type Boolean
         */
        this._ctrlState = (ctrlState === undefined) ? false : (ctrlState || (this._keyCode === CTRL_CODE));
        /**
         * Whether alt should be pressed in this key combination (next to _key being pressed).
         * @type Boolean
         */
        this._altState = (altState === undefined) ? false : (altState || (this._keyCode === ALT_CODE));
        control.ControlBinding.call(this, dataJSONOrActionName);
        application.log_DEBUG("Created key binding: " + this._actionName + " - " + this.getControlString(), 3);
    }
    KeyBinding.prototype = new control.ControlBinding();
    KeyBinding.prototype.constructor = KeyBinding;
    /**
     * @override
     * Loads the properties of the key binding as stored in the passed JSON object.
     * @param {Object} dataJSON
     */
    KeyBinding.prototype.loadFromJSON = function (dataJSON) {
        control.ControlBinding.prototype.loadFromJSON.call(this, dataJSON);
        this.setKey(dataJSON.key);
        this._shiftState = (dataJSON.shift === true) || (this._keyCode === SHIFT_CODE);
        this._ctrlState = (dataJSON.ctrl === true) || (this._keyCode === CTRL_CODE);
        this._altState = (dataJSON.alt === true) || (this._keyCode === ALT_CODE);
    };
    /**
     * @override
     * Saves the properties of this key binding to HTML5 local storage.
     */
    KeyBinding.prototype.saveToLocalStorage = function () {
        localStorage[_modulePrefix + this._actionName + KEY_SUFFIX] = this._key;
        localStorage[_modulePrefix + this._actionName + SHIFT_STATE_SUFFIX] = this._shiftState;
        localStorage[_modulePrefix + this._actionName + CTRL_STATE_SUFFIX] = this._ctrlState;
        localStorage[_modulePrefix + this._actionName + ALT_STATE_SUFFIX] = this._altState;
    };
    /**
     * @override
     * Loads the properties of the key binding if they are stored in the HTML5 local
     * storage object.
     */
    KeyBinding.prototype.loadFromLocalStorage = function () {
        if (localStorage[_modulePrefix + this._actionName + KEY_SUFFIX] !== undefined) {
            this.setKey(localStorage[_modulePrefix + this._actionName + KEY_SUFFIX]);
            this._shiftState = (localStorage[_modulePrefix + this._actionName + SHIFT_STATE_SUFFIX] === "true");
            this._ctrlState = (localStorage[_modulePrefix + this._actionName + CTRL_STATE_SUFFIX] === "true");
            this._altState = (localStorage[_modulePrefix + this._actionName + ALT_STATE_SUFFIX] === "true");
        }
    };
    /**
     * @override
     * Removes the properties of this key binding from the HTML5 local storage.
     */
    KeyBinding.prototype.removeFromLocalStorage = function () {
        localStorage.removeItem(_modulePrefix + this._actionName + KEY_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + SHIFT_STATE_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + CTRL_STATE_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + ALT_STATE_SUFFIX);
    };
    /**
     * Returns the string representation of the key assigned in this key binding.
     * (without respect to the shift, ctrl and alt states).
     * @returns {String}
     */
    KeyBinding.prototype.getKey = function () {
        return this._key;
    };
    /**
     * Assigns the passed key, binding it to the action assigned in this key binding.
     * The key needs to be given in string form. @see KeyboardInputInterpreter#getKeyCodeTable
     * @param {String} key
     */
    KeyBinding.prototype.setKey = function (key) {
        this._key = key;
        this._keyCode = utils.getKeyCodeOf(this._key);
    };
    /**
     * Returns if pressing shift is part of the key combination assigned in this
     * key binding.
     * @returns {Boolean}
     */
    KeyBinding.prototype.getShiftState = function () {
        return this._shiftState;
    };
    /**
     * Returns if pressing ctrl is part of the key combination assigned in this
     * key binding. 
     * @returns {Boolean}
     */
    KeyBinding.prototype.getCtrlState = function () {
        return this._ctrlState;
    };
    /**
     * Returns if pressing alt is part of the key combination assigned in this
     * key binding. 
     * @returns {Boolean}
     */
    KeyBinding.prototype.getAltState = function () {
        return this._altState;
    };
    /**
     * @override
     * Returns a string that describes the key combination that is bound to the action in this binding to show to the user.
     * @returns {String}
     */
    KeyBinding.prototype.getControlString = function () {
        var result, modifier;
        result = strings.get(KEY_STRING_PREFIX, this._key, this._key);
        if (this._shiftState && (this._keyCode !== SHIFT_CODE)) {
            modifier = utils.getKeyOfCode(SHIFT_CODE);
            modifier = strings.get(KEY_STRING_PREFIX, modifier, modifier);
            result = modifier + CONTROL_STRING_COMBINE + result;
        }
        if ((this._ctrlState) && (this._keyCode !== CTRL_CODE)) {
            modifier = utils.getKeyOfCode(CTRL_CODE);
            modifier = strings.get(KEY_STRING_PREFIX, modifier, modifier);
            result = modifier + CONTROL_STRING_COMBINE + result;
        }
        if ((this._altState) && (this._keyCode !== ALT_CODE)) {
            modifier = utils.getKeyOfCode(ALT_CODE);
            modifier = strings.get(KEY_STRING_PREFIX, modifier, modifier);
            result = modifier + CONTROL_STRING_COMBINE + result;
        }
        return result;
    };
    /**
     * Returns if the key combination is triggered according to the keyboard state
     * passed as parameter.
     * @param {Boolean[]} currentlyPressedKeys An array indicating the current pressed
     * state of each key on the keyboard. The index in the array corresponds to the
     * keyCode property of the event argument of the key event handlers.
     * @returns {Boolean}
     */
    KeyBinding.prototype.isTriggered = function (currentlyPressedKeys) {
        return (currentlyPressedKeys[this._keyCode] &&
                (currentlyPressedKeys[SHIFT_CODE] || !this._shiftState) &&
                (currentlyPressedKeys[CTRL_CODE] || !this._ctrlState) &&
                (currentlyPressedKeys[ALT_CODE] || !this._altState));
    };
    /**
     * @override
     * Returns whether this binding has the same key configuration as the passed one (and so it conflicts with it)
     * @param {KeyBinding} otherKeyBinding
     */
    KeyBinding.prototype.bindsTheSameControls = function (otherKeyBinding) {
        return (this._keyCode === otherKeyBinding._keyCode);
    };
    // #########################################################################
    /**
     * @class Monitors the keyboard inputs and stores the current state of which
     * keys are pressed. Can load and store key bindings and based on the current
     * state and the key bindings, determine the list of currently triggered actions
     * that controllers can/should execute.
     * @extends InputInterpreter
     * @param {Object} [dataJSON] Upon initialization, it can load the key bindings from
     * this JSON object if specified.
     */
    function KeyboardInputInterpreter(dataJSON) {
        control.InputInterpreter.call(this, KeyBinding, dataJSON);
        /**
         * An array indicating the current pressed state of each key on the keyboard. 
         * The index in the array corresponds to the keyCode property of the event 
         * argument of the key event handlers.
         * @type Boolean[256]
         */
        this._currentlyPressedKeys = new Array(256);
    }
    KeyboardInputInterpreter.prototype = new control.InputInterpreter();
    KeyboardInputInterpreter.prototype.constructor = KeyboardInputInterpreter;
    /**
     * @override
     * Returns of the name of the device this interpreter monitors. Every input
     * interpreter should implement this function.
     * @returns {String}
     */
    KeyboardInputInterpreter.prototype.getDeviceName = function () {
        return "keyboard";
    };
    /**
     * @override
     * Updates the internally stored state of the keyboard, marking all keys as non-pressed.
     */
    KeyboardInputInterpreter.prototype.resetState = function () {
        var i;
        for (i = 0; i < this._currentlyPressedKeys.length; i++) {
            this._currentlyPressedKeys[i] = false;
        }
    };
    /**
     * Returns whether the default browser actions for the key of the passed code
     * should be enabled while this interpreter is active.
     * @param {Number} keyCode
     * @returns {Boolean}
     */
    KeyboardInputInterpreter.prototype.defaultActionEnabledForKey = function (keyCode) {
        return ["f5", "f11", 'escape'].indexOf(utils.getKeyOfCode(keyCode)) >= 0;
    };
    /**
     * An event handler for the keydown event, updating the stored state of the 
     * keyboard.
     * @param {KeyboardEvent} event
     */
    KeyboardInputInterpreter.prototype.handleKeyDown = function (event) {
        this._currentlyPressedKeys[event.keyCode] = true;
        if (!this.defaultActionEnabledForKey(event.keyCode)) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
    /**
     * An event handler for the keyup event, updating the stored state of the 
     * keyboard.
     * @param {KeyboardEvent} event
     */
    KeyboardInputInterpreter.prototype.handleKeyUp = function (event) {
        this._currentlyPressedKeys[event.keyCode] = false;
        if (!this.defaultActionEnabledForKey(event.keyCode)) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
    /**
     * @override
     * Sets the event handlers on the document to start updating the stored internal
     * state on key presses and releases. The triggered actions can be queried from
     * this interpreter after this function has been called.
     */
    KeyboardInputInterpreter.prototype.startListening = function () {
        control.InputInterpreter.prototype.startListening.call(this);
        document.onkeydown = function (event) {
            this.handleKeyDown(event);
        }.bind(this);
        document.onkeyup = function (event) {
            this.handleKeyUp(event);
        }.bind(this);
        document.onkeypress = function (event) {
            if (!this.defaultActionEnabledForKey(event.keyCode)) {
                event.preventDefault();
                event.stopPropagation();
            }
        }.bind(this);
    };
    /**
     * @override
     * Cancels the event handlers on the document that update the internal state.
     * The triggered actions cannot be queried from this interpreter after this 
     * function has been called.
     */
    KeyboardInputInterpreter.prototype.stopListening = function () {
        control.InputInterpreter.prototype.stopListening.call(this);
        document.onkeydown = null;
        document.onkeyup = null;
    };
    /**
     * @override
     * Checks if the action with the supplied name is triggered based on the current input state.
     * @param {String} actionName
     * @returns {(ActionTrigger|null)} Null, if the action is not triggered
     */
    KeyboardInputInterpreter.prototype.checkAction = function (actionName) {
        return (this._bindings[actionName].isTriggered(this._currentlyPressedKeys)) ?
                {name: actionName, source: this} :
                null;
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        setModulePrefix: setModulePrefix,
        KeyBinding: KeyBinding,
        KeyboardInputInterpreter: KeyboardInputInterpreter
    };
});

/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides an input interpreter subclass (based on the base class provided by the generic control module) to
 * catch and process input from the mouse.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, Element, localStorage, document, window */

/**
 * @param utils Used for formatting control strings
 * @param strings For translation support of control strings
 * @param control We build on the generic functionality and classes of this module
 */
define('modules/control/mouse',[
    "utils/utils",
    "modules/strings",
    "modules/control/control"
], function (utils, strings, control) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // enums
            MouseButtonName = {
                NONE: "none",
                LEFT: "left",
                MIDDLE: "middle",
                RIGHT: "right"
            },
            // ----------------------------------------------------------------------
            // constants
            /**
             * The index of the element is the index of the button
             * @type Array
             */
            MOUSE_BUTTON_NAMES = [
                MouseButtonName.NONE,
                MouseButtonName.LEFT,
                MouseButtonName.MIDDLE,
                MouseButtonName.RIGHT
            ],
            DIRECTION_LEFT = "left",
            DIRECTION_RIGHT = "right",
            DIRECTION_UP = "up",
            DIRECTION_DOWN = "down",
            MOUSE_BUTTON_INDEX_SUFFIX = "_button",
            MOUSE_MOVE_X_SUFFIX = "_moveX",
            MOUSE_MOVE_Y_SUFFIX = "_moveY",
            MOUSE_FROM_CENTER_SUFFIX = "_measuredFromCenter",
            MOUSE_SCROLL_X_SUFFIX = "_scrollX",
            MOUSE_SCROLL_Y_SUFFIX = "_scrollY",
            // ----------------------------------------------------------------------
            // string definitions for translation of control strings
            MOUSE_LEFT_BUTTON = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "leftButton",
                defaultValue: "left click"
            },
            MOUSE_RIGHT_BUTTON = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "rightButton",
                defaultValue: "right click"
            },
            MOUSE_MIDDLE_BUTTON = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "middleButton",
                defaultValue: "middle click"
            },
            MOUSE_FROM_CENTER = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "fromCenter",
                defaultValue: "{move} {toDirection} from center"
            },
            MOUSE_NOT_FROM_CENTER = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "notFromCenter",
                defaultValue: "{move} {toDirection}"
            },
            MOUSE_MOVE = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "move",
                defaultValue: "move"
            },
            MOUSE_DIRECTION_LEFT = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "leftDirection",
                defaultValue: "left"
            },
            MOUSE_DIRECTION_RIGHT = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "rightDirection",
                defaultValue: "right"
            },
            MOUSE_DIRECTION_UP = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "upDirection",
                defaultValue: "up"
            },
            MOUSE_DIRECTION_DOWN = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "downDirection",
                defaultValue: "down"
            },
            MOUSE_SCROLL = {
                name: "mouse" + strings.CATEGORY_SEPARATOR + "scroll",
                defaultValue: "scroll"
            },
            // -------------------------------------------------------------------------
            // private variables
            /**
             * When saving to or loading from local storage, the names of any settings of this module will be prefixed by this string.
             * @type String
             */
            _modulePrefix = "";
    // -------------------------------------------------------------------------
    // functions
    /**
     * Sets a prefix string to be used before the setting names when saving to or loading from local storage.
     * @param {String} value
     */
    function setModulePrefix(value) {
        _modulePrefix = value;
    }
    // #########################################################################
    /**
     * @class Represents the assignment of a mouse action (such as move, click...) 
     * to an in-game action. (such as fire)
     * @extends ControlBinding
     * @param {Object} [dataJSON] If given, the properties will be initialized from
     * the data stored in this JSON object.
     */
    function MouseBinding(dataJSON) {
        /**
         * Which mouse button should be pressed to trigger this binding.
         * Possible values:
         * 0: none
         * 1: left
         * 2: middle
         * 3: right
         * @type Number
         * @default 0
         */
        this._buttonIndex = 0;
        /**
         * What kind of horizontal mouse movement needs to take place to trigger 
         * this binding.
         * Possible values:
         * 0: none
         * -1: movement to the left
         * 1: movement to the right
         * @type Number
         * @default 0
         */
        this._moveX = 0;
        /**
         * What kind of vertical mouse movement needs to take place to trigger 
         * this binding.
         * Possible values:
         * 0: none
         * -1: movement upward
         * 1: movement downward
         * @type Number
         * @default 0
         */
        this._moveY = 0;
        /**
         * Whether the movement (displacement) should be calculated relative to the
         * screen (canvas) center (or relative to the previous mouse position).
         * @type Boolean
         * @default false
         */
        this._measuredFromCenter = false;
        /**
         * What kind of mouse scrolling needs to take place on the X axis to trigger this binding.
         * Possible values:
         * 0: none
         * -1: scroll left
         * 1: scroll right
         * @type Number
         * @default 0
         */
        this._scrollX = 0;
        /**
         * What kind of mouse scrolling needs to take place on the Y axis to trigger this binding.
         * Possible values:
         * 0: none
         * 1: scroll downward
         * -1: scroll upward
         * @type Number
         * @default 0
         */
        this._scrollY = 0;
        control.ControlBinding.call(this, dataJSON);
    }
    MouseBinding.prototype = new control.ControlBinding();
    MouseBinding.prototype.constructor = MouseBinding;
    /**
     * @override
     * Loads the properties of the key binding as stored in the passed JSON object.
     * @param {Object} dataJSON
     */
    MouseBinding.prototype.loadFromJSON = function (dataJSON) {
        control.ControlBinding.prototype.loadFromJSON.call(this, dataJSON);
        this._buttonIndex = MOUSE_BUTTON_NAMES.indexOf(dataJSON.button);
        this._moveX = 0;
        this._moveY = 0;
        switch (dataJSON.move) {
            case DIRECTION_LEFT:
                this._moveX = -1;
                break;
            case DIRECTION_RIGHT:
                this._moveX = 1;
                break;
            case DIRECTION_UP:
                this._moveY = -1;
                break;
            case DIRECTION_DOWN:
                this._moveY = 1;
                break;
        }
        this._measuredFromCenter = (dataJSON.fromCenter === true);
        this._scrollX = 0;
        this._scrollY = 0;
        switch (dataJSON.scroll) {
            case DIRECTION_LEFT:
                this._scrollX = -1;
                break;
            case DIRECTION_RIGHT:
                this._scrollX = 1;
                break;
            case DIRECTION_UP:
                this._scrollY = -1;
                break;
            case DIRECTION_DOWN:
                this._scrollY = 1;
                break;
        }
    };
    /**
     * @override
     * Saves the properties of this mouse binding to HTML5 local storage.
     */
    MouseBinding.prototype.saveToLocalStorage = function () {
        localStorage[_modulePrefix + this._actionName + MOUSE_BUTTON_INDEX_SUFFIX] = this._buttonIndex;
        localStorage[_modulePrefix + this._actionName + MOUSE_MOVE_X_SUFFIX] = this._moveX;
        localStorage[_modulePrefix + this._actionName + MOUSE_MOVE_Y_SUFFIX] = this._moveY;
        localStorage[_modulePrefix + this._actionName + MOUSE_FROM_CENTER_SUFFIX] = this._measuredFromCenter;
        localStorage[_modulePrefix + this._actionName + MOUSE_SCROLL_X_SUFFIX] = this._scrollX;
        localStorage[_modulePrefix + this._actionName + MOUSE_SCROLL_Y_SUFFIX] = this._scrollY;
    };
    /**
     * @override
     * Loads the properties of the mouse binding if they are stored in the HTML5 local
     * storage object.
     */
    MouseBinding.prototype.loadFromLocalStorage = function () {
        if (localStorage[_modulePrefix + this._actionName + MOUSE_BUTTON_INDEX_SUFFIX] !== undefined) {
            this._buttonIndex = parseInt(localStorage[_modulePrefix + this._actionName + MOUSE_BUTTON_INDEX_SUFFIX], 10);
            this._moveX = parseInt(localStorage[_modulePrefix + this._actionName + MOUSE_MOVE_X_SUFFIX], 10);
            this._moveY = parseInt(localStorage[_modulePrefix + this._actionName + MOUSE_MOVE_Y_SUFFIX], 10);
            this._measuredFromCenter = (localStorage[_modulePrefix + this._actionName + MOUSE_FROM_CENTER_SUFFIX] === "true");
            this._scrollX = parseInt(localStorage[_modulePrefix + this._actionName + MOUSE_SCROLL_X_SUFFIX], 10);
            this._scrollY = parseInt(localStorage[_modulePrefix + this._actionName + MOUSE_SCROLL_Y_SUFFIX], 10);
        }
    };
    /**
     * @override
     * Removes the properties of this mouse binding from the HTML5 local storage.
     */
    MouseBinding.prototype.removeFromLocalStorage = function () {
        localStorage.removeItem(_modulePrefix + this._actionName + MOUSE_BUTTON_INDEX_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + MOUSE_MOVE_X_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + MOUSE_MOVE_Y_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + MOUSE_FROM_CENTER_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + MOUSE_SCROLL_X_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + MOUSE_SCROLL_Y_SUFFIX);
    };
    /**
     * Returns if the binding trigger intensity depends on the displacement of the
     * mouse from the center of the screen.
     * @returns {Boolean}
     */
    MouseBinding.prototype.isMeasuredFromCenter = function () {
        return this._measuredFromCenter;
    };
    /**
     * @override
     * Returns a string representation describing the mouse action the user needs
     * to perform to trigger this binding.
     * @returns {String}
     */
    MouseBinding.prototype.getControlString = function () {
        var result = "", direction = null;
        switch (MOUSE_BUTTON_NAMES[this._buttonIndex]) {
            case MouseButtonName.LEFT:
                return strings.get(MOUSE_LEFT_BUTTON);
            case MouseButtonName.MIDDLE:
                return strings.get(MOUSE_MIDDLE_BUTTON);
            case MouseButtonName.RIGHT:
                return strings.get(MOUSE_RIGHT_BUTTON);
        }
        result = this._measuredFromCenter ?
                strings.get(MOUSE_FROM_CENTER) :
                strings.get(MOUSE_NOT_FROM_CENTER);
        if (this._moveX < 0) {
            direction = strings.get(MOUSE_DIRECTION_LEFT);
        } else if (this._moveX > 0) {
            direction = strings.get(MOUSE_DIRECTION_RIGHT);
        } else if (this._moveY < 0) {
            direction = strings.get(MOUSE_DIRECTION_UP);
        } else if (this._moveY > 0) {
            direction = strings.get(MOUSE_DIRECTION_DOWN);
        }
        if (direction) {
            result = utils.formatString(result, {
                move: strings.get(MOUSE_MOVE),
                toDirection: direction
            });
            return result;
        }
        direction = null;
        result = strings.get(MOUSE_NOT_FROM_CENTER);
        if (this._scrollX < 0) {
            direction = strings.get(MOUSE_DIRECTION_LEFT);
        } else if (this._scrollX > 0) {
            direction = strings.get(MOUSE_DIRECTION_RIGHT);
        } else if (this._scrollY < 0) {
            direction = strings.get(MOUSE_DIRECTION_UP);
        } else if (this._scrollY > 0) {
            direction = strings.get(MOUSE_DIRECTION_DOWN);
        }
        if (direction) {
            result = utils.formatString(result, {
                move: strings.get(MOUSE_SCROLL),
                toDirection: direction
            });
        }
        return result;
    };
    /**
     * Returns how much is the mouse action  triggered according to the current mouse 
     * state passed as parameter. Mouse actions can have different trigger intensities
     * (the mouse moving faster/further from the base point), therefore the returned
     * value is an integer.
     * @param {Boolean[]} currentlyPressedButtons The current press state of the 
     * mouse buttons. Arrangement: [left,middle,right]
     * @param {Number[2]} mousePosition The current [x,y] position of the mouse on the screen
     * @param {Number[2]} mousePositionChange The difference of the current position from the one at the previous trigger check ([x,y])
     * @param {Number[2]} screenCenter The coordinates of the center of the screen ([x,y])
     * @param {Number[2]} scrollChange The change in scroll position from the one at the previous trigger check ([x,y])
     * @returns {Number} Whether the action was triggerend and with what intensity.
     * Zero means the action was not triggered, a positive value represents the 
     * intensity.
     */
    MouseBinding.prototype.getTriggeredIntensity = function (currentlyPressedButtons, mousePosition, mousePositionChange, screenCenter, scrollChange) {
        var relativeX, relativeY;
        // first if this is a button assignment, check the state of the appropriate
        // mouse button
        if (this._buttonIndex > 0) {
            return (currentlyPressedButtons[this._buttonIndex] === true) ? 1 : -1;
        }
        if (!mousePosition) {
            return 0;
        }
        // check movement on X and Y axes
        // movement in the negative direction is represented by '-1' value of _moveX/Y,
        // therefore multiplying with the actual movement will be positive if it was
        // in the same direction
        // only calculate the displacement if we have a valid mouse position
        relativeX = this._measuredFromCenter ?
                ((mousePosition[0] >= 0) ?
                        mousePosition[0] - screenCenter[0] :
                        0) :
                mousePositionChange[0];
        if (this._moveX !== 0) {
            return relativeX * this._moveX;
        }
        relativeY = this._measuredFromCenter ?
                ((mousePosition[1] >= 0) ?
                        mousePosition[1] - screenCenter[1] :
                        0) :
                mousePositionChange[1];
        if (this._moveY !== 0) {
            return relativeY * this._moveY;
        }
        if (this._scrollX !== 0) {
            return scrollChange[0] * this._scrollX;
        }
        if (this._scrollY !== 0) {
            return scrollChange[1] * this._scrollY;
        }
    };
    /**
     * @override
     * Returns whether this binding has the same control (button/axis) configuration as the passed one (and so it conflicts with it)
     * @param {MouseBinding} otherMouseBinding
     */
    MouseBinding.prototype.bindsTheSameControls = function (otherMouseBinding) {
        return (this._buttonIndex === otherMouseBinding._buttonIndex) &&
                (((this._moveX === 0) && (otherMouseBinding._moveX === 0)) || ((this._moveX * otherMouseBinding._moveX) !== 0)) &&
                (((this._moveY === 0) && (otherMouseBinding._moveY === 0)) || ((this._moveY * otherMouseBinding._moveY) !== 0)) &&
                (((this._scrollX === 0) && (otherMouseBinding._scrollX === 0)) || ((this._scrollX * otherMouseBinding._scrollX) !== 0)) &&
                (((this._scrollY === 0) && (otherMouseBinding._scrollY === 0)) || ((this._scrollY * otherMouseBinding._scrollY) !== 0));
    };
    // #########################################################################
    /**
     * @class Monitors the mouse inputs and stores the current state of the mouse. 
     * Can load and store mouse bindings and based on the current state and the 
     * bindings, determine the list of currently triggered actions that controllers 
     * can/should execute.
     * @extends InputInterpreter
     * @param {Object} [dataJSON] Upon initialization, it can load the mouse bindings from
     * this JSON object if specified.
     */
    function MouseInputInterpreter(dataJSON) {
        /**
         * An array storing the press state of mouse buttons.
         * Arrangement: [left,middle,right]
         * @type Boolean[3]
         */
        this._currentlyPressedButtons = [false, false, false];
        /**
         * Stores the center of the screen, relative to which the mouse coordinates
         * can be considered by bindings (instead of the change in mouse position) 
         * so that control is possible when the mouse does not need to be moved 
         * continuously for e.g. continuous turning.
         * @type Number[2]
         */
        this._screenCenter = [0, 0];
        /**
         * A cahced value of the mininum of the X and Y coordinates of the screen center.
         * @type Number
         */
        this._screenSize = 0;
        /**
         * The current mouse position as obtained from the mouse event.
         * @type Number[2]
         */
        this._mousePosition = [-1, -1];
        /**
         * The change in mouse position since the last time the inputs were processed.
         * @type Number[2]
         */
        this._mousePositionChange = [0, 0];
        /**
         * The scrolling that happened on axes X and Y since the last time the inputs were processed.
         * @type Number[2]
         */
        this._scrollChange = [0, 0];
        /**
         * The intensity of actions derived from the speed of the mouse movement
         * will be multiplied by this factor.
         * @type Number
         */
        this._moveSensitivity = 0;
        /**
         * The intensity of actions derived from displacement of the mouse from the
         * center will reach 1.0 at the distance that is the screen size (the smaller one of width / height)
         * multiplied by this factor.
         * @type Number
         */
        this._displacementAreaRelativeSize = 0;
        /**
         * The factor mouse displacement will be multiplied by to get the action intensity (maximum 1.0)
         * based on the displacement area relative size and the screen size (cached value).
         * @type Number
         */
        this._displacementFactor = 1;
        /**
         * The actions the would derive their intensity from displacement of the mouse 
         * from the center will not be triggered unless the displacement exceeds this
         * magnitude (in pixels).
         * @type Number
         */
        this._displacementDeadzone = 0;
        control.InputInterpreter.call(this, MouseBinding, dataJSON);
    }
    MouseInputInterpreter.prototype = new control.InputInterpreter();
    MouseInputInterpreter.prototype.constructor = MouseInputInterpreter;
    /**
     * Updates the factor mouse displacement will be multiplied by to get the action intensity (maximum 1.0)
     * based on the displacement area relative size and the screen size.
     */
    MouseInputInterpreter.prototype._updateDisplacementFactor = function () {
        this._displacementFactor = 1 / ((this._screenSize || 1) * this._displacementAreaRelativeSize);
    };
    /**
     * Updates the screen center relative to which the mouse position is sent to the
     * binding to check if they are triggered. Needs to be called when the center
     * changes, e.g. the window is resized.
     * @param {Number} x The X coordinate.
     * @param {Number} y The Y coordinate.
     */
    MouseInputInterpreter.prototype.setScreenCenter = function (x, y) {
        this._screenCenter = [x, y];
        this._screenSize = Math.min(x, y);
        this._updateDisplacementFactor();
        this._mousePosition = [x, y];
        this._mousePositionChange = [0, 0];
        this._scrollChange = [0, 0];
    };
    /**
     * @override
     * Returns of the name of the device this interpreter monitors. Every input
     * interpreter should implement this function.
     * @returns {String}
     */
    MouseInputInterpreter.prototype.getDeviceName = function () {
        return "mouse";
    };
    /**
     * @override
     */
    MouseInputInterpreter.prototype.resetState = function () {
        var i;
        for (i = 0; i < this._currentlyPressedButtons.length; i++) {
            this._currentlyPressedButtons[i] = false;
        }
        this._mousePosition = [-1, -1];
        this._mousePositionChange = [0, 0];
        this._scrollChange = [0, 0];
    };
    /**
     * Sets the mouse move sensitivity and stores the setting in HTML5 local storage.
     * @param {Number} moveSensitivity
     */
    MouseInputInterpreter.prototype.setAndStoreMoveSensitivity = function (moveSensitivity) {
        this._moveSensitivity = moveSensitivity;
        localStorage[_modulePrefix + "mouse_moveSensitivity"] = this._moveSensitivity;
    };
    /**
     * Returns the mouse displacement sensitivity.
     * @returns {Number}
     */
    MouseInputInterpreter.prototype.getDisplacementAreaRelativeSize = function () {
        return this._displacementAreaRelativeSize;
    };
    /**
     * Sets the mouse displacement sensitivity and stores the setting in HTML5 local storage.
     * @param {Number} displacementAreaRelativeSize
     */
    MouseInputInterpreter.prototype.setAndStoreDisplacementAreaRelativeSize = function (displacementAreaRelativeSize) {
        this._displacementAreaRelativeSize = displacementAreaRelativeSize;
        this._updateDisplacementFactor();
        localStorage[_modulePrefix + "mouse_displacementAreaRelativeSize"] = this._displacementAreaRelativeSize;
    };
    /**
     * Sets the mouse displacement deadzone and stores the setting in HTML5 local storage.
     * @param {Number} displacementDeadzone
     */
    MouseInputInterpreter.prototype.setAndStoreDisplacementDeadzone = function (displacementDeadzone) {
        this._displacementDeadzone = displacementDeadzone;
        localStorage[_modulePrefix + "mouse_displacementDeadzone"] = this._displacementDeadzone;
    };
    /**
     * @override
     * Loads the properties of the interpreter such as the (default) mouse bindings
     * from the passed JSON object.
     * @param {Object} dataJSON
     */
    MouseInputInterpreter.prototype.loadFromJSON = function (dataJSON) {
        control.InputInterpreter.prototype.loadFromJSON.call(this, dataJSON);
        this._moveSensitivity = dataJSON.sensitivityProfile.moveSensitivity;
        this._displacementAreaRelativeSize = dataJSON.sensitivityProfile.displacementAreaRelativeSize;
        this._updateDisplacementFactor();
        this._displacementDeadzone = dataJSON.sensitivityProfile.displacementDeadzone;
    };
    /**
     * @override
     * Loads the properties of the interpreter such as the (custom local) mouse bindings
     * from HTML5 local storage.
     */
    MouseInputInterpreter.prototype.loadFromLocalStorage = function () {
        control.InputInterpreter.prototype.loadFromLocalStorage.call(this);
        if (localStorage[_modulePrefix + "mouse_moveSensitivity"] !== undefined) {
            this._moveSensitivity = parseFloat(localStorage[_modulePrefix + "mouse_moveSensitivity"]);
        }
        if (localStorage[_modulePrefix + "mouse_displacementAreaRelativeSize"] !== undefined) {
            this._displacementAreaRelativeSize = parseFloat(localStorage[_modulePrefix + "mouse_displacementAreaRelativeSize"]);
            this._updateDisplacementFactor();
        }
        if (localStorage[_modulePrefix + "mouse_displacementDeadzone"] !== undefined) {
            this._displacementDeadzone = parseInt(localStorage[_modulePrefix + "mouse_displacementDeadzone"], 10);
        }
    };
    /**
     * @override
     * Removes custom mouse bindings stored in HTML5 local storage.
     */
    MouseInputInterpreter.prototype.removeFromLocalStorage = function () {
        control.InputInterpreter.prototype.removeFromLocalStorage.call(this);
        localStorage.removeItem(_modulePrefix + "mouse_moveSensitivity");
        localStorage.removeItem(_modulePrefix + "mouse_displacementAreaRelativeSize");
        localStorage.removeItem(_modulePrefix + "mouse_displacementDeadzone");
    };
    /**
     * An event handler for the mousedown event, updating the stored state of the 
     * mouse.
     * @param {MouseEvent} event
     */
    MouseInputInterpreter.prototype.handleMouseDown = function (event) {
        this._currentlyPressedButtons[event.which] = true;
        event.preventDefault();
        return false;
    };
    /**
     * An event handler for the mouseup event, updating the stored state of the 
     * mouse.
     * @param {MouseEvent} event
     */
    MouseInputInterpreter.prototype.handleMouseUp = function (event) {
        this._currentlyPressedButtons[event.which] = false;
        event.preventDefault();
        return false;
    };
    /**
     * An event handler for the mousemove event, updating the stored state of the 
     * mouse.
     * @param {MouseEvent} event
     */
    MouseInputInterpreter.prototype.handleMouseMove = function (event) {
        // we add up all movements of the mouse and null it out after every query for triggered actions, so all movements between two
        // queries are considered
        // only add the movement if we have a valid mouse position
        if (this._mousePosition[0] >= 0) {
            this._mousePositionChange[0] += (event.clientX - this._mousePosition[0]);
            this._mousePositionChange[1] += (event.clientY - this._mousePosition[1]);
        }
        this._mousePosition = [event.clientX, event.clientY];
    };
    /**
     * An event handler for the wheel event , updating the stored scrolling state
     * @param {WheelEvent} event
     */
    MouseInputInterpreter.prototype.handleWheel = function (event) {
        // changes are accumulated and reset to zero when processed
        this._scrollChange[0] += event.deltaX;
        this._scrollChange[1] += event.deltaY;
    };
    /**
     * @override
     * Sets the event handlers on the document to start updating the stored internal
     * state of the mouse. The triggered actions can be queried from this interpreter 
     * after this function has been called.
     */
    MouseInputInterpreter.prototype.startListening = function () {
        control.InputInterpreter.prototype.startListening.call(this);
        document.onmousedown = function (event) {
            this.handleMouseDown(event);
        }.bind(this);
        document.onmouseup = function (event) {
            this.handleMouseUp(event);
        }.bind(this);
        document.onmousemove = function (event) {
            this.handleMouseMove(event);
        }.bind(this);
        document.onwheel = function (event) {
            this.handleWheel(event);
        }.bind(this);
        document.onclick = function (event) {
            event.preventDefault();
            return false;
        };
        document.oncontextmenu = function (event) {
            event.preventDefault();
            return false;
        };
    };
    /**
     * @override
     * Cancels the event handlers on the document that update the internal state.
     * The triggered actions cannot be queried from this interpreter after this 
     * function has been called.
     */
    MouseInputInterpreter.prototype.stopListening = function () {
        control.InputInterpreter.prototype.stopListening.call(this);
        document.onmousedown = null;
        document.onmouseup = null;
        document.onmousemove = null;
        document.onwheel = null;
        document.onclick = null;
        document.oncontextmenu = null;
    };
    /**
     * @override
     * Checks if the action with the supplied name is triggered based on the current input state.
     * @param {String} actionName
     * @returns {(ActionTrigger|null)} Null, if the action is not triggered
     */
    MouseInputInterpreter.prototype.checkAction = function (actionName) {
        var actionIntensity =
                this._bindings[actionName].getTriggeredIntensity(
                this._currentlyPressedButtons,
                this._mousePosition,
                this._mousePositionChange,
                this._screenCenter,
                this._scrollChange);
        return (actionIntensity >= 0) ?
                {
                    name: actionName,
                    intensity: (this._bindings[actionName].isMeasuredFromCenter() === true) ?
                            Math.min(1, Math.max(0, actionIntensity - this._displacementDeadzone) * this._displacementFactor) :
                            (actionIntensity * this._moveSensitivity),
                    source: this
                } :
                null;
    };
    /**
     * @override
     * Returns the list of currently triggered actions based on the internally stored input device state and the control bindings.
     * @param {Function} [actionFilterFunction] If given, every triggered action will be tested against this function (by passing its name
     * as a parameter), and only added to the resulting list if the function returns true.
     * @returns {Object[][]} The lists of action names and intensities, grouped by the triggering controls (if two actions were triggered
     * by the same controls, they will be in the same array, and the result itself is an array of such arrays. The name (String) property 
     * stores the action's name and the intensity (Number) property the intensity.
     */
    MouseInputInterpreter.prototype.getTriggeredActions = function (actionFilterFunction) {
        var result = control.InputInterpreter.prototype.getTriggeredActions.call(this, actionFilterFunction);
        // null out the mouse movements added up since the last query
        this._mousePositionChange = [0, 0];
        this._scrollChange = [0, 0];
        return result;
    };
    /**
     * Returns the currently stored mouse position.
     * @returns {Number[2]}
     */
    MouseInputInterpreter.prototype.getMousePosition = function () {
        return this._mousePosition;
    };
    /**
     * Returns whether the currently stored mouse position is outside the set displacement deadzone.
     * @returns {Boolean}
     */
    MouseInputInterpreter.prototype.isMouseDisplaced = function () {
        return (Math.abs(this._mousePosition[0] - this._screenCenter[0]) > this._displacementDeadzone) ||
                (Math.abs(this._mousePosition[1] - this._screenCenter[1]) > this._displacementDeadzone);
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        setModulePrefix: setModulePrefix,
        MouseBinding: MouseBinding,
        MouseInputInterpreter: MouseInputInterpreter
    };
});

/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides an input interpreter subclass (based on the base class provided by the generic control module) to
 * catch and process input from a joystick or gamepad.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, localStorage, window, navigator */

/**
 * @param utils Used for formatting control strings
 * @param application Used for logging and error displaying functionality
 * @param strings For translation support of control strings
 * @param control We build on the generic functionality and classes of this module
 */
define('modules/control/gamepad',[
    "utils/utils",
    "modules/application",
    "modules/strings",
    "modules/control/control"
], function (utils, application,  strings, control) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // constants
            GAMEPAD_BUTTON_INDEX_SUFFIX = "_gamepad_button",
            GAMEPAD_AXIS_INDEX_SUFFIX = "_gamepad_axisIndex",
            GAMEPAD_AXIS_POSITIVE_SUFFIX = "_gamepad_axisPositive",
            // ----------------------------------------------------------------------
            // string definitions for translation of control strings
            JOYSTICK_BUTTON = {
                name: "joystick" + strings.CATEGORY_SEPARATOR + "button",
                defaultValue: "button {index}"
            },
            JOYSTICK_AXIS = {
                name: "joystick" + strings.CATEGORY_SEPARATOR + "axis",
                defaultValue: "axis {index} {direction}"
            },
            JOYSTICK_DIRECTION_POSITIVE = {
                name: "joystick" + strings.CATEGORY_SEPARATOR + "positiveDirection",
                defaultValue: "positive"
            },
            JOYSTICK_DIRECTION_NEGATIVE = {
                name: "joystick" + strings.CATEGORY_SEPARATOR + "negativeDirection",
                defaultValue: "negative"
            },
            // -------------------------------------------------------------------------
            // private variables
            /**
             * When saving to or loading from local storage, the names of any settings of this module will be prefixed by this string.
             * @type String
             */
            _modulePrefix = "";
    // -------------------------------------------------------------------------
    // functions
    /**
     * Sets a prefix string to be used before the setting names when saving to or loading from local storage.
     * @param {String} value
     */
    function setModulePrefix(value) {
        _modulePrefix = value;
    }
    // #########################################################################
    /**
     * @class Represents the assignment of a gamepad/joystick action (moving an 
     * axis or pressing a button) to an in-game action. (such as fire)
     * @extends ControlBinding
     * @param {Object} [dataJSON] If given, the properties will be initialized from
     * the data stored in this JSON object.
     */
    function GamepadBinding(dataJSON) {
        /**
         * Which mouse button should be pressed to trigger this binding.
         * @type Number
         */
        this._button = this.BUTTON_NONE;
        /**
         * Which axis should be moved to trigger this binding.
         * @type Number
         */
        this._axisIndex = this.AXIS_NONE;
        /**
         * Whether the correspoding axis is needed to be moved in the positive direction to trigger this binding.
         * @type Boolean
         */
        this._axisPositive = false;
        control.ControlBinding.call(this, dataJSON);
    }
    GamepadBinding.prototype = new control.ControlBinding();
    GamepadBinding.prototype.constructor = GamepadBinding;
    /**
     * Button index value for no button set
     * @constant
     * @type Number
     */
    GamepadBinding.prototype.BUTTON_NONE = -1;
    /**
     * Axis index value for no axis set
     * @constant
     * @type Number
     */
    GamepadBinding.prototype.AXIS_NONE = -1;
    /**
     * @override
     * Loads the properties of the binding as stored in the passed JSON object.
     * @param {Object} dataJSON
     */
    GamepadBinding.prototype.loadFromJSON = function (dataJSON) {
        control.ControlBinding.prototype.loadFromJSON.call(this, dataJSON);
        if ((typeof dataJSON.button) === "number") {
            this._button = dataJSON.button;
        }
        if ((typeof dataJSON.axis) === "string") {
            this._axisIndex = Math.abs(parseInt(dataJSON.axis, 10));
            this._axisPositive = (dataJSON.axis[0] !== "-");
        }
    };
    /**
     * @override
     * Saves the properties of this binding to HTML5 local storage.
     */
    GamepadBinding.prototype.saveToLocalStorage = function () {
        localStorage[_modulePrefix + this._actionName + GAMEPAD_BUTTON_INDEX_SUFFIX] = this._button;
        localStorage[_modulePrefix + this._actionName + GAMEPAD_AXIS_INDEX_SUFFIX] = this._axisIndex;
        localStorage[_modulePrefix + this._actionName + GAMEPAD_AXIS_POSITIVE_SUFFIX] = this._axisPositive;
    };
    /**
     * @override
     * Loads the properties of the binding if they are stored in the HTML5 local
     * storage object.
     */
    GamepadBinding.prototype.loadFromLocalStorage = function () {
        if (localStorage[_modulePrefix + this._actionName + GAMEPAD_BUTTON_INDEX_SUFFIX] !== undefined) {
            this._button = parseInt(localStorage[_modulePrefix + this._actionName + GAMEPAD_BUTTON_INDEX_SUFFIX], 10);
            this._axisIndex = parseInt(localStorage[_modulePrefix + this._actionName + GAMEPAD_BUTTON_INDEX_SUFFIX], 10);
            this._axisPositive = (localStorage[_modulePrefix + this._actionName + GAMEPAD_AXIS_POSITIVE_SUFFIX] === "true");
        }
    };
    /**
     * @override
     * Removes the properties of this binding from the HTML5 local storage.
     */
    GamepadBinding.prototype.removeFromLocalStorage = function () {
        localStorage.removeItem(_modulePrefix + this._actionName + GAMEPAD_BUTTON_INDEX_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + GAMEPAD_AXIS_INDEX_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + GAMEPAD_AXIS_POSITIVE_SUFFIX);
    };
    /**
     * Returns how much is the gamepad action  triggered according to the current gamepad 
     * state passed as parameter. Gamepad actions can have different trigger intensities
     * (the gamepad axes are offset to a different degree), therefore the returned
     * value is an integer.
     * @param {Object} gamepad The gamepad object containing the current gamepad
     * state.
     * @returns {Number} Whether the action was triggerend and with what intensity.
     * Zero means the action was not triggered, a positive value represents the 
     * intensity.
     */
    GamepadBinding.prototype.getTriggeredIntensity = function (gamepad) {
        if (!gamepad) {
            return 0;
        }
        // first if this is a button assignment, check the state of the appropriate
        // gamepad button
        if (this._button !== this.BUTTON_NONE) {
            return (gamepad.buttons[this._button] === 1.0 ||
                    ((typeof (gamepad.buttons[this._button]) === "object") && gamepad.buttons[this._button].pressed)) ? 1 : 0;
        }
        if (this._axisIndex !== this.AXIS_NONE) {
            return Math.max((gamepad.axes[this._axisIndex] * (this._axisPositive ? 1 : -1)), 0);
        }
        return 0;
    };
    /**
     * @override
     * Returns a string representation describing the action the user needs
     * to perform to trigger this binding.
     * @returns {String}
     */
    GamepadBinding.prototype.getControlString = function () {
        if (this._button !== this.BUTTON_NONE) {
            return utils.formatString(strings.get(JOYSTICK_BUTTON), {index: (this._button + 1)});
        }
        if (this._axisIndex !== this.AXIS_NONE) {
            return utils.formatString(strings.get(JOYSTICK_AXIS), {
                index: (this._axisIndex + 1),
                direction: (this._axisPositive ?
                        strings.get(JOYSTICK_DIRECTION_POSITIVE) :
                        strings.get(JOYSTICK_DIRECTION_NEGATIVE))});
        }
        return "";
    };
    /**
     * @override
     * Returns whether this binding has the same control (button/axis) configuration as the passed one (and so it conflicts with it)
     * @param {GamepadBinding} otherGamepadBinding
     */
    GamepadBinding.prototype.bindsTheSameControls = function (otherGamepadBinding) {
        return (this._button === otherGamepadBinding._button) &&
                (this._axisIndex === otherGamepadBinding._axisIndex);
    };
    // #########################################################################
    /**
     * @class This class stores a set of actions and associated sensitivity modifiers that can be used
     * by GamepadInputInterpreters to apply different sensitivities when triggering different actions.
     * @param {Object} dataJSON
     */
    function GamepadSensitivityActionGroup(dataJSON) {
        /**
         * This factor will be applied for graded (dynamic) intensities.
         * @type Number
         */
        this._sensitivityFactor = dataJSON.sensitivityFactor || 0;
        /**
         * If set to true, when encountering an action stored in this group, the intensity will be set to
         * static (undefined), losing any graded (dynamic) intensity even if the action was triggered by
         * a (partially moved) axis.
         * @type Boolean
         */
        this._staticSensitivity = (dataJSON.staticSensitivity === true);
        /**
         * If set to true, the intensity of triggered actions in this group will be based on the squared value
         * of the intensity reported by the gamepad.
         */
        this._quadraticIntensity = (dataJSON.quadraticSensitivity === true);
        /**
         * This array stores the names of action the sensitivity modifiers should apply to.
         * @type Array
         */
        this._actionNames = dataJSON.actionNames;
        if (this._sensitivityFactor && this._staticSensitivity) {
            application.showError("Sensitivity action group defined with both factored and static sensitivity!", application.ErrorSeverity.MINOR);
        }
    }
    /**
     * Checks whether the action with the passed name is in this group, and if so, returns the modified intensity for it.
     * @param {Number} baseIntensity The intensity of this triggered action before any modifiers.
     * @param {String} actionName The name of the action to check.
     * @returns {(Number|undefined)} Will be a positive number or zero if the action is in the group and the modified 
     * intensity is graded (dynamic) or undefined if it is static, and will be -1 if the action is not in the group.
     */
    GamepadSensitivityActionGroup.prototype.getIntensityForAction = function (baseIntensity, actionName) {
        if (this._actionNames.indexOf(actionName) >= 0) {
            return this._staticSensitivity ? undefined : (baseIntensity * (this._quadraticIntensity ? baseIntensity : 1) * this._sensitivityFactor);
        }
        return -1;
    };
    /**
     * @class Monitors the gamepad/joystick inputs and stores the current state 
     * of the gamepad/joystick. 
     * Can load and store gamepad bindings and based on the current state and the 
     * bindings, determine the list of currently triggered actions that controllers 
     * can/should execute.
     * @extends InputInterpreter
     * @param {Object} [dataJSON] Upon initialization, it can load the bindings from
     * this JSON object if specified.
     */
    function GamepadInputInterpreter(dataJSON) {
        /**
         * A reference to the gamepad(/joystick) this interpreter is listening to.
         * @type Gamepad
         */
        this._gamepad = null;
        /**
         * 
         * @type GamepadSensitivityActionGroup[]
         */
        this._sensitivityActionGroups = null;
        control.InputInterpreter.call(this, GamepadBinding, dataJSON);
    }
    GamepadInputInterpreter.prototype = new control.InputInterpreter();
    GamepadInputInterpreter.prototype.constructor = GamepadInputInterpreter;
    /**
     * @override
     * Returns of the name of the device this interpreter monitors. Every input
     * interpreter should implement this function.
     * @returns {String}
     */
    GamepadInputInterpreter.prototype.getDeviceName = function () {
        return "joystick";
    };
    /**
     * @override
     */
    GamepadInputInterpreter.prototype.resetState = function () {
        this._gamepad = null;
    };
    /**
     * @override
     * Loads the properties of the interpreter such as the (default) gamepad bindings
     * from the passed JSON object.
     * @param {Object} dataJSON
     */
    GamepadInputInterpreter.prototype.loadFromJSON = function (dataJSON) {
        var i;
        control.InputInterpreter.prototype.loadFromJSON.call(this, dataJSON);
        this._sensitivityActionGroups = [];
        if (dataJSON.sensitivityProfile && dataJSON.sensitivityProfile.actionGroups) {
            for (i = 0; i < dataJSON.sensitivityProfile.actionGroups.length; i++) {
                this._sensitivityActionGroups.push(new GamepadSensitivityActionGroup(dataJSON.sensitivityProfile.actionGroups[i]));
            }
        }
    };
    /**
     * An event handler for the event that fires when a new gamepad is connected. Stores the received Gamepad object for use
     * @param {GamepadEvent} event
     */
    GamepadInputInterpreter.prototype.handleGamepadConnected = function (event) {
        if (!this._gamepad) {
            this._gamepad = event.gamepad;
        }
    };
    /**
     * @override
     * Sets the event handlers to grab a gamepad object for this interpreter
     * once it has become available for the web application.
     * The triggered actions can be queried from this interpreter after this 
     * method has been called.
     */
    GamepadInputInterpreter.prototype.startListening = function () {
        control.InputInterpreter.prototype.startListening.call(this);
        window.addEventListener("gamepadconnected", function (event) {
            this.handleGamepadConnected(event);
        }.bind(this));
    };
    /**
     * @override
     * The input state will not be updated after this call.
     * The triggered actions cannot be queried from this interpreter after this 
     * function has been called.
     */
    GamepadInputInterpreter.prototype.stopListening = function () {
        control.InputInterpreter.prototype.stopListening.call(this);
        window.ongamepadconnected = null;
    };
    /**
     * @override
     * Checks if the action with the supplied name is triggered based on the current input state.
     * @param {String} actionName
     * @returns {(ActionTrigger|null)} Null, if the action is not triggered
     */
    GamepadInputInterpreter.prototype.checkAction = function (actionName) {
        var baseIntensity, i, finalIntensity;
        baseIntensity = this._bindings[actionName].getTriggeredIntensity(this._gamepad);
        if (baseIntensity > 0) {
            for (i = 0; i < this._sensitivityActionGroups.length; i++) {
                finalIntensity = this._sensitivityActionGroups[i].getIntensityForAction(baseIntensity, actionName);
                if ((finalIntensity === undefined) || (finalIntensity > 0)) {
                    return {
                        name: actionName,
                        intensity: finalIntensity,
                        source: this
                    };
                }
            }
            return {
                name: actionName,
                intensity: baseIntensity,
                source: this
            };
        }
        return null;
    };
    /**
     * @override
     * Returns the list of currently triggered actions and their intensity based on 
     * the internally stored gamepad state and gamepad bindings.
     * @param {Function} [actionFilterFunction] If given, every triggered action will be tested against this function (by passing its name
     * as a parameter), and only added to the resulting list if the function returns true.
     * @returns {Object[][]} The lists of action names and intensities, grouped by the triggering controls (if two actions were triggered
     * by the same controls, they will be in the same array, and the result itself is an array of such arrays. The name (String) property 
     * stores the action's name and the intensity (Number) property the intensity.
     */
    GamepadInputInterpreter.prototype.getTriggeredActions = function (actionFilterFunction) {
        var gamepads;
        if (!this.isListening()) {
            return [];
        }
        // Firefox continuously updates the Gamepad object obtained from the gamepadconnected event, but it has to be manually
        // refreshed for Chrome to get an up-to-date state, so we do it right before the query
        gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
        if (gamepads && (gamepads.length > 0)) {
            this._gamepad = gamepads[0];
        } else {
            this._gamepad = null;
        }
        if (this._gamepad) {
            return control.InputInterpreter.prototype.getTriggeredActions.call(this, actionFilterFunction);
        }
        return [];
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        setModulePrefix: setModulePrefix,
        GamepadBinding: GamepadBinding,
        GamepadInputInterpreter: GamepadInputInterpreter
    };
});

/**
 * Copyright 2018-2020 Krisztián Nagy
 * @file Provides an input interpreter subclass (based on the base class provided by the generic control module) to
 * catch and process input from a touchscreen.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, localStorage, window, navigator */

/**
 * @param utils Used for formatting control strings and handling enums
 * @param strings For translation support of control strings
 * @param control We build on the generic functionality and classes of this module
 */
define('modules/control/touch',[
    "utils/utils",
    "modules/strings",
    "modules/control/control"
], function (utils, strings, control) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // enums
            /**
             * An enumeration to define the main types of gestures that are available
             * @type Object
             */
            GestureType = {
                TAP: 0, // action is triggered when the user finishes a touch at (around) the same place it started within a short period of time
                LONG_TAP: 1, // action is triggered when the user finishes a touch at (around) the same place it started after a longer time
                TWO_POINT_TAP: 2, // action is triggered when the user finishes touches with two fingers at (around) the same places they started after a short period of time
                THREE_POINT_TAP: 3, // action is triggered when the user finishes touches with three fingers at (around) the same places they started after a short period of time
                HOLD: 4, // action is triggered while the user holds a finger on the screen (distance from the starting point is available as intensity)
                SLIDE: 5, // action is triggered continuously after the user touches and moves the finger (even after release),
                // with an intensity proportional to the passed distance  
                SWIPE: 6 // action is triggered when the user releases after swiping on the screen
            },
            // ----------------------------------------------------------------------
            // constants
            /** Tap gestures (except long tap) need to be finished within this much time to be triggered, in milliseconds
             * @type Number */
            SHORT_TAP_TIMEOUT = 300,
            /** Long tap gestures need to be finished within this much time to be triggered, in milliseconds
             * @type Number */
            LONG_TAP_TIMEOUT = 2000,
            /** Swipe gestures need to be finished within this much time to be triggered, in milliseconds
             * @type Number */
            SWIPE_TIMEOUT = 1000,
            /** The maximum distance between touch start and end positions for tap gestures to be triggered (across both X and Y axes), in pixels
             * @type Number */
            TAP_DEADZONE = 20,
            /** The minimum distance between touch start and end positions for hold and slide gestures to be triggered, in pixels
             * @type Number */
            MOVE_DEADZONE = 5,
            /** The default range value for hold and slide gestures (the _range property gets this value if it was not specified in the data - see property description for details)
             * @type Number */
            DEFAULT_MOVE_RANGE = 0.5,
            /** Some predefined areas that can be referenced by their keys in the touch binding definition objects
             * @type Object */
            TOUCH_AREA = {
                NONE: {x: [0, 0], y: [0, 0]},
                FULL: {x: [0, 1], y: [0, 1]},
                "top-left": {x: [0, 0.5], y: [0, 0.5]},
                "top-right": {x: [0.5, 1], y: [0, 0.5]},
                "bottom-left": {x: [0, 0.5], y: [0.5, 1]},
                "bottom-right": {x: [0.5, 1], y: [0.5, 1]},
                "left": {x: [0, 0.5], y: [0, 1]},
                "right": {x: [0.5, 1], y: [0, 1]}
            },
            DIRECTION_LEFT = "left",
            DIRECTION_RIGHT = "right",
            DIRECTION_UP = "up",
            DIRECTION_DOWN = "down",
            TOUCH_AREA_SUFFIX = "_touch_area",
            TOUCH_TYPE_SUFFIX = "_touch_type",
            TOUCH_MOVE_X_SUFFIX = "_touch_moveX",
            TOUCH_MOVE_Y_SUFFIX = "_touch_moveY",
            TOUCH_RANGE_SUFFIX = "_touch_range",
            // ----------------------------------------------------------------------
            // string definitions for translation of control strings
            TAP_STRING = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "tap",
                defaultValue: "tap {area} of the screen"
            },
            LONG_TAP_STRING = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "longTap",
                defaultValue: "long tap {area} of the screen"
            },
            TWO_POINT_TAP_STRING = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "twoPointTap",
                defaultValue: "tap {area} of the screen with two fingers"
            },
            THREE_POINT_TAP_STRING = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "threePointTap",
                defaultValue: "tap {area} of the screen with three fingers"
            },
            SWIPE_STRING = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "swipe",
                defaultValue: "swipe {direction} on {area} of the screen"
            },
            HOLD_STRING_NO_DIRECTION = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "hold",
                defaultValue: "tap and hold on {area} of the screen"
            },
            HOLD_STRING_WITH_DIRECTION = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "holdDirection",
                defaultValue: "swipe {direction} and hold on {area} of the screen"
            },
            SLIDE_STRING = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "slide",
                defaultValue: "slide {direction} on {area} of the screen"
            },
            TOUCH_DIRECTION_LEFT = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "leftDirection",
                defaultValue: "left"
            },
            TOUCH_DIRECTION_RIGHT = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "rightDirection",
                defaultValue: "right"
            },
            TOUCH_DIRECTION_UP = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "upDirection",
                defaultValue: "up"
            },
            TOUCH_DIRECTION_DOWN = {
                name: "touch" + strings.CATEGORY_SEPARATOR + "downDirection",
                defaultValue: "down"
            },
            // -------------------------------------------------------------------------
            // private variables
            /**
             * When saving to or loading from local storage, the names of any settings of this module will be prefixed by this string.
             * @type String
             */
            _modulePrefix = "";
    /**
     * @typedef {Object} ExtendedTouch
     * @property {Number} identifier 
     * @property {DOMHighResTimeStamp} startTime 
     * @property {Number} startX 
     * @property {Number} startY 
     * @property {Number} previousX 
     * @property {Number} previousY 
     * @property {Number} currentX 
     * @property {Number} currentY 
     * @property {Boolean} false
     * @property {TouchBinding} capturedBy
     * @property {Number} age 
     */
    // -------------------------------------------------------------------------
    // functions
    /**
     * Sets a prefix string to be used before the setting names when saving to or loading from local storage.
     * @param {String} value
     */
    function setModulePrefix(value) {
        _modulePrefix = value;
    }
    // #########################################################################
    /**
     * @class Represents the assignment of a touch action (gesture) to an in-game action. (such as fire)
     * @extends ControlBinding
     * @param {Object} [dataJSON] If given, the properties will be initialized from
     * the data stored in this JSON object.
     */
    function TouchBinding(dataJSON) {
        /**
         * The area on the screen where to touch for this gesture (like texture coordinates: [0,0] top left to [1,1] bottom right)
         * x (Number[2]): X range, y( Number[2]): Y range
         * @type Object
         */
        this._area = TOUCH_AREA.NONE;
        /**
         * (enum GestureType) What kind of gesture does the user need to make to trigger the action of this binding 
         * @type String
         */
        this._type = null;
        /**
         * The gesture (tap) needs to be finished within this amount of time (ms)
         * @type Number
         */
        this._timeout = 0;
        /**
         * How many fingers to touch with for this gesture
         * @type Number
         */
        this._count = 1;
        /**
         * For hold and slide gestures, the distance from the starting point at which intensity will be considered 1.0, as a ratio of the shorter side of the screen
         * (e.g. the value of 0.5 on a screen with 1920x1080 resolution will indicate a distance of 540 pixels)
         * @type Number
         */
        this._range = 0;
        /**
         * Marks the X direction of movement for swipe annd similar gestures (-1: left, 0: none, 1: right)
         * @type Number
         */
        this._moveX = 0;
        /**
         * Marks the Y direction of movement for swipe annd similar gestures (-1: up, 0: none, 1: down)
         * @type Number
         */
        this._moveY = 0;
        /**
         * The current X offset for slide gestures, in pixels (remember even while there are no active touches)
         * @type Number
         */
        this._currentX = 0;
        /**
         * The current Y offset for slide gestures, in pixels (remember even while there are no active touches)
         * @type Number
         */
        this._currentY = 0;
        /**
         * Touches captured for this gesture (for taps only)
         * @type Array
         */
        this._touches = [];
        /**
         * Cached value of the calculated area in pixels for the current viewport resolution
         * @type Number
         */
        this._areaPx = null;
        /**
         * Cached value of the calculated range in pixels for the current viewport resolution
         * @type Number
         */
        this._rangePx = 0;
        /**
         * Cached value of the reciprocal of the calculated range in pixels for the current viewport resolution
         * @type Number
         */
        this._rangeFactor = 0;
        control.ControlBinding.call(this, dataJSON);
    }
    TouchBinding.prototype = new control.ControlBinding();
    TouchBinding.prototype.constructor = TouchBinding;
    /**
     * @private
     * Calculates the values of properties that are derived from the one loaded from JSON / local storage
     * or just have fixed default values.
     */
    TouchBinding.prototype._initDerivedProperties = function () {
        this._areaPx = utils.deepCopy(this._area);
        switch (this._type) {
            case GestureType.TWO_POINT_TAP: 
                this._count = 2;
                break;
            case GestureType.THREE_POINT_TAP:
                this._count = 3;
                break;
            default:
                this._count = 1;
        }
        this._timeout = (this._type === GestureType.LONG_TAP) ? LONG_TAP_TIMEOUT : SHORT_TAP_TIMEOUT;
        this._rangePx = 0;
        this._rangeFactor = 0;
        this._currentX = 0;
        this._currentY = 0;
    };
    /**
     * @override
     * Loads the properties of the binding as stored in the passed JSON object.
     * @param {Object} dataJSON
     */
    TouchBinding.prototype.loadFromJSON = function (dataJSON) {
        control.ControlBinding.prototype.loadFromJSON.call(this, dataJSON);
        if ((typeof dataJSON.area) === "string") {
            this._area = TOUCH_AREA[dataJSON.area];
        } else {
            this._area = TOUCH_AREA.FULL;
        }
        if ((typeof dataJSON.type) === "string") {
            this._type = utils.getSafeEnumValueForKey(GestureType, dataJSON.type);
        }
        this._range  = dataJSON.range || DEFAULT_MOVE_RANGE;
        this._moveX = 0;
        this._moveY = 0;
        if ((typeof dataJSON.direction) === "string") {
            switch (dataJSON.direction) {
                case DIRECTION_LEFT:
                    this._moveX = -1;
                    break;
                case DIRECTION_RIGHT:
                    this._moveX = 1;
                    break;
                case DIRECTION_UP:
                    this._moveY = -1;
                    break;
                case DIRECTION_DOWN:
                    this._moveY = 1;
                    break;
            }
        }
        this._initDerivedProperties();
    };
    /**
     * @override
     * Saves the properties of this binding to HTML5 local storage.
     */
    TouchBinding.prototype.saveToLocalStorage = function () {
        localStorage[_modulePrefix + this._actionName + TOUCH_AREA_SUFFIX] = JSON.stringify(this._area);
        localStorage[_modulePrefix + this._actionName + TOUCH_TYPE_SUFFIX] = this._type;
        localStorage[_modulePrefix + this._actionName + TOUCH_MOVE_X_SUFFIX] = this._moveX;
        localStorage[_modulePrefix + this._actionName + TOUCH_MOVE_Y_SUFFIX] = this._moveY;
        localStorage[_modulePrefix + this._actionName + TOUCH_RANGE_SUFFIX] = this._range;
    };
    /**
     * @override
     * Loads the properties of the binding if they are stored in the HTML5 local
     * storage object.
     */
    TouchBinding.prototype.loadFromLocalStorage = function () {
        if (localStorage[_modulePrefix + this._actionName + TOUCH_TYPE_SUFFIX] !== undefined) {
            this._area = JSON.parse(localStorage[_modulePrefix + this._actionName + TOUCH_AREA_SUFFIX]);
            this._type = localStorage[_modulePrefix + this._actionName + TOUCH_TYPE_SUFFIX];
            this._moveX = parseInt(localStorage[_modulePrefix + this._actionName + TOUCH_MOVE_X_SUFFIX], 10);
            this._moveY = parseInt(localStorage[_modulePrefix + this._actionName + TOUCH_MOVE_Y_SUFFIX], 10);
            this._range = parseInt(localStorage[_modulePrefix + this._actionName + TOUCH_RANGE_SUFFIX], 10);
            this._initDerivedProperties();
        }
    };
    /**
     * @override
     * Removes the properties of this binding from the HTML5 local storage.
     */
    TouchBinding.prototype.removeFromLocalStorage = function () {
        localStorage.removeItem(_modulePrefix + this._actionName + TOUCH_AREA_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + TOUCH_TYPE_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + TOUCH_MOVE_X_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + TOUCH_MOVE_Y_SUFFIX);
        localStorage.removeItem(_modulePrefix + this._actionName + TOUCH_RANGE_SUFFIX);
    };
    /**
     * Updates the cached value for area and range checking for the current screen size.
     * @param {Number} width Width of the viewport, in pixels
     * @param {Number} height Height of the viewport, in pixels
     */
    TouchBinding.prototype.setScreenSize = function (width, height) {
        this._areaPx.x[0] = this._area.x[0] * width;
        this._areaPx.x[1] = this._area.x[1] * width;
        this._areaPx.y[0] = this._area.y[0] * height;
        this._areaPx.y[1] = this._area.y[1] * height;
        this._rangePx = this._range * Math.min(width, height);
        this._rangeFactor = 1 / (this._rangePx || 1);
    };
    /**
     * @private
     * @param {ExtendedTouch} touch
     * @returns {Boolean}
     */
    TouchBinding.prototype._touchStartedInArea = function (touch) {
        return (touch.startX >= this._areaPx.x[0]) && (touch.startX <= this._areaPx.x[1]) &&
                (touch.startY >= this._areaPx.y[0]) && (touch.startY <= this._areaPx.y[1]);
    };
    /**
     * Returns how much is the touch action triggered according to the current touch 
     * state passed as parameter. Touch actions can have different trigger intensities
     * (e.g. depending on distance from starting point for hold gesture), therefore the 
     * returned value is a number.
     * @param {Array.<ExtendedTouch>} touches The list of active touches (including 
     * the ones that ended since the last simulation step, with their finished property 
     * set to true
     * @returns {Number} Whether the action was triggered and with what intensity.
     * Zero means the action was not triggered, a positive value represents the 
     * intensity.
     */
    TouchBinding.prototype.getTriggeredIntensity = function (touches) {
        var i, touch, long, releaseCount;
        switch (this._type) {
            // single-point tap gestures are much simpler than multi finger ones, handle them separately
            case GestureType.TAP:
            case GestureType.LONG_TAP:
                // the touches are order by creation time, older touches are further back in the array, we are only interested
                // in the ones newer than our timeout value
                for (i = touches.length - 1; i >= 0; i--) {
                    touch = touches[i];
                    if (touch.age > this._timeout) {
                        return 0;
                    }
                    if ((touch.capturedBy === null) && (this._touchStartedInArea(touch)) && 
                            (Math.abs(touch.currentX - touch.startX) <= TAP_DEADZONE) &&
                            (Math.abs(touch.currentY - touch.startY) <= TAP_DEADZONE) && (touch.finished === true)) {
                        touch.capturedBy = this;
                        return 1;
                    }
                }
                return 0;
            case GestureType.TWO_POINT_TAP:
            case GestureType.THREE_POINT_TAP:
                // multi-point taps are handled in two steps:
                // first, we check if there were the right number of touches happening within the tap timeout
                // if so, we capture those touches, so other tap events will not be triggered based on them
                // we follow up if the touches are ended before the timout expires (and are not captured by
                // other bindings), and if so, trigger the action
                // capturing is reset each step!
                // this way a three-point tap can be defined earlier in the binding list, and it will capture 
                // the 3 touches every step before other events are processed, and so a two-point or single-point
                // tap binding later in the array will not trigger when the first one or two of those touches are ended
                // (e.g. menu opening is three-point tap on any part of the screen, it is defined as the first binding)
                if (this._touches.length > 0) {
                    // if we have captured our touches already, follow them up
                    releaseCount = 0;
                    for (i = 0; i < this._count; i++) {
                        touch = this._touches[i];
                        // if any of the touches expired or were captured by another binding (e.g. this is a two-point
                        // tap gesture, and a third tap started, and there is a three-point tap gesture defined as well,
                        // in that case that three-point gesture could capture the three taps so we cancel this one)
                        if ((touch.age > this._timeout) || ((touch.capturedBy !== null) && (touch.capturedBy !== this))) {
                            this._touches.length = 0;
                            return 0;
                        }
                        // count how many of the touches have already finished
                        if (touch.finished === true) {
                            releaseCount++;
                        }
                    }
                    // there were no expired or captured touches, so renew our capturing over them
                    for (i = 0; i < this._count; i++) {
                        this._touches[i].capturedBy = this;
                    }
                    // if all the touches have finished, we trigger and reset
                    if (releaseCount === this._count) {
                        this._touches.length = 0;
                        return 1;
                    }
                } else {
                    // if we have not captured our touches yet, look for applicable touches among the touch state
                    // since touches are added in the order they are started, the youngest ones are back in the array
                    for (i = touches.length - 1; i >= 0; i--) {
                        touch = touches[i];
                        // no more young enough touches available, break the loop
                        if (touch.age > this._timeout) {
                            break;
                        }
                        // check if this touch is applicable - in the right area, now a swipe, not captured
                        if ((touch.capturedBy === null) && (this._touchStartedInArea(touch)) && 
                                (Math.abs(touch.currentX - touch.startX) <= TAP_DEADZONE) &&
                                (Math.abs(touch.currentY - touch.startY) <= TAP_DEADZONE)) {
                            // if we haven't yet found enough touches, we add this one, but if there are more than what we need, cancel
                            // the process - an instant three-point tap does not qualify for a two-point tap
                            if (this._touches.length < this._count) {
                                this._touches.push(touch);
                            } else {
                                this._touches.length = 0;
                                return 0;
                            }
                        }
                    }
                    // if there are exactly the number of relevant touches that we need, we can capture them and continue with the follow-up
                    // branch from now on - otherwise, reset the process, keep looking
                    if (this._touches.length === this._count) {
                        for (i = 0; i < this._count; i++) {
                            this._touches[i].capturedBy = this;
                        }
                    } else {
                        this._touches.length = 0;
                        return 0;
                    }
                }
                return 0;
            case GestureType.SWIPE:
                // simply check if we have a finished touch that qualifies
                for (i = 0; i < touches.length; i++) {
                    touch = touches[i];
                    if (touch.finished === true) {
                        long = touch.age >= SWIPE_TIMEOUT;
                        if (!long && this._touchStartedInArea(touch) && 
                                ((((touch.currentX - touch.startX) > TAP_DEADZONE) && (this._moveX > 0)) ||
                                (((touch.currentX - touch.startX) < -TAP_DEADZONE) && (this._moveX < 0)) ||
                                (((touch.currentY - touch.startY) > TAP_DEADZONE) && (this._moveY > 0)) ||
                                (((touch.currentY - touch.startY) < -TAP_DEADZONE) && (this._moveY < 0)))) {
                            return 1;
                        } 
                    }
                }
                return 0;
            case GestureType.HOLD:
                // simply check if we have an ongoing touch that qualifies
                for (i = 0; i < touches.length; i++) {
                    touch = touches[i];
                    if ((touch.finished === false) && (this._touchStartedInArea(touch))) {
                        // cap intensity between 0 and 1
                        if (this._moveX > 0) {
                            return Math.min(Math.max(0, (touch.currentX - touch.startX - MOVE_DEADZONE) * this._rangeFactor), 1);
                        } else if (this._moveX < 0) {
                            return Math.min(Math.max(0, (touch.startX - touch.currentX - MOVE_DEADZONE) * this._rangeFactor), 1);
                        } else if (this._moveY > 0) {
                            return Math.min(Math.max(0, (touch.currentY - touch.startY - MOVE_DEADZONE) * this._rangeFactor), 1);
                        } else if (this._moveY < 0) {
                            return Math.min(Math.max(0, (touch.startY - touch.currentY - MOVE_DEADZONE) * this._rangeFactor), 1);
                        } else {
                            return 1;
                        }
                    }
                }
                break;
            case GestureType.SLIDE:
                // reset offset (currentX, currentY) on short touch:
                for (i = 0; i < touches.length; i++) {
                    touch = touches[i];
                    if (touch.finished === true) {
                        long = touch.age >= SHORT_TAP_TIMEOUT;
                        if (!long && this._touchStartedInArea(touch) && 
                                (Math.abs(touch.currentX - touch.startX) <= MOVE_DEADZONE) &&
                                (Math.abs(touch.currentY - touch.startY) <= MOVE_DEADZONE)) {
                            this._currentX = 0;
                            this._currentY = 0;
                            return 0;
                        } 
                    }
                }
                // change offset (currentX, currentY) based on ongoing touch:
                for (i = 0; i < touches.length; i++) {
                    touch = touches[i];
                    if ((touch.finished === false) && (this._touchStartedInArea(touch))) {
                        this._currentX += touch.currentX - touch.previousX;
                        this._currentY += touch.currentY - touch.previousY;
                        if (this._currentX > this._rangePx + MOVE_DEADZONE) {
                            this._currentX = this._rangePx + MOVE_DEADZONE;
                        } else if (this._currentX < -this._rangePx - MOVE_DEADZONE) {
                            this._currentX = -this._rangePx - MOVE_DEADZONE;
                        }
                        if (this._currentY > this._rangePx + MOVE_DEADZONE) {
                            this._currentY = this._rangePx + MOVE_DEADZONE;
                        } else if (this._currentY < -this._rangePx - MOVE_DEADZONE) {
                            this._currentY = -this._rangePx - MOVE_DEADZONE;
                        }
                    }
                }
                // return the intensity (capped to 0-1 range) based on the current offset
                if (this._moveX > 0) {
                    return Math.min(Math.max(0, (this._currentX - MOVE_DEADZONE) * this._rangeFactor), 1);
                } else if (this._moveX < 0) {
                    return Math.min(Math.max(0, (-this._currentX - MOVE_DEADZONE) * this._rangeFactor), 1);
                } else if (this._moveY > 0) {
                    return Math.min(Math.max(0, (this._currentY - MOVE_DEADZONE) * this._rangeFactor), 1);
                } else if (this._moveY < 0) {
                    return Math.min(Math.max(0, (-this._currentY - MOVE_DEADZONE) * this._rangeFactor), 1);
                } else {
                    return 0;
                }
        }
        return 0;
    };
    /**
     * @override
     * Returns a string representation describing the action the user needs
     * to perform to trigger this binding.
     * @returns {String}
     */
    TouchBinding.prototype.getControlString = function () {
        var direction = "", area = "";
        if (this._moveX < 0) {
            direction = strings.get(TOUCH_DIRECTION_LEFT);
        } else if (this._moveX > 0) {
            direction = strings.get(TOUCH_DIRECTION_RIGHT);
        } else if (this._moveY < 0) {
            direction = strings.get(TOUCH_DIRECTION_UP);
        } else if (this._moveY > 0) {
            direction = strings.get(TOUCH_DIRECTION_DOWN);
        }
        area = strings.get(strings.TOUCH_AREA.PREFIX, utils.getKeyOfValue(TOUCH_AREA, this._area));
        switch (this._type) {
            case GestureType.TAP:
                return utils.formatString(strings.get(TAP_STRING), {area: area});
            case GestureType.LONG_TAP:
                return utils.formatString(strings.get(LONG_TAP_STRING), {area: area});
            case GestureType.TWO_POINT_TAP:
                return utils.formatString(strings.get(TWO_POINT_TAP_STRING), {area: area});
            case GestureType.THREE_POINT_TAP:
                return utils.formatString(strings.get(THREE_POINT_TAP_STRING), {area: area});
            case GestureType.SWIPE:
                return utils.formatString(strings.get(SWIPE_STRING), {area: area, direction: direction});
            case GestureType.HOLD:
                if ((this._moveX !== 0) || (this._moveY !== 0)) {
                    return utils.formatString(strings.get(HOLD_STRING_WITH_DIRECTION), {area: area, direction: direction});
                } else {
                    return utils.formatString(strings.get(HOLD_STRING_NO_DIRECTION), {area: area});
                }
            case GestureType.SLIDE:
                return utils.formatString(strings.get(SLIDE_STRING), {area: area, direction: direction});
        }
        return "";
    };
    /**
     * @override
     * Returns whether this binding has the same control configuration as the passed one (and so it conflicts with it)
     * @param {TouchBinding} otherBinding
     */
    TouchBinding.prototype.bindsTheSameControls = function (otherBinding) {
        return (this._type === otherBinding._type) &&
                (this._moveX === otherBinding._moveX) &&
                (this._moveY === otherBinding._moveY) &&
                utils.objectsEqual(this._area, otherBinding._area);
    };
    // #########################################################################
    /**
     * @class Monitors the touch input and stores the currently ongoing touches.
     * Can load and store touch bindings and based on the current state and the 
     * bindings, determine the list of currently triggered actions that controllers 
     * can/should execute.
     * @extends InputInterpreter
     * @param {Object} [dataJSON] Upon initialization, it can load the bindings from
     * this JSON object if specified.
     */
    function TouchInputInterpreter(dataJSON) {
        /**
         * The list of ongoing touches, and also the ones that have been ended
         * since the last processing step (getTriggeredActions() call)
         * @type Array.<ExtendedTouch>
         */
        this._touches = [];
        // Create bound event listeners
        this._handleTouchStart = this._handleTouchStart.bind(this);
        this._handleTouchMove = this._handleTouchMove.bind(this);
        this._handleTouchEnd = this._handleTouchEnd.bind(this);
        control.InputInterpreter.call(this, TouchBinding, dataJSON);
    }
    TouchInputInterpreter.prototype = new control.InputInterpreter();
    TouchInputInterpreter.prototype.constructor = TouchInputInterpreter;
    /**
     * @override
     * @returns {String}
     */
    TouchInputInterpreter.prototype.getDeviceName = function () {
        return "touch";
    };
    /**
     * @override
     */
    TouchInputInterpreter.prototype.resetState = function () {
        this._touches = [];
    };
    /**
     * Updates the cached values that depend on the screen size and are used to
     * e.g. check if touches fall inside screen regions. Needs to be called when 
     * the screen size changes.
     * @param {Number} x The X coordinate of the screen center, in pixels.
     * @param {Number} y The Y coordinate of the screen center, in pixels.
     */
    TouchInputInterpreter.prototype.setScreenCenter = function (x, y) {
        var i, keys;
        keys = Object.keys(this._bindings);
        for (i = 0; i < keys.length; i++) {
            this._bindings[keys[i]].setScreenSize(x * 2, y * 2);
        }
    };
    /**
     * @private
     * Creates and stores an ExtendedTouch object for the current state
     * @param {Touch} touch As acquired from the touch events
     * @param {DOMHighResTimestamp} now Current timestamp
     */
    TouchInputInterpreter.prototype._addTouch = function (touch, now) {
        this._touches.push({
            identifier: touch.identifier,
            startTime: now,
            startX: touch.clientX,
            startY: touch.clientY,
            previousX: touch.clientX,
            previousY: touch.clientY,
            currentX: touch.clientX,
            currentY: touch.clientY,
            finished: false,
            capturedBy: null,
            age: 0
        });
    };
    /**
     * @private
     * Updates the ExtendedTouch object corresponding to the passed Touch
     * (matched by identifier) in the current touches list
     * @param {Touch} touch As acquired from the touch events
     */
    TouchInputInterpreter.prototype._updateTouch = function (touch) {
        var i;
        // linear search is fine, this array will not really be larger than five elements
        for (i = 0; i < this._touches.length; i++) {
            if ((this._touches[i].identifier === touch.identifier) && (this._touches[i].finished === false)) {
                this._touches[i].currentX = touch.clientX;
                this._touches[i].currentY = touch.clientY;
                return;
            }
        }
    };
    /**
     * @private
     * Marks the ExtendedTouch object corresponding to the passed Touch
     * (matched by identifier) for removal from the current touches list (will
     * happen after the next processing of bindings)
     * @param {Touch} touch As acquired from the touch events
     */
    TouchInputInterpreter.prototype._removeTouch = function (touch) {
        var i;
        // linear search is fine, this array will not really be larger than five elements
        for (i = 0; i < this._touches.length; i++) {
            if (this._touches[i].identifier === touch.identifier) {
                this._touches[i].finished = true;
                return;
            }
        }
    };
    /**
     * @private
     * @param {TouchEvent} event
     * @returns {Boolean}
     */
    TouchInputInterpreter.prototype._handleTouchStart = function (event) {
        var i, now = performance.now();
        event.preventDefault();
        for (i = 0; i < event.changedTouches.length; i++) {
            this._addTouch(event.changedTouches[i], now);
        }
        return false;
    };
    /**
     * @private
     * @param {TouchEvent} event
     * @returns {Boolean}
     */
    TouchInputInterpreter.prototype._handleTouchMove = function (event) {
        var i;
        event.preventDefault();
        for (i = 0; i < event.changedTouches.length; i++) {
            this._updateTouch(event.changedTouches[i]);
        }
        return false;
    };
    /**
     * @private
     * @param {TouchEvent} event
     * @returns {Boolean}
     */
    TouchInputInterpreter.prototype._handleTouchEnd = function (event) {
        var i;
        event.preventDefault();
        for (i = 0; i < event.changedTouches.length; i++) {
            this._removeTouch(event.changedTouches[i]);
        }
        return false;
    };
    /**
     * @override
     * Sets the event handlers to react to touch events.
     * The triggered actions can be queried from this interpreter after this 
     * method has been called.
     */
    TouchInputInterpreter.prototype.startListening = function () {
        var options = {passive: false};
        control.InputInterpreter.prototype.startListening.call(this);
        document.addEventListener("touchstart", this._handleTouchStart, options);
        document.addEventListener("touchmove", this._handleTouchMove, options);
        document.addEventListener("touchend", this._handleTouchEnd, options);
        document.addEventListener("touchcancel", this._handleTouchEnd, options);
    };
    /**
     * @override
     * The input state will not be updated after this call.
     * The triggered actions cannot be queried from this interpreter after this 
     * function has been called.
     */
    TouchInputInterpreter.prototype.stopListening = function () {
        control.InputInterpreter.prototype.stopListening.call(this);
        document.removeEventListener("touchstart", this._handleTouchStart);
        document.removeEventListener("touchmove", this._handleTouchMove);
        document.removeEventListener("touchend", this._handleTouchEnd);
        document.removeEventListener("touchcancel", this._handleTouchEnd);
    };
    /**
     * @override
     * Checks if the action with the supplied name is triggered based on the current input state.
     * @param {String} actionName
     * @returns {(ActionTrigger|null)} Null, if the action is not triggered
     */
    TouchInputInterpreter.prototype.checkAction = function (actionName) {
        var intensity = this._bindings[actionName].getTriggeredIntensity(this._touches);
        if (intensity > 0) {
            return {
                name: actionName,
                intensity: intensity,
                source: this
            };
        }
        return null;
    };
    /**
     * @override
     * @param {Function} [actionFilterFunction] 
     * @returns {Object[][]}
     */
    TouchInputInterpreter.prototype.getTriggeredActions = function (actionFilterFunction) {
        var i, result, touch, now = performance.now();
        result = control.InputInterpreter.prototype.getTriggeredActions.call(this, actionFilterFunction);
        for (i = 0; i < this._touches.length; i++) {
            touch = this._touches[i];
            // we remove the touches finished since the last getTriggeredActions() call after letting
            // the bindings process them
            if (touch.finished) {
                this._touches.splice(i, 1);
                i--;
            } else {
                touch.previousX = touch.currentX;
                touch.previousY = touch.currentY;
                touch.age = now - touch.startTime;
                touch.capturedBy = null;
            }
        }
        return result;
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        setModulePrefix: setModulePrefix,
        TouchBinding: TouchBinding,
        TouchInputInterpreter: TouchInputInterpreter
    };
});

/**
 * Copyright 2014-2017, 2020 Krisztián Nagy
 * @file This file provides a class that builds on the Control module to provide a Controller for cameras of the SceneGraph module
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, Element, localStorage, document, window, navigator */

/**
 * @param types Used for type-checking the configuration JSON for the camera controller
 * @param application Used for displaying error messages
 * @param control CameraController is a subclass of controller
 * @param camera Used to access the style enum of the Camera class
 */
define('modules/camera-controller',[
    "utils/types",
    "modules/application",
    "modules/control/control",
    "modules/scene/camera"
], function (types, application, control, camera) {
    "use strict";
    // #########################################################################
    /**
     * @class The camera controller pocesses and executes the actions with which
     * the user can control the camera
     * @extends Controller
     * @param {Object} dataJSON
     */
    function CameraController(dataJSON) {
        control.Controller.call(this, dataJSON);
        /**
         * A reference to the controlled camera object.
         * @type Camera
         */
        this._controlledCamera = null;
        /**
         * The relative velocity vector that is the result of acceleration induced by the user controlling the camera.
         * @type Number[3]
         */
        this._controlledVelocityVector = [0, 0, 0];
        /**
         * The target value for the controlled velocity vector currently set by user controls (it might take some time to reach this target
         * depending of the acceleration parameters of the camera). E.g. if when the user is moving the camera to the right, this will be
         * [max speed, 0, 0]
         * @type Number[3]
         */
        this._velocityTargetVector = [0, 0, 0];
        /**
         * The maximum speed the camera is allowed to move with along one axis by the user. (meters / second)
         * @type Number
         */
        this._maxSpeed = dataJSON.maxSpeed || 0;
        /**
         * The acceleration rate of the camera along one axis when controlled (moved) by the user. (m/s^2)
         * @type Number
         */
        this._acceleration = dataJSON.acceleration || 0;
        /**
         * The deceleration rate of the camera along one axis when controlled (stopped) by the user. (m/s^2)
         * @type Number
         */
        this._deceleration = dataJSON.deceleration || 0;
        /**
         * The current relative angular velocity of the camera, around axes: [X,Y,Z], in degrees / second
         * This is the result of angular acceleration induced by the player. (followed objects not considered)
         * @type Number[3]
         */
        this._angularVelocityVector = [0, 0, 0];
        /**
         * The maximum angular velocity around an axis when controlled by the user, degrees / second
         * @type Number
         */
        this._maxAngularVelocity = dataJSON.maxSpin || 0;
        /**
         * The angular acceleration of the camera along one axis when controlled (turned) by the user. (deg/s^2)
         * @type Number
         */
        this._angularAcceleration = dataJSON.angularAcceleration || 0;
        /**
         * The angular deceleration of the camera along one axis when controlled (stopped) by the user. (deg/s^2)
         * @type Number
         */
        this._angularDeceleration = dataJSON.angularDeceleration || 0;
        /**
         * The target value for the controlled angular velocity vector currently set by user controls (it might take some time to reach this 
         * target depending of the angular acceleration parameters of the camera). E.g. if when the user is turning the camera to the right, 
         * this will be [0, max.ang.acc., 0]
         * @type Number[3]
         */
        this._angularVelocityTargetVector = [0, 0, 0];
        /**
         * The duration of transitions that will occur when the camera is controlled to change the object(s) it is following. (in milliseconds)
         * @type Number
         */
        this._objectChangeTransitionDuration = dataJSON.objectChangeTransitionDuration;
        /**
         * The duration of transitions that will occur when the camera is controlled to change its current view of the same object. (in milliseconds)
         * @type Number
         */
        this._viewChangeTransitionDuration = dataJSON.viewChangeTransitionDuration;
        /**
         * The duration of transitions that will occur when the camera is controlled to reset its current view. (in milliseconds)
         * @type Number
         */
        this._viewResetTransitionDuration = dataJSON.viewResetTransitionDuration;
        /**
         * (enum Camera.TransitionStyle) The style of transitions applied by commands given to the camera by this controller.
         * @type String
         */
        this._transitionStyle = types.getEnumValue(camera.Camera.TransitionStyle, dataJSON.transitionStyle, {name: "cameraController.transitionStyle"});
        // The superclass constructor above loads the data from the JSON, so all action
        // properties should have been created.
        this.setActionFunctions("controlCamera", function () {
            if (this._context) {
                this._context.makeControllerPriority(this);
            } else {
                application.showError("Cannot make camera controller the priority controller because it is not added to any control context!");
            }
        }.bind(this), function () {
            if (this._controlledCamera.getConfiguration().resetsOnFocusChange()) {
                this._controlledCamera.transitionToConfigurationDefaults(this._viewResetTransitionDuration, this._transitionStyle);
            }
            if (this._context) {
                this._context.restoreDefaultControllerPriorityOrder();
            } else {
                application.showError("Cannot restore original priority order of the camera controller's context because it is not added to any!");
            }
        }.bind(this));
        // turning the camera in the six directions
        this.setActionFunctions("cameraTurnLeft", function (intensity) {
            if (intensity === undefined) {
                if (this._angularVelocityTargetVector[1] > -this._maxAngularVelocity) {
                    this._angularVelocityTargetVector[1] = -this._maxAngularVelocity;
                }
            } else {
                this._angularVelocityTargetVector[1] = -intensity;
                this._angularVelocityVector[1] = -intensity;
            }
        }.bind(this), function () {
            // stopping unnecessary left turn
            if (this._angularVelocityTargetVector[1] < 0) {
                this._angularVelocityTargetVector[1] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraTurnRight", function (intensity) {
            if (intensity === undefined) {
                if (this._angularVelocityTargetVector[1] < this._maxAngularVelocity) {
                    this._angularVelocityTargetVector[1] = this._maxAngularVelocity;
                }
            } else {
                this._angularVelocityTargetVector[1] = intensity;
                this._angularVelocityVector[1] = intensity;
            }
        }.bind(this), function () {
            // stopping unnecessary right turn
            if (this._angularVelocityTargetVector[1] > 0) {
                this._angularVelocityTargetVector[1] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraTurnUp", function (intensity) {
            if (intensity === undefined) {
                if (this._angularVelocityTargetVector[0] > -this._maxAngularVelocity) {
                    this._angularVelocityTargetVector[0] = -this._maxAngularVelocity;
                }
            } else {
                this._angularVelocityTargetVector[0] = -intensity;
                this._angularVelocityVector[0] = -intensity;
            }
        }.bind(this), function () {
            // stopping unnecessary upward turn
            if (this._angularVelocityTargetVector[0] < 0) {
                this._angularVelocityTargetVector[0] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraTurnDown", function (intensity) {
            if (intensity === undefined) {
                if (this._angularVelocityTargetVector[0] < this._maxAngularVelocity) {
                    this._angularVelocityTargetVector[0] = this._maxAngularVelocity;
                }
            } else {
                this._angularVelocityTargetVector[0] = intensity;
                this._angularVelocityVector[0] = intensity;
            }
        }.bind(this), function () {
            // stopping unnecessary downward turn
            if (this._angularVelocityTargetVector[0] > 0) {
                this._angularVelocityTargetVector[0] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraRollLeft", function (intensity) {
            if (intensity === undefined) {
                if (this._angularVelocityTargetVector[2] > -this._maxAngularVelocity) {
                    this._angularVelocityTargetVector[2] = -this._maxAngularVelocity;
                }
            } else {
                this._angularVelocityTargetVector[2] = -intensity;
                this._angularVelocityVector[2] = -intensity;
            }
        }.bind(this), function () {
            // stopping unnecessary left roll
            if (this._angularVelocityTargetVector[2] < 0) {
                this._angularVelocityTargetVector[2] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraRollRight", function (intensity) {
            if (intensity === undefined) {
                if (this._angularVelocityTargetVector[2] < this._maxAngularVelocity) {
                    this._angularVelocityTargetVector[2] = this._maxAngularVelocity;
                }
            } else {
                this._angularVelocityTargetVector[2] = intensity;
                this._angularVelocityVector[2] = intensity;
            }
        }.bind(this), function () {
            // stopping unnecessary right roll
            if (this._angularVelocityTargetVector[2] > 0) {
                this._angularVelocityTargetVector[2] = 0;
            }
        }.bind(this));
        //moving the camera along the 3 axes
        this.setActionFunctions("cameraMoveLeft", function () {
            if (this._velocityTargetVector[0] > -this._maxSpeed) {
                this._velocityTargetVector[0] = -this._maxSpeed;
            }
        }.bind(this), function () {
            // stopping unnecessary leftward movement
            if (this._velocityTargetVector[0] < 0) {
                this._velocityTargetVector[0] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraMoveRight", function () {
            if (this._velocityTargetVector[0] < this._maxSpeed) {
                this._velocityTargetVector[0] = this._maxSpeed;
            }
        }.bind(this), function () {
            // stopping unnecessary rightward movement
            if (this._velocityTargetVector[0] > 0) {
                this._velocityTargetVector[0] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraMoveUp", function () {
            if (this._velocityTargetVector[1] < this._maxSpeed) {
                this._velocityTargetVector[1] = this._maxSpeed;
            }
        }.bind(this), function () {
            // stopping unnecessary upward movement
            if (this._velocityTargetVector[1] > 0) {
                this._velocityTargetVector[1] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraMoveDown", function () {
            if (this._velocityTargetVector[1] > -this._maxSpeed) {
                this._velocityTargetVector[1] = -this._maxSpeed;
            }
        }.bind(this), function () {
            // stopping unnecessary downward movement
            if (this._velocityTargetVector[1] < 0) {
                this._velocityTargetVector[1] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraMoveForward", function (i) {
            var targetSpeed = ((i !== undefined) ? i : 1) * this._maxSpeed;
            if ((this._velocityTargetVector[2] > -targetSpeed) || (i !== undefined)) {
                this._velocityTargetVector[2] = -targetSpeed;
            }
        }.bind(this), function () {
            // stopping unnecessary forward movement
            if (this._velocityTargetVector[2] < 0) {
                this._velocityTargetVector[2] = 0;
            }
        }.bind(this));
        this.setActionFunctions("cameraMoveBackward", function () {
            if (this._velocityTargetVector[2] < this._maxSpeed) {
                this._velocityTargetVector[2] = this._maxSpeed;
            }
        }.bind(this), function () {
            // stopping unnecessary backward movement
            if (this._velocityTargetVector[2] > 0) {
                this._velocityTargetVector[2] = 0;
            }
        }.bind(this));
        // zooming
        this.setActionFunction("cameraDecreaseFOV", true, function () {
            this._controlledCamera.decreaseFOV();
        }.bind(this));
        this.setActionFunction("cameraIncreaseFOV", true, function () {
            this._controlledCamera.increaseFOV();
        }.bind(this));
        // changing the view
        this.setActionFunction("nextView", true, function () {
            this._controlledCamera.changeToNextView(this._viewChangeTransitionDuration, this._transitionStyle);
        }.bind(this));
        this.setActionFunction("previousView", true, function () {
            this._controlledCamera.changeToPreviousView(this._viewChangeTransitionDuration, this._transitionStyle);
        }.bind(this));
        // following another object
        this.setActionFunction("followNext", true, function () {
            this._controlledCamera.followNextNode(true, this._objectChangeTransitionDuration, this._transitionStyle);
        }.bind(this));
        this.setActionFunction("followPrevious", true, function () {
            this._controlledCamera.followPreviousNode(true, this._objectChangeTransitionDuration, this._transitionStyle);
        }.bind(this));
        this.setActionFunction("resetView", true, function () {
            this._controlledCamera.transitionToConfigurationDefaults(this._viewResetTransitionDuration, this._transitionStyle);
        }.bind(this));
    }
    CameraController.prototype = new control.Controller();
    CameraController.prototype.constructor = CameraController;
    /**
     * Returns the string representation of the type (domain) of the controller.
     * This will be shown to users on the control settings page, which groups controls
     * based on domains.
     * @returns {String}
     */
    CameraController.prototype.getType = function () {
        return "camera";
    };
    /**
     * Sets the controlled camera for this controller. After called, all controls 
     * will take effect on the camera passed here as a parameter.
     * @param {Camera} controlledCamera
     */
    CameraController.prototype.setControlledCamera = function (controlledCamera) {
        this._controlledCamera = controlledCamera;
    };
    /**
     * Returns the maximum speed the camera is allowed to move with along one axis by the user. (meters / second)
     * @returns {Number}
     */
    CameraController.prototype.getMaxSpeed = function () {
        return this._maxSpeed;
    };
    /**
     * Sets the controlled camera to follow the passed visual object from now on.
     * @param {Object3D} renderableObject
     * @param {Number} [duration]
     * @param {String} [style] (enum Camera.TransitionStyle)
     * @param {String} [configurationName] The name of the configuration (view) of the object to follow (if not given, the first one associated with the object is selected)
     */
    CameraController.prototype.setCameraToFollowObject = function (renderableObject, duration, style, configurationName) {
        this._controlledCamera.followObject(renderableObject, false, duration, style, configurationName);
    };
    /**
     * Sets the controlled camera to free control (not following any objects)
     */
    CameraController.prototype.setToFreeCamera = function () {
        this._controlledCamera.setToFreeCamera(false);
    };
    /**
     * Instantly stops camera movement and turning
     */
    CameraController.prototype.stop = function () {
        this._controlledVelocityVector[0] = 0;
        this._controlledVelocityVector[1] = 0;
        this._controlledVelocityVector[2] = 0;
        this._velocityTargetVector[0] = 0;
        this._velocityTargetVector[1] = 0;
        this._velocityTargetVector[2] = 0;
        this._angularVelocityVector[0] = 0;
        this._angularVelocityVector[1] = 0;
        this._angularVelocityVector[2] = 0;
        this._angularVelocityTargetVector[0] = 0;
        this._angularVelocityTargetVector[1] = 0;
        this._angularVelocityTargetVector[2] = 0;
    };
    /**
     * Calculates the angular velocity for this control step based on the control inputs that were issued in this step.
     * @param {Number} dt The time that has passed since the last control step (in milliseconds)
     */
    CameraController.prototype._updateAngularVelocity = function (dt) {
        var i;
        for (i = 0; i < this._angularVelocityVector.length; i++) {
            if (this._angularVelocityVector[i] >= 0) {
                if (this._angularVelocityVector[i] < this._angularVelocityTargetVector[i]) {
                    this._angularVelocityVector[i] += this._angularAcceleration * dt / 1000;
                    if (this._angularVelocityVector[i] > this._angularVelocityTargetVector[i]) {
                        this._angularVelocityVector[i] = this._angularVelocityTargetVector[i];
                    }
                } else if (this._angularVelocityVector[i] > this._angularVelocityTargetVector[i]) {
                    this._angularVelocityVector[i] -= this._angularDeceleration * dt / 1000;
                    if (this._angularVelocityVector[i] < this._angularVelocityTargetVector[i]) {
                        this._angularVelocityVector[i] = this._angularVelocityTargetVector[i];
                    }
                }
            } else if (this._angularVelocityVector[i] < 0) {
                if (this._angularVelocityVector[i] > this._angularVelocityTargetVector[i]) {
                    this._angularVelocityVector[i] -= this._angularAcceleration * dt / 1000;
                    if (this._angularVelocityVector[i] < this._angularVelocityTargetVector[i]) {
                        this._angularVelocityVector[i] = this._angularVelocityTargetVector[i];
                    }
                } else if (this._angularVelocityVector[i] < this._angularVelocityTargetVector[i]) {
                    this._angularVelocityVector[i] += this._angularDeceleration * dt / 1000;
                    if (this._angularVelocityVector[i] > this._angularVelocityTargetVector[i]) {
                        this._angularVelocityVector[i] = this._angularVelocityTargetVector[i];
                    }
                }
            }
        }
    };
    /**
     * Calculates the velocity for this control step based on the control inputs that were issued in this step.
     * @param {Number} dt The time that has passed since the last control step (in milliseconds)
     */
    CameraController.prototype._updateVelocity = function (dt) {
        var i;
        for (i = 0; i < this._controlledVelocityVector.length; i++) {
            if (this._controlledVelocityVector[i] >= 0) {
                if (this._controlledVelocityVector[i] < this._velocityTargetVector[i]) {
                    this._controlledVelocityVector[i] += this._acceleration * dt / 1000;
                    if (this._controlledVelocityVector[i] > this._velocityTargetVector[i]) {
                        this._controlledVelocityVector[i] = this._velocityTargetVector[i];
                    }
                } else if (this._controlledVelocityVector[i] > this._velocityTargetVector[i]) {
                    this._controlledVelocityVector[i] -= this._deceleration * dt / 1000;
                    if (this._controlledVelocityVector[i] < this._velocityTargetVector[i]) {
                        this._controlledVelocityVector[i] = this._velocityTargetVector[i];
                    }
                }
            } else if (this._controlledVelocityVector[i] < 0) {
                if (this._controlledVelocityVector[i] > this._velocityTargetVector[i]) {
                    this._controlledVelocityVector[i] -= this._acceleration * dt / 1000;
                    if (this._controlledVelocityVector[i] < this._velocityTargetVector[i]) {
                        this._controlledVelocityVector[i] = this._velocityTargetVector[i];
                    }
                } else if (this._controlledVelocityVector[i] < this._velocityTargetVector[i]) {
                    this._controlledVelocityVector[i] += this._deceleration * dt / 1000;
                    if (this._controlledVelocityVector[i] > this._velocityTargetVector[i]) {
                        this._controlledVelocityVector[i] = this._velocityTargetVector[i];
                    }
                }
            }
        }
    };
    /**
     * Checks if there is a controlled camera set, and if there is one, executes the 
     * actions on the camera.
     * @param {Object[][]} triggeredActions See {@link Controller#executeActions}
     * @param {Number} dt The time elapsed since the last control step
     */
    CameraController.prototype.executeActions = function (triggeredActions, dt) {
        if (this._controlledCamera) {
            control.Controller.prototype.executeActions.call(this, triggeredActions);
            this._updateAngularVelocity(dt);
            this._updateVelocity(dt);
            this._controlledCamera.setControlledVelocityVector(this._controlledVelocityVector);
            this._controlledCamera.setAngularVelocityVector(this._angularVelocityVector);
        }
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        CameraController: CameraController
    };
});

/**
 * Copyright 2014-2018, 2020 Krisztián Nagy
 * @file Provides various classes that can be used integrated with the Screen module as components on screens. Also manages a shader cache
 * for storing the downloaded source (HTML and CSS) files of the created components.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document */

/**
 * @param utils Used for formatted strings when setting component content
 * @param application Used for logging, displaying errors and loading files.
 * @param asyncResource Used for managing asynchronous loading of components from files (subclassing AsyncResource)
 * @param strings Used for translation support
 */
define('modules/components',[
    "utils/utils",
    "modules/application",
    "modules/async-resource",
    "modules/strings"
], function (utils, application, asyncResource, strings) {
    "use strict";
    /**
     * @typedef {Object} Components~ModelLoadInfoObject
     * Stores a model and its loading state
     * @property {Boolean} requested
     * @property {DocumentFragment} model
     * @property {Function[]} onLoadQueue
     */
    /**
     * @typedef {Object} Components~LabelDescriptor
     * Stores the data based on which the text of an HTML element that is used as a
     * label can be determined.
     * @property {String} [caption] A static caption to be used on the label.
     * @property {String} [id] An ID that can be used as a translation key for the
     * text on the label for auto-translation.
     */
    var
            // ------------------------------------------------------------------------------
            // Constants
            /**
             * The id attributes of the HTML elements are separated from the name of their
             * parent components by this string to create their unique ID among the elements
             * on the same screen
             * @type String
             */
            ELEMENT_ID_SEPARATOR = "_",
            /**
             * ID of the folder containing the component source HTML files
             * @type String
             */
            COMPONENT_FOLDER = "component",
            CSS_FOLDER = "css",
            LOADING_BOX_PROGRESS_ID = "progress",
            LOADING_BOX_STATUS_DIV_ID = "status",
            LOADING_BOX_HEADER_ID = "header",
            INFO_BOX_MESSAGE_PARAGRAPH_ID = "message",
            INFO_BOX_OK_BUTTON_ID = "okButton",
            INFO_BOX_HEADER_ID = "header",
            SELECTOR_PROPERTY_LABEL_ID = "property",
            SELECTOR_VALUE_BUTTON_ID = "value",
            SLIDER_PROPERTY_LABEL_ID = "property",
            SLIDER_ID = "slider",
            SLIDER_VALUE_LABEL_ID = "valueLabel",
            // key codes
            ENTER_CODE = 13,
            UP_CODE = 38,
            DOWN_CODE = 40,
            // CSS class names
            DISABLED_CLASS_NAME = "disabled",
            SELECTED_CLASS_NAME = "selected",
            HIGHLIGHTED_CLASS_NAME = "highlighted",
            // event names for passing event handlers when components are crated
            SHOW_EVENT_NAME = "show",
            HIDE_EVENT_NAME = "hide",
            ENABLE_EVENT_NAME = "enable",
            DISABLE_EVENT_NAME = "disable",
            SELECT_EVENT_NAME = "select",
            UNSELECT_EVENT_NAME = "unselect",
            BUTTON_SELECT_EVENT_NAME = "buttonselect",
            BUTTON_CLICK_EVENT_NAME = "buttonclick",
            OPTION_SELECT_EVENT_NAME = "optionselect",
            OPTION_CLICK_EVENT_NAME = "optionclick",
            ELEMENT_HIGHLIGHT_EVENT_NAME = "elementhighlight",
            ELEMENT_SELECT_EVENT_NAME = "elementselect",
            TRANSLATION_KEY_ATTRIBUTE = "data-translation-key",
            // ------------------------------------------------------------------------------
            // Private variables
            /**
             * Stores the loaded DOM models and their associated loading states and queued
             * functions for each HTML file that the components use, by the names of the
             * files
             * @type Object.<String, Components~ModelLoadInfoObject>
             */
            _modelLoadInfo = {};
    // ------------------------------------------------------------------------------
    // private functions
    // a set of module functions to manage a common pool of DOM models about HTML files
    // that the components use so they can be reused, as likely components of the same
    // class will use the same HTML file
    /**
     * Returns whether the DOM model has already been loaded and is available for the
     * HTML file with the passed name
     * @param {String} sourceFileName
     * @returns {Boolean}
     */
    function _isModelLoadedForSource(sourceFileName) {
        return _modelLoadInfo[sourceFileName] && !!_modelLoadInfo[sourceFileName].model;
    }
    /**
     * Returns the loaded DOM model for the HTML file with the passed name
     * @param {String} sourceFileName
     * @returns {HTMLDocument}
     */
    function _getModelForSource(sourceFileName) {
        return _modelLoadInfo[sourceFileName] && _modelLoadInfo[sourceFileName].model;
    }
    /**
     * Returns whether the loading of the HTML file with the passed name has already been
     * requested
     * @param {type} sourceFileName
     * @returns {Boolean}
     */
    function _isModelRequestedForSource(sourceFileName) {
        return _modelLoadInfo[sourceFileName] && _modelLoadInfo[sourceFileName].requested;
    }
    /**
     * If needed, initiates the loading of the HTML file with the passed name, and makes sure
     * the callback function is executed once the file has been loaded and its DOM model has
     * been created. If no loading is needed, the callback is executed right away (synchronously)
     * @param {String} sourceFileName
     * @param {Function} callback
     */
    function _requestModelForSource(sourceFileName, callback) {
        if (!_isModelRequestedForSource(sourceFileName)) {
            _modelLoadInfo[sourceFileName] = {};
            _modelLoadInfo[sourceFileName].requested = true;
            _modelLoadInfo[sourceFileName].onLoadQueue = [callback];
            // send an asynchronous request to grab the HTML file
            application.requestTextFile(COMPONENT_FOLDER, sourceFileName, function (responseText) {
                var i, helperDiv;
                // once the files has been loaded, create and save the DOM model
                _modelLoadInfo[sourceFileName].model = document.createDocumentFragment();
                // the DocumentFragment node has no innerHTML property, so we create a helper
                // HTML element so we can convert the source file's text content to DOM
                helperDiv = document.createElement("div");
                helperDiv.innerHTML = responseText;
                _modelLoadInfo[sourceFileName].model.appendChild(helperDiv.firstElementChild);
                // execute all queued functions
                for (i = 0; i < _modelLoadInfo[sourceFileName].onLoadQueue.length; i++) {
                    _modelLoadInfo[sourceFileName].onLoadQueue[i]();
                }
            });
        } else {
            // if the model has been requested, but is not loaded yet, put the callback function
            // in the execution queue
            if (!_isModelLoadedForSource(sourceFileName)) {
                _modelLoadInfo[sourceFileName].onLoadQueue.push(callback);
            } else {
                // if we have the model already, execute the callback right away
                if (callback) {
                    callback();
                }
            }
        }
    }
    /**
     * Returns the text that should be shown on a label that uses the passed descriptor.
     * @param {Components~LabelDescriptor} labelDescriptor
     * @returns {String}
     */
    function _getLabelText(labelDescriptor) {
        return labelDescriptor.caption || strings.get({name: labelDescriptor.id});
    }
    // ------------------------------------------------------------------------------
    // public functions
    /**
     * Deletes the references to DOM models stored for external component sources files.
     * After all components have been added to the page, these models become unnecessary
     * and can be deleted.
     */
    function clearStoredDOMModels() {
        _modelLoadInfo = {};
    }
    // #########################################################################
    /**
     * @class A wrapper class around a regular HTML5 element, that makes it easier
     * to integrate its functionality into a screen. Provides several
     * methods that are called automatically by the screen at certain points as well
     * as some that can be called on-demand and only serve to make code more readable.
     * @param {String} name The name of the component ot identify it.
     * @param {String} [elementID]  The id attribute of the HTML5 element this component
     * wraps. If omitted, it will have the same value as name.
     * @param {Object.<String, Function>} [eventHandlers] The functions to execute when various events happen to this component
     */
    function SimpleComponent(name, elementID, eventHandlers) {
        /**
         * The name of the component. 
         * @type String
         */
        this._name = name;
        /**
         * The id attribute of the HTML5 element must have this value for successful initialization.
         * @type String
         */
        this._elementID = elementID || name;
        /**
         * The DOM object of the wrapped HTML element.
         * @type HTMLElement
         */
        this._element = null;
        /**
         * A function that runs whenever the component becomes visible.
         * @type Function
         */
        this._onShow = eventHandlers ? eventHandlers[SHOW_EVENT_NAME] : null;
        /**
         * A function that runs whenever the component becomes hidden.
         * @type Function
         */
        this._onHide = eventHandlers ? eventHandlers[HIDE_EVENT_NAME] : null;
        /**
         * A function that runs whenever the component becomes enabled.
         * @type Function
         */
        this._onEnable = eventHandlers ? eventHandlers[ENABLE_EVENT_NAME] : null;
        /**
         * A function that runs whenever the component becomes disabled.
         * @type Function
         */
        this._onDisable = eventHandlers ? eventHandlers[DISABLE_EVENT_NAME] : null;
        /**
         * A function that runs whenever the component becomes selected.
         * @type Function
         */
        this._onSelect = eventHandlers ? eventHandlers[SELECT_EVENT_NAME] : null;
        /**
         * A function that runs whenever the component becomes unselected.
         * @type Function
         */
        this._onUnselect = eventHandlers ? eventHandlers[UNSELECT_EVENT_NAME] : null;
    }
    /**
     * Return the name that identifies this component (within its screen / external component)
     * @returns {String}
     */
    SimpleComponent.prototype.getName = function () {
        return this._name;
    };
    /**
     * Sets a new element ID - either for later initialization or along with resetting the id of the
     * actual wrapped element.
     * @param {String} elementID
     */
    SimpleComponent.prototype.setElementID = function (elementID) {
        this._elementID = elementID;
        if (this._element) {
            this._element.setAttribute("id", this._elementID);
        }
    };
    /**
     * Returns the wrapped HTML element.
     * @returns {HTMLElement}
     */
    SimpleComponent.prototype.getElement = function () {
        return this._element;
    };
    /**
     * Returns the inner HTML text content of the wrapped element.
     * @returns {String}
     */
    SimpleComponent.prototype.getContent = function () {
        return this._element.innerHTML;
    };
    /**
     * Sets the inner HTML content (parsing the passed string) of the wrapped element.
     * @param {String} newContent
     * @param {Object} [replacements] If given, the newContent string will be used as a format string and the named values given in this
     * object will be replaced in it
     */
    SimpleComponent.prototype.setContent = function (newContent, replacements) {
        this._element.innerHTML = replacements ? utils.formatString(newContent, replacements) : newContent;
    };
    /**
     * Sets the inner text content of the wrapped element.
     * @param {String} newContent
     * @param {Object} [replacements] If given, the newContent string will be used as a format string and the named values given in this
     * object will be replaced in it
     */
    SimpleComponent.prototype.setTextContent = function (newContent, replacements) {
        this._element.textContent = replacements ? utils.formatString(newContent, replacements) : newContent;
    };
    /**
     * Replaces the named parameters in the inner HTML text content of the wrapped elements to the values defined in the passed object.
     * @param {Object} replacements
     */
    SimpleComponent.prototype.customizeContent = function (replacements) {
        this._element.innerHTML = utils.formatString(this._element.innerHTML, replacements);
    };
    /**
     * Returns the current value of an attribute of the wrapped HTML element
     * @param {String} name The name of the attribute to be checked
     * @returns {}
     */
    SimpleComponent.prototype.getAttribute = function (name) {
        return this._element[name];
    };
    /**
     * Sets a new value for an attribute of the wrapped HTML element
     * @param {String} name
     * @param {} value
     */
    SimpleComponent.prototype.setAttribute = function (name, value) {
        this._element[name] = value;
    };
    /**
     * Grabs the element and the display style from the current HTML document. Needs
     * to be called after the wrapped element has been appended to the document.
     * (automatically called by screens after append)
     */
    SimpleComponent.prototype.initComponent = function () {
        this._element = document.getElementById(this._elementID);
        if (!this._element) {
            application.showError(
                    "Cannot initialize component: '" + this._name + "'!",
                    application.ErrorSeverity.SEVERE,
                    "No element can be found on the page with a corresponding ID: '" + this._elementID + "'!");
        }
    };
    /**
     * Returns whether the component is currently visible.
     * @returns {Boolean}
     */
    SimpleComponent.prototype.isVisible = function () {
        return !this._element.hidden;
    };
    /**
     * Hides the wrapped HTML element by setting its hidden attribute
     */
    SimpleComponent.prototype.hide = function () {
        if (this.isVisible()) {
            this._element.hidden = true;
            if (this._onHide) {
                this._onHide();
            }
        }
    };
    /**
     * Shows (reveals) the wrapped HTML element by setting its hidden attribute
     */
    SimpleComponent.prototype.show = function () {
        if (!this.isVisible()) {
            this._element.hidden = false;
            if (this._onShow) {
                this._onShow();
            }
        }
    };
    /**
     * Shows / hides the component, if needed to achieve the passed visibility (also calling the appropriate event handlers)
     * @param {Boolean} visible The desired visibility of the component
     */
    SimpleComponent.prototype.setVisible = function (visible) {
        if (visible) {
            this.show();
        } else {
            this.hide();
        }
    };
    /**
     * Returns whether the component is currently in enabled state.
     * @returns {Boolean}
     */
    SimpleComponent.prototype.isEnabled = function () {
        return !this._element.classList.contains(DISABLED_CLASS_NAME);
    };
    /**
     * Puts the component in disabled state.
     */
    SimpleComponent.prototype.disable = function () {
        if (this.isEnabled()) {
            this._element.classList.add(DISABLED_CLASS_NAME);
            if (this._onDisable) {
                this._onDisable();
            }
        }
    };
    /**
     * Puts the component in enabled state.
     */
    SimpleComponent.prototype.enable = function () {
        if (!this.isEnabled()) {
            this._element.classList.remove(DISABLED_CLASS_NAME);
            if (this._onEnable) {
                this._onEnable();
            }
        }
    };
    /**
     * Returns whether the component is currently in selected state.
     * @returns {Boolean}
     */
    SimpleComponent.prototype.isSelected = function () {
        return this._element.classList.contains(SELECTED_CLASS_NAME);
    };
    /**
     * Puts the component in selected state.
     */
    SimpleComponent.prototype.select = function () {
        if (!this.isSelected()) {
            this._element.classList.add(SELECTED_CLASS_NAME);
            if (this._onSelect) {
                this._onSelect();
            }
        }
    };
    /**
     * Puts the component in not selected state.
     */
    SimpleComponent.prototype.unselect = function () {
        if (this.isSelected()) {
            this._element.classList.remove(SELECTED_CLASS_NAME);
            if (this._onUnselect) {
                this._onUnselect();
            }
        }
        this._element.blur();
    };
    // #########################################################################
    /**
     * @typedef {Object} ExternalComponent~Style
     * A style descriptor for an external component storing the name of the CSS file
     * associated with the component as well as class names for dynamically created
     * HTML elements.
     * @property {String} cssFilename
     */
    /**
     * @class A reusable component that consist of HTML elements (a fragment of a 
     * HTML document, stored in an external file, hence the name) and can be appended 
     * to screens. Specific components can be the descendants of this 
     * class, and implement their own various methods.
     * @extends AsyncResource
     * @param {String} name The name of the component to be identified by. Names
     * must be unique within one screen.
     * @param {String} htmlFilename The filename of the HTML document where the structure
     * of the component should be defined. The component will be loaded as the first
     * element (and all its children) inside the body tag of this file.
     * @param {ExternalComponent~Style} [style] An object storing the name of the CSS
     * file that contains the styling rules and for this component and the desired classes for  
     * dynamically created elements.
     */
    function ExternalComponent(name, htmlFilename, style) {
        asyncResource.AsyncResource.call(this);
        /**
         * The name of the component to be identified by.
         * @type String
         */
        this._name = name;
        /**
         * The root element will be set to this id and the contained named elements will be prefixed
         * with this id once the component is added to the page.
         * @type String
         */
        this._rootElementID = name;
        /**
         * The filename of the HTML document where the structure of the component should be defined.
         * @type String
         */
        this._htmlFilename = htmlFilename;
        /**
         * An object storing the name of the CSS file that contains the styling rules and for this 
         * components and the desired classes for dynamically created elements.
         * @type ExternalComponent~Style
         */
        this._style = style || {};
        /**
         * The root HTML element of the structure of this component on the screen it has been added to.
         * @type HTMLElement
         */
        this._rootElement = null;
        /**
         * A flag that marks whether loading the correspoding CSS stylesheet has finished.
         * @type Boolean
         */
        this._cssLoaded = false;
        /**
         * The array of contained simple components. The components in this array
         * are automatically managed (initialization and reset).
         * @type SimpleComponent[]
         */
        this._simpleComponents = [];
        // Subclasses will call this constructor to set their prototype without any
        // parameters, therefore make sure we don't attempt to load from "undefined"
        // source.
        if (htmlFilename) {
            this.requestModelLoad();
        }
    }
    ExternalComponent.prototype = new asyncResource.AsyncResource();
    ExternalComponent.prototype.constructor = ExternalComponent;
    ExternalComponent.prototype.getName = function () {
        return this._name;
    };
    /**
     * The root element will be set to the given id and the contained named elements will be prefixed
     * with this id once the component is added to the page. This can only be called before the component
     * is added to the page!
     * @param {String} rootElementID
     */
    ExternalComponent.prototype.setRootElementID = function (rootElementID) {
        var i;
        if (!this._rootElement) {
            this._rootElementID = rootElementID;
            for (i = 0; i < this._simpleComponents.length; i++) {
                this._simpleComponents[i].setElementID(this._getElementID(this._simpleComponents[i].getName()));
            }
        } else {
            application.showError("Attempting to change the root element ID for external component '" + this._name + "' after it has already been added to the page!");
        }
    };
    /**
     * Initiates the asynchronous loading of the component's structure from the
     * external HTML file and potential styling from the external CSS style.
     */
    ExternalComponent.prototype.requestModelLoad = function () {
        if (this._style.cssFilename) {
            this._cssLoaded = false;
            application.requestCSSFile(CSS_FOLDER, this._style.cssFilename, function () {
                this._cssLoaded = true;
                if (_isModelLoadedForSource(this._htmlFilename)) {
                    this.setToReady();
                }
            }.bind(this));
        } else {
            this._cssLoaded = true;
        }
        // if needed, initiate the request to get the HTML source file
        _requestModelForSource(this._htmlFilename, function () {
            if (this._cssLoaded === true) {
                this.setToReady();
            }
        }.bind(this));
    };
    /**
     * Appends the component's elements to the current document. This is called by the addExternalComponent
     * method of the screens when they are added to the page, which happens only after the DOM models for
     * the screen and all its components have been loaded. Do not call this manually.
     * @param {Node} [parentNode=document.body] The component will be appended as child of this node.
     */
    ExternalComponent.prototype.appendToPage = function (parentNode) {
        var namedElements, i;
        parentNode = parentNode || document.body;
        this._rootElement = parentNode.appendChild(document.importNode(_getModelForSource(this._htmlFilename).firstElementChild, true));
        this._rootElement.setAttribute("id", this._rootElementID);
        // All elements with an "id" attribute within this structure have to
        // be renamed to make sure their id does not conflict with other elements
        // in the main document (such as elements of another instance of the
        // same external component), when they are appended. Therefore prefix
        // their id with the name of this component. (which is unique within
        // a game screen, and is prefixed with the name of the game screen,
        // which is uniqe within the game, thus fulfilling the requirement of
        // overall uniqueness)
        namedElements = this._rootElement.querySelectorAll("[id]");
        for (i = 0; i < namedElements.length; i++) {
            namedElements[i].setAttribute("id", this._getElementID(namedElements[i].getAttribute("id")));
        }
        this._initializeComponents();
    };
    /**
     * Returns appropriately prefixed version of the original, passed ID that would correspond
     * to the ID of an element of this component.
     * @param {String} originalElementID
     * @returns {String}
     */
    ExternalComponent.prototype._getElementID = function (originalElementID) {
        return this._rootElementID + ELEMENT_ID_SEPARATOR + originalElementID;
    };
    /**
     * Returns the ID of the passed element without the prefix referencing to this component
     * @param {Element} element
     * @returns {String}
     */
    ExternalComponent.prototype._getOriginalElementID = function (element) {
        return element.getAttribute("id").substr(this._rootElementID.length + ELEMENT_ID_SEPARATOR.length);
    };
    /**
     * Setting the properties that will be used to easier access DOM elements later.
     * In subclasses, this method should be overloaded if custom properties need
     * to be initialized (registered simple components are already imitialized here
     * automatically.
     */
    ExternalComponent.prototype._initializeComponents = function () {
        var i;
        if (this._rootElement) {
            for (i = 0; i < this._simpleComponents.length; i++) {
                this._simpleComponents[i].initComponent();
            }
        } else {
            application.log_DEBUG("WARNING! Attempting to initaialize external component " + this._name + " before appending it to the page! It will be initialized automatically once it is added.");
        }
    };
    /**
     * If possible, updates the inner HTML text of the child elements to the translation in the current language.
     * (it is possible, if the child element has a data-translation-key attribute with the value of the translation key)
     */
    ExternalComponent.prototype.updateComponents = function () {
        var i, elementsToTranslate;
        if (this._rootElement) {
            elementsToTranslate = this._rootElement.querySelectorAll("[" + TRANSLATION_KEY_ATTRIBUTE + "]");
            for (i = 0; i < elementsToTranslate.length; i++) {
                elementsToTranslate[i].innerHTML = strings.get({
                    name: elementsToTranslate[i].getAttribute(TRANSLATION_KEY_ATTRIBUTE),
                    defaultValue: elementsToTranslate[i].innerHTML
                });
            }
        } else {
            application.log_DEBUG("WARNING! Attempting to update external component " + this._name + " before appending it to the page!");
        }
    };
    /**
     * Adds a new simple component with the specified name (prefixed with the name
     * of this component, as id attributes are also prefixed when the component is
     * appended to the document), and also returns it.
     * @param {String} simpleComponentName This name will be automatically
     * prefixed with the external component's name when the simple component is created.
     * @param {Object.<String, Function>} [eventHandlers] Will be passed to the created SimpleComponent
     * @returns {SimpleComponent}
     */
    ExternalComponent.prototype.registerSimpleComponent = function (simpleComponentName, eventHandlers) {
        var component = new SimpleComponent(simpleComponentName, this._getElementID(simpleComponentName), eventHandlers);
        this._simpleComponents.push(component);
        return component;
    };
    /**
     * Returns whether the component is currently set to be visible
     * @returns {Boolean}
     */
    ExternalComponent.prototype.isVisible = function () {
        return !this._rootElement.hidden;
    };
    /**
     * Sets the hidden attribute of the root element of the component to show it.
     * @returns {Boolean} Whether the component became visible as the result of this call
     */
    ExternalComponent.prototype.show = function () {
        if (this._rootElement) {
            if (!this.isVisible()) {
                this._rootElement.hidden = false;
                return true;
            }
        } else {
            application.log_DEBUG("WARNING! Attempting to show external component " + this._name + " before appending it to the page!");
        }
        return false;
    };
    /**
     * Sets the hidden attribute of the root element of the component to hide it.
     * @returns {Boolean} Whether the component became hidden as the result of this call
     */
    ExternalComponent.prototype.hide = function () {
        if (this._rootElement) {
            if (this.isVisible()) {
                this._rootElement.hidden = true;
                return true;
            }
        } else {
            application.log_DEBUG("WARNING! Attempting to hide external component " + this._name + " before appending it to the page!");
        }
        return false;
    };
    // #########################################################################
    /**
     * @class A loading box component, that has a title, a progress bar and a status
     * message. Hidden upon initialization by default.
     * @extends ExternalComponent
     * @param {String} name See ExternalComponent.
     * @param {String} htmlFilename See ExternalComponent.
     * @param {ExternalComponent~Style} [style] See ExternalComponent.
     * @param {String} [headerID] If given, the header element will get this ID
     * (prefixed with the component name), making it possible to auto-translate it
     * using the same string key as this ID
     */
    function LoadingBox(name, htmlFilename, style, headerID) {
        ExternalComponent.call(this, name, htmlFilename, style);
        /**
         * @type SimpleComponent
         */
        this._progress = this.registerSimpleComponent(LOADING_BOX_PROGRESS_ID);
        /**
         * @type SimpleComponent
         */
        this._status = this.registerSimpleComponent(LOADING_BOX_STATUS_DIV_ID);
        /**
         * @type SimpleComponent
         */
        this._header = this.registerSimpleComponent(LOADING_BOX_HEADER_ID);
        /**
         * If set, the header element gets this ID (prefixed with the component 
         * name), making it possible to auto-translate it using the same string key as this ID
         * @type String
         */
        this._headerID = headerID;
    }
    LoadingBox.prototype = new ExternalComponent();
    LoadingBox.prototype.constructor = LoadingBox;
    /**
     * @override
     * Initializes the contained simple components and hides the box.
     */
    LoadingBox.prototype._initializeComponents = function () {
        ExternalComponent.prototype._initializeComponents.call(this);
        if (this._rootElement) {
            if (this._headerID) {
                this._header.setElementID(this._getElementID(this._headerID));
            }
            this.hide();
        }
    };
    /**
     * Updates the maximum value of the progress bar shown on the loading box.
     * @param {Number} value 
     */
    LoadingBox.prototype.setMaxProgress = function (value) {
        if (this._rootElement) {
            this._progress.getElement().max = value;
        } else {
            application.log_DEBUG("WARNING! Attempting to update the maximum progress value of loading box" + this._name + " before appending it to the page!");
        }
    };
    /**
     * Updates the value of the progress bar shown on the loading box.
     * @param {Number} value The new value of the progress bar.
     */
    LoadingBox.prototype.updateProgress = function (value) {
        if (this._rootElement) {
            this._progress.getElement().value = value;
        } else {
            application.log_DEBUG("WARNING! Attempting to update the progress value of loading box" + this._name + " before appending it to the page!");
        }
    };
    /**
     * Updates the status message, and optionally the progress value shown on the loading box.
     * @param {String} status The new status to show.
     * @param {Object} [replacements] If given the status string will be considered a format string, and its
     * placeholders will be replaced according to the properties of this object
     * @param {Number} [progress] The new progress value to show
     */
    LoadingBox.prototype.updateStatus = function (status, replacements, progress) {
        if (this._rootElement) {
            this._status.setContent(status, replacements);
            if (progress !== undefined) {
                this.updateProgress(progress);
            }
        } else {
            application.log_DEBUG("WARNING! Attempting to update the status message of loading box" + this._name + " before appending it to the page!");
        }
    };
    // #########################################################################
    /**
     * @class An info box component, that has a title, and a message to tell to the
     * user. Hidden upon initialization by default.
     * @extends ExternalComponent
     * @param {String} name See ExternalComponent.
     * @param {String} htmlFilename See ExternalComponent.
     * @param {ExternalComponent~Style} [style] See ExternalComponent.
     * @param {String} [headerID] If given, the header element will get this ID
     * (prefixed with the component name), making it possible to auto-translate it
     * using the same string key as this ID
     * @param {String} [okButtonID] If given, the OK button element will get this ID
     * (prefixed with the component name), making it possible to auto-translate it
     * using the same string key as this ID
     * @param {Object.<String, Function>} [eventHandlers] The functions to execute when various events happen to this component.
     * Currently supported events: show, hide, buttonselect, buttonclick
     */
    function InfoBox(name, htmlFilename, style, headerID, okButtonID, eventHandlers) {
        ExternalComponent.call(this, name, htmlFilename, style);
        /**
         * A function that will be run every time the box is shown.
         * @type Function
         */
        this._onShow = eventHandlers ? eventHandlers[SHOW_EVENT_NAME] : null;
        /**
         * A function that will be run every time the box is hidden.
         * @type Function
         */
        this._onHide = eventHandlers ? eventHandlers[HIDE_EVENT_NAME] : null;
        /**
         * A function that will be run every time the OK button on the box is selected
         * @type Function
         */
        this._onButtonSelect = eventHandlers ? eventHandlers[BUTTON_SELECT_EVENT_NAME] : null;
        /**
         * A function that will be run every time the OK button on the box is clicked (/activated)
         */
        this._onButtonClick = eventHandlers ? eventHandlers[BUTTON_CLICK_EVENT_NAME] : null;
        /**
         * @type SimpleComponent
         */
        this._message = this.registerSimpleComponent(INFO_BOX_MESSAGE_PARAGRAPH_ID);
        /**
         * @type SimpleComponent
         */
        this._okButton = this.registerSimpleComponent(
                INFO_BOX_OK_BUTTON_ID,
                (this._onButtonSelect) ?
                {select: function () {
                        this._onButtonSelect(this._okButton.isEnabled());
                    }.bind(this)} :
                null);
        /**
         * @type SimpleComponent
         */
        this._header = this.registerSimpleComponent(INFO_BOX_HEADER_ID);
        /**
         * If set, the header element gets this ID (prefixed with the component name), making
         * it possible to auto-translate it using the same string key as this ID
         * @type String
         */
        this._headerID = headerID;
        /**
         * If set, the OK button element gets this ID (prefixed with the component name), making
         * it possible to auto-translate it using the same string key as this ID
         * @type String
         */
        this._okButtonID = okButtonID;
        /**
         * A keyboard event handler that can be added to the document when the box is
         * shown to allow closing it by pressing enter, not just clicking on the button.
         * This needs to be a privileged method so that it can always access the 
         * original info box instance, no matter where is it called from.
         * @type Function
         * @param {KeyboardEvent} event
         */
        this._handleKeyUp = function (event) {
            if (event.keyCode === ENTER_CODE) {
                this._okButton.getElement().onclick();
            } else if ((event.keyCode === UP_CODE) || (event.keyCode === DOWN_CODE)) {
                this._okButton.select();
            }
        }.bind(this);
    }
    InfoBox.prototype = new ExternalComponent();
    InfoBox.prototype.constructor = InfoBox;
    /**
     * Initializes the contained simple components, set the event handler for the
     * button and hides the box.
     */
    InfoBox.prototype._initializeComponents = function () {
        ExternalComponent.prototype._initializeComponents.call(this);
        if (this._rootElement) {
            if (this._headerID) {
                this._header.setElementID(this._getElementID(this._headerID));
            }
            if (this._okButtonID) {
                this._okButton.setElementID(this._getElementID(this._okButtonID));
            }
            this._okButton.getElement().onmouseenter = function () {
                this._okButton.select();
            }.bind(this);
            this._okButton.getElement().onmouseleave = function () {
                this._okButton.unselect();
            }.bind(this);
            this._okButton.getElement().onclick = function () {
                if (this._onButtonClick) {
                    this._onButtonClick(this._okButton.isEnabled());
                }
                this.hide();
                return false;
            }.bind(this);
            // at initialization, do not yet run the onHide function, since the box has
            // not been shown yet
            ExternalComponent.prototype.hide.call(this);
        }
    };
    /**
     * @override
     * @returns {Boolean}
     */
    InfoBox.prototype.show = function () {
        if (ExternalComponent.prototype.show.call(this)) {
            this._okButton.unselect();
            document.addEventListener("keyup", this._handleKeyUp);
            if (this._onShow) {
                this._onShow();
            }
            return true;
        }
        return false;
    };
    /**
     * @override
     * @returns {Boolean}
     */
    InfoBox.prototype.hide = function () {
        if (ExternalComponent.prototype.hide.call(this)) {
            document.removeEventListener("keyup", this._handleKeyUp);
            if (this._onHide) {
                this._onHide();
            }
            return true;
        }
        return false;
    };
    /**
     * Updates the message shown on the info box.
     * @param {String} message The new message to show.
     * @param {Object} [replacements] If given the status string will be considered a format string, and its
     * placeholders will be replaced according to the properties of this object
     */
    InfoBox.prototype.updateMessage = function (message, replacements) {
        if (this._rootElement) {
            this._message.setContent(message, replacements);
        } else {
            application.log_DEBUG("WARNING! Attempting to update the message of info box" + this._name + " before appending it to the page!");
        }
    };
    // #########################################################################
    /**
     * @typedef {ExternalComponent~Style} MenuComponent~Style
     * @property {String} [menuClassName]
     * @property {String} [buttonClassName]
     * @property {String} [buttonContainerClassName]
     * @property {String} disabledClassName Added to disabled menu options. Disabled menu options cannot be selected
     * @property {String} selectedButtonClassName
     */
    /**
     * @typedef {Components~LabelDescriptor} MenuComponent~MenuOption
     * @property {String} [id] The key for translation
     * @property {String} [caption] Static caption (non-translated)
     * @property {Function} action The function to execute
     * @property {Boolean} [enabled=true] Only enabled options can be selected, and non-enabled options have a the disabled CSS class (defined in MenuComponent~Style)
     * @property {Element} [element] Set when the element is created
     */
    /**
     * @class A component that consists of a container and a list of menu options
     * inside, which execute given functions when clicked on
     * @extends ExternalComponent
     * @param {String} name See ExternalComponent.
     * @param {String} htmlFilename See ExternalComponent
     * @param {MenuComponent~Style} [style] See ExternalComponent
     * @param {MenuComponent~MenuOption[]} menuOptions An array of the available menu options
     * @param {Object.<String, Function>} [eventHandlers] The functions to execute when various events happen to this component.
     * Currently supported events: optionselect, optionclick
     */
    function MenuComponent(name, htmlFilename, style, menuOptions, eventHandlers) {
        var i;
        ExternalComponent.call(this, name, htmlFilename, style);
        /**
         * An array of the available menu options, each described by an object with 
         * a caption (String) and an action (Function) property.
         * @type MenuComponent~MenuOption[]
         */
        this._menuOptions = menuOptions;
        for (i = 0; i < this._menuOptions.length; i++) {
            if (this._menuOptions[i].enabled === undefined) {
                this._menuOptions[i].enabled = true;
            }
        }
        /**
         * The index of the currently selected menu option. -1 if no option is selected.
         * @type Number
         */
        this._selectedIndex = -1;
        /**
         * A function that runs whenever a menu option is selected.
         * @type Function
         */
        this._onOptionSelect = eventHandlers ? eventHandlers[OPTION_SELECT_EVENT_NAME] : null;
        /**
         * A function that runs whenever a menu option is clicked (/activated).
         * @type Function
         */
        this._onOptionClick = eventHandlers ? eventHandlers[OPTION_CLICK_EVENT_NAME] : null;
        // validate the style object as a missings selected style can lead to obscure bugs
        this._validateStyle(style);
    }
    MenuComponent.prototype = new ExternalComponent();
    MenuComponent.prototype.constructor = MenuComponent;
    /**
     * Shows an error message if the given style object is not valid.
     * @param {MenuComponent~Style} style
     */
    MenuComponent.prototype._validateStyle = function (style) {
        if (typeof style !== "object") {
            application.showError("Invalid menu style specified: not an object!");
            return;
        }
        if (!style.selectedButtonClassName) {
            application.showError("Attempting to specify a menu style without specifying a class for selected menu buttons!");
        }
        if (!style.disabledClassName) {
            application.showError("Attempting to specify a menu style without specifying a class for disabled menu buttons!");
        }
    };
    /**
     * Selects the option with the passed index (distinguishes the selected option with the set CSS class)
     * @param {Number} index
     */
    MenuComponent.prototype._selectIndex = function (index) {
        if (index !== this._selectedIndex) {
            if (this._selectedIndex >= 0) {
                this._menuOptions[this._selectedIndex].element.classList.remove(this._style.selectedButtonClassName);
                this._menuOptions[this._selectedIndex].element.blur();
            }
            this._selectedIndex = index;
            if (this._selectedIndex >= 0) {
                if (this._menuOptions[this._selectedIndex].enabled) {
                    this._menuOptions[this._selectedIndex].element.classList.add(this._style.selectedButtonClassName);
                    if (this._onOptionSelect) {
                        this._onOptionSelect(true); // always enabled - disabled menu options cannot be selected
                    }
                }
            }
        }
    };
    /**
     * The return value of the click handler on a link decides whether the link path 
     * should be followed or not. By making sure it is false, the links serving as 
     * buttons in the menu will not bring the user back to the top of the page 
     * (because href is #). This function returns a function that executes the action
     * for the button of the given index, and then returns false to be used as a click
     * event handler.
     * @param {Number} index
     * @returns {Function}
     */
    MenuComponent.prototype._getMenuClickHandler = function (index) {
        return function () {
            if (this._menuOptions[index].enabled) {
                this._selectIndex(index);
                this._menuOptions[index].action();
            }
            if (this._onOptionClick) {
                this._onOptionClick(this._menuOptions[index].enabled);
            }
            return false;
        }.bind(this);
    };
    /**
     * Returns an event listener that can be used for the element corresponding to the menu option with the
     * passed index to handle the mouse move events on it - selecting the option.
     * @param {Number} index
     * @returns {Function}
     */
    MenuComponent.prototype._getMenuMouseMoveHandler = function (index) {
        return function () {
            if (this._menuOptions[index].enabled) {
                this._selectIndex(index);
            }
        }.bind(this);
    };
    /**
     * Sets up the menu by appending the buttons to the container.
     */
    MenuComponent.prototype._initializeComponents = function () {
        var i, buttonElement, liElement;
        ExternalComponent.prototype._initializeComponents.call(this);
        if (this._rootElement) {
            this._rootElement.classList.add(this._style.menuClassName);
            for (i = 0; i < this._menuOptions.length; i++) {
                buttonElement = document.createElement("button");
                if (this._menuOptions[i].id) {
                    buttonElement.id = this._getElementID(this._menuOptions[i].id);
                    buttonElement.setAttribute(TRANSLATION_KEY_ATTRIBUTE, this._menuOptions[i].id);
                }
                buttonElement.className = (this._style.menuClassName || "") + " " + (this._style.buttonClassName || "") + (this._menuOptions[i].enabled ? "" : this._style.disabledClassName);
                buttonElement.innerHTML = _getLabelText(this._menuOptions[i]);
                // we need to generate an appropriate handler function here for each
                // menu element (cannot directly create it here as they would all use
                // the same index as i would be a closure)
                buttonElement.onclick = this._getMenuClickHandler(i);
                buttonElement.onmousemove = this._getMenuMouseMoveHandler(i);
                this._menuOptions[i].element = buttonElement;
                liElement = document.createElement("li");
                liElement.className = (this._style.buttonContainerClassName || "");
                liElement.appendChild(buttonElement);
                this._rootElement.appendChild(liElement);
            }
            this._rootElement.onmouseout = this.unselect.bind(this);
        }
    };
    /**
     * Cancels the selection of the currently selected menu item (if any)
     */
    MenuComponent.prototype.unselect = function () {
        this._selectIndex(-1);
    };
    /**
     * Selects the menu item coming after the currently selected one, or the first one if none are selected. Skips disabled options.
     */
    MenuComponent.prototype.selectNext = function () {
        var start = this._selectedIndex;
        if (start === -1) {
            start = this._menuOptions.length - 1;
        }
        do {
            this._selectIndex((this._selectedIndex + 1) % this._menuOptions.length);
        } while (this._selectedIndex !== start && !this._menuOptions[this._selectedIndex].enabled);
        if (!this._menuOptions[this._selectedIndex].enabled) {
            this._selectIndex(-1);
        }
    };
    /**
     * Selects the menu item coming before the currently selected one, or the last one if none are selected. Skips disabled options.
     */
    MenuComponent.prototype.selectPrevious = function () {
        var start = this._selectedIndex;
        if (start === -1) {
            start = 0;
        }
        do {
            if (this._selectedIndex > 0) {
                this._selectIndex(this._selectedIndex - 1);
            } else {
                this._selectIndex(this._menuOptions.length - 1);
            }
        } while (this._selectedIndex !== start && !this._menuOptions[this._selectedIndex].enabled);
        if (!this._menuOptions[this._selectedIndex].enabled) {
            this._selectIndex(-1);
        }
    };
    /**
     * Executes the action associated with the currently selected menu option (if any).
     */
    MenuComponent.prototype.activateSelected = function () {
        if (this._selectedIndex >= 0) {
            this._menuOptions[this._selectedIndex].element.onclick();
        }
    };
    // #########################################################################
    /**
     * @typedef {ExternalComponent~Style} ListComponent~Style
     * @property {String} [listClassName]
     * @property {String} [listContainerClassName]
     * @property {String} [elementClassName]
     * @property {String} [elementContainerClassName]
     * @property {String} [captionClassName]
     * @property {String} [subcaptionClassName]
     * @property {String} disabledElementClassName Added to disabled list elements. Disabled list elements cannot be highlighted or selected
     * @property {String} selectedElementClassName
     * @property {String} highlightedElementClassName
     */
    /**
     * @typedef {Object} ListComponent~ListElement
     * @property {String} [captionID] The key for translation for the main caption
     * @property {String} [caption] Main static caption (non-translated)
     * @property {String} [subcaptionID] The key for translation for the subcaption
     * @property {String} [subcaption] Static subcaption (non-translated)
     * @property {Boolean} [enabled=true] Only enabled list elements can be selected, and non-enabled elements have a the disabled CSS class (defined in ListComponent~Style)
     * @property {Element} [element] Set when the element is created
     */
    /**
     * @class A component that consists of a container and a list of selectable elements. Elements can be highlighted, which represents a 
     * transient state and then the highlighted element can be selected (cancelling previous selections - only one element can be highlighted
     * or selected at a time) - selection is a persistent state
     * @extends ExternalComponent
     * @param {String} name See ExternalComponent.
     * @param {String} htmlFilename See ExternalComponent
     * @param {ListComponent~Style} [style] See ExternalComponent
     * @param {ListComponent~ListElement[]} listElements An array of the available list elements
     * @param {Boolean} subcaptions Whether to display the subcaptions of the list element
     * @param {Object.<String, Function>} [eventHandlers] The functions to execute when various events happen to this component.
     * Currently supported events: elementhighlight, elementselect
     */
    function ListComponent(name, htmlFilename, style, listElements, subcaptions, eventHandlers) {
        var i;
        ExternalComponent.call(this, name, htmlFilename, style);
        /**
         * An array of the available list elements, each described by a ListComponent~ListElement object
         * @type ListComponent~ListElement[]
         */
        this._listElements = listElements;
        for (i = 0; i < this._listElements.length; i++) {
            if (this._listElements[i].enabled === undefined) {
                this._listElements[i].enabled = true;
            }
        }
        /**
         * Whether to display the subcaptions of the list element
         * @type Boolean
         */
        this._subcaptions = subcaptions;
        /**
         * The index of the highlighted list element. -1 if no element is highlighted.
         * @type Number
         */
        this._highlightedIndex = -1;
        /**
         * The index of the selected list element. -1 if no element is selected.
         * @type Number
         */
        this._selectedIndex = -1;
        /**
         * A function that runs whenever an element is highlighted
         * @type Function
         */
        this._onElementHighlight = eventHandlers ? eventHandlers[ELEMENT_HIGHLIGHT_EVENT_NAME] : null;
        /**
         * A function that runs whenever an element is selected
         * @type Function
         */
        this._onElementSelect = eventHandlers ? eventHandlers[ELEMENT_SELECT_EVENT_NAME] : null;
        /**
         * The ul tag housing the list elements
         * @type Element
         */
        this._ulElement = null;
        // validate the style object as a missings highlighted style can lead to obscure bugs
        this._validateStyle(style);
    }
    ListComponent.prototype = new ExternalComponent();
    ListComponent.prototype.constructor = ListComponent;
    /**
     * Shows an error message if the given style object is not valid.
     * @param {ListComponent~Style} style
     */
    ListComponent.prototype._validateStyle = function (style) {
        if (typeof style !== "object") {
            application.showError("Invalid menu style specified: not an object!");
            return;
        }
        if (!style.disabledElementClassName) {
            application.showError("Attempting to specify a list style without specifying a class for disabled list elements!");
        }
        if (!style.selectedElementClassName) {
            application.showError("Attempting to specify a list style without specifying a class for selected list elements!");
        }
        if (!style.highlightedElementClassName) {
            application.showError("Attempting to specify a list style without specifying a class for highlighted list elements!");
        }
    };
    /**
     * Make sure the element with the passed index is visible by scrolling if necessary 
     * @param {Number} index
     */
    ListComponent.prototype._scrollToIndex = function (index) {
        var listElement;
        listElement = this._listElements[index].element;
        if (listElement.offsetTop < this._rootElement.scrollTop) {
            this._rootElement.scrollTop = listElement.offsetTop;
        } else if (listElement.offsetTop + listElement.offsetHeight > this._rootElement.scrollTop + this._rootElement.clientHeight) {
            this._rootElement.scrollTop = listElement.offsetTop + listElement.offsetHeight - this._rootElement.clientHeight;
        }
    };
    /**
     * Highlights the element with the passed index (distinguishes the highlighted option with the set CSS class)
     * @param {Number} index Index of the element (-1 to cancel current highlight)
     * @param {Boolean} [scroll=false] Whether to make sure the highlighted element is visible by scrolling if necessary (to be used with 
     * keyboard controls)
     */
    ListComponent.prototype._highlightIndex = function (index, scroll) {
        if (index !== this._highlightedIndex) {
            if (this._highlightedIndex >= 0) {
                this._listElements[this._highlightedIndex].element.classList.remove(this._style.highlightedElementClassName);
            }
            this._highlightedIndex = index;
            if (this._highlightedIndex >= 0) {
                if (this._listElements[this._highlightedIndex].enabled) {
                    this._listElements[this._highlightedIndex].element.classList.add(this._style.highlightedElementClassName);
                    if (scroll) {
                        this._scrollToIndex(index);
                    }
                    if (this._onElementHighlight) {
                        this._onElementHighlight(index, true); // always enabled - disabled list elements cannot be highlighted
                    }
                }
            }
        }
    };
    /**
     * Selects the element with the passed index (distinguishes the selected option with the set CSS class)
     * @param {Number} index Index of the element (-1 to cancel selection)
     * @param {Boolean} [scroll=false] Whether to make sure the selected element is visible by scrolling if necessary
     */
    ListComponent.prototype.selectIndex = function (index, scroll) {
        if (scroll && (index >= 0)) {
            this._scrollToIndex(index);
        }
        if (index !== this._selectedIndex) {
            if ((index < 0) || ((index >= 0) && this._listElements[index].enabled)) {
                if (this._selectedIndex >= 0) {
                    this._listElements[this._selectedIndex].element.classList.remove(this._style.selectedElementClassName);
                }
                this._selectedIndex = index;
                if (this._selectedIndex >= 0) {
                    this._listElements[this._selectedIndex].element.classList.add(this._style.selectedElementClassName);
                }
            }
            if (this._onElementSelect) {
                this._onElementSelect(index, (index >= 0) && this._listElements[index].enabled);
            }
        }
    };
    /**
     * Returns the index of the currently highlighted element (-1 if no element is currently highlighted)
     * @returns {Number}
     */
    ListComponent.prototype.getHighlightedIndex = function () {
        return this._highlightedIndex;
    };
    /**
     * Returns the index of the currently selected element (-1 if no element is currently selected)
     * @returns {Number}
     */
    ListComponent.prototype.getSelectedIndex = function () {
        return this._selectedIndex;
    };
    /**
     * The return value of the click handler on a link decides whether the link path 
     * should be followed or not. By making sure it is false, the links will not bring 
     * the user back to the top of the page (because href is #). 
     * @param {Number} index
     * @returns {Function}
     */
    ListComponent.prototype._getElementClickHandler = function (index) {
        return function () {
            if (this._listElements[index].enabled) {
                this.selectIndex(index);
            }
            return false;
        }.bind(this);
    };
    /**
     * Returns an event listener that can be used for the HTML element corresponding to the list element with the
     * passed index to handle the mouse move events on it - highlighting the option. (without scrolling)
     * @param {Number} index
     * @returns {Function}
     */
    ListComponent.prototype._getElementMouseMoveHandler = function (index) {
        return function () {
            if (this._listElements[index].enabled) {
                this._highlightIndex(index);
            } else {
                this._highlightIndex(-1);
            }
        }.bind(this);
    };
    /**
     * @param {ListComponent~ListElement} listElement
     * @param {Number} index
     */
    ListComponent.prototype._addListElement = function (listElement, index) {
        var spanElement, aElement, liElement;
        // element container
        liElement = document.createElement("li");
        liElement.className = (this._style.elementContainerClassName || "");
        // element 
        aElement = document.createElement("a");
        aElement.className = (this._style.elementClassName || "") + " " + (listElement.enabled ? "" : this._style.disabledElementClassName);
        listElement.element = aElement;
        aElement.onclick = this._getElementClickHandler(index);
        aElement.onmousemove = this._getElementMouseMoveHandler(index);
        liElement.appendChild(aElement);
        // main caption
        spanElement = document.createElement("span");
        if (listElement.captionID) {
            spanElement.setAttribute(TRANSLATION_KEY_ATTRIBUTE, listElement.captionID);
        }
        spanElement.className = (this._style.captionClassName || "");
        spanElement.innerHTML = listElement.caption || strings.get({name: listElement.captionID});
        aElement.appendChild(spanElement);
        if (this._subcaptions) {
            // dividing captions
            aElement.appendChild(document.createElement("br"));
            // subcaption
            spanElement = document.createElement("span");
            if (listElement.subcaptionID) {
                spanElement.setAttribute(TRANSLATION_KEY_ATTRIBUTE, listElement.subcaptionID);
            }
            spanElement.className = (this._style.subcaptionClassName || "");
            spanElement.innerHTML = listElement.subcaption || strings.get({name: listElement.subcaptionID});
            aElement.appendChild(spanElement);
        }
        // adding to DOM hierarchy
        this._ulElement.appendChild(liElement);
    };
    /**
     * Add a new list element after the last one
     * @param {ListComponent~ListElement} listElement
     */
    ListComponent.prototype.addListElement = function (listElement) {
        if (listElement.enabled === undefined) {
            listElement.enabled = true;
        }
        this._listElements.push(listElement);
        this._addListElement(listElement, this._listElements.length - 1);
    };
    /**
     * @override
     */
    ListComponent.prototype._initializeComponents = function () {
        var i;
        ExternalComponent.prototype._initializeComponents.call(this);
        if (this._rootElement) {
            // list container
            this._rootElement.classList.add(this._style.listContainerClassName);
            // list
            this._ulElement = document.createElement("ul");
            this._ulElement.classList.add(this._style.listClassName);
            for (i = 0; i < this._listElements.length; i++) {
                this._addListElement(this._listElements[i], i);
            }
            this._rootElement.onmouseleave = this.unhighlight.bind(this);
            this._rootElement.appendChild(this._ulElement);
        }
    };
    /**
     * Cancels the highlight of the currently highlighted list element (if any)
     */
    ListComponent.prototype.unhighlight = function () {
        this._highlightIndex(-1);
    };
    /**
     * Cancels the selection of the currently selected list element (if any)
     */
    ListComponent.prototype.unselect = function () {
        this.selectIndex(-1);
    };
    /**
     * Cancels the highlight and selection and scrolls to the top of the list
     */
    ListComponent.prototype.reset = function () {
        this.unselect();
        this.unhighlight();
        this._rootElement.scrollTop = 0;
    };
    /**
     * Highlights the list element coming after the currently highlighted one, or the first one if none are highlighted. Skips disabled elements.
     */
    ListComponent.prototype.highlightNext = function () {
        var start = this._highlightedIndex;
        if (start === -1) {
            start = this._listElements.length - 1;
        }
        do {
            this._highlightIndex((this._highlightedIndex + 1) % this._listElements.length, true);
        } while (this._highlightedIndex !== start && !this._listElements[this._highlightedIndex].enabled);
        if (!this._listElements[this._highlightedIndex].enabled) {
            this._highlightIndex(-1);
        }
    };
    /**
     * Highlights the list element coming before the currently highlighted one, or the last one if none are highlighted. Skips disabled elements.
     */
    ListComponent.prototype.highlightPrevious = function () {
        var start = this._highlightedIndex;
        if (start === -1) {
            start = 0;
        }
        do {
            if (this._highlightedIndex > 0) {
                this._highlightIndex(this._highlightedIndex - 1, true);
            } else {
                this._highlightIndex(this._listElements.length - 1, true);
            }
        } while (this._highlightedIndex !== start && !this._listElements[this._highlightedIndex].enabled);
        if (!this._listElements[this._highlightedIndex].enabled) {
            this._highlightIndex(-1);
        }
    };
    /**
     * Selects the currently highlighted list element (executing the handler if set)
     */
    ListComponent.prototype.selectHighlighted = function () {
        if (this._highlightedIndex >= 0) {
            this._listElements[this._highlightedIndex].element.onclick();
        }
    };
    /**
     * Executes the passed callback function for each list element, passing the HTML element representing that list element as its single
     * argument
     * @param {Function} callback 
     */
    ListComponent.prototype.executeForListElements = function (callback) {
        var i;
        for (i = 0; i < this._listElements.length; i++) {
            callback(this._listElements[i].element);
        }
    };
    /**
     * Set the caption of a list element directly (removing any translation keys)
     * @param {Number} index
     * @param {String} caption
     */
    ListComponent.prototype.setCaption = function (index, caption) {
        var listElement = this._listElements[index], spanElement = listElement.element.querySelector("." + this._style.captionClassName);
        if (listElement.captionID) {
            listElement.captionID = "";
            spanElement.removeAttribute(TRANSLATION_KEY_ATTRIBUTE);
        }
        listElement.caption = caption;
        spanElement.innerHTML = caption;
    };
    // #########################################################################
    /**
     * @typedef {ExternalComponent~Style} Selector~Style
     * @property {String} [selectorClassName] The root element of the Selector will have this CSS class
     * @property {String} [propertyContainerClassName] The element containing the property name label will have this CSS class
     */
    /**
     * @class A component that consists of a label describing a property, and a
     * button that can be clicked to select from a list of possible values for that
     * property. (suitable for properties with a small amount of possible values, 
     * as each click will show the next value, and when the last is reached, the 
     * cycle will begin again)
     * @extends ExternalComponent
     * @param {String} name See ExternalComponent.
     * @param {String} htmlFilename See ExternalComponent.
     * @param {Selector~Style} [style] See ExternalComponent.
     * @param {Components~LabelDescriptor} propertyLabelDescriptor The caption and id of the property label element that is displayed on this
     * selector, indicating what property can be set with it
     * @param {String[]} valueList The list of possible values that can be selected
     * for the property.
     */
    function Selector(name, htmlFilename, style, propertyLabelDescriptor, valueList) {
        ExternalComponent.call(this, name, htmlFilename, style);
        /**
         * The name of the property that can be set using this selector.
         * @type Components~LabelDescriptor
         */
        this._propertyLabelDescriptor = propertyLabelDescriptor;
        /**
         * The list of possible values that can be selected with this selector.
         * @type String[]
         */
        this._valueList = valueList;
        /**
         * The index of the currently selected value.
         * @type Number
         */
        this._valueIndex = 0;
        /**
         * A wrapper for the HTML element containing the label caption for the property
         * this selector sets.
         * @type SimpleComponent
         */
        this._propertyLabel = this.registerSimpleComponent(SELECTOR_PROPERTY_LABEL_ID);
        /**
         * A wrapper for the HTML element which serves as the selector button to select
         * from the available values.
         * @type SimpleComponent
         */
        this._valueSelector = this.registerSimpleComponent(SELECTOR_VALUE_BUTTON_ID);
        /**
         * A function to execute when the selected value has been changed.
         * @type Function
         */
        this.onChange = null;
    }
    Selector.prototype = new ExternalComponent();
    Selector.prototype.constructor = Selector;
    /**
     * Initializes the components, sets their text and sets the handler for the click
     * on the selector.
     */
    Selector.prototype._initializeComponents = function () {
        ExternalComponent.prototype._initializeComponents.call(this);
        if (this._rootElement) {
            if (this._style.selectorClassName) {
                this._rootElement.className = this._style.selectorClassName;
            }
            if (this._propertyLabelDescriptor.id) {
                this._propertyLabel.setElementID(this._getElementID(this._propertyLabelDescriptor.id));
                this._propertyLabel.getElement().setAttribute(TRANSLATION_KEY_ATTRIBUTE, this._propertyLabelDescriptor.id);
            }
            this._propertyLabel.setContent(_getLabelText(this._propertyLabelDescriptor));
            if (this._style.propertyContainerClassName) {
                this._propertyLabel.getElement().className = this._style.propertyContainerClassName;
            }
            this._valueSelector.setContent(this._valueList[0]);
            this._valueIndex = 0;
            this.setValueList(this._valueList);
            this._valueSelector.getElement().onmouseup = function (event) {
                event.preventDefault();
                event.stopPropagation();
                switch (event.which) {
                    case 1:
                        this.selectNextValue();
                        break;
                    case 3:
                        this.selectPreviousValue();
                        break;
                }
                return false;
            }.bind(this);
            this._valueSelector.getElement().oncontextmenu = function (event) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            };
        }
    };
    /**
     * Selects the value given as parameter from the list of available values.
     * @param {String} value
     */
    Selector.prototype.selectValue = function (value) {
        if (this._rootElement) {
            var i = 0;
            while ((i < this._valueList.length) && (this._valueList[i] !== value)) {
                i++;
            }
            if (i < this._valueList.length) {
                this.selectValueWithIndex(i, 0);
            } else {
                application.showError(
                        "Attempted to select value: '" + value + "' for '" + _getLabelText(this._propertyLabelDescriptor) + "', which is not one of the available options.",
                        application.ErrorSeverity.MINOR);
            }
        } else {
            application.showError("Attemted to select value for selector " + this._name + " which is not yet appended to the page!");
        }
    };
    /**
     * Selects the value with the passed index from the list.
     * @param {Number} index
     * @param {Number} [stepping=0] If the value was changed by stepping through the value list (clicking on the selector),
     * should be 1 for stepping up (forward), -1 for stepping down (backward) and 0 otherwise. The value of this is passed
     * to the onChange() handler.
     */
    Selector.prototype.selectValueWithIndex = function (index, stepping) {
        var originalIndex = this._valueIndex;
        if (this._rootElement) {
            if (this._valueList.length > index) {
                this._valueIndex = index;
                this._valueSelector.setContent(this._valueList[this._valueIndex]);
                if ((originalIndex !== index) && this.onChange) {
                    this.onChange(stepping || 0);
                }
            } else {
                application.showError(
                        "Attempted to select value with index '" + index + "' for '" + _getLabelText(this._propertyLabelDescriptor) + "', while the available range is: 0-" + (this._valueList.length - 1),
                        application.ErrorSeverity.MINOR);
            }
        } else {
            application.showError("Attemted to select value for selector " + this._name + " which is not yet appended to the page!");
        }
    };
    /**
     * Returns the currently selected value.
     * @returns {String}
     */
    Selector.prototype.getSelectedValue = function () {
        return this._valueList[this._valueIndex];
    };
    /**
     * Returns the index of the currently selected value.
     * @returns {Number}
     */
    Selector.prototype.getSelectedIndex = function () {
        return this._valueIndex;
    };
    /**
     * Selects the next available value from the list. If the last value was selected,
     * selects the first one.
     */
    Selector.prototype.selectNextValue = function () {
        this.selectValueWithIndex((this._valueIndex + 1) % this._valueList.length, 1);
    };
    /**
     * Selects the previous available value from the list. If the first value was selected,
     * selects the last one.
     */
    Selector.prototype.selectPreviousValue = function () {
        this.selectValueWithIndex((this._valueIndex > 0) ? this._valueIndex - 1 : this._valueList.length - 1, -1);
    };
    /**
     * 
     * @param {String[]} valueList
     */
    Selector.prototype.setValueList = function (valueList) {
        this._valueList = valueList;
        if (this._valueIndex >= this._valueList.length) {
            this._valueIndex = 0;
        }
        if (this._valueList.length < 2) {
            this._valueSelector.disable();
        } else {
            this._valueSelector.enable();
        }
    };
    // #########################################################################
    /**
     * @typedef {Object} Slider~Params
     * @property {Number} min
     * @property {Number} max
     * @property {Number} default
     * @property {Number} [step]
     * @property {String[]} [valueList] If given, the slider will have as many possible values as the number of these options, and a label
     * will be displayed next to the slider, showing the currently selected item from this list
     */
    /**
     * @class A component that consists of a label describing a property, and a slider that can be used to select from a range of possible 
     * numeric values for that property.
     * @extends ExternalComponent
     * @param {String} name See ExternalComponent.
     * @param {String} htmlFilename See ExternalComponent.
     * @param {ExternalComponent~Style} [style] See ExternalComponent.
     * @param {Components~LabelDescriptor} propertyLabelDescriptor The caption and id of the property label element that is displayed on this
     * selector, indicating what property can be set with it
     * @param {Slider~Params} params
     * @param {Function} [onChange]
     */
    function Slider(name, htmlFilename, style, propertyLabelDescriptor, params, onChange) {
        ExternalComponent.call(this, name, htmlFilename, style);
        /**
         * The name of the property that can be set using this selector.
         * @type Components~LabelDescriptor
         */
        this._propertyLabelDescriptor = propertyLabelDescriptor;
        params = params || {};
        /**
         * The minimum value on the slider
         * @type Number
         */
        this._min = params.valueList ? 0 : params.min;
        /**
         * The maximum value on the slider
         * @type Number
         */
        this._max = params.valueList ? (params.valueList.length - 1) : params.max;
        /**
         * The starting value on the slider
         * @type Number
         */
        this._default = params.default;
        /**
         * The difference between two adjacent possible values of the slider
         * @type Number
         */
        this._step = params.valueList ? 1 : ((params.step !== undefined) ? params.step : 1);
        /**
         * The list of possible values, in case the slider is used to select from them
         * @type String[]
         */
        this._valueList = params.valueList || null;
        /**
         * A wrapper for the HTML element containing the label caption for the property
         * this selector sets.
         * @type SimpleComponent
         */
        this._propertyLabel = this.registerSimpleComponent(SLIDER_PROPERTY_LABEL_ID);
        /**
         * A wrapper for the HTML element corresponding to the slider itself (an "input" of type "range")
         * @type SimpleComponent
         */
        this._slider = this.registerSimpleComponent(SLIDER_ID);
        /**
         * A wrapper for the HTML element which serves as the label of the currently selected value (in case a value list is given)
         * @type SimpleComponent
         */
        this._valueLabel = this.registerSimpleComponent(SLIDER_VALUE_LABEL_ID);
        /**
         * A function to execute when the selected value has been changed.
         * @type Function
         */
        this.onChange = onChange || null;
    }
    Slider.prototype = new ExternalComponent();
    Slider.prototype.constructor = Slider;
    /**
     * Initializes the components, sets their text and sets the handler for the click on the selector.
     */
    Slider.prototype._initializeComponents = function () {
        var changeHandler = function () {
            this._updateValueLabel();
            if (this.onChange) {
                this.onChange(this.getValue());
            }
        }.bind(this);
        ExternalComponent.prototype._initializeComponents.call(this);
        if (this._rootElement) {
            if (this._propertyLabelDescriptor.id) {
                this._propertyLabel.setElementID(this._getElementID(this._propertyLabelDescriptor.id));
                this._propertyLabel.getElement().setAttribute(TRANSLATION_KEY_ATTRIBUTE, this._propertyLabelDescriptor.id);
            }
            this._propertyLabel.setContent(_getLabelText(this._propertyLabelDescriptor));

            if (this._valueList) {
                this.setValueList(this._valueList);
                this._valueLabel.show();
            } else {
                this._valueLabel.hide();
                this._updateSlider();
            }

            this.setNumericValue(this._default);

            this._slider.getElement().onchange = changeHandler;
            this._slider.getElement().oninput = changeHandler;
        }
    };
    /**
     * Updated the attributes of the slider HTML element based on the properties of this object
     */
    Slider.prototype._updateSlider = function () {
        this._slider.setAttribute("min", this._min);
        this._slider.setAttribute("max", this._max);
        this._slider.setAttribute("step", this._step);
    };
    /**
     * Updates the content of the value label to show the currently selected value (if a value list is given)
     */
    Slider.prototype._updateValueLabel = function () {
        if (this._valueList) {
            this._valueLabel.setContent(this._valueList[this.getNumericValue()]);
        }
    };
    /**
     * Directly sets a new numeric value for the slider
     * @param {Number} value
     */
    Slider.prototype.setNumericValue = function (value) {
        this._slider.setAttribute("value", value);
        this._updateValueLabel();
    };
    /**
     * Sets a new value for the slider based on the given string, which should be one of the values given as a value list
     * @param {String} value
     */
    Slider.prototype.setListedValue = function (value) {
        var index;
        if (this._valueList) {
            index = this._valueIndex.indexOf(value);
            if (index >= 0) {
                this.setNumericValue(index);
            } else {
                application.showError("Cannot set listed value '" + value + "' for slider '" + this.getName() + "', because it is not in the value list!");
            }
        } else {
            application.showError("Cannot set listed value '" + value + "' for slider '" + this.getName() + "', because it has no value list!");
        }
    };
    /**
     * Returns the value currently selected on the slider
     * @returns {Number} 
     */
    Slider.prototype.getNumericValue = function () {
        return parseFloat(this._slider.getAttribute("value"));
    };
    /**
     * Returns the value from the value list given (which needs to be initialized!) based on the current value of the slider
     * @returns {String} 
     */
    Slider.prototype.getListedValue = function () {
        return this._valueList[this.getNumericValue()];
    };
    /**
     * Returns either the numeric (if there is no value list) or the listed (if there is one) value of the slider component
     * @returns {Number|String}
     */
    Slider.prototype.getValue = function () {
        return this._valueList ? this.getListedValue() : this.getNumericValue();
    };
    /**
     * Sets a new value list to be used for this component - that is, the possible slider values will represent the items of this list in 
     * order, and the current item will be displayed on the component
     * @param {String[]} valueList
     */
    Slider.prototype.setValueList = function (valueList) {
        var value = this.getNumericValue();
        this._valueList = valueList;
        this._min = 0;
        this._max = valueList.length - 1;
        this._step = 1;
        if (value > this._max) {
            value = 0;
        }
        this._updateSlider();
        this.setNumericValue(value);
    };
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        ELEMENT_ID_SEPARATOR: ELEMENT_ID_SEPARATOR,
        // class names
        DISABLED_CLASS_NAME: DISABLED_CLASS_NAME,
        SELECTED_CLASS_NAME: SELECTED_CLASS_NAME,
        HIGHLIGHTED_CLASS_NAME: HIGHLIGHTED_CLASS_NAME,
        // event names
        SHOW_EVENT_NAME: SHOW_EVENT_NAME,
        HIDE_EVENT_NAME: HIDE_EVENT_NAME,
        BUTTON_SELECT_EVENT_NAME: BUTTON_SELECT_EVENT_NAME,
        BUTTON_CLICK_EVENT_NAME: BUTTON_CLICK_EVENT_NAME,
        OPTION_SELECT_EVENT_NAME: OPTION_SELECT_EVENT_NAME,
        OPTION_CLICK_EVENT_NAME: OPTION_CLICK_EVENT_NAME,
        // attribute names
        TRANSLATION_KEY_ATTRIBUTE: TRANSLATION_KEY_ATTRIBUTE,
        // functions
        clearStoredDOMModels: clearStoredDOMModels,
        // classes
        SimpleComponent: SimpleComponent,
        LoadingBox: LoadingBox,
        InfoBox: InfoBox,
        MenuComponent: MenuComponent,
        ListComponent: ListComponent,
        Selector: Selector,
        Slider: Slider
    };
});
/**
 * Copyright 2016-2020 Krisztián Nagy
 * @file Contains the common constants and functions accessible to all screens of the Interstellar Armada game.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define */

/**
 * @param game Used to change the screen in public functions
 * @param resources Used to load and access the sound effects for buttons
 * @param components Used for constants (CSS class names)
 * @param config Used to access which sound effects and music to load
 * @param audio Used to initialize music
 */
define('armada/screens/shared',[
    "modules/game",
    "modules/media-resources",
    "modules/components",
    "armada/configuration",
    "armada/audio"
], function (game, resources, components, config, audio) {
    "use strict";
    var
            exports = {
                // ------------------------------------------------------------------------------
                // Constants
                // music
                MENU_THEME: "menu",
                DEBRIEFING_VICTORY_THEME: "debriefing_victory",
                DEBRIEFING_DEFEAT_THEME: "debriefing_defeat",
                // components
                SELECTOR_SOURCE: "selector.html",
                SELECTOR_CSS: "selector.css",
                SLIDER_SOURCE: "slider.html",
                SLIDER_CSS: "slider.css",
                LOADING_BOX_SOURCE: "loadingbox.html",
                LOADING_BOX_CSS: "loadingbox.css",
                INFO_BOX_SOURCE: "infobox.html",
                INFO_BOX_CSS: "infobox.css",
                MENU_COMPONENT_SOURCE: "menucomponent.html",
                LIST_COMPONENT_SOURCE: "listcomponent.html",
                LIST_COMPONENT_CSS: "listcomponent.css",
                // menu component classes
                MENU_CLASS_NAME: "menu",
                MENU_BUTTON_CONTAINER_CLASS_NAME: "transparentContainer",
                // list component classes
                LIST_CLASS_NAME: "list",
                LIST_ELEMENT_CLASS_NAME: "listElement",
                LIST_ELEMENT_CONTAINER_CLASS_NAME: "transparentContainer",
                CAPTION_CLASS_NAME: "caption",
                SUBCAPTION_CLASS_NAME: "subcaption",
                // general
                SUPERIMPOSE_BACKGROUND_COLOR: [0.25, 0.25, 0.25, 0.5],
                SCREEN_BACKGROUND_CLASS_NAME: "fullScreenFix",
                SCREEN_CONTAINER_CLASS_NAME: "fullScreenContainer",
                // welcome message
                RELEASE_NOTES_CLASS_NAME: "releaseNotes",
                // screens
                MAIN_MENU_SCREEN_NAME: "mainMenu",
                MAIN_MENU_SCREEN_SOURCE: "menu.html",
                MAIN_MENU_CONTAINER_ID: "menuContainer",
                MISSIONS_SCREEN_NAME: "missions",
                MISSIONS_SCREEN_SOURCE: "missions.html",
                MISSIONS_SCREEN_CSS: "missions.css",
                MISSIONS_LIST_CONTAINER_ID: "missionListContainer",
                BATTLE_SCREEN_NAME: "battle",
                BATTLE_SCREEN_SOURCE: "battle.html",
                BATTLE_SCREEN_CSS: "battle.css",
                DEBRIEFING_SCREEN_NAME: "debriefing",
                DEBRIEFING_SCREEN_SOURCE: "debriefing.html",
                DEBRIEFING_SCREEN_CSS: "debriefing.css",
                DATABASE_SCREEN_NAME: "database",
                DATABASE_SCREEN_SOURCE: "database.html",
                DATABASE_SCREEN_CSS: "database.css",
                SETTINGS_SCREEN_NAME: "settings",
                SETTINGS_SCREEN_SOURCE: "menu.html",
                SETTINGS_MENU_CONTAINER_ID: "menuContainer",
                GENERAL_SETTINGS_SCREEN_NAME: "generalSettings",
                GENERAL_SETTINGS_SCREEN_SOURCE: "general-settings.html",
                GENERAL_SETTINGS_SCREEN_CSS: "general-settings.css",
                GRAPHICS_SCREEN_NAME: "graphics",
                GRAPHICS_SCREEN_SOURCE: "graphics.html",
                GRAPHICS_SCREEN_CSS: "graphics.css",
                AUDIO_SCREEN_NAME: "audio",
                AUDIO_SCREEN_SOURCE: "audio.html",
                CONTROLS_SCREEN_NAME: "controls",
                CONTROLS_SCREEN_SOURCE: "controls.html",
                CONTROLS_SCREEN_CSS: "controls.css",
                GAMEPLAY_SETTINGS_SCREEN_NAME: "gameplaySettings",
                GAMEPLAY_SETTINGS_SCREEN_SOURCE: "gameplay-settings.html",
                GAMEPLAY_SETTINGS_SCREEN_CSS: "gameplay-settings.css",
                ABOUT_SCREEN_NAME: "about",
                ABOUT_SCREEN_SOURCE: "about.html",
                ABOUT_SCREEN_CSS: "about.css",
                INGAME_MENU_SCREEN_NAME: "ingameMenu",
                INGAME_MENU_SCREEN_SOURCE: "ingame-menu.html",
                INGAME_MENU_SCREEN_CSS: "ingame-menu.css",
                INGAME_MENU_CONTAINER_ID: "menuContainer",
                DIALOG_SCREEN_NAME: "dialog",
                DIALOG_SCREEN_SOURCE: "dialog.html",
                DIALOG_SCREEN_CSS: "dialog.css"
            },
            // --------------------------------------------------------------------------------------------
            // Constants
            FULLSCREEN_BUTTON_ID = "fullscreenButton",
            // ------------------------------------------------------------------------------
            // Private variables
            /**
             * Stores the sound source that can be used to play the button select sound (played when the player hovers over a button or selects it
             * with the arrow keys)
             * @type SoundSource
             */
            _buttonSelectSound,
            /**
             * Stores the sound source that can be used to play the button click sound (played when the player clicks on or activates an
             * enabled button)
             * @type SoundSource
             */
            _buttonClickSound;
    // --------------------------------------------------------------------------------------------
    // Private functions
    function _toggleFullscreen() {
        if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if (document.documentElement.mozRequestFullScreen) {
                document.documentElement.mozRequestFullScreen();
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozExitFullScreen) {
                document.mozExitFullScreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
    }
    // ------------------------------------------------------------------------------
    // Public functions
    /**
     * Initiates the loading of the sound effects used on all screens.
     * @param {Function} [callback] If given, this function is executed once all sound effects are loaded
     */
    exports.initAudio = function (callback) {
        var s1, s2;
        s1 = resources.getSoundEffect(config.getSetting(config.GENERAL_SETTINGS.BUTTON_SELECT_SOUND).name);
        s2 = resources.getSoundEffect(config.getSetting(config.GENERAL_SETTINGS.BUTTON_CLICK_SOUND).name);
        audio.initMusic(config.getSetting(config.GENERAL_SETTINGS.MENU_MUSIC), exports.MENU_THEME, true);
        if ((s1 && !s1.isLoaded() && !s1.hasError()) || (s2 && !s2.isLoaded() && !s2.hasError())) {
            resources.executeWhenReady(function () {
                _buttonSelectSound = s1 && s1.createSoundClip(
                        resources.SoundCategory.UI,
                        config.getSetting(config.GENERAL_SETTINGS.BUTTON_SELECT_SOUND).volume);
                _buttonClickSound = s2 && s2.createSoundClip(
                        resources.SoundCategory.UI,
                        config.getSetting(config.GENERAL_SETTINGS.BUTTON_CLICK_SOUND).volume);
            });
        }
        resources.requestResourceLoad();
        if (callback) {
            resources.executeWhenReady(callback);
        }
    };
    /**
     * Plays the button select sound, if it is loaded.
     * @param {Boolean} [enabled=false] If false, does not play the sound
     */
    exports.playButtonSelectSound = function (enabled) {
        if (_buttonSelectSound && enabled) {
            _buttonSelectSound.play();
        }
    };
    /**
     * Plays the button click sound, if it is loaded.
     * @param {Boolean} [enabled=false] If false, does not play the sound
     */
    exports.playButtonClickSound = function (enabled) {
        if (_buttonClickSound && enabled) {
            _buttonClickSound.play();
        }
    };
    /**
     * Sets up a dialog screen using the passed data and opens it as a superimposed screen
     * @param {DialogScreen~Data} dialogData
     */
    exports.openDialog = function (dialogData) {
        game.getScreen(exports.DIALOG_SCREEN_NAME).setup(dialogData);
        game.setScreen(exports.DIALOG_SCREEN_NAME, true, exports.SUPERIMPOSE_BACKGROUND_COLOR);
    };
    /**
     * Returns the HTML code for insterting the passed text as a sub paragraph.
     * @param {String} text
     * @returns {String}
     */
    exports.getSubParagraph = function (text) {
        return '<p class="sub fadedText">' + text + "</p>";
    };
    /**
     * Call on the screen that has a fullscreen button to set up its event handlers
     */
    exports.setupFullscreenButton = function () {
        if (game.usesElectron()) {
            this.getElement(FULLSCREEN_BUTTON_ID).hidden = true;
        } else {
            this.getElement(FULLSCREEN_BUTTON_ID).onclick = _toggleFullscreen;
        }
    };
    // ------------------------------------------------------------------------------
    // Derived constants
    /**
     * Contains event handlers to play the button click and select sounds for elements with the class "button". Can be used for all screens
     * that contain buttons (but needs to be complemented with additional event handlers if those are needed)
     * @type Object.<String, Object.<String, Function>>
     */
    exports.BUTTON_EVENT_HANDLERS = {
        "button": {
            mouseenter: function () {
                exports.playButtonSelectSound(!this.classList.contains(components.DISABLED_CLASS_NAME));
            },
            mouseup: function () {
                exports.playButtonClickSound(!this.classList.contains(components.DISABLED_CLASS_NAME));
            }
        }
    };
    /**
     * Contains event handlers for MenuScreen screens to play the button select and click sounds for the menu option buttons
     * and to set up the fullscreen toggling button
     * @type Object.<String, Function>
     */
    exports.MENU_EVENT_HANDLERS = {
        show: exports.setupFullscreenButton,
        optionselect: exports.playButtonSelectSound,
        optionclick: exports.playButtonClickSound
    };
    /**
     * A style descriptor containing the CSS class names needed to create a MenuComponent
     * @type MenuComponent~Style
     */
    exports.MENU_STYLE = {
        menuClassName: exports.MENU_CLASS_NAME,
        buttonContainerClassName: exports.MENU_BUTTON_CONTAINER_CLASS_NAME,
        selectedButtonClassName: components.SELECTED_CLASS_NAME,
        disabledClassName: components.DISABLED_CLASS_NAME
    };
    // ------------------------------------------------------------------------------
    // Public interface of the module
    return exports;
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Implementations of the various classes that represent all the different types of equipment to be added to spacecrafts
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Element, Float32Array, performance */

/**
 * @param utils Used for solving quadratic equations
 * @param vec Vector operations are needed for several logic functions
 * @param mat Matrices are widely used for 3D simulation
 * @param application Used for file loading and logging functionality
 * @param managedGL Used for accessing shader variable types
 * @param physics Physics simulation is done using this module
 * @param resources Used to access the loaded media (graphics and sound) resources
 * @param pools Used to access the common pools for particles and projectiles
 * @param renderableObjects Used for creating visual models for game objects
 * @param lights Used for creating light sources for game objects
 * @param sceneGraph Creating and managing the scene graph for visual simulation is done using this module
 * @param graphics Used to access graphics settings
 * @param audio Used to access constants
 * @param config Used to access game settings/configuration
 * @param classes Used to load and access the classes of Interstellar Armada
 * @param SpacecraftEvents Used to call spacecraft events handlers for events triggered by equipment
 * @param constants Used to access the light priorities
 * @param explosion Used to create explosion for e.g. hits
 */
define('armada/logic/equipment',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/managed-gl",
    "modules/physics",
    "modules/media-resources",
    "modules/pools",
    "modules/scene/renderable-objects",
    "modules/scene/lights",
    "modules/scene/scene-graph",
    "armada/graphics",
    "armada/audio",
    "armada/logic/classes",
    "armada/logic/SpacecraftEvents",
    "armada/configuration",
    "armada/logic/constants",
    "armada/logic/explosion",
    "utils/polyfill"
], function (
        utils, vec, mat,
        application, managedGL, physics, resources, pools,
        renderableObjects, lights, sceneGraph,
        graphics, audio, classes, SpacecraftEvents, config,
        constants, explosion) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // enums
            /**
             * @enum {String}
             * The available flight modes.
             */
            FlightMode = {
                /**
                 * The pilot can freely control all thrusters
                 */
                FREE: "free",
                /**
                 * The maneuvering computer automatically adds thrust to compensate for drift and keep the set speed
                 */
                COMBAT: "combat",
                /**
                 * Turning faster than it would be possible to compensate for drift is not allowed by the maneuvering computer 
                 */
                CRUISE: "cruise"
            },
            /**
             * @enum {Number}
             * When aiming (rotating), weapons determine in which of these states they are within the aiming process. It is used when 
             * deciding whether to fire or not.
             * @type Object
             */
            WeaponAimStatus = {
                /**
                 * The weapon cannot be rotated and thus cannot be aimed at targets.
                 */
                FIXED: 0,
                /**
                 * The weapon can be rotated, but it currently does not have a target to aim for (and is rotating back to the default position)
                 */
                NO_TARGET: 1,
                /**
                 * The weapon is currently trying to aim at a target, but the target lies out of the region accessible based on the restrictions
                 * of the weapon's rotators.
                 */
                AIMING_OUT_OF_REACH: 2,
                /**
                 * The weapon is in the process of aiming at a target (rotating).
                 */
                AIMING: 3,
                /**
                 * The weapon is currently aimed at the direction towards the target, but the target is out of its range.
                 */
                AIMED_OUT_OF_RANGE: 4,
                /**
                 * The weapon is currently aimed at the direction towards the target, and the target is within its range (ready to fire).
                 */
                AIMED_IN_RANGE: 5
            },
            /**
             * @enum {String}
             * The valid thruster use identifiers.
             * @type Object
             */
            ThrusterUse = {
                FORWARD: "forward",
                REVERSE: "reverse",
                STRAFE_LEFT: "strafeLeft",
                STRAFE_RIGHT: "strafeRight",
                RAISE: "raise",
                LOWER: "lower",
                YAW_LEFT: "yawLeft",
                YAW_RIGHT: "yawRight",
                PITCH_UP: "pitchUp",
                PITCH_DOWN: "pitchDown",
                ROLL_LEFT: "rollLeft",
                ROLL_RIGHT: "rollRight"
            },
            // ------------------------------------------------------------------------------
            // constants
            /**
             * When adding the resources of a projectile (class) to a scene, this prefix is used in the ID to avoid adding the same one multiple
             * times
             * @type String
             */
            PROJECTILE_RESOURCE_ID_PREFIX = "projectile/",
            /**
             * When adding the resources of a missile (class) to a scene, this prefix is used in the ID to avoid adding the same one multiple
             * times
             * @type String
             */
            MISSILE_RESOURCE_ID_PREFIX = "missile/",
            /**
             * When adding the resources of a weapon (class) to a scene, this prefix is used in the ID to avoid adding the same one multiple
             * times
             * @type String
             */
            WEAPON_RESOURCE_ID_PREFIX = "weapon/",
            /**
             * When adding the resources of a missile launcher to a scene, this prefix is used in the ID to avoid adding the same one multiple
             * times
             * @type String
             */
            MISSILE_LAUNCHER_RESOURCE_ID_PREFIX = "missileLauncher/",
            /**
             * The number of discrete volume levels to which the thruster sounds can be set according to the rate at which the thrusters
             * are firing (so that the sound source is not ramping the volume all the time as the thruster fire rate changes)
             * @type Number
             */
            THRUSTER_SOUND_VOLUME_GRADES = 3,
            /**
             * The duration while the thruster sound effects ramp to a new volume if needed as the firing rate of the thrusters change.
             * In seconds.
             * @type Number
             */
            THRUSTER_SOUND_VOLUME_RAMP_DURATION = 0.020,
            /**
             * When mapping potential targets to numerical values for ordering, the bearing angle of the target will be multiplied by this
             * factor
             * @type Number
             */
            TARGET_MAPPING_ANGLE_FACTOR = 200,
            /**
             * When mapping potential targets to numerical values for ordering, the final value will be multiplied by this factor, if the
             * targeting spacecraft has a spacecraft type effective against the target
             * @type Number
             */
            TARGET_MAPPING_GOOD_AGAINST_FACTOR = 0.5,
            /**
             * When mapping potential targets to numerical values for ordering, the final value will be multiplied by this factor, if the
             * targeting spacecraft has a spacecraft type that is not effective against the target
             * @type Number
             */
            TARGET_MAPPING_BAD_AGAINST_FACTOR = 2.0,
            /**
             * Missiles will stop turning towards the specified direction when reaching this angle (in radians).
             * (note that they will activate their main thruster to accelerate with a higher threshold defined
             * for the specific missile class)
             * @type Number
             */
            MISSILE_TURN_THRESHOLD_ANGLE = Math.radians(0.05),
            /**
             * The factor to apply when converting angular velocity (turning) matrix angles to rad / s.
             * @type Number
             */
            ANGULAR_VELOCITY_CONVERSION_FACTOR = 1000 / physics.ANGULAR_VELOCITY_MATRIX_DURATION,
            /**
             * Missiles will use their maneuvering thrusters for maximum this long bursts to spin
             * them up for the proper rotation towards the desired orientation, in seconds
             * @type Number
             */
            MISSILE_TURN_ACCELERATION_DURATION_S = 0.2,
            /**
             * Cached value of the reciprocal of the missile turn acceleration duration (converted to
             * 1 / ms) for faster missile turn calculations
             * @type Number
             */
            MISSILE_TURN_INTENSITY_BASE_FACTOR = 1000 / MISSILE_TURN_ACCELERATION_DURATION_S,
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * Cached value of the configuration setting whether self-fire (a spacecraft hitting itself with its own projectiles) is enabled.
             * @type Boolean
             */
            _isSelfFireEnabled = false,
            /**
             * Cached value of the setting for the current difficulty whether the player ship can damage itself
             * @type Boolean
             */
            _isPlayerSelfDamageEnabled = false,
            /**
             * Cached value of the setting for the current difficulty whether the player ship can be damaged by friendly fire
             * @type Boolean
             */
            _isPlayerFriendlyFireDamageEnabled = false,
            /**
             * Cached value of the setting for the current difficulty of how big of an offset should be applied for hitboxes when the player ship is shooting hostiles
             * @type Number
             */
            _hitboxOffset = 0,
            /**
             * Cached value of the configuration setting of how long does a momentary action (e.g. firing a projectile) take in terms of 
             * physics simulation, in milliseconds.
             * @type Number
             */
            _momentDuration = 0,
            /**
             * Cached value of the configuration setting of minimum number of particles that should trigger their instanced rendering.
             * @type Number
             */
            _minimumParticleCountForInstancing = 0,
            /**
             * Cached value of the configuration setting of minimum number of projectiles that should trigger their instanced rendering.
             * @type Number
             */
            _minimumProjectileCountForInstancing = 0,
            /**
             * Cached value of the configuration setting of minimum number of trail segments that should trigger their instanced rendering.
             * @type Number
             */
            _minimumTrailSegmentCountForInstancing = 0,
            /**
             * Cached value of the configuration setting for maximum combat forward speed factor.
             * @type Number
             */
            _maxCombatForwardSpeedFactor,
            /**
             * Cached value of the configuration setting for maximum combat reverse speed factor.
             * @type Number
             */
            _maxCombatReverseSpeedFactor,
            /**
             * Cached value of the configuration setting for maximum cruise forward speed factor.
             * @type Number
             */
            _maxCruiseForwardSpeedFactor,
            /**
             * Cached value of the configuration setting for maximum cruise reverse speed factor.
             * @type Number
             */
            _maxCruiseReverseSpeedFactor,
            /**
             * Cached value of the configuration setting for toggling hitbox visibility based on for which objects are hitchecks calculated.
             * @type Boolean
             */
            _showHitboxesForHitchecks,
            /**
             * Cached value of the configuration setting of the name of the uniform array storing the luminosity factors for models.
             * @type String
             */
            _luminosityFactorsArrayName = null,
            /**
             * Cached value of the configuration setting of the name of the uniform array storing the group transforms for models.
             * @type String
             */
            _groupTransformsArrayName = null,
            /**
             * Stores the uniform parameter array definitions (what arrays are there and what are their types in
             * name: type format) to use when creating visual models for equipment
             * @type Object
             */
            _parameterArrays = null,
            /**
             * A cached value of whether dynamic lights are turned on / available
             * @type Boolean
             */
            _dynamicLights = false,
            /**
             * Cached value of the configuration setting of the same name (see configuration.json)
             * @type Number
             */
            _fireSoundStackingTimeThreshold,
            /**
             * Cached value of the configuration setting of the same name (see configuration.json)
             * @type Number
             */
            _fireSoundStackingVolumeFactor,
            /**
             * A pool containing dynamic particles (such as particles for muzzle flashes and explosions) for reuse, so that creation of
             * new particle objects can be decreased for optimization.
             * @type Pool
             */
            _particlePool,
            /**
             * A pool containing projectiles for reuse, so that creation of new projectile objects can be decreased for optimization.
             * @type Pool
             */
            _projectilePool,
            /**
             * A pool containing missiles for reuse, so that creation of new missile objects can be decreased for optimization.
             * @type Pool
             */
            _missilePool,
            /**
             * A pool containing trail segments for reuse, so that creation of objects while creating trails can be decreased for optimization.
             * @type Pool
             */
            _trailSegmentPool;
    Object.freeze(FlightMode);
    Object.freeze(WeaponAimStatus);
    Object.freeze(ThrusterUse);
    // #########################################################################
    // public functions
    /**
     * Needs to be executed whenever the settings in the graphics module change
     */
    function handleGraphicsSettingsChanged() {
        _parameterArrays = {};
        // setting up parameter array declarations (name: type)
        _parameterArrays[_groupTransformsArrayName] = managedGL.ShaderVariableType.MAT4;
        if (graphics.areLuminosityTexturesAvailable()) {
            _parameterArrays[_luminosityFactorsArrayName] = managedGL.ShaderVariableType.FLOAT;
        }
        _dynamicLights = graphics.areDynamicLightsAvailable() && (graphics.getMaxPointLights() > 0);
    }
    /**
     * Needs to be called when the difficulty level is set / changed (i.e. when a mission is started)
     * @param {DifficultyLevel} difficulty
     */
    function handleDifficultySet(difficulty) {
        _isPlayerSelfDamageEnabled = difficulty.getPlayerSelfDamage();
        _isPlayerFriendlyFireDamageEnabled = difficulty.getPlayerFriendlyFireDamage();
        _hitboxOffset = difficulty.getHitboxOffset();
    }
    // ------------------------------------------------------------------------------
    // private functions
    /**
     * Adds to the thruster burn level corresponding to a specific use command
     * @param {Object} use The object storing the burn level and thruster list
     * corresponding to the use command
     * @param {Number} value The amount added to the thruster burn level.
     */
    function _addThrusterBurn(use, value) {
        var i;
        use.burn += value;
        for (i = 0; i < use.thrusters.length; i++) {
            use.thrusters[i].addBurn(value);
        }
    }
    /**
     * Get the offset to be used for hit checks for projectiles (the sides of the hitboxes
     * are offset towards the outside (i.e. the hitbox is enlarged in all directions) by this
     * much, in meters)
     * @param {Spacecraft} hitObject The spacecraft getting hit
     * @param {Boolean} pilotedToHostile Whether this is for a projectile fired by the player ship hit checking a hostile
     * @returns {Number}
     */
    function _getDefaultOffset(hitObject, pilotedToHostile) {
        return pilotedToHostile ? _hitboxOffset : 0;
    }
    /**
     * @callback HitCallback
     * @param {Spacecraft} hitObject 
     * @param {PhysicalObject} physicalHitObject 
     * @param {Number[4]} hitPositionVectorInObjectSpace 
     * @param {Number[4]} hitPositionVectorInWorldSpace 
     * @param {Number[3]} relativeHitPositionVectorInWorldSpace
     * @param {Number[3]} relativeVelocityDirectionInObjectSpace
     * @param {Number[3]} relativeVelocityDirectionInWorldSpace
     * @param {Number} relativeVelocity
     * @param {Number} offset
     */
    /**
     * The common code to use for both projectile and missile hitchecks.
     * @param {PhysicalObject} object The physical model of the object (i.e. projectile or missile) that can hit the others
     * @param {Octree} hitObjectOctree The octree containing the objects that our projectile/missile can hit
     * @param {Number} hitCheckDT The elapsed time to consider for the hit check (since last hitcheck, in ms)
     * @param {Spacecraft} origin The spacecraft that fired our projectile / missile (for self hit checks)
     * @param {Spacecraft} [pilotedCraft] The spacecraft the player pilots in the current mission
     * @param {Function} offsetCallback The function to return the offset to be used for the hitchecks (modifying
     * the hitbox sizes so that e.g. missiles can already hit the object from farther away)
     * @param {HitCallback} hitCallback The function to call if an object is hit, passing the parameters of the hit to it
     */
    function _checkHit(object, hitObjectOctree, hitCheckDT, origin, pilotedCraft, offsetCallback, hitCallback) {
        var i, hitObjects, isHostile, isPiloted,
                positionVectorInWorldSpace, relativeVelocityDirectionInObjectSpace, velocityVectorInWorldSpace,
                relativeVelocity, relativeVelocityDirectionInWorldSpace,
                physicalHitObject, hitPositionVectorInObjectSpace, hitPositionVectorInWorldSpace, relativeHitPositionVectorInWorldSpace, offset;
        positionVectorInWorldSpace = mat.translationVector3(object.getPositionMatrix());
        velocityVectorInWorldSpace = mat.translationVector3(object.getVelocityMatrix());
        hitObjects = hitObjectOctree.getObjects(
                Math.min(positionVectorInWorldSpace[0], positionVectorInWorldSpace[0] - velocityVectorInWorldSpace[0] * hitCheckDT * 0.001),
                Math.max(positionVectorInWorldSpace[0], positionVectorInWorldSpace[0] - velocityVectorInWorldSpace[0] * hitCheckDT * 0.001),
                Math.min(positionVectorInWorldSpace[1], positionVectorInWorldSpace[1] - velocityVectorInWorldSpace[1] * hitCheckDT * 0.001),
                Math.max(positionVectorInWorldSpace[1], positionVectorInWorldSpace[1] - velocityVectorInWorldSpace[1] * hitCheckDT * 0.001),
                Math.min(positionVectorInWorldSpace[2], positionVectorInWorldSpace[2] - velocityVectorInWorldSpace[2] * hitCheckDT * 0.001),
                Math.max(positionVectorInWorldSpace[2], positionVectorInWorldSpace[2] - velocityVectorInWorldSpace[2] * hitCheckDT * 0.001));
        if (_showHitboxesForHitchecks) {
            for (i = 0; i < hitObjects.length; i++) {
                hitObjects[i].showHitbox();
            }
        }
        isHostile = !pilotedCraft || pilotedCraft.isHostile(origin);
        isPiloted = (origin === pilotedCraft);
        for (i = 0; i < hitObjects.length; i++) {
            physicalHitObject = hitObjects[i].getPhysicalModel();
            if (physicalHitObject && (
                    ((hitObjects[i] === origin) && _isSelfFireEnabled && (_isPlayerSelfDamageEnabled || !isPiloted)) ||
                    ((hitObjects[i] !== origin) && (_isPlayerFriendlyFireDamageEnabled || (hitObjects[i] !== pilotedCraft) || isHostile)))) {
                offset = offsetCallback(hitObjects[i], isPiloted && pilotedCraft.isHostile(hitObjects[i]));
                hitPositionVectorInObjectSpace = physicalHitObject.checkHit(positionVectorInWorldSpace, velocityVectorInWorldSpace, hitCheckDT, offset);
                if (hitPositionVectorInObjectSpace) {
                    relativeVelocityDirectionInWorldSpace = vec.diffVec3Mat4(velocityVectorInWorldSpace, physicalHitObject.getVelocityMatrix());
                    relativeVelocity = vec.extractLength3(relativeVelocityDirectionInWorldSpace);
                    relativeVelocityDirectionInObjectSpace = vec.prodVec3Mat4Aux(relativeVelocityDirectionInWorldSpace, mat.inverseOfRotation4Aux(hitObjects[i].getVisualModel().getOrientationMatrix()));
                    hitPositionVectorInWorldSpace = vec.prodVec4Mat4Aux(hitPositionVectorInObjectSpace, hitObjects[i].getVisualModel().getModelMatrix());
                    relativeHitPositionVectorInWorldSpace = vec.diffVec3Mat4Aux(hitPositionVectorInWorldSpace, physicalHitObject.getPositionMatrix());
                    hitCallback(hitObjects[i], physicalHitObject, hitPositionVectorInObjectSpace, hitPositionVectorInWorldSpace, relativeHitPositionVectorInWorldSpace, relativeVelocityDirectionInObjectSpace, relativeVelocityDirectionInWorldSpace, relativeVelocity, offset);
                    return;
                }
            }
        }
    }
    // ##############################################################################
    /**
     * @class Represents a projectile fired from a weapon.
     * @param {ProjectileClass} projectileClass The class of the projectile defining its general properties.
     * @param {Float32Array} [positionMatrix] The transformation matrix describing the initial position of the projectile.
     * @param {Float32Array} [orientationMatrix] The transformation matrix describing the initial oriantation of the projectile.
     * @param {Spacecraft} [spacecraft] The spacecraft which fired the projectile.
     * @param {Number} [muzzleVelocity] The starting velocity of the projectile, in its +Y direction, in m/s
     */
    function Projectile(projectileClass, positionMatrix, orientationMatrix, spacecraft, muzzleVelocity) {
        /**
         * The class storing the general characteristics of this projectile.
         * @type ProjectileClass
         */
        this._class = null;
        /**
         * The renderable node that represents this projectile in a scene.
         * @type RenderableObject
         */
        this._visualModel = null;
        /**
         * The object that represents and simulates the physical behaviour of
         * this projectile.
         * @type PhysicalObject
         */
        this._physicalModel = new physics.PhysicalObject();
        /**
         * The amount of time this projectile has left to "live", in milliseconds.
         * @type Number
         */
        this._timeLeft = 0;
        /**
         * The spacecraft that originally fired this projectile. It will be 
         * excluded from hit check so that a projectile cannot hit the same craft
         * it was fired from.
         * @type Spacecraft
         */
        this._origin = null;
        /**
         * A reference to the light source associated with this projectile.
         * @type PointLightSource
         */
        this._lightSource = null;
        /**
         * The callback function to use when the projectile hits a spacecraft, bound to this instance
         * @type HitCallback
         */
        this._hitCallback = Projectile.prototype._hitCallback.bind(this);
        if (projectileClass) {
            this.init(projectileClass, positionMatrix, orientationMatrix, spacecraft, muzzleVelocity);
        }
    }
    /**
     * @param {ProjectileClass} projectileClass The class of the projectile defining its general properties.
     * @param {Float32Array} [positionMatrix] The transformation matrix describing the initial position of the projectile.
     * @param {Float32Array} [orientationMatrix] The transformation matrix describing the initial oriantation of the projectile.
     * @param {Spacecraft} [spacecraft] The spacecraft which fired the projectile.
     * @param {Number} [muzzleVelocity] The starting velocity of the projectile, in its +Y direction, in m/s
     */
    Projectile.prototype.init = function (projectileClass, positionMatrix, orientationMatrix, spacecraft, muzzleVelocity) {
        var velocityMatrix = mat.identity4Aux();
        if (spacecraft) {
            mat.copyTranslation4(velocityMatrix, spacecraft.getVelocityMatrix());
        }
        if (muzzleVelocity) {
            velocityMatrix[12] += orientationMatrix[4] * muzzleVelocity;
            velocityMatrix[13] += orientationMatrix[5] * muzzleVelocity;
            velocityMatrix[14] += orientationMatrix[6] * muzzleVelocity;
        }
        this._class = projectileClass;
        this._physicalModel.init(
                projectileClass.getMass(),
                positionMatrix || mat.IDENTITY4,
                orientationMatrix || mat.IDENTITY4,
                mat.scaling4Aux(projectileClass.getSize()),
                velocityMatrix,
                utils.EMPTY_ARRAY,
                true,
                true,
                projectileClass.getDragFactor());
        this._timeLeft = projectileClass.getDuration();
        this._origin = spacecraft;
    };
    /**
     * Returns whether this projectile object can be reused to represent a new
     * projectile.
     * @returns {Boolean}
     */
    Projectile.prototype.canBeReused = function () {
        return (this._timeLeft <= 0);
    };
    /**
     * Creates a new billboard to be used as the visual model for this projectile. Safe to be called on Projectile objects that have not
     * been set up yet, so that the visual model objects can be created in advance.
     */
    Projectile.prototype.createVisualModel = function () {
        this._visualModel = new renderableObjects.Billboard();
    };
    /**
     * Sets up the renderable object that can be used to represent this projectile in a visual scene.
     * @param {Boolean} [wireframe=false] Whether to set up the model in wireframe mode
     */
    Projectile.prototype._initVisualModel = function (wireframe) {
        if (!this._visualModel) {
            this.createVisualModel();
        }
        this._visualModel.init(
                this._class.getModel(),
                this._class.getShader(),
                this._class.getTexturesOfTypes(this._class.getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                this._class.getSize(),
                wireframe,
                this._physicalModel.getPositionMatrix(),
                this._physicalModel.getOrientationMatrix(),
                this._class.getInstancedShader());
    };
    /**
     * Returns the visual model of the projectile.
     * @returns {Billboard}
     */
    Projectile.prototype.getVisualModel = function () {
        return this._visualModel;
    };
    /**
     * Sets the associated light source for this projectile, so its intensity can be updated as the projectile dissipates (fades)
     * @param {PointLightSource} lightSource
     */
    Projectile.prototype.setLightSource = function (lightSource) {
        this._lightSource = lightSource;
    };
    /**
     * Adds the projectile to a scene immediately, assuming its resources have already been loaded.
     * @param {Scene} scene The scene to which to add the renderable object presenting the projectile.
     * @param {Boolean} [wireframe=false] Whether to add the model for wireframe rendering
     * @param {Function} [callback] If given, this function will be executed right after the projectile is addded to the scene, with the 
     * visual model of the projectile passed to it as its only argument
     */
    Projectile.prototype.addToSceneNow = function (scene, wireframe, callback) {
        this._initVisualModel(wireframe);
        scene.addObject(this._visualModel, false, _minimumProjectileCountForInstancing);
        if (callback) {
            callback(this._visualModel);
        }
    };
    /**
     * Adds a renderable node representing this projectile to the passed scene.
     * @param {Scene} scene The scene to which to add the renderable object presenting the projectile.
     * @param {Boolean} [wireframe=false] Whether to add the model for wireframe rendering
     * @param {Function} [callback] If given, this function will be executed right after the projectile is addded to the scene, with the 
     * visual model of the projectile passed to it as its only argument
     */
    Projectile.prototype.addToScene = function (scene, wireframe, callback) {
        resources.executeWhenReady(this.addToSceneNow.bind(this, scene, wireframe, callback));
    };
    /**
     * Adds the resources required to render this projectile to the passed scene,
     * so they get loaded at the next resource load as well as added to any context
     * the scene is added to.
     * @param {Scene} scene
     * @param {Boolean} [wireframe=false] Whether to add the model resource for wireframe rendering
     */
    Projectile.prototype.addResourcesToScene = function (scene, wireframe) {
        var exp, resourceID = PROJECTILE_RESOURCE_ID_PREFIX + this._class.getName();
        this._class.acquireResources({projectileOnly: false, sound: true});
        resources.executeWhenReady(function () {
            if (!scene.hasResourcesOfObject(resourceID)) {
                this._initVisualModel(wireframe);
                scene.addResourcesOfObject(this._visualModel, resourceID);
                exp = new explosion.Explosion(this._class.getExplosionClass(), mat.IDENTITY4, mat.IDENTITY4, [0, 0, 0], true);
                exp.addResourcesToScene(scene);
                exp = new explosion.Explosion(this._class.getShieldExplosionClass(), mat.IDENTITY4, mat.IDENTITY4, [0, 0, 0], true);
                exp.addResourcesToScene(scene);
            }
        }.bind(this));
    };
    /**
     * The function to call when the projectile hits a spacecraft
     * @param {Spacecraft} hitObject 
     * @param {PhysicalObject} physicalHitObject 
     * @param {Number[4]} hitPositionVectorInObjectSpace 
     * @param {Number[4]} hitPositionVectorInWorldSpace 
     * @param {Number[3]} relativeHitPositionVectorInWorldSpace
     * @param {Number[3]} relativeVelocityDirectionInObjectSpace
     * @param {Number[3]} relativeVelocityDirectionInWorldSpace
     * @param {Number} relativeVelocity
     * @param {Number} offset
     */
    Projectile.prototype._hitCallback = function (hitObject, physicalHitObject, hitPositionVectorInObjectSpace, hitPositionVectorInWorldSpace, relativeHitPositionVectorInWorldSpace, relativeVelocityDirectionInObjectSpace, relativeVelocityDirectionInWorldSpace, relativeVelocity, offset) {
        var exp, power;
        power = Math.min(this._timeLeft / this._class.getDissipationDuration(), 1);
        physicalHitObject.applyForceAndTorque(relativeHitPositionVectorInWorldSpace, relativeVelocityDirectionInWorldSpace, power * relativeVelocity * this._physicalModel.getMass() * 1000 / _momentDuration, _momentDuration);
        exp = explosion.getExplosion();
        exp.init(((hitObject.getShieldIntegrity() > 0) ? this._class.getShieldExplosionClass() : this._class.getExplosionClass()), mat.translation4vAux(hitPositionVectorInWorldSpace), mat.IDENTITY4, vec.scaled3(relativeVelocityDirectionInWorldSpace, -1), true, true, physicalHitObject.getVelocityMatrix());
        exp.addToSceneNow(this._visualModel.getNode().getScene().getRootNode(), hitObject.getSoundSource(), true);
        hitObject.damage(power * this._class.getDamage(), hitPositionVectorInObjectSpace, vec.scaled3(relativeVelocityDirectionInObjectSpace, -1), this._origin, false, offset);
        this._timeLeft = 0;
        this._visualModel.markAsReusable(true);
    };
    /**
     * Simulates the movement of the projectile and checks if it hit any objects.
     * @param {Number} dt The passed time since the last simulation in milliseconds.
     * @param {Octree} hitObjectOctree The root node of the octree that is used to spatially partition the spacecrafts this projectile can
     * hit.
     * @param {Spacecraft} [pilotedCraft] The spacecraft the player pilots in the current mission
     */
    Projectile.prototype.simulate = function (dt, hitObjectOctree, pilotedCraft) {
        var hitCheckDT, power;
        if (this.canBeReused()) {
            return;
        }
        // avoid hit checking right after the projectile is fired, as it could hit the firing ship
        hitCheckDT = Math.min(dt, this._class.getDuration() - this._timeLeft);
        this._timeLeft -= dt;
        if (this._timeLeft > 0) {
            this._physicalModel.simulate(dt);
            this._visualModel.setPositionMatrix(this._physicalModel.getPositionMatrix());
            if (this._timeLeft < this._class.getDissipationDuration()) {
                power = this._timeLeft / this._class.getDissipationDuration();
                this._visualModel.setDirectionW(power);
                if (this._lightSource) {
                    this._lightSource.setObjectIntensity(power * this._class.getLightIntensity());
                }
            }
            _checkHit(this._physicalModel, hitObjectOctree, hitCheckDT, this._origin, pilotedCraft, _getDefaultOffset, this._hitCallback);
        } else {
            this._visualModel.markAsReusable(true);
        }
    };
    /**
     * Removes the renferences to the renderable and physics objects of the
     * projectile and marks it for removel / reuse.
     */
    Projectile.prototype.destroy = function () {
        this._timeLeft = 0;
        this._class = null;
        this._origin = null;
        if (this._visualModel && this._visualModel.getNode()) {
            this._visualModel.getNode().markAsReusable(true);
        }
        this._visualModel = null;
        this._physicalModel = null;
    };
    // ##############################################################################
    /**
     * @class Creates the trail that the missile leaves behind as it moves.
     * @param {TrailDescriptor} descriptor The descriptor storing the trail's
     * general properties.
     */
    function TrailEmitter(descriptor) {
        /**
         * The descriptor storing the general characteristics of this trail.
         * @type TrailDescriptor
         */
        this._descriptor = descriptor;
        /**
         * The world position of where this trail starts (first point emitted)
         * @type Number[3]
         */
        this._firstPoint = [0, 0, 0];
        /**
         * The last point where the trail was emitted (world coordinates)
         * @type Number[3]
         */
        this._lastPoint = [0, 0, 0];
        /**
         * Whether there is a trail currently being emitted
         * @type Boolean
         */
        this._emitting = false;
        /**
         * The last trail segment that was emitted
         * @type TrailSegment
         */
        this._lastSegment = null;
        /**
         * The renderable object that houses the current active section of the
         * trail (has its segments as its children)
         * @type Trail
         */
        this._visualModel = null;
        /**
         * The last scene where a trail was/is emitted by this emitter
         * @type Scene
         */
        this._lastScene = null;
    }
    /**
     * @returns {TrailDescriptor}
     */
    TrailEmitter.prototype.getDescriptor = function () {
        return this._descriptor;
    };
    /**
     * Whether there is a currently active / growing section of this trail to
     * which new points / segments can be added.
     * @returns {Boolean}
     */
    TrailEmitter.prototype.isEmitting = function () {
        return this._emitting;
    };
    /**
     * Call this before loading resources to make sure the trail can be rendered
     * onto this scene.
     * @param {Scene} scene
     */
    TrailEmitter.prototype.addResourcesToScene = function (scene) {
        this._descriptor.acquireResources();
        resources.executeWhenReady(function () {
            scene.addResourcesOfObject(new renderableObjects.TrailSegment(
                    this._descriptor.getModel(),
                    this._descriptor.getShader(),
                    this._descriptor.getTexturesOfTypes(this._descriptor.getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                    this._descriptor.getSize(),
                    false,
                    vec.NULL3,
                    vec.NULL3,
                    vec.NULL3,
                    vec.NULL3,
                    vec.NULL4,
                    0, 0, 0,
                    this._descriptor.getInstancedShader()));
        }.bind(this));
    };
    /**
     * Start a new active section for the trail (abandoning the current one if
     * there was already one), with a new parent node
     * @param {Scene} scene
     * @param {Number[3]} point The world coordinates of where this trail starts.
     * When calling addPoint() the first time after this call, the first segment
     * will connect this point with the one passed there
     */
    TrailEmitter.prototype.startNew = function (scene, point) {
        vec.setVector3(this._firstPoint, point);
        vec.setVector3(this._lastPoint, point);
        this._emitting = true;
        this._lastSegment = null;
        this._visualModel = new renderableObjects.Trail(this._descriptor.getSize());
        scene.addNode(new sceneGraph.RenderableNode(this._visualModel, false, true));
        if (this._lastScene !== scene) {
            scene.addObjectToMove(this);
            this._lastScene = scene;
        }
    };
    /**
     * Adds a new 3D point to the currently emitted section of the trail (there
     * needs to be one when calling this method), growing the section with a
     * new segment if needed.
     * @param {Number[3]} point The point to add.
     * @param {Number} dt The time elapsed since the last simulation step. This
     * is used when growing a new section to its maximum duration, to make sure
     * that process stays consistent across framerates
     */
    TrailEmitter.prototype.addPoint = function (point, dt) {
        var segment, prevTime, direction;
        this._visualModel.setPositionv(point);
        direction = vec.normalize3(vec.diff3(point, this._lastPoint));
        prevTime = this._lastSegment ? this._lastSegment.getEndTimeLeft() : 0;
        segment = _trailSegmentPool.getObject();
        segment.init(
                this._descriptor.getModel(),
                this._descriptor.getShader(),
                this._descriptor.getTexturesOfTypes(this._descriptor.getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                this._descriptor.getSize(),
                false,
                this._lastPoint,
                this._lastSegment ? this._lastSegment.getEndDirection() : direction,
                point,
                direction,
                this._descriptor.getColor(),
                this._descriptor.getDuration(),
                prevTime,
                Math.min(this._descriptor.getDuration(), prevTime + this._descriptor.getGrowthRate() * dt),
                this._descriptor.getInstancedShader());
        this._visualModel.getNode().addSubnode(segment.getNode() || new sceneGraph.RenderableNode(segment, false, false, _minimumTrailSegmentCountForInstancing));
        this._visualModel.setSize(vec.length3(vec.diff3Aux(this._firstPoint, point)));
        vec.setVector3(this._lastPoint, point);
        this._lastSegment = segment;
    };
    /**
     * Call this when the whole scene is moved, to make sure the next trail
     * segment is emitted at the right position
     * @param {Number[3]} v [x,y,z]
     */
    TrailEmitter.prototype.translatev = function (v) {
        vec.add3(this._lastPoint, v);
    };
    /**
     * Finishes the current emitted section fo the trail by removing
     * any references to it. No new points can be added to it after this point,
     * it simply expires through the default animation of the segments.
     */
    TrailEmitter.prototype.detach = function () {
        this._emitting = false;
        this._lastSegment = null;
        this._visualModel = null;
    };
    /**
     * Removes all references to other objects for proper cleanup of memory.
     * Segments already emitted by this emitter are not affected.
     */
    TrailEmitter.prototype.destroy = function () {
        this._descriptor = null;
        this._emitting = false;
        this._firstPoint = null;
        this._lastPoint = null;
        this._lastSegment = null;
        if (this._visualModel) {
            this._visualModel.getNode().markAsReusable(true);
            this._visualModel = null;
        }
    };
    // ##############################################################################
    /**
     * @class Represents a missile launched from a missile launcher.
     * @param {MissileClass} missileClass The class of the missile defining its general properties.
     * @param {Float32Array} [positionMatrix] The transformation matrix describing the initial position of the missile.
     * @param {Float32Array} [orientationMatrix] The transformation matrix describing the initial oriantation of the missile.
     * @param {Spacecraft} [spacecraft] The spacecraft which launched the missile.
     * @param {Number} [muzzleVelocity] The starting velocity of the missile, in its +Y direction, in m/s
     * @param {Spacecraft} [target] 
     */
    function Missile(missileClass, positionMatrix, orientationMatrix, spacecraft, muzzleVelocity, target) {
        /**
         * The class storing the general characteristics of this missile.
         * @type MissileClass
         */
        this._class = null;
        /**
         * The renderable node that represents this missile in a scene.
         * @type RenderableObject
         */
        this._visualModel = null;
        /**
         * Used to emit the trail a launched missile leaves behind when using its engine.
         * @type TrailEmitter
         */
        this._trailEmitter = null;
        /**
         * The object that represents and simulates the physical behaviour of
         * this missile.
         * @type PhysicalObject
         */
        this._physicalModel = new physics.PhysicalObject();
        /**
         * The amount of time this missile has before it explodes (even if not
         * hitting anything), in milliseconds.
         * @type Number
         */
        this._timeLeft = 0;
        /**
         * The spacecraft that originally launched this missile. If self fire is
         * off, it will be excluded from hit check so that a missile cannot hit 
         * the same craft it was launched from.
         * @type Spacecraft
         */
        this._origin = null;
        /**
         * Cached value of the matrix representing the turning the current angular velocity of the object causes over 
         * ANGULAR_VELOCITY_MATRIX_DURATION milliseconds in model space.
         * @type Float32Array
         */
        this._turningMatrix = mat.identity4();
        /**
         * Whether the currently stored turning matrix value is up-to-date.
         * @type Boolean
         */
        this._turningMatrixValid = false;
        /**
         * The target angle in radian between the identity orientation and the
         * relative angular velocity matrix on the yawing (XY) plane. The missile
         * will use the yawing thursters to reach this angle.
         * (representing rad / physics.ANGULAR_VELOCITY_MATRIX_DURATION ms turn)
         * @type Number
         */
        this._yawTarget = 0;
        /**
         * The target angle in radian between the identity orientation and the
         * relative angular velocity matrix on the pitching (YZ) plane. The missile
         * will use the pitching thursters to reach this angle.
         * (representing rad / physics.ANGULAR_VELOCITY_MATRIX_DURATION ms turn)
         * @type Number
         */
        this._pitchTarget = 0;
        /**
         * The maximum angle between vectors of the relative angular acceleration 
         * matrix and the identity axes on the yaw and pitch planes
         * (representing rad / physics.ANGULAR_VELOCITY_MATRIX_DURATION ms turn)
         * This is the general limit based on the missile's class (angular acceleration)
         * I.e. the missile will accelerate it's turning up to this rate and then 
         * decelerate from it when close to the target direction.
         * @type Number
         */
        this._turningLimit = 0;
        /**
         * An array storing direct references to all the thrusters of the missile.
         * @type Thruster[]
         */
        this._thrusters = [];
        /**
         * The burn level and nozzles associated with each thruster use command.
         * @type Object
         */
        this._forward = {burn: 0, thrusters: []};
        this._yawLeft = {burn: 0, thrusters: []};
        this._yawRight = {burn: 0, thrusters: []};
        this._pitchUp = {burn: 0, thrusters: []};
        this._pitchDown = {burn: 0, thrusters: []};
        /**
         * Cached value to enable faster calculation of the needed burn for 
         * specific angular velocity change, based on the missile's parameters.
         * @type Number
         */
        this._burnForAngularVelocityChangeFactor = 0;
        /**
         * Whether the main engine (forward thruster) is currently turned on.
         * (this thruster always operates at 100% burn when turned on)
         * The main thruster gets turned off if the missile is homing and the
         * target gets outside of its course too much, until the course is
         * corrected via the maneuvering thrusters.
         * @type Boolean
         */
        this._mainBurn = false;
        /**
         * Whether the missile has already ignited its engines (after its ignitionTime)
         * Once this is set to true, it remains true for the rest of the missile's lifetime.
         * @type Boolean
         */
        this._started = false;
        /**
         * Whether the missile is currently using its maneuvering thrusters to home in on the target
         * @type Boolean
         */
        this._homing = false;
        /**
         * Whether the missile is currently finishing its homing maneuver (only using maneuvering
         * thrusters to cancel any spin)
         * @type Boolean
         */
        this._stopHoming = false;
        /**
         * The target the missile is aiming for (for homing)
         * @type Spacecraft
         */
        this._target = null;
        /**
         * The estimated (calculated) position where the missile will (can) hit its target
         * (and thus which it should turn towards) based on the target's current
         * relative position and velocity and the acceleration capability of the missile.
         * @type Number[3]
         */
        this._targetHitPosition = [0, 0, 0];
        /**
         * Whether the stored target hit position has been updated for the current frame.
         * @type Boolean
         */
        this._targetHitPositionValid = false;
        /**
         * The light source associated with the missile (representing light from its main
         * thruster, with its intensity set according to whether the thruster is on)
         * @type PointLightSource
         */
        this._lightSource = null;
        /**
         * The sound source used to position the sound effects beloning to this missile in 3D sound (=camera) space
         * @type SoundSource
         */
        this._soundSource = null;
        /**
         * Reusable vector for storing the calculated sound source position
         * @type Number[3]
         */
        this._soundSourcePosition = [0, 0, 0];
        /**
         * The callback function to execute when the missile hits a spacecraft.
         * (bound to this in the constructor so it can be readily passed to _checkHit)
         * @tpye HitCallback
         */
        this._hitCallback = Missile.prototype._hitCallback.bind(this);
        /**
         * The callback to get the offset to be used for hit checks for this missile
         * (the sides of the hitboxes are offset towards the outside (i.e. the hitbox 
         * is enlarged in all directions) by this much, in meters)
         * (bound to this in the constructor so it can be readily passed to _checkHit)
         * @type Function
         */
        this._getHitOffset = Missile.prototype._getHitOffset.bind(this);
        if (missileClass) {
            this.init(missileClass, positionMatrix, orientationMatrix, spacecraft, muzzleVelocity, target);
        }
    }
    /**
     * We reuse the same Missile instance for multiple missiles in a single games, as old missiles are
     * destroyed. This method is called to reinitialize this Missile instance for a new missile.
     * @param {MissileClass} missileClass The class of the missile defining its general properties.
     * @param {Float32Array} [positionMatrix] The transformation matrix describing the initial position of the missile.
     * @param {Float32Array} [orientationMatrix] The transformation matrix describing the initial oriantation of the missile.
     * @param {Spacecraft} [spacecraft] The spacecraft which launched the missile.
     * @param {Number} [muzzleVelocity] The starting velocity of the missile, in its +Y direction, in m/s
     * @param {Spacecraft} [target] 
     */
    Missile.prototype.init = function (missileClass, positionMatrix, orientationMatrix, spacecraft, muzzleVelocity, target) {
        var i, velocityMatrix = mat.identity4Aux();
        if (spacecraft) {
            mat.copyTranslation4(velocityMatrix, spacecraft.getVelocityMatrix());
        }
        if (muzzleVelocity) {
            velocityMatrix[12] += orientationMatrix[4] * muzzleVelocity;
            velocityMatrix[13] += orientationMatrix[5] * muzzleVelocity;
            velocityMatrix[14] += orientationMatrix[6] * muzzleVelocity;
        }
        this._class = missileClass;
        this._physicalModel.init(
                missileClass.getMass(),
                positionMatrix || mat.IDENTITY4,
                orientationMatrix || mat.IDENTITY4,
                mat.scaling4Aux(missileClass.getModelScale()),
                velocityMatrix,
                utils.EMPTY_ARRAY,
                false,
                false,
                missileClass.getDragFactor());
        this._timeLeft = missileClass.getDuration();
        this._timeLeftForIgnition = missileClass.getIgnitionTime();
        this._origin = spacecraft;
        this._turningLimit = missileClass.getAngularAcceleration() * MISSILE_TURN_ACCELERATION_DURATION_S * physics.ANGULAR_VELOCITY_MATRIX_DURATION_S;
        for (i = 0; i < this._thrusters.length; i++) {
            this._thrusters[i].destroy();
        }
        this._thrusters.length = 0;
        this._forward.thrusters.length = 0;
        this._yawLeft.thrusters.length = 0;
        this._yawRight.thrusters.length = 0;
        this._pitchUp.thrusters.length = 0;
        this._pitchDown.thrusters.length = 0;
        this.addThrusters(missileClass.getThrusterSlots());
        this._homing = (missileClass.getHomingMode() !== classes.MissileHomingMode.NONE);
        this._burnForAngularVelocityChangeFactor = this._homing ? (1 / physics.ANGULAR_VELOCITY_MATRIX_DURATION_S * missileClass.getMass() / missileClass.getAngularThrust() * 1000) : 0;
        this._target = target || null;
        this._targetHitPositionValid = false;
        this._yawTorque = null;
        this._pitchTorque = null;
        this._mainBurn = false;
        this._started = false;
        this._stopHoming = false;
        this._startSound = null;
    };
    /**
     * Returns whether this missile object can be reused to represent a new
     * missile.
     * @returns {Boolean}
     */
    Missile.prototype.canBeReused = function () {
        return (this._timeLeft <= 0);
    };
    /**
     * Creates a new ParameterizedMesh to be used as the visual model for this missile. 
     * Safe to be called on Missile objects that have not been set up yet, so 
     * that the visual model objects can be created in advance.
     */
    Missile.prototype.createVisualModel = function () {
        this._visualModel = new renderableObjects.ParameterizedMesh();
    };
    /**
     * Sets up the renderable object that can be used to represent this missile in a visual scene.
     * @param {Boolean} [wireframe=false] Whether to set up the model in wireframe mode
     * @param {Number} [lod] Optional static LOD to use instead of automatic dynamic one
     * @param {String} [shaderName] Optional shader to use for the visual model instead of the one provided by the missile class
     * @param {Boolean} [trail=false] Whether to also initialize the trail for the missile
     */
    Missile.prototype._initVisualModel = function (wireframe, lod, shaderName, trail) {
        var shader = shaderName ? graphics.getManagedShader(shaderName) : this._class.getShader();
        if (!this._visualModel) {
            this.createVisualModel();
        }
        this._visualModel.init(
                this._class.getModel(),
                shader,
                this._class.getTexturesOfTypes(shader.getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                this._physicalModel.getPositionMatrix(),
                this._physicalModel.getOrientationMatrix(),
                this._physicalModel.getScalingMatrix(),
                wireframe,
                lod,
                undefined,
                _parameterArrays);
        // setting the starting values of the parameter arrays
        // setting an identity transformation for all transform groups
        if (this._visualModel.hasParameterArray(_groupTransformsArrayName)) {
            this._visualModel.setParameterArray(_groupTransformsArrayName, graphics.getGroupTransformIdentityArray());
        }
        // setting the default luminosity for all luminosity groups
        if (graphics.areLuminosityTexturesAvailable() && this._visualModel.hasParameterArray(_luminosityFactorsArrayName)) {
            this._visualModel.setParameterArray(_luminosityFactorsArrayName, this._class.getDefaultGroupLuminosityFactors());
        }
        if (trail) {
            this._trailEmitter = new TrailEmitter(this._class.getTrailDescriptor());
        }
    };
    /**
     * Returns the visual model of the missile.
     * @returns {ParameterizedMesh}
     */
    Missile.prototype.getVisualModel = function () {
        return this._visualModel;
    };
    /**
     * Returns the physical model of the missile.
     * @returns {PhysicalObject}
     */
    Missile.prototype.getPhysicalModel = function () {
        return this._physicalModel;
    };
    /**
     * Returns the target the missile is homing in on
     * @returns {Spacecraft}
     */
    Missile.prototype.getTarget = function () {
        return this._target;
    };
    /**
     * Returns the class of the missile
     * @returns {MissileClass}
     */
    Missile.prototype.getClass = function () {
        return this._class;
    };
    /**
     * Adds the missile to a scene immediately, assuming its resources have already been loaded.
     * @param {Scene} scene The scene to which to add the renderable object presenting the missile.
     * @param {Boolean} [wireframe=false] Whether to add the model for wireframe rendering
     * @param {Number} [lod] Optional static LOD to use instead of automatic dynamic one
     * @param {String} [shaderName] Optional shader to use for the visual model instead of the one provided by the missile class
     * @param {Boolean} [trail=false] Whether to add a trail for the missile
     * @param {Function} [callback] If given, this function will be executed right after the missile is addded to the scene, with the 
     * visual model of the missile passed to it as its only argument
     */
    Missile.prototype.addToSceneNow = function (scene, wireframe, lod, shaderName, trail, callback) {
        var i;
        this._initVisualModel(wireframe, lod, shaderName, trail);
        scene.addObject(this._visualModel, true);
        for (i = 0; i < this._thrusters.length; i++) {
            this._thrusters[i].addToScene(this._visualModel.getNode(), true);
        }
        if (_dynamicLights && this._class.getLightColor()) {
            if (!this._lightSource) {
                this._lightSource = new lights.PointLightSource(this._class.getLightColor(), 0, vec.NULL3, [this._visualModel]);
            }
            scene.addPointLightSource(this._lightSource, constants.MISSILE_LIGHT_PRIORITY);
        }
        if (callback) {
            callback(this._visualModel);
        }
    };
    /**
     * Adds a renderable node representing this missile to the passed scene.
     * @param {Scene} scene The scene to which to add the renderable object presenting the missile.
     * @param {Boolean} [wireframe=false] Whether to add the model for wireframe rendering
     * @param {Number} [lod] Optional static LOD to use instead of automatic dynamic one
     * @param {String} [shaderName] Optional shader to use for the visual model instead of the one provided by the missile class
     * @param {Boolean} [trail=false] Whether to add a trail for the missile
     * @param {Function} [callback] If given, this function will be executed right after the missile is addded to the scene, with the 
     * visual model of the missile passed to it as its only argument
     */
    Missile.prototype.addToScene = function (scene, wireframe, lod, shaderName, trail, callback) {
        resources.executeWhenReady(this.addToSceneNow.bind(this, scene, wireframe, lod, shaderName, trail, callback));
    };
    /**
     * Adds the resources required to render this missile to the passed scene,
     * so they get loaded at the next resource load as well as added to any context
     * the scene is added to.
     * @param {Scene} scene
     * @param {Boolean} [wireframe=false] Whether to add the model resource for wireframe rendering
     * @param {Number} [lod] Optional static LOD to use instead of automatic dynamic one
     * @param {String} [shaderName] Optional shader to use for the visual model instead of the one provided by the missile class
     * @param {Boolean} [trail=false] Whether to add the resources for rendering the trail for the missile
     */
    Missile.prototype.addResourcesToScene = function (scene, wireframe, lod, shaderName, trail) {
        var exp, resourceID = MISSILE_RESOURCE_ID_PREFIX + this._class.getName();
        this._class.acquireResources({missileOnly: false, sound: true, trail: trail});
        resources.executeWhenReady(function () {
            if (!scene.hasResourcesOfObject(resourceID)) {
                this._initVisualModel(wireframe, lod, shaderName, trail);
                scene.addResourcesOfObject(this._visualModel, resourceID);
                if (trail) {
                    this._trailEmitter.addResourcesToScene(scene);
                }
                exp = new explosion.Explosion(this._class.getExplosionClass(), mat.IDENTITY4, mat.IDENTITY4, [0, 0, 0], true);
                exp.addResourcesToScene(scene);
                exp = new explosion.Explosion(this._class.getShieldExplosionClass(), mat.IDENTITY4, mat.IDENTITY4, [0, 0, 0], true);
                exp.addResourcesToScene(scene);
            }
        }.bind(this));
    };
    /**
     * Returns the object storing the burn level and thruster list associated
     * with the passed thruster use command
     * @param {String} name
     * @returns {Object}
     */
    Missile.prototype.getThrusterUse = function (name) {
        switch (name) {
            case ThrusterUse.FORWARD:
                return this._forward;
            case ThrusterUse.YAW_LEFT:
                return this._yawLeft;
            case ThrusterUse.YAW_RIGHT:
                return this._yawRight;
            case ThrusterUse.PITCH_UP:
                return this._pitchUp;
            case ThrusterUse.PITCH_DOWN:
                return this._pitchDown;
            default:
                application.showError("Invalid thruster use specified for missile: '" + name + "'!", application.ErrorSeverity.SEVERE);
                return null;
        }
    };
    /**
     * Creates and adds thruster objects to all the thruster slots in the passed
     * array
     * @param {ThrusterSlot[]} slots
     */
    Missile.prototype.addThrusters = function (slots) {
        var i, j, thruster, use;
        for (i = 0; i < slots.length; i++) {
            thruster = new Thruster(this._class.getPropulsionClass(), slots[i]); //eslint-disable-line no-use-before-define
            this._thrusters.push(thruster);
            for (j = 0; j < slots[i].uses.length; j++) {
                use = this.getThrusterUse(slots[i].uses[j]);
                if (use) {
                    use.thrusters.push(thruster);
                }
            }
        }
    };
    /**
     * Returns the 4x4 rotation matrix describing the current rotation of this missile in relative (model) space.
     * @returns {Float32Array}
     */
    Missile.prototype.getTurningMatrix = function () {
        if (!this._turningMatrixValid) {
            mat.setProd3x3SubOf4(this._turningMatrix,
                    mat.prod3x3SubOf4Aux(
                            this._physicalModel.getOrientationMatrix(),
                            this._physicalModel.getAngularVelocityMatrix()),
                    mat.rotation4m4Aux(this._physicalModel.getRotationMatrixInverse()));
            this._turningMatrixValid = true;
        }
        return this._turningMatrix;
    };
    /**
     * Sets the target angular velocity to yaw to the left with the given intensity 
     * multiplied by the turning limit.
     * @param {Number} intensity
     */
    Missile.prototype.yawLeft = function (intensity) {
        this._yawTarget = -intensity * this._turningLimit;
    };
    /**
     * Sets the target angular velocity to yaw to the right with the given intensity 
     * multiplied by the turning limit.
     * @param {Number} intensity
     */
    Missile.prototype.yawRight = function (intensity) {
        this._yawTarget = intensity * this._turningLimit;
    };
    /**
     * Sets the target angular velocity to pitch down with the given intensity 
     * multiplied by the turning limit.
     * @param {Number} intensity
     */
    Missile.prototype.pitchDown = function (intensity) {
        this._pitchTarget = -intensity * this._turningLimit;
    };
    /**
     * Sets the target angular velocity to pitch up with the given intensity 
     * multiplied by the turning limit.
     * @param {Number} intensity
     */
    Missile.prototype.pitchUp = function (intensity) {
        this._pitchTarget = intensity * this._turningLimit;
    };
    /**
     * Resets the all the thruster burn levels to zero.
     */
    Missile.prototype.resetThrusterBurn = function () {
        var i;
        this._forward.burn = 0;
        this._yawLeft.burn = 0;
        this._yawRight.burn = 0;
        this._pitchUp.burn = 0;
        this._pitchDown.burn = 0;
        for (i = 0; i < this._thrusters.length; i++) {
            this._thrusters[i].resetBurn();
        }
    };
    Missile.prototype.addThrusterBurnForward = function (value) {
        _addThrusterBurn(this._forward, value);
    };
    Missile.prototype.addThrusterBurnYawLeft = function (value) {
        _addThrusterBurn(this._yawLeft, value);
    };
    Missile.prototype.addThrusterBurnYawRight = function (value) {
        _addThrusterBurn(this._yawRight, value);
    };
    Missile.prototype.addThrusterBurnPitchUp = function (value) {
        _addThrusterBurn(this._pitchUp, value);
    };
    Missile.prototype.addThrusterBurnPitchDown = function (value) {
        _addThrusterBurn(this._pitchDown, value);
    };
    /**
     * Returns the thruster burn level that is needed to produce the passed difference in angular velocity for the given duration.
     * @param {Number} angularVelocityDifference The angular velocity difference that needs to be produced, in rad / physics.ANGULAR_VELOCITY_MATRIX_DURATION ms !!.
     * @param {Number} duration The length of time during which the difference needs to be produced, in milliseconds
     * @returns {Number}
     */
    Missile.prototype.getNeededBurnForAngularVelocityChange = function (angularVelocityDifference, duration) {
        return angularVelocityDifference * this._burnForAngularVelocityChangeFactor / duration;
    };
    /**
     * Sets the appropriate thruster burn levels for the maneuvering thrusters of the missile 
     * based on the current targets (pitch and yaw)
     * @param {Number} dt The time elapsed since the last control step, in ms
     */
    Missile.prototype._controlTurnThrusters = function (dt) {
        var
                // grab flight parameters for turning control
                turningMatrix = this.getTurningMatrix(),
                turnThreshold = physics.ANGULAR_VELOCITY_MATRIX_ERROR_THRESHOLD,
                // for caching turn parameters (in rad / ANGULAR_VELOCITY_MATRIX_DURATION ms),
                yawAngle, pitchAngle, turnEnd;
        // controlling yaw
        yawAngle = Math.sign(turningMatrix[4]) * vec.angle2y(turningMatrix[4], turningMatrix[5]);
        if ((this._yawTarget - yawAngle) > turnThreshold) {
            this.addThrusterBurnYawRight(Math.min(1, this.getNeededBurnForAngularVelocityChange(this._yawTarget - yawAngle, dt)));
        } else if ((this._yawTarget - yawAngle) < -turnThreshold) {
            this.addThrusterBurnYawLeft(Math.min(1, this.getNeededBurnForAngularVelocityChange(yawAngle - this._yawTarget, dt)));
        } else {
            turnEnd = true;
        }
        // controlling pitch
        pitchAngle = Math.sign(turningMatrix[6]) * vec.angle2x(turningMatrix[5], turningMatrix[6]);
        if ((this._pitchTarget - pitchAngle) > turnThreshold) {
            this.addThrusterBurnPitchUp(Math.min(1, this.getNeededBurnForAngularVelocityChange(this._pitchTarget - pitchAngle, dt)));
        } else if ((this._pitchTarget - pitchAngle) < -turnThreshold) {
            this.addThrusterBurnPitchDown(Math.min(1, this.getNeededBurnForAngularVelocityChange(pitchAngle - this._pitchTarget, dt)));
        } else if (turnEnd && this._stopHoming) {
            this._homing = false;
        }
        // reset the targets, as they have been processed, the new targets will be set by the next control step
        this._yawTarget = 0;
        this._pitchTarget = 0;
    };
    /**
     * Apply the torques caused by the currently operating maneuvering thrusters to the physical
     * model of the missile
     */
    Missile.prototype._applyTurnThrust = function () {
        var yawAxis, pitchAxis;
        yawAxis = mat.getRowC4(this._physicalModel.getOrientationMatrix());
        pitchAxis = mat.getRowA4(this._physicalModel.getOrientationMatrix());
        if (this._yawRight.burn > 0) {
            this._yawTorque = this._physicalModel.addOrRenewTorque(this._yawTorque, this._class.getAngularThrust() * this._yawRight.burn, yawAxis);
        } else if (this._yawLeft.burn > 0) {
            this._yawTorque = this._physicalModel.addOrRenewTorque(this._yawTorque, -this._class.getAngularThrust() * this._yawLeft.burn, yawAxis);
        }
        if (this._pitchUp.burn > 0) {
            this._pitchTorque = this._physicalModel.addOrRenewTorque(this._pitchTorque, -this._class.getAngularThrust() * this._pitchUp.burn, pitchAxis);
        } else if (this._pitchDown.burn > 0) {
            this._pitchTorque = this._physicalModel.addOrRenewTorque(this._pitchTorque, this._class.getAngularThrust() * this._pitchDown.burn, pitchAxis);
        }
    };
    /**
     * Calculate and return the expected (world) position where the missile can hit its current target, given
     * the target's relative position and velocity and the acceleration capabilities of the missile (assuming
     * it is constantly accelerating towards this point)
     * @returns {Number[3]}
     */
    Missile.prototype._getTargetHitPosition = function () {
        var
                position, targetPosition,
                relativeTargetVelocity,
                hitTime;
        if (!this._targetHitPositionValid) {
            targetPosition = this._target.getPhysicalPositionVector();
            position = mat.translationVector3(this._physicalModel.getPositionMatrix());
            relativeTargetVelocity = vec.diffTranslation3(this._target.getVelocityMatrix(), this._physicalModel.getVelocityMatrix());
            hitTime = this._class.getTargetHitTime(position, targetPosition, relativeTargetVelocity);
            this._targetHitPosition[0] = targetPosition[0] + hitTime * relativeTargetVelocity[0];
            this._targetHitPosition[1] = targetPosition[1] + hitTime * relativeTargetVelocity[1];
            this._targetHitPosition[2] = targetPosition[2] + hitTime * relativeTargetVelocity[2];
            this._targetHitPositionValid = true;
        }
        return this._targetHitPosition;
    };
    /**
     * Sets the yaw and pitch targets to turn the missile in the desired direction specified by the given two angles.
     * To be executed while the missile is actively homing.
     * @param {Number} yaw The yaw angle of the direction to turn towards, with a positive number meaning a direction to the left, in radians.
     * @param {Number} pitch The pitch angle of the direction to turn towards, with a positive number meaning a direction upwards, in radians.
     * @param {Number} dt The time passed since the last turn command in milliseconds - for an estimation of the time the set yaw and pitch 
     * angular velocity will be in effect, so that they can be limited to avoid overshooting the desired angles
     */
    Missile.prototype._turn = function (yaw, pitch, dt) {
        var turningMatrix, angularVelocity, angularAcceleration, turnStopAngle, turnIntensityFactor;
        turningMatrix = this.getTurningMatrix();
        angularAcceleration = this._class.getAngularAcceleration();
        // a turn intensity of 1 means to accelerate the angular velocity to TURN_ACCELERATION_DURATION_S * acceleration (in rad / sec) and
        // lower values represent a linear portion of this intended angular velocity
        // the base intensity factor converts dt to seconds and counts in TURN_ACCELERATION_DURATION_S
        // based on angle = angular velocity * time, we choose an angular velocity that will not overshoot the intended angle in the next dt
        // milliseconds (which will mean about the next simulation step with relatively stable framerates)
        turnIntensityFactor = MISSILE_TURN_INTENSITY_BASE_FACTOR / (angularAcceleration * dt);
        // calculating how much will the missile turn at the current angular velocity if it starts decelerating right now
        angularVelocity = Math.sign(turningMatrix[4]) * vec.angle2y(turningMatrix[4], turningMatrix[5]) * ANGULAR_VELOCITY_CONVERSION_FACTOR;
        turnStopAngle = Math.max(angularVelocity * angularVelocity / (2 * angularAcceleration), MISSILE_TURN_THRESHOLD_ANGLE);
        if (yaw > turnStopAngle) {
            this.yawLeft(Math.min(Math.max(0, turnIntensityFactor * (yaw - turnStopAngle)), 1));
        } else if (yaw < -turnStopAngle) {
            this.yawRight(Math.min(Math.max(0, turnIntensityFactor * (-yaw - turnStopAngle)), 1));
        }
        angularVelocity = Math.sign(turningMatrix[6]) * vec.angle2x(turningMatrix[5], turningMatrix[6]) * ANGULAR_VELOCITY_CONVERSION_FACTOR;
        turnStopAngle = Math.max(angularVelocity * angularVelocity / (2 * angularAcceleration), MISSILE_TURN_THRESHOLD_ANGLE);
        if (pitch > turnStopAngle) {
            this.pitchUp(Math.min(Math.max(0, turnIntensityFactor * (pitch - turnStopAngle)), 1));
        } else if (pitch < -turnStopAngle) {
            this.pitchDown(Math.min(Math.max(0, turnIntensityFactor * (-pitch - turnStopAngle)), 1));
        }
    };
    /**
     * Returns a 3D vector that can be used to position the sound source of this missile in the soundscape
     * @returns {Number[3]}
     */
    Missile.prototype._getSoundSourcePosition = function () {
        var pos = this._visualModel.getPositionMatrixInCameraSpace(this._visualModel.getNode().getScene().getCamera());
        this._soundSourcePosition[0] = Math.round(pos[12] * 10) * 0.1;
        this._soundSourcePosition[1] = Math.round(pos[13] * 10) * 0.1;
        this._soundSourcePosition[2] = Math.round(pos[14] * 10) * 0.1;
        return this._soundSourcePosition;
    };
    /**
     * Returns the sound source to be used for the sounds emitted by this missile.
     * @returns {SoundSource}
     */
    Missile.prototype.getSoundSource = function () {
        if (!this._soundSource) {
            this._soundSource = audio.createSoundSource([0, 0, 0]);
        }
        return this._soundSource;
    };
    /**
     * Performs the destruction of the missile, complete with explosion
     * @param {ExplosionClass} explosionClass The class of the explosion to use
     * @param {Float32Array} positionMatrix The world position where the missile explodes
     * @param {Number[3]} direction The direction (unit) vector to use for the explosion (directional particle emitters)
     * @param {Float32Array} velocityMatrix The velocity matrix to use for the explosion
     * @param {SoundSource} soundSource The sound source to use for the explosion
     * @param {Boolean} isHit Whether the destruction was the result of the missile hitting a spacecraft
     */
    Missile.prototype._destruct = function (explosionClass, positionMatrix, direction, velocityMatrix, soundSource, isHit) {
        var exp;
        this._target = null;
        exp = explosion.getExplosion();
        exp.init(explosionClass, positionMatrix, mat.IDENTITY4, direction, true, true, velocityMatrix);
        exp.addToSceneNow(this._visualModel.getNode().getScene().getRootNode(), soundSource, isHit);
        this._visualModel.markAsReusable(true);
        if (this._startSound) {
            this._startSound.stopPlaying(audio.SOUND_RAMP_DURATION);
            this._startSound = null;
        }
        if (this._trailEmitter) {
            this._trailEmitter.detach();
        }
    };
    /**
     * The callback to get the offset to be used for hit checks for this missile
     * (the sides of the hitboxes are offset towards the outside (i.e. the hitbox 
     * is enlarged in all directions) by this much, in meters)
     * @param {Spacecraft} hitObject The spacecraft that is getting checked for hit
     * @returns {Number}
     */
    Missile.prototype._getHitOffset = function (hitObject) {
        return this._origin.isHostile(hitObject) ? this._class.getProximityRange() : 0;
    };
    /**
     * The function to call when the missile hits a spacecraft
     * @param {Spacecraft} hitObject 
     * @param {PhysicalObject} physicalHitObject 
     * @param {Number[4]} hitPositionVectorInObjectSpace 
     * @param {Number[4]} hitPositionVectorInWorldSpace 
     * @param {Number[3]} relativeHitPositionVectorInWorldSpace
     * @param {Number[3]} relativeVelocityDirectionInObjectSpace
     * @param {Number[3]} relativeVelocityDirectionInWorldSpace
     * @param {Number} relativeVelocity
     * @param {Number} offset
     */
    Missile.prototype._hitCallback = function (hitObject, physicalHitObject, hitPositionVectorInObjectSpace, hitPositionVectorInWorldSpace, relativeHitPositionVectorInWorldSpace, relativeVelocityDirectionInObjectSpace, relativeVelocityDirectionInWorldSpace, relativeVelocity, offset) {
        physicalHitObject.applyForceAndTorque(relativeHitPositionVectorInWorldSpace, relativeVelocityDirectionInWorldSpace, relativeVelocity * this._class.getKineticFactor() * this._physicalModel.getMass() * 1000 / _momentDuration, _momentDuration);
        this._destruct(
                ((hitObject.getShieldIntegrity() > 0) ? this._class.getShieldExplosionClass() : this._class.getExplosionClass()),
                mat.translation4vAux(hitPositionVectorInWorldSpace),
                vec.scaled3(relativeVelocityDirectionInWorldSpace, -1),
                physicalHitObject.getVelocityMatrix(),
                hitObject.getSoundSource(),
                true);
        hitObject.damage(this._class.getDamage(0), hitPositionVectorInObjectSpace, vec.scaled3(relativeVelocityDirectionInObjectSpace, -1), this._origin, true, offset);
        this._timeLeft = 0;
    };
    /**
     * Simulates the movement of the missile and checks if it hit any objects.
     * @param {Number} dt The passed time since the last simulation in milliseconds.
     * @param {Octree} hitObjectOctree The root node of the octree that is used to spatially partition the spacecrafts this missile can
     * hit.
     * @param {Spacecraft} [pilotedCraft] The spacecraft the player pilots in the current mission
     */
    Missile.prototype.simulate = function (dt, hitObjectOctree, pilotedCraft) {
        var i, p, oriMatrix, targetYawAndPitch, threshold, hitCheckDT, enginePosition;
        if (this.canBeReused()) {
            return;
        }
        // avoid hit checking right after the missile is launched, as it could hit the launching ship
        hitCheckDT = Math.min(dt, this._class.getDuration() - this._timeLeft);
        this._timeLeft -= dt;
        this._timeLeftForIgnition -= dt;
        // if the target the missile is trying to home in on has been destroyed, self-destruct the missile
        if (this._target && this._homing && !this._target.isAlive()) {
            this._target = null;
            if (this._timeLeftForIgnition <= 0) {
                this._timeLeft = 0;
            }
        }
        this._mainBurn = false;
        if (this._timeLeft > 0) {
            // set up and apply the main and maneuvering thrusters
            if ((this._timeLeftForIgnition <= 0) && this._target) {
                oriMatrix = this._physicalModel.getOrientationMatrix();
                this.resetThrusterBurn();
                if (this._homing && !this._stopHoming) {
                    // for homing, calculate expected target hit position and the yaw and pitch angles towards it
                    targetYawAndPitch = vec.getYawAndPitch(vec.normalize3(vec.prodVec3Mat4Aux(
                            vec.diff3(this._getTargetHitPosition(), mat.translationVector3(this._physicalModel.getPositionMatrix())),
                            mat.inverseOfRotation4Aux(oriMatrix))));
                    threshold = this._class.getMainBurnAngleThreshold();
                }
                // apply main thrust if the missile is not homing or is homing and sufficiently facing the target
                // direction
                if (!this._homing || this._stopHoming || (Math.abs(targetYawAndPitch.yaw) < threshold && Math.abs(targetYawAndPitch.pitch) < threshold)) {
                    this._physicalModel.applyForce(this._class.getThrust(), oriMatrix[4], oriMatrix[5], oriMatrix[6], dt);
                    this._mainBurn = true;
                    this.addThrusterBurnForward(1);
                    if (!this._started) {
                        this._started = true;
                        if (this._class.getHomingMode() === classes.MissileHomingMode.INITIAL) {
                            this._stopHoming = true;
                        }
                        this._startSound = this._class.playStartSound(this.getSoundSource());
                    }
                }
                // use maneuvering thrusters for homing
                if (this._homing) {
                    if (!this._stopHoming) {
                        this._turn(targetYawAndPitch.yaw, targetYawAndPitch.pitch, dt);
                    }
                    this._controlTurnThrusters(dt);
                    this._applyTurnThrust();
                }
                for (i = 0; i < this._thrusters.length; i++) {
                    this._thrusters[i].updateVisuals();
                }
            }
            // update sound position
            if (this._started) {
                p = this._getSoundSourcePosition();
                this.getSoundSource().setPosition(p[0], p[1], p[2]);
            }
            // update lightsource
            if (this._lightSource) {
                this._lightSource.setObjectIntensity(this._mainBurn ? this._class.getLightIntensity() : 0);
            }
            this._physicalModel.simulate(dt);
            this._turningMatrixValid = false;
            this._targetHitPositionValid = false;
            this._visualModel.setPositionMatrix(this._physicalModel.getPositionMatrix());
            this._visualModel.setOrientationMatrix(this._physicalModel.getOrientationMatrix());
            // update the trail that the missile leaves behind
            if (this._trailEmitter) {
                if (this._mainBurn) {
                    enginePosition = this._visualModel.getPositionVector();
                    vec.add3(enginePosition, vec.prodVec3Mat3Aux(this._class.getEnginePosition(), mat.prodScalingRotation3Aux(this._visualModel.getScalingMatrix(), this._visualModel.getOrientationMatrix())));
                    if (!this._trailEmitter.isEmitting()) {
                        this._trailEmitter.startNew(this._visualModel.getNode().getScene(), enginePosition);
                    } else {
                        this._trailEmitter.addPoint(enginePosition, dt);
                    }
                } else {
                    if (this._trailEmitter.isEmitting()) {
                        this._trailEmitter.detach();
                    }
                }
            }
            if ((hitCheckDT > 0) && (this._timeLeftForIgnition <= 0)) {
                _checkHit(this._physicalModel, hitObjectOctree, hitCheckDT, this._origin, pilotedCraft, this._getHitOffset, this._hitCallback);
            }
        } else {
            // self-destruct if the time has run out
            this._timeLeft = 0;
            if (!this._visualModel.canBeReused()) {
                this._destruct(
                        this._class.getExplosionClass(),
                        this._physicalModel.getPositionMatrix(),
                        vec.scaled3(vec.normalize3(mat.translationVector3(this._physicalModel.getVelocityMatrix())), -1),
                        this._physicalModel.getVelocityMatrix(),
                        audio.createSoundSource(mat.translationVector3(this._visualModel.getPositionMatrixInCameraSpace(this._visualModel.getNode().getScene().getCamera()))),
                        false);
            }
        }
    };
    /**
     * Updates the thruster particle sizes and luminosity factors to reflect the
     * current thruster burn levels.
     */
    Missile.prototype.updateThrusterVisuals = function () {
        var i;
        for (i = 0; i < this._thrusters.length; i++) {
            this._thrusters[i].updateVisuals();
        }
    };
    /**
     * Removes all references from the missile.
     */
    Missile.prototype.destroy = function () {
        var i;
        this._timeLeft = 0;
        this._class = null;
        this._origin = null;
        this._turningMatrix = null;
        this._target = null;
        this._targetHitPosition = null;
        for (i = 0; i < this._thrusters.length; i++) {
            this._thrusters[i].destroy();
        }
        this._thrusters = null;
        this._forward = null;
        this._yawLeft = null;
        this._yawRight = null;
        this._pitchUp = null;
        this._pitchDown = null;
        this._yawTorque = null;
        this._pitchTorque = null;
        if (this._visualModel && this._visualModel.getNode()) {
            this._visualModel.getNode().markAsReusable(true);
        }
        this._visualModel = null;
        if (this._trailEmitter) {
            this._trailEmitter.destroy();
            this._trailEmitter = null;
        }
        this._physicalModel = null;
        if (this._startSound) {
            this._startSound.stopPlaying(audio.SOUND_RAMP_DURATION);
            this._startSound = null;
        }
        this._soundSource = null;
        this._soundSourcePosition = null;
        this._lightSource = null;
        this._hitCallback = null;
        this._getHitOffset = null;
    };
    // #########################################################################
    /**
     * @class Represents a weapon on a spacecraft.
     * @param {WeaponClass} weaponClass The class storing the general 
     * characteristics of this weapon.
     * @param {Spacecraft} spacecraft The spacecraft on which this weapon is 
     * located.
     * @param {WeaponSlot} slot The weapon slot that this weapon occupies on the 
     * spacecraft.
     * @returns {Weapon}
     */
    function Weapon(weaponClass, spacecraft, slot) {
        /**
         * The class storing the general characteristics of this weapon.
         * @type WeaponClass
         */
        this._class = weaponClass;
        /**
         * The spacecraft on which this weapon is located.
         * @type Spacecraft
         */
        this._spacecraft = spacecraft;
        /**
         * The weapon slot that this weapon occupies on the spacecraft.
         * @type WeaponSlot
         */
        this._slot = slot;
        /**
         * The time remaining until the weapon can fire again, in milliseconds
         * @type Number
         */
        this._cooldown = 0;
        /**
         * The renderable node that represents this weapon in a scene.
         * @type RenderableObject
         */
        this._visualModel = null;
        /**
         * Stores the calculated value of the position of the origo of the weapon in model space based on the position and orientation of
         * the weapon slot and the point of attachment. (4x4 translation matrix)
         * @type Float32Array
         */
        this._origoPositionMatrix = null;
        /**
         * Stores the calculated value of the scaling matrix of the parent spacecraft and the orientation of the weapon slot for speeding
         * up calculations.
         * @type Float32Array
         */
        this._scaledOriMatrix = null;
        /**
         * The current angles at which the weapon is positioned (if it is turnable), in radians. The first number belong to the first 
         * rotator and the second one to the second rotator.
         * @type Number[2]
         */
        this._rotationAngles = [0, 0];
        /**
         * A flag indicating whether the rotation angles of the weapon have changed in this simulation step (triggering a recalculation of
         * the respective matrices).
         * @type Boolean
         */
        this._rotationChanged = false;
        /**
         * A 4x4 matrix describing the transformation (translation and rotation) corresponding to the current position (determined by 
         * rotation angles) of the weapon, considering all the rotators. Used to transform the base point (for aiming) or the barrel
         * positions (for firing). Interim matrices (considering only some, but not all rotators) are not stored, but directly feeded to the
         * visual model as parameters when calculated.
         * @type Float32Array
         */
        this._transformMatrix = mat.identity4();
        /**
         * A shortcut flag indicating whether this weapon can rotate or is fixed in pointing to one direction.
         * @type Boolean
         */
        this._fixed = this._class.isFixed();
        /**
         * The saved value of the current aiming state of the weapon refreshed every time the weapon is rotated.
         * @type Number
         */
        this._lastAimStatus = this._fixed ? WeaponAimStatus.FIXED : WeaponAimStatus.NO_TARGET;
    }
    /**
     * Returns the name of the weapon in a way that can be displayed to the user (translated)
     * @returns {String}
     */
    Weapon.prototype.getDisplayName = function () {
        return this._class.getDisplayName();
    };
    /**
     * Returns the class of the projectiles the first barrel of this weapon fires.
     * @returns {ProjectileClass}
     */
    Weapon.prototype.getProjectileClass = function () {
        return this._class.getProjectileClass();
    };
    /**
     * Returns the velocity in m/s at which the first barrel of this weapon is firing projectiles.
     */
    Weapon.prototype.getProjectileVelocity = function () {
        return this._class.getProjectileVelocity();
    };
    /**
     * Returns the damage one shot (from all barrels) this weapon deals to a target with the passed armor rating.
     * @param {Number} [armorRating=0]
     * @returns {Number}
     */
    Weapon.prototype.getDamage = function (armorRating) {
        return this._class.getDamage(armorRating);
    };
    /**
     * Returns the damage per second dealt this a weapon to a target with the passed armor rating.
     * @param {Number} [armorRating=0]
     * @returns {Number}
     */
    Weapon.prototype.getFirepower = function (armorRating) {
        return this._class.getFirepower(armorRating);
    };
    /**
     * Returns the rate of fire of this weapon, in shots per second
     * @returns {Number}
     */
    Weapon.prototype.getFireRate = function () {
        return this._class.getFireRate();
    };
    /**
     * Returns the relative range of the weapon, based on the first barrel, that is the farthest distance the fired projectiles will reach
     * if the weapon itself is travelling with the given speed along its firing line in world space.
     * @param {Number} baseSpeed
     * @returns {Number}
     */
    Weapon.prototype.getRange = function (baseSpeed) {
        return (this._class.getProjectileVelocity() + (baseSpeed || 0)) * this._class.getProjectileClass().getDuration() / 1000;
    };
    /**
     * Return the duration this weapon needs between shots, in milliseconds.
     * @returns {Number}
     */
    Weapon.prototype.getCooldown = function () {
        return this._class.getCooldown();
    };
    /**
     * Returns the calculated value of the position of the origo of the weapon in model space based on the position and orientation of
     * the weapon slot and the point of attachment. (4x4 translation matrix)
     * @returns {Float32Array}
     */
    Weapon.prototype.getOrigoPositionMatrix = function () {
        this._origoPositionMatrix = this._origoPositionMatrix || mat.translatedByVector(
                this._slot ? this._slot.positionMatrix : mat.IDENTITY4,
                vec.prodVec3Mat4Aux(
                        vec.scaled3(this._class.getAttachmentPoint(), -1),
                        mat.prodScalingRotationAux(
                                mat.scaling4(this._class.getModel().getScale() / (this._spacecraft ? this._spacecraft.getPhysicalScalingMatrix()[0] : 1)),
                                this._slot ? this._slot.orientationMatrix : mat.IDENTITY4)));
        return this._origoPositionMatrix;
    };
    /**
     * Returns the calculated value of the scaling matrix of the parent spacecraft and the orientation of the weapon slot.
     * @returns {Float32Array}
     */
    Weapon.prototype.getScaledOriMatrix = function () {
        this._scaledOriMatrix = this._scaledOriMatrix || mat.prodScalingRotation(this._visualModel.getScalingMatrix(), this._slot.orientationMatrix);
        return this._scaledOriMatrix;
    };
    /**
     * Returns whether this weapon is fixed i.e. is pointing in one fix direction and does not have any rotators.
     * @returns {Boolean}
     */
    Weapon.prototype.isFixed = function () {
        return this._fixed;
    };
    /**
     * Returns a 3D vector indicating the position of the base point of this weapon in world space.
     * @param {Float32Array} shipScaledOriMatrix A 4x4 matrix describing the scaling and rotation of the spacecraft that has this weapon.
     * it is more effective to calculate this separately once and pass it to all functions that need it.
     * @returns {Number[3]}
     */
    Weapon.prototype.getBasePointPosVector = function (shipScaledOriMatrix) {
        var
                basePointPosVector,
                weaponSlotPosVector = vec.prodVec3Mat4Aux(mat.translationVector3(this.getOrigoPositionMatrix()), shipScaledOriMatrix);
        vec.add3(weaponSlotPosVector, this._spacecraft.getPhysicalPositionVector());
        basePointPosVector = vec.prodVec4Mat4(this._class.getBasePoint(), this._transformMatrix);
        vec.mulVec3Mat4(basePointPosVector, mat.prod3x3SubOf4Aux(this.getScaledOriMatrix(), shipScaledOriMatrix));
        vec.add3(basePointPosVector, weaponSlotPosVector);
        return basePointPosVector;
    };
    /**
     * Returns a 4x4 rotation matrix describing the orientation of projectiles fired by this weapon in world space.
     * Uses an auxiliary matrix common to all Weapons.
     * @returns {Float32Array}
     */
    Weapon.prototype.getProjectileOrientationMatrix = function () {
        mat.setProd3x3SubOf4(Weapon._projectileOriMatrix, this._slot.orientationMatrix, this._spacecraft.getPhysicalOrientationMatrix());
        if (!this._fixed) {
            mat.setProd3x3SubOf4(Weapon._projectileOriMatrix, this._transformMatrix, mat.matrix4Aux(Weapon._projectileOriMatrix));
        }
        return Weapon._projectileOriMatrix;
    };
    /**
     * Marks the resources necessary to render this weapon for loading.
     * @param {WeaponClass~ResourceParams} params
     */
    Weapon.prototype.acquireResources = function (params) {
        this._class.acquireResources(params);
    };
    /**
     * @typedef {Object} Weapon~AddToSceneParams
     * @property {Boolean} [skipResources=false] If true, resources will not be acquired
     * @property {String} [shaderName] If given, the original shader of this weapon will be substituted by the shader with this name.
     * @property {Float32Array} [orientationMatrix]
     * @property {Boolean} [projectileResources=false] Whether to acquire resources for firing projectiles
     * @property {Boolean} [sound=false] Whether to acquire resources for sound effects
     */
    /**
     * @typedef {Function} logic~addToSceneCallback
     * @param {ParameterizedMesh} model
     */
    /**
     * Adds a renderable node representing this weapon to the scene under the
     * passed parent node, assuming its resources have already been loaded.
     * @param {ParameterizedMesh} parentNode See addToScene()
     * @param {Number} [lod] See addToScene()
     * @param {Boolean} wireframe See addToScene()
     * @param {Weapon~AddToSceneParams} params See addToScene()
     * @param {logic~addToSceneCallback} [callback] See addToScene()
     */
    Weapon.prototype.addToSceneNow = function (parentNode, lod, wireframe, params, callback) {
        var visualModel, scale, shader;
        application.log_DEBUG("Adding weapon (" + this._class.getName() + ") to scene...", 2);
        shader = params.shaderName ? graphics.getManagedShader(params.shaderName) : this._class.getShader();
        scale = this._class.getModel().getScale() / parentNode.getRenderableObject().getScalingMatrix()[0];
        visualModel = new renderableObjects.ParameterizedMesh(
                this._class.getModel(),
                shader,
                this._class.getTexturesOfTypes(shader.getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                this._slot ? this.getOrigoPositionMatrix() : mat.identity4(),
                params.orientationMatrix || (this._slot ? this._slot.orientationMatrix : mat.identity4()),
                mat.scaling4(scale),
                (wireframe === true),
                lod,
                undefined,
                _parameterArrays);
        parentNode.addSubnode(new sceneGraph.RenderableNode(visualModel));
        // setting the starting values of the parameter arrays
        // setting an identity transformation for all transform groups
        if (visualModel.hasParameterArray(_groupTransformsArrayName)) {
            visualModel.setParameterArray(_groupTransformsArrayName, graphics.getGroupTransformIdentityArray());
        }
        // setting the default luminosity for all luminosity groups
        if (graphics.areLuminosityTexturesAvailable() && visualModel.hasParameterArray(_luminosityFactorsArrayName)) {
            visualModel.setParameterArray(_luminosityFactorsArrayName, this._class.getDefaultGroupLuminosityFactors());
        }
        if (!this._visualModel) {
            this._visualModel = visualModel;
        }
        if (callback) {
            callback(visualModel);
        }
    };
    /**
     * Adds a renderable node representing this weapon to the scene under the
     * passed parent node.
     * @param {ParameterizedMesh} parentNode The parent node to which to attach this
     * weapon in the scene. (normally the renderable node of the spacecraft
     * that has this weapon, but optionally can be different)
     * @param {Number} [lod] The level of detail to use for the added model. If no
     * value is given, all available LODs will be loaded for dynamic rendering.
     * @param {Boolean} wireframe Whether to add the model in wireframe rendering
     * mode.
     * @param {Weapon~AddToSceneParams} [params] 
     * @param {logic~addToSceneCallback} [callback]
     */
    Weapon.prototype.addToScene = function (parentNode, lod, wireframe, params, callback) {
        if (!params.skipResources) {
            this.acquireResources({omitShader: !!params.shaderName, projectileResources: params.projectileResources, sound: params.sound});
            if (params.shaderName) {
                graphics.getShader(params.shaderName);
            }
        }
        resources.executeWhenReady(this.addToSceneNow.bind(this, parentNode, lod, wireframe, params, callback));
    };
    /**
     * Returns the renderable object representing the muzzle flash that is visible
     * when the barrel having the passed index is firing a projectile.
     * @param {Number} barrelIndex
     * @param {Number[3] relativeBarrelPosVector The position of the barrel (muzzle) in object-space (where the object is the spacecraft
     * having this weapon)
     * @returns {Particle}
     */
    Weapon.prototype._getMuzzleFlashForBarrel = function (barrelIndex, relativeBarrelPosVector) {
        var
                projectileClass = this._class.getBarrel(barrelIndex).getProjectileClass(),
                muzzleFlashPosMatrix = mat.translation4vAux(relativeBarrelPosVector),
                particle = _particlePool.getObject();
        renderableObjects.initDynamicParticle(
                particle,
                projectileClass.getMuzzleFlash().getModel(),
                projectileClass.getMuzzleFlash().getShader(),
                projectileClass.getMuzzleFlash().getTexturesOfTypes(projectileClass.getMuzzleFlash().getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                projectileClass.getMuzzleFlash().getColor(),
                projectileClass.getMuzzleFlash().getSize(),
                muzzleFlashPosMatrix,
                projectileClass.getMuzzleFlash().getDuration() || config.getSetting(config.BATTLE_SETTINGS.DEFAULT_MUZZLE_FLASH_DURATION),
                projectileClass.getMuzzleFlash().getInstancedShader());
        return particle;
    };
    /**
     * 
     * @param {Scene} scene
     * @param {Number} barrelIndex
     * @param {String} resourceID
     * @returns {Function}
     */
    Weapon.prototype.getResourceAdderFunction = function (scene, barrelIndex, resourceID) {
        return function () {
            var particle;
            if (!scene.hasResourcesOfObject(resourceID)) {
                particle = this._getMuzzleFlashForBarrel(barrelIndex, [0, 0, 0]);
                scene.addResourcesOfObject(particle);
            }
        }.bind(this);
    };
    /**
     * Adds the resources required to render the projeciles fired by this weapon
     * to the passed scene, so they get loaded at the next resource load as well 
     * as added to any context the scene is added to.
     * @param {Scene} scene
     */
    Weapon.prototype.addProjectileResourcesToScene = function (scene) {
        var i, projectile, barrels, resourceID = WEAPON_RESOURCE_ID_PREFIX + this._class.getName();
        barrels = this._class.getBarrels();
        for (i = 0; i < barrels.length; i++) {
            projectile = new Projectile(barrels[i].getProjectileClass());
            projectile.addResourcesToScene(scene);
            resources.executeWhenReady(this.getResourceAdderFunction(scene, i, resourceID).bind(this));
        }
        resources.executeWhenReady(function () {
            scene.addResourcesOfObject(null, resourceID);
        });
    };
    /**
     * Does all the needed updates to the weapon's state for one simulation step.
     * @param {Number} dt The time elapsed since the last simulation step, in milliseconds
     */
    Weapon.prototype.simulate = function (dt) {
        var i, rotators;
        this._cooldown = Math.max(this._cooldown - dt, 0);
        // updating the group transform matrices of the visual model if needed as well as recalculating the final transform matrix
        if (this._rotationChanged) {
            mat.setIdentity4(this._transformMatrix);
            rotators = this._class.getRotators();
            for (i = 0; i < rotators.length; i++) {
                mat.rotateAroundPoint4(
                        this._transformMatrix,
                        vec.prodVec3Mat4Aux(rotators[i].center, this._transformMatrix),
                        vec.prodVec3Mat4Aux(rotators[i].axis, this._transformMatrix),
                        this._rotationAngles[i]);
                this._visualModel.setMat4Parameter(
                        _groupTransformsArrayName,
                        rotators[i].transformGroupIndex,
                        this._transformMatrix);
            }
            this._rotationChanged = false;
        }
    };
    // static auxiliary matrices to be used in the fire() method (to avoid created new matrices during each execution of the method)
    Weapon._weaponSlotPosMatrix = mat.identity4();
    Weapon._projectilePosMatrix = mat.identity4();
    Weapon._projectileOriMatrix = mat.identity4();
    /**
     * Fires the weapon and adds the projectiles it fires (if any) to the passed pool.
     * @param {Float32Array} shipScaledOriMatrix A 4x4 matrix describing the scaling and rotation of the spacecraft having this weapon - it
     * is more effective to calculate it once for a spacecraft and pass it to all weapons as a parameter.
     * @param {Boolean} onlyIfAimedOrFixed The weapon only fires if it is fixed (cannot be rotated) or if it is aimed at its current target
     * and it is in range (based on the last aiming status of the weapon)
     * @param {SoundSource} shipSoundSource The sound source belonging to the spacecraft that fires this weapon
     * @returns {Number} How many projectiles did the weapon fire.
     */
    Weapon.prototype.fire = function (shipScaledOriMatrix, onlyIfAimedOrFixed, shipSoundSource) {
        var i, p, result,
                weaponSlotPosVector,
                projectileOriMatrix,
                projectileClass, barrelPosVector, muzzleFlash, barrels, projectileLights, projClassName,
                soundPosition, lighSource,
                scene = this._visualModel.getNode().getScene();
        if (onlyIfAimedOrFixed && (this._lastAimStatus !== WeaponAimStatus.FIXED) && (this._lastAimStatus !== WeaponAimStatus.AIMED_IN_RANGE)) {
            return 0;
        }
        // check cooldown
        if (this._cooldown <= 0) {
            this._cooldown = this._class.getCooldown();
            // cache the matrices valid for the whole weapon
            weaponSlotPosVector = vec.prodVec3Mat4Aux(mat.translationVector3(this.getOrigoPositionMatrix()), shipScaledOriMatrix);
            mat.setTranslatedByVector(Weapon._weaponSlotPosMatrix, this._spacecraft.getPhysicalPositionMatrix(), weaponSlotPosVector);
            projectileOriMatrix = this.getProjectileOrientationMatrix();
            barrels = this._class.getBarrels();
            if (_dynamicLights) {
                projectileLights = {};
            }
            result = 0;
            // generate the muzzle flashes and projectiles for each barrel
            for (i = 0; i < barrels.length; i++) {
                // cache variables
                projectileClass = barrels[i].getProjectileClass();
                barrelPosVector = barrels[i].getPositionVector();
                if (!this._fixed) {
                    barrelPosVector = vec.prodVec4Mat4(barrelPosVector, this._transformMatrix);
                }
                // add the muzzle flash of this barrel
                muzzleFlash = this._getMuzzleFlashForBarrel(i, barrelPosVector);
                barrelPosVector = vec.prodVec3Mat4(barrelPosVector, mat.prod3x3SubOf4Aux(this.getScaledOriMatrix(), shipScaledOriMatrix));
                mat.setTranslatedByVector(Weapon._projectilePosMatrix, Weapon._weaponSlotPosMatrix, barrelPosVector);
                this._visualModel.getNode().addSubnode(muzzleFlash.getNode() || new sceneGraph.RenderableNode(muzzleFlash, false, false, _minimumParticleCountForInstancing));
                // add the projectile of this barrel
                p = _projectilePool.getObject();
                p.init(
                        projectileClass,
                        Weapon._projectilePosMatrix,
                        projectileOriMatrix,
                        this._spacecraft,
                        barrels[i].getProjectileVelocity());
                p.addToSceneNow(scene);
                if (_dynamicLights && projectileClass.getLightColor()) {
                    // creating the light source / adding the projectile to the emitting objects if a light source for this class of fired projectiles has already
                    // been created, so that projectiles from the same weapon and of the same class only use one light source object
                    if (!projectileLights[projectileClass.getName()]) {
                        lighSource = new lights.PointLightSource(projectileClass.getLightColor(), projectileClass.getLightIntensity(), vec.NULL3, [p.getVisualModel()]);
                        projectileLights[projectileClass.getName()] = lighSource;
                        p.setLightSource(lighSource);
                    } else {
                        projectileLights[projectileClass.getName()].addEmittingObject(p.getVisualModel());
                    }
                }
                // create the counter-force affecting the firing ship
                this._spacecraft.getPhysicalModel().applyForceAndTorque(
                        vec.diffTranslation3(
                                Weapon._projectilePosMatrix,
                                this._spacecraft.getPhysicalPositionMatrix()),
                        mat.getRowB43Neg(projectileOriMatrix),
                        barrels[i].getForceForDuration(_momentDuration),
                        _momentDuration
                        );
                result++;
            }
            if (_dynamicLights) {
                for (projClassName in projectileLights) {
                    if (projectileLights.hasOwnProperty(projClassName)) {
                        scene.addPointLightSource(projectileLights[projClassName], constants.PROJECTILE_LIGHT_PRIORITY);
                    }
                }
            }
            if (!shipSoundSource) {
                soundPosition = mat.translationVector3(p.getVisualModel().getPositionMatrixInCameraSpace(scene.getCamera()));
            }
            this._class.playFireSound(soundPosition, shipSoundSource, _fireSoundStackingTimeThreshold, _fireSoundStackingVolumeFactor);
            return result;
        }
        return 0;
    };
    /**
     * Sets new rotation angles (instantly) for this weapon (if it can be rotated)
     * @param {Number} angleOne The angle to be set for the first rotator, in degrees
     * @param {Number} angleTwo The angle to be set for the second rotator, in degrees
     */
    Weapon.prototype.setRotation = function (angleOne, angleTwo) {
        if (!this._fixed) {
            this._rotationAngles[0] = angleOne * utils.RAD;
            this._rotationAngles[1] = angleTwo * utils.RAD;
            this._rotationChanged = true;
        }
    };
    /**
     * Rotates the weapon towards a desired angle according to its rotation speed and the passed elapsed time.
     * @param {Number} angleOne The angle towards which to rotate the first rotator, in radians
     * @param {Number} angleTwo The angle towards which to rotate the second rotator, in radians
     * @param {Number} turnThreshold The weapon will not be rotated if it is closer to the desired angle than this value (in radians)
     * @param {Number} fireThreshold The weapon will only set an aimed status if it is closer to the desired angle than this value (in 
     * radians)
     * @param {Number} dt The elapsed time, in milliseconds
     */
    Weapon.prototype.rotateTo = function (angleOne, angleTwo, turnThreshold, fireThreshold, dt) {
        var angleDifference, rotators, i, rotationAmount;
        if (!this._fixed) {
            this._lastAimStatus = WeaponAimStatus.AIMED_IN_RANGE;
            rotators = this._class.getRotators();
            for (i = 0; i < rotators.length; i++) {
                switch (i) {
                    case 0:
                        angleDifference = angleOne - this._rotationAngles[0];
                        // roll-yaw type weapons can yaw in the opposite direction if that results in less rolling
                        if (this._class.getRotationStyle() === classes.WeaponRotationStyle.ROLL_YAW) {
                            if (Math.abs(angleDifference - Math.sign(angleDifference) * Math.PI) < Math.abs(angleDifference)) {
                                angleDifference -= Math.sign(angleDifference) * Math.PI;
                                angleTwo = -angleTwo;
                            }
                        }
                        break;
                    case 1:
                        angleDifference = angleTwo - this._rotationAngles[1];
                        break;
                    default:
                        application.crash();
                }
                // if the weapon can freely turn around in 360 degrees, it is faster to turn in the other direction in case the angle 
                // difference is larger than 180 degrees
                if (!rotators[i].restricted) {
                    if (angleDifference > Math.PI) {
                        angleDifference -= utils.DOUBLE_PI;
                    } else if (angleDifference < -Math.PI) {
                        angleDifference += utils.DOUBLE_PI;
                    }
                }
                // perform the actual turn, if needed
                rotationAmount = 0;
                if (Math.abs(angleDifference) > turnThreshold) {
                    rotationAmount = rotators[i].rotationRate * dt / 1000;
                    if (angleDifference > 0) {
                        this._rotationAngles[i] += Math.min(rotationAmount, angleDifference);
                    } else {
                        this._rotationAngles[i] -= Math.min(rotationAmount, -angleDifference);
                    }
                    this._rotationChanged = true;
                    if ((Math.abs(angleDifference) - rotationAmount) > fireThreshold) {
                        this._lastAimStatus = WeaponAimStatus.AIMING;
                    }
                }
                if (!rotators[i].restricted) {
                    // if the weapon can turn around in 360 degrees, make sure its angle stays in the -180,180 range
                    if (this._rotationAngles[i] > Math.PI) {
                        this._rotationAngles[i] -= utils.DOUBLE_PI;
                    }
                    if (this._rotationAngles[i] < -Math.PI) {
                        this._rotationAngles[i] += utils.DOUBLE_PI;
                    }
                } else {
                    // if the weapon is restricted in turning around, apply the restriction
                    if (this._rotationAngles[i] > rotators[i].range[1]) {
                        this._rotationAngles[i] = rotators[i].range[1];
                        if ((Math.abs(angleDifference) - rotationAmount) > fireThreshold) {
                            this._lastAimStatus = WeaponAimStatus.AIMING_OUT_OF_REACH;
                        }
                    }
                    if (this._rotationAngles[i] < rotators[i].range[0]) {
                        this._rotationAngles[i] = rotators[i].range[0];
                        if ((Math.abs(angleDifference) - rotationAmount) > fireThreshold) {
                            this._lastAimStatus = WeaponAimStatus.AIMING_OUT_OF_REACH;
                        }
                    }
                }
            }
        }
    };
    /**
     * Rotates the weapon towards the angles necessary to make it point towards the passed position. (based on the weapon's rotation speed
     * and the elapsed time)
     * @param {Number[3]} targetPositionVector The position towards which the weapon should aim, in world-space coordinates.
     * @param {Number} turnThreshold The weapon will rotate if the angle between its current direction and the one pointing towards the given
     * target is greater than this value, in radians.
     * @param {Number} fireThreshold The weapon will set an aimed status if the angle between its current direction and the one pointing 
     * towards the given target is less than this value, in radians.
     * @param {Float32Array} shipScaledOriMatrix A 4x4 transformation matrix describing the scalin and rotation of the spacecraft that has
     * this weapon.
     * @param {Number} dt The elapsed time, in milliseconds.
     */
    Weapon.prototype.aimTowards = function (targetPositionVector, turnThreshold, fireThreshold, shipScaledOriMatrix, dt) {
        var basePointPosVector, vectorToTarget, yawAndPitch, rollAndYaw, inRange;
        if (!this._fixed) {
            // as a basis for calculating the direction pointing towards the target, the base point of the weapon is considered (in world 
            // space, transformed according to the current rotation angles of the weapon)
            basePointPosVector = this.getBasePointPosVector(shipScaledOriMatrix);
            // calculate the vector pointing towards the target in world coordinates
            vectorToTarget = vec.diff3(targetPositionVector, basePointPosVector);
            // transform to object space - relative to the weapon
            vectorToTarget = vec.prodMat4Vec3(this._spacecraft.getPhysicalOrientationMatrix(), vectorToTarget);
            vectorToTarget = vec.prodMat4Vec3(this._slot.orientationMatrix, vectorToTarget);
            inRange = vec.extractLength3(vectorToTarget) <= this.getRange();
            switch (this._class.getRotationStyle()) {
                case classes.WeaponRotationStyle.YAW_PITCH:
                    yawAndPitch = vec.getYawAndPitch(vectorToTarget);
                    this.rotateTo(-yawAndPitch.yaw, -yawAndPitch.pitch, turnThreshold, fireThreshold, dt);
                    break;
                case classes.WeaponRotationStyle.ROLL_YAW:
                    rollAndYaw = vec.getRollAndYaw(vectorToTarget);
                    this.rotateTo(rollAndYaw.roll, rollAndYaw.yaw, turnThreshold, fireThreshold, dt);
                    break;
                default:
                    application.crash();
            }
            if (!inRange && this._lastAimStatus === WeaponAimStatus.AIMED_IN_RANGE) {
                this._lastAimStatus = WeaponAimStatus.AIMED_OUT_OF_RANGE;
            }
        }
    };
    /**
     * Rotates the weapon towards its default rotation angles according to its rotation speed and the passed elapsed time.
     * @param {Number} threshold The weapon will not be rotated if it is closer to the desired angle than this value (in radians)
     * @param {Number} dt The elapsed time, in milliseconds
     */
    Weapon.prototype.rotateToDefaultPosition = function (threshold, dt) {
        var rotators;
        if (!this._fixed) {
            rotators = this._class.getRotators();
            this.rotateTo(rotators[0].defaultAngle, rotators[1].defaultAngle, threshold, 0, dt);
            this._lastAimStatus = WeaponAimStatus.NO_TARGET;
        }
    };
    /**
     * Returns the amount of score points to be added to the total score value of spacecrafts that have this weapon equipped
     * @returns {Number}
     */
    Weapon.prototype.getScoreValue = function () {
        return this._class.getScoreValue();
    };
    /**
     * Returns the highest number of projectiles that might be used for this weapon simultaneously in one battle.
     * @returns {Number}
     */
    Weapon.prototype.getMaxProjectileCount = function () {
        return this._class.getMaxProjectileCount();
    };
    /**
     * Returns the highest number of explosions that might be used for this weapon simultaneously in one battle.
     * @returns {Number}
     */
    Weapon.prototype.getMaxExplosionCount = function () {
        return this._class.getMaxExplosionCount();
    };
    /**
     * Returns the highest number of particles that might be used for this weapon simultaneously in one battle.
     * @returns {Number}
     */
    Weapon.prototype.getMaxParticleCount = function () {
        return this._class.getMaxParticleCount();
    };
    /**
     * Removes all references stored by this object
     */
    Weapon.prototype.destroy = function () {
        this._class = null;
        this._spacecraft = null;
        this._slot = null;
        if (this._visualModel) {
            this._visualModel.markAsReusable(true);
        }
        this._visualModel = null;
    };
    // #########################################################################
    /**
     * @class Represents a missile launcher with fixed tubes on a spacecraft.
     * @param {MissileClass} missileClass The class storing the general 
     * characteristics of the missiles loaded into this launcher.
     * (a launcher can only have one class of missiles equipped at a time)
     * @param {Spacecraft} spacecraft The spacecraft on which this launcher is 
     * located.
     * @param {MissileLauncherDescriptor} descriptor The descriptor belonging to
     * the spacecraft's class that corresponds to this launcher.
     * @param {Number} missileCount The amount of missiles currently loaded into this
     * launcher.
     */
    function MissileLauncher(missileClass, spacecraft, descriptor, missileCount) {
        /**
         * The class storing the general characteristics of the missiles loaded 
         * into this launcher.
         * (a launcher can only have one class of missiles equipped at a time)
         * @type MissileClass
         */
        this._class = missileClass;
        /**
         * The spacecraft on which this launcher is located.
         * @type Spacecraft
         */
        this._spacecraft = spacecraft;
        /**
         * The descriptor belonging to the spacecraft's class that corresponds 
         * to this launcher.
         * @type MissileLauncherDescriptor
         */
        this._descriptor = descriptor;
        /**
         * The amount of missiles loaded into this launcher.
         * @type Number
         */
        this._missileCount = missileCount;
        /**
         * The time remaining until the next missile can be launched, in milliseconds.
         * @type Number
         */
        this._cooldown = 0;
        /**
         * The index of the missile tube that will launch next
         * @type Number
         */
        this._activeTubeIndex = 0;
        /**
         * Whether salvo launching mode is turned on
         * @type Number
         */
        this._salvo = false;
        /**
         * The amount of missiles left to launch in the current salvo
         * @type Number
         */
        this._salvoLeft = 0;
        /**
         * The target of the current salvo (missiles launched in this salvo will
         * target this spacecraft, regardless of the current target of the
         * spacecraft the missile launcher is on)
         * @type Spacecraft
         */
        this._salvoTarget = null;
        /**
         * The array of meshes representing the missiles loaded into the launch tubes
         * of this missile launcher
         * @type ParameterizedMesh[]
         */
        this._visualModels = null;
    }
    /**
     * Returns the class of missiles loaded into this launcher
     * @returns {MissileClass}
     */
    MissileLauncher.prototype.getMissileClass = function () {
        return this._class;
    };
    /**
     * Returns the name of the missile loaded into this launcher  in a way that 
     * can be displayed to the user (translated)
     * @returns {String}
     */
    MissileLauncher.prototype.getDisplayName = function () {
        return this._class.getDisplayName();
    };
    /**
     * Returns the damage one missile from this launcher deals to a target with 
     * the passed armor rating.
     * @param {Number} [armorRating=0]
     * @returns {Number}
     */
    MissileLauncher.prototype.getDamage = function (armorRating) {
        return this._class.getDamage(armorRating);
    };
    /**
     * Returns the total damage dealt by all missiles from this launcher to a
     * target with the passed armor rating.
     * @param {Number} [armorRating=0]
     * @returns {Number}
     */
    MissileLauncher.prototype.getFirepower = function (armorRating) {
        return this._missileCount * this._class.getDamage(armorRating);
    };
    /**
     * Returns the range of the missile fired from a still fighter if it flies
     * straight forward. (actual effective range will depend on the relative 
     * velocity of the fighter and the maneuvering of the missile if homing)
     * @returns {Number}
     */
    MissileLauncher.prototype.getNominalRange = function () {
        return this._class.getNominalRange();
    };
    /**
     * Returns the rate of fire of this launcher, in shots per second
     * @returns {Number}
     */
    MissileLauncher.prototype.getFireRate = function () {
        return this._class.getFireRate();
    };
    /**
     * Returns the time it takes for this launcher to lock on to a target, in milliseconds
     * @returns {Number}
     */
    MissileLauncher.prototype.getLockingTime = function () {
        return this._class.getLockingTime();
    };
    /**
     * Return the duration this launcher needs between launches, in milliseconds.
     * @returns {Number}
     */
    MissileLauncher.prototype.getCooldown = function () {
        return this._class.getCooldown();
    };
    /**
     * Returns how close is the launcher to being ready for the next manual launch (from 0 to 1)
     * @returns {Number}
     */
    MissileLauncher.prototype.getLoadRatio = function () {
        return (this._missileCount > this._salvoLeft) ?
                (this._salvo ?
                        1 - (this._salvoLeft + this._cooldown / this._class.getCooldown()) / this._descriptor.salvo :
                        1 - this._cooldown / this._class.getCooldown()) :
                0;
    };
    /**
     * Whether the launcher is currently in salvo mode
     * @returns {Boolean}
     */
    MissileLauncher.prototype.isInSalvoMode = function () {
        return this._salvo;
    };
    /**
     * Turn salvo mode on or off
     * @param {Booelan} value
     */
    MissileLauncher.prototype.setSalvoMode = function (value) {
        this._salvo = value && (this._descriptor.salvo > 1);
    };
    /**
     * Toggle salvo mode
     * @returns {Boolean} Whether the salvo mode has been changed
     */
    MissileLauncher.prototype.toggleSalvoMode = function () {
        if (this._descriptor.salvo > 1) {
            this._salvo = !this._salvo;
            return true;
        }
        return false;
    };
    /**
     * The amount of missiles left to launch in the current salvo
     * @returns {Number}
     */
    MissileLauncher.prototype.getSalvoLeft = function () {
        return this._salvoLeft;
    };
    /**
     * The total amount of missiles launched in one salvo
     * @returns {Number}
     */
    MissileLauncher.prototype.getSalvo = function () {
        return this._descriptor.salvo;
    };
    /**
     * Sets the cooldown to the passed value, if it is larger than the currently remaining cooldown
     * @param {Number} value In milliseconds
     */
    MissileLauncher.prototype.setMinimumCooldown = function (value) {
        if (this._cooldown < value) {
            this._cooldown = value;
        }
    };
    /**
     * Returns a 4x4 rotation matrix describing the orientation of missiles launched by this launcher in world space.
     * Uses an auxiliary matrix common to all MissileLaunchers.
     * @returns {Float32Array}
     */
    MissileLauncher.prototype.getMissileOrientationMatrix = function () {
        mat.setProd3x3SubOf4(MissileLauncher._missileOriMatrix, this._descriptor.orientationMatrix, this._spacecraft.getPhysicalOrientationMatrix());
        return MissileLauncher._missileOriMatrix;
    };
    /**
     * Marks the resources necessary to render missiles from this launcher for loading.
     * @param {MissileClass~ResourceParams} params
     */
    MissileLauncher.prototype.acquireResources = function (params) {
        this._class.acquireResources(params);
    };
    /**
     * Adds the resources required to render the missiles launched by this launcher
     * to the passed scene, so they get loaded at the next resource load as well 
     * as added to any context the scene is added to.
     * @param {Scene} scene
     */
    MissileLauncher.prototype.addMissileResourcesToScene = function (scene) {
        var missile, resourceID = MISSILE_LAUNCHER_RESOURCE_ID_PREFIX + this._class.getName();
        missile = new Missile(this._class);
        missile.addResourcesToScene(scene, false, undefined, undefined, true);
        resources.executeWhenReady(function () {
            scene.addResourcesOfObject(null, resourceID);
        });
    };
    /**
     * @typedef {Object} MissileLauncher~AddToSceneParams
     * @property {String} [shaderName]
     * @property {Boolean} [allMissiles] Whether to add all the loaded missiles, not
     * just the first ones for each tube - use all missiles to display them in wireframe
     * inside the spacecraft, use the first missile only for displaying in solid mode
     * (updating visuals during simulation only works properly with the first missiles
     * added)
     */
    /**
     * Adds renderable nodes representing the missiles loaded into this launcher to 
     * the scene under the passed parent node, assuming its resources have already been loaded.
     * @param {ParameterizedMesh} parentNode
     * @param {Number} [lod]
     * @param {Boolean} wireframe
     * @param {MissileLauncher~AddToSceneParams} params 
     * @param {logic~addToSceneCallback} [callback]
     */
    MissileLauncher.prototype.addToSceneNow = function (parentNode, lod, wireframe, params, callback) {
        var visualModel, scale, shader, textures, i, j, count, newVisualModel = false;
        application.log_DEBUG("Adding missile launcher (" + this._class.getName() + ") to scene...", 2);
        scale = this._class.getModel().getScale() / parentNode.getRenderableObject().getScalingMatrix()[0];
        shader = params.shaderName ? graphics.getManagedShader(params.shaderName) : this._class.getShader();
        textures = this._class.getTexturesOfTypes(shader.getTextureTypes(), graphics.getTextureQualityPreferenceList());
        if (!this._visualModels) {
            this._visualModels = [];
            newVisualModel = true;
        }
        for (i = 0; i < this._descriptor.tubePositions.length; i++) {
            count = params.allMissiles ? Math.floor(this._missileCount / this._descriptor.tubePositions.length) + ((this._missileCount % this._descriptor.tubePositions.length > i) ? 1 : 0) : 1;
            for (j = 0; j < count; j++) {
                visualModel = new renderableObjects.ParameterizedMesh(
                        this._class.getModel(),
                        shader,
                        textures,
                        mat.translation4v(vec.sum3(this._descriptor.tubePositions[i], [0, -j * scale * this._class.getLength(), 0])),
                        mat.identity4(),
                        mat.scaling4(scale),
                        (wireframe === true),
                        lod,
                        undefined,
                        _parameterArrays);
                parentNode.addSubnode(new sceneGraph.RenderableNode(visualModel));
                // setting the starting values of the parameter arrays
                // setting an identity transformation for all transform groups
                if (visualModel.hasParameterArray(_groupTransformsArrayName)) {
                    visualModel.setParameterArray(_groupTransformsArrayName, graphics.getGroupTransformIdentityArray());
                }
                // setting the default luminosity for all luminosity groups
                if (graphics.areLuminosityTexturesAvailable() && visualModel.hasParameterArray(_luminosityFactorsArrayName)) {
                    visualModel.setParameterArray(_luminosityFactorsArrayName, this._class.getDefaultGroupLuminosityFactors());
                }
                if (newVisualModel) {
                    this._visualModels.push(visualModel);
                }
                if (callback) {
                    callback(visualModel);
                }
            }
        }
    };
    /**
     * Does all the needed updates to the missile launcher's state for one simulation step.
     * @param {Number} dt The time elapsed since the last simulation step, in milliseconds
     */
    MissileLauncher.prototype.simulate = function (dt) {
        this._cooldown = Math.max(this._cooldown - dt, 0);
        // launch the next missile in the salvo, if we are in one
        if (this._salvoLeft > 0) {
            if (this._cooldown <= 0) {
                if ((this._missileCount > 0) && this._salvoTarget && this._salvoTarget.isAlive()) {
                    if (this.launch(this._spacecraft.getScaledOriMatrix(), this._spacecraft.getSoundSourceForFireSound(), true)) {
                        this._spacecraft.handleSalvoMissileLaunched();
                    }
                } else {
                    // cancel the salvo if we are out of missiles or the salvo target has been destroyed
                    this._salvoLeft = 0;
                    this._salvoTarget = null;
                }
            }
        }
        // if we have the loaded missiles displayed, remove the ones from empty tubes
        // note: this only works properly if only the first missiles were added to the
        // scene, not all! (use all missiles to display loadout in wireframe and first
        // missiles to display the loaded missiles in combat)
        if (this._visualModels !== null) {
            while (this._visualModels.length > this._missileCount) {
                this._visualModels.shift().markAsReusable(true);
            }
        }
    };
    // static auxiliary matrices to be used in the luanch() method (to avoid created new matrices during each execution of the method)
    MissileLauncher._tubePosMatrix = mat.identity4();
    MissileLauncher._missileOriMatrix = mat.identity4();
    /**
     * Launches a missile and adds it (if any) to the passed pool.
     * @param {Float32Array} shipScaledOriMatrix A 4x4 matrix describing the scaling and rotation of the spacecraft having this launcher - it
     * is more effective to calculate it once for a spacecraft and pass it to all launchers as a parameter.
     * @param {SoundSource} shipSoundSource The sound source belonging to the spacecraft this launcher is on
     * @param {Boolean} salvo Whether this is an automatic launch as part of a salvo (the first launch in a salvo is manual)
     * @returns {Missile} The missile that has been launched, if any
     */
    MissileLauncher.prototype.launch = function (shipScaledOriMatrix, shipSoundSource, salvo) {
        var m,
                tubePosVector,
                missileOriMatrix,
                soundPosition,
                scene = this._spacecraft.getVisualModel().getNode().getScene();
        // check missile count and cooldown
        if ((this._missileCount > 0) && (this._cooldown <= 0) && (salvo || (this._salvoLeft <= 0))) {
            if (!salvo) {
                // start a new salvo
                if (this._salvo && this._spacecraft.getTarget()) {
                    this._salvoLeft = this._descriptor.salvo;
                    this._salvoTarget = this._spacecraft.getTarget();
                } else {
                    // if not starting a salvo, set salvoLeft to one so after the launch it will be zero
                    this._salvoLeft = 1;
                }
            }
            this._missileCount--;
            this._salvoLeft--;
            this._cooldown = (this._salvoLeft > 0) ? this._class.getSalvoCooldown() : this._class.getCooldown();
            tubePosVector = vec.prodVec3Mat4Aux(this._descriptor.tubePositions[this._activeTubeIndex], shipScaledOriMatrix);
            mat.setTranslatedByVector(MissileLauncher._tubePosMatrix, this._spacecraft.getPhysicalPositionMatrix(), tubePosVector);
            missileOriMatrix = this.getMissileOrientationMatrix();
            // generate the missile
            m = _missilePool.getObject();
            m.init(
                    this._class,
                    MissileLauncher._tubePosMatrix,
                    missileOriMatrix,
                    this._spacecraft,
                    this._class.getLaunchVelocity(),
                    salvo ? this._salvoTarget : this._spacecraft.getTarget());
            m.addToSceneNow(scene, false, undefined, undefined, true);
            // create the counter-force affecting the firing ship
            this._spacecraft.getPhysicalModel().applyForceAndTorque(
                    tubePosVector,
                    mat.getRowB43Neg(missileOriMatrix),
                    this._class.getForceForDuration(_momentDuration),
                    _momentDuration
                    );
            if (!shipSoundSource) {
                soundPosition = mat.translationVector3(m.getVisualModel().getPositionMatrixInCameraSpace(scene.getCamera()));
            }
            this._class.playLaunchSound(soundPosition, shipSoundSource, _fireSoundStackingTimeThreshold, _fireSoundStackingVolumeFactor);
            this._activeTubeIndex = (this._activeTubeIndex + 1) % this._descriptor.tubePositions.length;
            return m;
        }
        return null;
    };
    /**
     * Whether the missile launcher is ready to launch the next missile
     * @returns {Boolean}
     */
    MissileLauncher.prototype.isReady = function () {
        return (this._cooldown <= 0) && (this._salvoLeft <= 0);
    };
    /**
     * Returns whether the passed spacecraft is within range of the missiles from this launcher.
     * Considers the current velocity of the spacecraft and the target, the launch velocity of the missile, the estimated time
     * it would take for homing missiles to turn towards the target before firing the main engine (based on angular acceleration
     * and main engine burn start threshold angle). Works with the center of the spacecraft and the target, does not consider
     * exact missile start position and target size for simplicity's sake (and to increase margin for error) as well as possible
     * range lost due to maneuvering on a curve instead of a straight line if the main burn start threshold angle is significant.
     * Also considers locking angle for homing missiles - is the target is outside of the allowed angle, it is considered out of
     * range
     * @param {Spacecraft} target
     * @returns {Boolean}
     */
    MissileLauncher.prototype.isInLockingRange = function (target) {
        var driftTime, burnTime, position, targetPosition, orientationMatrix, turnAngles, maxTurnAngle, turnTime, velocityVector, relativeTargetVelocity, angularAcceleration;
        orientationMatrix = this._spacecraft.getPhysicalOrientationMatrix();
        // velocity vector for the original drifting of the missile after it is launched, before igniting main engine
        velocityVector = vec.sum3(mat.translationVector3(this._spacecraft.getVelocityMatrix()), vec.scaled3Aux(mat.getRowB43(orientationMatrix), this._class.getLaunchVelocity()));
        relativeTargetVelocity = vec.diff3(mat.translationVector3(target.getVelocityMatrix()), velocityVector);
        driftTime = 0.001 * this._class.getIgnitionTime();
        // first, consider drifting after launch
        position = this._spacecraft.getPhysicalPositionVector();
        targetPosition = vec.sum3(target.getPhysicalPositionVector(), vec.scaled3Aux(relativeTargetVelocity, driftTime));
        // consider turning before firing main engine
        if (this._class.getHomingMode() === classes.MissileHomingMode.NONE) {
            turnTime = 0;
        } else {
            turnAngles = vec.getYawAndPitch(vec.normalize3(vec.prodVec3Mat4Aux(
                    vec.diff3(targetPosition, position),
                    mat.inverseOfRotation4Aux(orientationMatrix))));
            turnAngles.yaw = Math.abs(turnAngles.yaw);
            turnAngles.pitch = Math.abs(turnAngles.pitch);
            if (this._class.getLockingAngle() > 0) {
                if (Math.max(turnAngles.yaw, turnAngles.pitch) > this._class.getLockingAngle()) {
                    return false;
                }
            }
            maxTurnAngle = Math.max(0, Math.max(turnAngles.yaw, turnAngles.pitch) - this._class.getMainBurnAngleThreshold());
            angularAcceleration = this._class.getAngularAcceleration();
            turnTime = (angularAcceleration * MISSILE_TURN_ACCELERATION_DURATION_S * MISSILE_TURN_ACCELERATION_DURATION_S + maxTurnAngle) / (angularAcceleration * MISSILE_TURN_ACCELERATION_DURATION_S);
            if (turnTime < 2 * MISSILE_TURN_ACCELERATION_DURATION_S) {
                turnTime = Math.sqrt(4 * maxTurnAngle / angularAcceleration);
            }
            targetPosition = vec.sum3(targetPosition, vec.scaled3Aux(relativeTargetVelocity, turnTime));
        }
        // consider the phase accelerating towards the target (assuming straight line for simplicity)
        burnTime = 0.001 * this._class.getDuration() - driftTime - turnTime;
        return this._class.getTargetHitTime(position, targetPosition, relativeTargetVelocity) < burnTime;
    };
    /**
     * Returns the amount of score points to be added to the total score value of spacecrafts that have this launcher
     * (and the missiles loaded to it) equipped
     * @returns {Number}
     */
    MissileLauncher.prototype.getScoreValue = function () {
        return this._class.getScoreValue() * this._missileCount;
    };
    /**
     * Returns the amount of missiles currently loaded into this launcher.
     * @returns {Number}
     */
    MissileLauncher.prototype.getMissileCount = function () {
        return this._missileCount;
    };
    /**
     * Returns whether this missile launcher still has missiles loaded in it which are not yet queued for launch
     * @returns {Number}
     */
    MissileLauncher.prototype.hasMissilesLeftToLaunch = function () {
        return this._missileCount > this._salvoLeft;
    };
    /**
     * Returns the highest number of missiles that might be simultaneously used (flying, rendered on the battle)
     * for this launcher in one battle.
     * @returns {Number}
     */
    MissileLauncher.prototype.getMaxMissileCount = function () {
        return Math.min(this._missileCount, this._class.getMaxCount());
    };
    /**
     * Returns the highest number of explosions that might be used for this launcher simultaneously in one battle.
     * @returns {Number}
     */
    MissileLauncher.prototype.getMaxExplosionCount = function () {
        // all the missiles might theoretically explode at the same time
        return this.getMaxMissileCount();
    };
    /**
     * Returns the highest number of particles that might be used (rendered) for this launcher simultaneously in one battle.
     * @returns {Number}
     */
    MissileLauncher.prototype.getMaxParticleCount = function () {
        return this.getMaxMissileCount() * this._class.getParticleCount();
    };
    /**
     * Removes all references stored by this object
     */
    MissileLauncher.prototype.destroy = function () {
        var i;
        this._class = null;
        this._spacecraft = null;
        this._descriptor = null;
        this._salvoTarget = null;
        if (this._visualModels !== null) {
            for (i = 0; i < this._visualModels.length; i++) {
                this._visualModels[i].markAsReusable(true);
            }
            this._visualModels = null;
        }
    };
    // #########################################################################
    /**
     * @class The targeting computer keeps track of all targeting related data and performs targeting related tasks for the spacecraft it
     * is equipped on.
     * @param {Spacecraft} spacecraft The spacecraft this computer is equipped on
     * @param {Spacecraft[]} spacecraftArray The list of spacecrafts from which this computer can choose its target
     * @param {Environment} [environment] The environment the host spacecraft is situated in
     */
    function TargetingComputer(spacecraft, spacecraftArray, environment) {
        /**
         * The spacecraft this computer is equipped on
         * @type Spacecraft
         */
        this._spacecraft = spacecraft;
        /**
         * The currently targeted spacecraft.
         * @type Spacecraft
         */
        this._target = null;
        /**
         * The list of spacecrafts from which this computer can choose its target
         * @type Spacecraft[]
         */
        this._spacecraftArray = spacecraftArray || null;
        /**
         * Cached value of the estimated future target position where the spacecraft should fire to hit it.
         * @type Number[3]
         */
        this._targetHitPosition = null;
        /**
         * A cached list of hostile targets from the list, ordered based on how much the spacecrat needs to turn to face them
         * @type Spacecraft[]
         */
        this._orderedHostileTargets = null;
        /**
         * A cached list of non-hostile targets from the list, ordered based on how much the spacecrat needs to turn to face them
         * @type Spacecraft[]
         */
        this._orderedNonHostileTargets = null;
        /**
         * The amount of time while the current ordered hostile list is still valid and should be used for cycling targets, in milliseconds
         * @type Number
         */
        this._timeUntilHostileOrderReset = 0;
        /**
         * The amount of time while the current ordered non-hostile list is still valid and should be used for cycling targets, in milliseconds
         * @type Number
         */
        this._timeUntilNonHostileOrderReset = 0;
        /**
         * The missile launcher for which the computer is locking the current target
         * @type MissileLauncher
         */
        this._missileLauncher = null;
        /**
         * The total amount of time needed until the current target is locked for missile launch, in milliseconds
         * @type Number
         */
        this._lockTime = 1;
        /**
         * The amount of time remaining until the current target is locked for missile launch, in milliseconds
         * @type Number
         */
        this._lockTimeLeft = 1;
        /**
         * Missile locking time is multiplied by this factor
         * @type Number
         */
        this._lockingTimeFactor = environment ? environment.getLockingTimeFactor() : 1;
    }
    /**
     * Reset locking time and time remaining according to missile launcher and target characteristics
     */
    TargetingComputer.prototype._resetMissileLock = function () {
        this._lockTime = (this._target && this._missileLauncher) ? (this._target.getLockingTimeFactor() * this._lockingTimeFactor * this._missileLauncher.getLockingTime()) : 1;
        this._lockTimeLeft = this._lockTime;
    };
    /**
     * Whether the current target is locked for missile launch
     * @returns {Boolean}
     */
    TargetingComputer.prototype.isMissileLocked = function () {
        return this._lockTimeLeft <= 0;
    };
    /**
     * Returns the progress ratio of the current missile locking process (0: not locked, 1: missile locked)
     * @returns {Number}
     */
    TargetingComputer.prototype.getMissileLockRatio = function () {
        return 1 - (this._lockTimeLeft / this._lockTime);
    };
    /**
     * Set a new missile launcher to use for locking on to the target with missiles
     * @param {MissileLauncher} missileLauncher 
     */
    TargetingComputer.prototype.setMissileLauncher = function (missileLauncher) {
        if (!this._missileLauncher || !missileLauncher || (missileLauncher.getMissileClass() !== this._missileLauncher.getMissileClass())) {
            this._missileLauncher = missileLauncher;
            this._resetMissileLock();
        } else {
            this._missileLauncher = missileLauncher;
        }
    };
    /**
     * Targets the given spacecraft and executes related operations, such as changing target views. 
     * @param {Spacecraft|null} target If null is given, the current target will be canceled.
     */
    TargetingComputer.prototype.setTarget = function (target) {
        var i, camConfigs, node, camera;
        if (target !== this._target) {
            if (this._target) {
                this._target.setBeingUntargeted(this._spacecraft);
            }
            this._target = target;
            this._targetHitPosition = null;
            if (this._spacecraft.getVisualModel()) {
                node = this._spacecraft.getVisualModel().getNode();
                camera = node.getScene().getCamera();
                // set the target following views to follow the new target
                camConfigs = node.getCameraConfigurationsWithName(config.getSetting(config.BATTLE_SETTINGS.TARGET_VIEW_NAME));
                for (i = 0; i < camConfigs.length; i++) {
                    if (camera.getConfiguration() === camConfigs[i]) {
                        camera.transitionToSameConfiguration(
                                config.getSetting(config.BATTLE_SETTINGS.TARGET_CHANGE_TRANSITION_DURATION),
                                config.getSetting(config.BATTLE_SETTINGS.TARGET_CHANGE_TRANSITION_STYLE));
                    }
                    camConfigs[i].setOrientationFollowedObjects(this._target ? [this._target.getVisualModel()] : [], true);
                }
            }
            if (this._target) {
                this._target.setBeingTargeted(this._spacecraft);
            }
            this._resetMissileLock();
        }
    };
    /**
     * Used to filter the potential target list to include only hostiles
     * @param {Spacecraft} craft
     * @returns {unresolved}
     */
    TargetingComputer.prototype._filterHostileTarget = function (craft) {
        return this._spacecraft.isHostile(craft);
    };
    /**
     * Used to filter the potential target list to include only non-hostiles
     * @param {Spacecraft} craft
     * @returns {Boolean}
     */
    TargetingComputer.prototype._filterNonHostileTarget = function (craft) {
        return (craft !== this._spacecraft) && !this._spacecraft.isHostile(craft);
    };
    /**
     * @typedef {Object} TargetingComputer~MappedTarget
     * @property {Number} index The index of the potential target within the unordered target array
     * @property {Number} value The numerical value assigned to this potential target based on which it can be ordered (in ascending order)
     */
    /**
     * @callback TargetingComputer~mappingFunction
     * @param {Spacecraft} craft
     * @param {Number} index
     * @returns {TargetingComputer~MappedTarget}
     */
    /**
     * Maps the passed spacecraft to an object that contains a numeric value based on which it should be placed in the ordered target list
     * (ascending), as well as includes the passed, original index in the object
     * Calculates the value based on the bearing of the spacecraft, favouring targets that are closer to the direction vector of the
     * spacecraft.
     * @param {Spacecraft} craft
     * @param {Number} index
     * @returns {TargetingComputer~MappedTarget}
     */
    TargetingComputer.prototype._mapTargetByBearing = function (craft, index) {
        return {
            index: index,
            value: vec.angle3u(
                    mat.getRowB43(this._spacecraft.getPhysicalOrientationMatrix()),
                    vec.normalize3(vec.diff3(
                            craft.getPhysicalPositionVector(), this._spacecraft.getPhysicalPositionVector())))
        };
    };
    /**
     * Maps the passed spacecraft to an object that contains a numeric value based on which it should be placed in the ordered target list
     * (ascending), as well as includes the passed, original index in the object
     * Calculates the value based on a complex formula that represents how ideal the target is. (to be used for the AI)
     * @param {Spacecraft} craft
     * @param {Number} index
     * @returns {TargetingComputer~MappedTarget}
     */
    TargetingComputer.prototype._mapTargetToCombinedValue = function (craft, index) {
        var
                vector = vec.diffTranslation3(craft.getPhysicalPositionMatrix(), this._spacecraft.getPhysicalPositionMatrix()),
                distance = vec.extractLength3(vector);
        return {
            index: index,
            value: (distance +
                    TARGET_MAPPING_ANGLE_FACTOR * vec.angle3u(
                            mat.getRowB43(this._spacecraft.getPhysicalOrientationMatrix()),
                            vector)
                    ) *
                    (this._spacecraft.isGoodAgainst(craft) ? TARGET_MAPPING_GOOD_AGAINST_FACTOR : (
                            this._spacecraft.isBadAgainst(craft) ? TARGET_MAPPING_BAD_AGAINST_FACTOR : 1))
        };
    };
    /**
     * Can be used for sorting the list of mapped target objects
     * @param {TargetingComputer~MappedTarget} first
     * @param {TargetingComputer~MappedTarget} second
     * @returns {Number}
     */
    TargetingComputer._compareMappedTargets = function (first, second) {
        return first.value - second.value;
    };
    /**
     * If the current cached ordered hostile target list is not valid, created a new ordered list based on the current game state.
     * @param {TargetingComputer~mappingFunction} mapFunction The mapping function to use on which the order will depend.
     * @returns {Boolean} Whether the list was updated
     */
    TargetingComputer.prototype._updateHostileOrder = function (mapFunction) {
        var filteredTargets, orderedMappedTargets, i;
        if (this._spacecraftArray) {
            filteredTargets = this._spacecraftArray.filter(this._filterHostileTarget, this);
            // if the order is invalid (expired), generate a new list with a new, up-to-date order
            if (this._timeUntilHostileOrderReset <= 0) {
                orderedMappedTargets = filteredTargets.map(mapFunction, this).sort(TargetingComputer._compareMappedTargets);
                this._orderedHostileTargets = [];
                for (i = 0; i < orderedMappedTargets.length; i++) {
                    this._orderedHostileTargets.push(filteredTargets[orderedMappedTargets[i].index]);
                }
                return true;
            } else {
                // if the order was not updated, still check for new potential targets (e.g. ships that
                // jumped in) and append them to the list
                for (i = 0; i < filteredTargets.length; i++) {
                    if (this._orderedHostileTargets.indexOf(filteredTargets[i]) < 0) {
                        this._orderedHostileTargets.push(filteredTargets[i]);
                    }
                }
            }
        }
        return false;
    };
    /**
     * If the current cached ordered non-hostile target list is not valid, created a new ordered list based on the current game state.
     * @returns {Boolean} Whether the list was updated
     */
    TargetingComputer.prototype._updateNonHostileOrder = function () {
        var filteredTargets, orderedMappedTargets, i;
        if (this._spacecraftArray) {
            filteredTargets = this._spacecraftArray.filter(this._filterNonHostileTarget, this);
            // if the order is invalid (expired), generate a new list with a new, up-to-date order
            if (this._timeUntilNonHostileOrderReset <= 0) {
                orderedMappedTargets = filteredTargets.map(this._mapTargetByBearing, this).sort(TargetingComputer._compareMappedTargets);
                this._orderedNonHostileTargets = [];
                for (i = 0; i < orderedMappedTargets.length; i++) {
                    this._orderedNonHostileTargets.push(filteredTargets[orderedMappedTargets[i].index]);
                }
                return true;
            } else {
                // if the order was not updated, still check for new potential targets (e.g. ships that
                // jumped in) and append them to the list
                for (i = 0; i < filteredTargets.length; i++) {
                    if (this._orderedNonHostileTargets.indexOf(filteredTargets[i]) < 0) {
                        this._orderedNonHostileTargets.push(filteredTargets[i]);
                    }
                }
            }
        }
        return false;
    };
    /**
     * Can be used to check whether a target chosen from one of the cached ordered list is a valid new target
     * @param {Spacecraft} craft
     * @returns {Boolean}
     */
    TargetingComputer.prototype._isValidNewTarget = function (craft) {
        // the game state might have changed, since the ordered list was cached, so check if the craft is still alive and present
        return craft.isAlive() && !craft.isAway() && (craft !== this._target);
    };
    /**
     * Targets the next spacecraft, ordering the potential targets using the passed mapping function.
     * @param {TargetingComputer~mappingFunction} mapFunction
     * @returns {Boolean} Whether a new spacecraft has been targeted
     */
    TargetingComputer.prototype._targetNextHostile = function (mapFunction) {
        var index, count, length, newOrder = this._updateHostileOrder(mapFunction);
        if (this._orderedHostileTargets && (this._orderedHostileTargets.length > 0)) {
            // the game state might have changed since the ordered list was updated, so check until we find a still valid target
            length = this._orderedHostileTargets.length;
            index = newOrder ? 0 : (this._orderedHostileTargets.indexOf(this._target) + 1) % length;
            // count invalid targets in the array
            count = 0;
            while ((count < length) && !this._isValidNewTarget(this._orderedHostileTargets[index])) {
                index = (index + 1) % length;
                count++;
            }
            // if there is at least one valid target, select it
            if (count < length) {
                this.setTarget(this._orderedHostileTargets[index]);
                this._timeUntilHostileOrderReset = config.getSetting(config.BATTLE_SETTINGS.TARGET_ORDER_DURATION);
                return true;
            }
        }
        this._timeUntilHostileOrderReset = 0;
        return false;
    };
    /**
     * Targets the previous spacecraft, ordering the potential targets using the passed mapping function.
     * @param {TargetingComputer~mappingFunction} mapFunction
     * @returns {Boolean} Whether a new spacecraft has been targeted
     */
    TargetingComputer.prototype._targetPreviousHostile = function (mapFunction) {
        var index, count, length, newOrder = this._updateHostileOrder(mapFunction);
        if (this._orderedHostileTargets && (this._orderedHostileTargets.length > 0)) {
            // the game state might have changed since the ordered list was updated, so check until we find a still valid target
            length = this._orderedHostileTargets.length;
            index = newOrder ? (length - 1) : (this._orderedHostileTargets.indexOf(this._target) + length - 1) % length;
            // count invalid targets in the array
            count = 0;
            while ((count < length) && !this._isValidNewTarget(this._orderedHostileTargets[index])) {
                index = (index + length - 1) % length;
                count++;
            }
            // if there is at least one valid target, select it
            if (count < length) {
                this.setTarget(this._orderedHostileTargets[index]);
                this._timeUntilHostileOrderReset = config.getSetting(config.BATTLE_SETTINGS.TARGET_ORDER_DURATION);
                return true;
            }
        }
        this._timeUntilHostileOrderReset = 0;
        return false;
    };
    /**
     * Targets the next hostile spacecraft, ordering the hostiles based on the angle between the spacecraft's direction and the vector
     * pointing to the hostile spacecraft
     * @returns {Boolean} Whether a new spacecraft has been targeted
     */
    TargetingComputer.prototype.targetNextNearestHostile = function () {
        return this._targetNextHostile(this._mapTargetByBearing);
    };
    /**
     * Targets the previous hostile spacecraft, ordering the hostiles based on the angle between the spacecraft's direction and the vector
     * pointing to the hostile spacecraft
     * @returns {Boolean} Whether a new spacecraft has been targeted
     */
    TargetingComputer.prototype.targetPreviousNearestHostile = function () {
        return this._targetPreviousHostile(this._mapTargetByBearing);
    };
    /**
     * Targets the next hostile spacecraft, ordering the hostiles based on a complex evaluation of how fitting targets they are.
     * (to be used by the AI)
     * @returns {Boolean}
     */
    TargetingComputer.prototype.targetNextBestHostile = function () {
        return this._targetNextHostile(this._mapTargetToCombinedValue);
    };
    /**
     * Targets the next non-hostile (friendly or neutral) spacecraft, ordering the hostiles based on the angle between the spacecraft's 
     * direction and the vector pointing to the hostile spacecraft
     * @returns {Boolean} Whether a new spacecraft has been targeted
     */
    TargetingComputer.prototype.targetNextNearestNonHostile = function () {
        var index, count, length, newOrder = this._updateNonHostileOrder();
        if (this._orderedNonHostileTargets && (this._orderedNonHostileTargets.length > 0)) {
            // the game state might have changed since the ordered list was updated, so check until we find a still valid target
            length = this._orderedNonHostileTargets.length;
            index = newOrder ? 0 : (this._orderedNonHostileTargets.indexOf(this._target) + 1) % length;
            // count invalid targets in the array
            count = 0;
            while ((count < length) && !this._isValidNewTarget(this._orderedNonHostileTargets[index])) {
                index = (index + 1) % length;
                count++;
            }
            // if there is at least one valid target, select it
            if (count < length) {
                this.setTarget(this._orderedNonHostileTargets[index]);
                this._timeUntilNonHostileOrderReset = config.getSetting(config.BATTLE_SETTINGS.TARGET_ORDER_DURATION);
                return true;
            }
        }
        this._timeUntilNonHostileOrderReset = 0;
        return false;
    };
    /**
     * Returns the currently targeted spacecraft.
     * @returns {Spacecraft|null}
     */
    TargetingComputer.prototype.getTarget = function () {
        if (this._target && (this._target.canBeReused() || this._target.isAway())) {
            this.setTarget(null);
        }
        return this._target;
    };
    /**
     * Returns the estimated position towards which the spacecraft needs to fire to hit its current target in case both itself and the 
     * target retain their current velocity, based on the speed of the projectile fired from the first barrel of the first equipped weapon.
     * @returns {Number[3]}
     */
    TargetingComputer.prototype.getTargetHitPosition = function () {
        var
                position, targetPosition,
                relativeTargetVelocity,
                weapons,
                projectileSpeed,
                a, b, c, i, hitTime;
        if (!this._targetHitPosition) {
            targetPosition = this._target.getPhysicalPositionVector();
            weapons = this._spacecraft.getWeapons();
            if (weapons.length === 0) {
                return targetPosition;
            }
            position = this._spacecraft.getPhysicalPositionVector();
            relativeTargetVelocity = vec.diffTranslation3(this._target.getVelocityMatrix(), this._spacecraft.getVelocityMatrix());
            projectileSpeed = weapons[0].getProjectileVelocity();
            a = projectileSpeed * projectileSpeed - (relativeTargetVelocity[0] * relativeTargetVelocity[0] + relativeTargetVelocity[1] * relativeTargetVelocity[1] + relativeTargetVelocity[2] * relativeTargetVelocity[2]);
            b = 0;
            for (i = 0; i < 3; i++) {
                b += (2 * relativeTargetVelocity[i] * (position[i] - targetPosition[i]));
            }
            c = 0;
            for (i = 0; i < 3; i++) {
                c += (-targetPosition[i] * targetPosition[i] - position[i] * position[i] + 2 * targetPosition[i] * position[i]);
            }
            hitTime = utils.getGreaterSolutionOfQuadraticEquation(a, b, c);
            this._targetHitPosition = [
                targetPosition[0] + hitTime * relativeTargetVelocity[0],
                targetPosition[1] + hitTime * relativeTargetVelocity[1],
                targetPosition[2] + hitTime * relativeTargetVelocity[2]
            ];
        }
        return this._targetHitPosition;
    };
    /**
     * Updates the internal state of the computer for the current simulation step
     * @param {Number} dt The time elapsed since the last simulation step, in milliseconds
     */
    TargetingComputer.prototype.simulate = function (dt) {
        if (this._target && (this._target.canBeReused() || this._target.isAway())) {
            this.setTarget(null);
        }
        this._targetHitPosition = null;
        if (this._timeUntilHostileOrderReset > 0) {
            this._timeUntilHostileOrderReset -= dt;
        }
        if (this._timeUntilNonHostileOrderReset > 0) {
            this._timeUntilNonHostileOrderReset -= dt;
        }
        if (this._target && this._missileLauncher && this._missileLauncher.hasMissilesLeftToLaunch() && (this._missileLauncher.isInLockingRange(this._target))) {
            this._lockTimeLeft = Math.max(0, this._lockTimeLeft - dt);
        } else {
            this._resetMissileLock();
        }
    };
    /**
     * Removes all references from this object
     */
    TargetingComputer.prototype.destroy = function () {
        this._spacecraft = null;
        this._spacecraftArray = null;
        this._target = null;
        this._targetHitPosition = null;
        this._orderedHostileTargets = null;
        this._orderedNonHostileTargets = null;
        this._missileLauncher = null;
    };
    // #########################################################################
    /**
     * @class Represents a thruster on a spacecraft.
     * @param {PropulsionClass} propulsionClass
     * @param {ThusterSlot} slot The thruster slot to which this thruster is
     * equipped.
     */
    function Thruster(propulsionClass, slot) {
        /**
         * @type PropulsionClass
         */
        this._propulsionClass = propulsionClass;
        /**
         * The thruster slot to which this thruster is equipped.
         * @type ThrusterSlot
         */
        this._slot = slot;
        /**
         * The renderable object that is used to render the thruster burn particle.
         * @type RenderableObject
         */
        this._visualModel = null;
        /**
         * The renderable object corresponding to the ship this thruster is located on.
         * @type RenderableObject
         */
        this._shipModel = null;
        /**
         * The level of intensity this thuster is currently used with. (0 is off, 1 is maximum)
         * @type Number
         */
        this._burnLevel = 0;
        /**
         * Maximum thrust for acceleration is applied at this burn level. (cache variable)
         * @type Number
         */
        this._maxMoveBurnLevel = this._propulsionClass.getMaxMoveBurnLevel();
    }
    /**
     * @type PropulsionClass~ResourceParams
     */
    Thruster.PROPULSION_RESOURCE_PARAMS = {sound: true};
    /**
     * Adds a renderable node representing the particle that is rendered to show
     * the burn level of this thruster to the scene under the passed parent node.
     * @param {ParameterizedMesh} parentNode The parent node to which to attach the
     * particle in the scene. (normally the renderable node of the spacecraft
     * that has this thruster)
     * @param {Boolean} [replaceVisualModel=false] Whether to set the newly created
     * renderable node as the visual model of the thruster even if one already
     * existed before
     */
    Thruster.prototype.addToScene = function (parentNode, replaceVisualModel) {
        var visualModel;
        this._propulsionClass.acquireResources(Thruster.PROPULSION_RESOURCE_PARAMS);
        resources.executeWhenReady(function () {
            visualModel = renderableObjects.staticParticle(
                    this._propulsionClass.getThrusterBurnParticle().getModel(),
                    this._propulsionClass.getThrusterBurnParticle().getShader(),
                    this._propulsionClass.getThrusterBurnParticle().getTexturesOfTypes(this._propulsionClass.getThrusterBurnParticle().getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                    this._propulsionClass.getThrusterBurnParticle().getColor(),
                    this._slot.size,
                    mat.translation4v(this._slot.positionVector),
                    this._propulsionClass.getThrusterBurnParticle().getInstancedShader());
            visualModel.setRelativeSize(0);
            parentNode.addSubnode(new sceneGraph.RenderableNode(visualModel, false, false, config.getSetting(config.BATTLE_SETTINGS.MINIMUM_THRUSTER_PARTICLE_COUNT_FOR_INSTANCING)));
            if (!this._visualModel || replaceVisualModel) {
                if (this._visualModel) {
                    this._visualModel.markAsReusable(true);
                }
                this._visualModel = visualModel;
                this._shipModel = parentNode.getRenderableObject();
            }
        }.bind(this));
    };
    /**
     * Updates the visual representation of this thruster to represent the current burn level.
     */
    Thruster.prototype.updateVisuals = function () {
        // set the size of the particle that shows the burn
        this._visualModel.setRelativeSize(this._burnLevel);
        // set the strength of which the luminosity texture is lighted
        if (graphics.areLuminosityTexturesAvailable()) {
            this._shipModel.setFloatParameter(
                    _luminosityFactorsArrayName,
                    this._slot.group,
                    Math.min(1.0, this._burnLevel / this._maxMoveBurnLevel));
        }
    };
    /**
     * Sets the burn level of this thruster to zero.
     */
    Thruster.prototype.resetBurn = function () {
        this._burnLevel = 0;
    };
    /**
     * Adds the passed value to the current burn level of this thruster.
     * @param {Number} value
     */
    Thruster.prototype.addBurn = function (value) {
        this._burnLevel += value;
    };
    /**
     * Removes all references stored by this object
     */
    Thruster.prototype.destroy = function () {
        this._propulsionClass = null;
        this._slot = null;
        if (this._visualModel) {
            this._visualModel.markAsReusable(true);
        }
        this._visualModel = null;
        this._shipModel = null;
    };
    // #########################################################################
    /**
     * @class Represents the propulsion system equipped to a spacecraft.
     * @param {PropulsionClass} propulsionClass The class describing the general
     * properties of this propulsion.
     * @param {PhysicalObject} drivenPhysicalObject The physical object that is
     * driven by this propulsion (the physical model of the spacecraft)
     */
    function Propulsion(propulsionClass, drivenPhysicalObject) {
        /**
         * The class describing the general properties of this propulsion.
         * @type PropulsionClass
         */
        this._class = propulsionClass;
        /**
         * The physical object that is driven by this propulsion (the physical 
         * model of the spacecraft)
         * @type PhysicalObject
         */
        this._drivenPhysicalObject = drivenPhysicalObject;
        /**
         * An array storing direct references to all the thrusters.
         * @type Thruster[]
         */
        this._thrusters = [];
        /**
         * The burn level and nozzles associated with each thruster use command.
         * @type Object
         */
        this._forward = {burn: 0, thrusters: []};
        this._reverse = {burn: 0, thrusters: []};
        this._strafeLeft = {burn: 0, thrusters: []};
        this._strafeRight = {burn: 0, thrusters: []};
        this._raise = {burn: 0, thrusters: []};
        this._lower = {burn: 0, thrusters: []};
        this._yawLeft = {burn: 0, thrusters: []};
        this._yawRight = {burn: 0, thrusters: []};
        this._pitchUp = {burn: 0, thrusters: []};
        this._pitchDown = {burn: 0, thrusters: []};
        this._rollLeft = {burn: 0, thrusters: []};
        this._rollRight = {burn: 0, thrusters: []};
        /**
         * Sound clip used for playing the thruster sound effect for this propulsion.
         * @type SoundClip
         */
        this._thrusterSoundClip = null;
        // the continuous forces and torques used to move the ship
        /**
         * Torque to rotate along Z axis (yaw left/right)
         * @type Torque
         */
        this._yawTorque = null;
        /**
         * Torque to rotate along X axis (pitch up/down)
         * @type Torque
         */
        this._pitchTorque = null;
        /**
         * Torque to rotate along Y axis (roll left/right)
         * @type Torque
         */
        this._rollTorque = null;
        // cache variables
        /**
         * Cached value to calculate thrust forces faster
         * @type Number
         */
        this._thrustFactor = this._class.getThrust() / this._class.getMaxMoveBurnLevel();
        /**
         * Cached value to calculate angular thrust torques faster
         * @type Number
         */
        this._angularThrustFactor = this._class.getAngularThrust() / this._class.getMaxTurnBurnLevel();
    }
    /**
     * Nulls out the stored forces and torques - to be called afte the physical model of the spacecraft is reset and so
     * the forces and torques should be readded to it.
     */
    Propulsion.prototype.resetForcesAndTorques = function () {
        this._yawTorque = null;
        this._pitchTorque = null;
        this._rollTorque = null;
    };
    /**
     * @param {PropulsionClass~ResourceParams} params 
     */
    Propulsion.prototype.acquireResources = function (params) {
        this._class.acquireResources(params);
    };
    /**
     * Returns the name of the propulsion system in a way that can be displayed to the user (translated)
     * @returns {String}
     */
    Propulsion.prototype.getDisplayName = function () {
        return this._class.getDisplayName();
    };
    /**
     * Returns the thrust power of this propulsion system, in newtowns.
     * @returns {Number}
     */
    Propulsion.prototype.getThrust = function () {
        return this._class.getThrust();
    };
    /**
     * Returns the angular thrust power of this propulsion system, measured in
     * kg*rad/s^2.
     * @returns {Number}
     */
    Propulsion.prototype.getAngularThrust = function () {
        return this._class.getAngularThrust();
    };
    /**
     * Returns the maximum move burn level of the class of this propulsion
     * @returns {Number}
     */
    Propulsion.prototype.getMaxMoveBurnLevel = function () {
        return this._class.getMaxMoveBurnLevel();
    };
    /**
     * Returns the maximum turn burn level of the class of this propulsion
     * @returns {Number}
     */
    Propulsion.prototype.getMaxTurnBurnLevel = function () {
        return this._class.getMaxTurnBurnLevel();
    };
    /**
     * Returns the object storing the burn level and thruster list associated
     * with the passed thruster use command
     * @param {String} name
     * @returns {Object}
     */
    Propulsion.prototype.getThrusterUse = function (name) {
        switch (name) {
            case ThrusterUse.FORWARD:
                return this._forward;
            case ThrusterUse.REVERSE:
                return this._reverse;
            case ThrusterUse.STRAFE_LEFT:
                return this._strafeLeft;
            case ThrusterUse.STRAFE_RIGHT:
                return this._strafeRight;
            case ThrusterUse.RAISE:
                return this._raise;
            case ThrusterUse.LOWER:
                return this._lower;
            case ThrusterUse.YAW_LEFT:
                return this._yawLeft;
            case ThrusterUse.YAW_RIGHT:
                return this._yawRight;
            case ThrusterUse.PITCH_UP:
                return this._pitchUp;
            case ThrusterUse.PITCH_DOWN:
                return this._pitchDown;
            case ThrusterUse.ROLL_LEFT:
                return this._rollLeft;
            case ThrusterUse.ROLL_RIGHT:
                return this._rollRight;
            default:
                application.showError("Invalid thruster use specified: '" + name + "'!", application.ErrorSeverity.SEVERE);
                return null;
        }
    };
    /**
     * Creates and adds thruster objects to all the thruster slots in the passed
     * array
     * @param {ThrusterSlot[]} slots
     */
    Propulsion.prototype.addThrusters = function (slots) {
        var i, j, thruster, use;
        for (i = 0; i < slots.length; i++) {
            thruster = new Thruster(this._class, slots[i]);
            this._thrusters.push(thruster);
            for (j = 0; j < slots[i].uses.length; j++) {
                use = this.getThrusterUse(slots[i].uses[j]);
                if (use) {
                    use.thrusters.push(thruster);
                }
            }
        }
    };
    /**
     * Adds all necessary renderable objects under the passed parent node that
     * can be used to render the propulsion system (and its thrusters).
     * @param {RenderableNode} parentNode
     */
    Propulsion.prototype.addToScene = function (parentNode) {
        var i;
        for (i = 0; i < this._thrusters.length; i++) {
            this._thrusters[i].addToScene(parentNode, false);
        }
    };
    /**
     * Adds to the thruster burn level corresponding to the thrusters of the passed 
     * use command.
     * This is slow, only to be used in non-performance-critical cases, when
     * the specific thruster use is not known. Otherwise, use the specific
     * methods for each thruster use instead. (below)
     * @param {String} use The use identifying which thrusters' level to increase. 
     * e.g. "forward" or "yawLeft"
     * @param {Number} value The amount added to the thruster burn level.
     */
    Propulsion.prototype.addThrusterBurn = function (use, value) {
        _addThrusterBurn(this.getThrusterUse(use), value);
    };
    Propulsion.prototype.addThrusterBurnForward = function (value) {
        _addThrusterBurn(this._forward, value);
    };
    Propulsion.prototype.addThrusterBurnReverse = function (value) {
        _addThrusterBurn(this._reverse, value);
    };
    Propulsion.prototype.addThrusterBurnLeft = function (value) {
        _addThrusterBurn(this._strafeLeft, value);
    };
    Propulsion.prototype.addThrusterBurnRight = function (value) {
        _addThrusterBurn(this._strafeRight, value);
    };
    Propulsion.prototype.addThrusterBurnUp = function (value) {
        _addThrusterBurn(this._raise, value);
    };
    Propulsion.prototype.addThrusterBurnDown = function (value) {
        _addThrusterBurn(this._lower, value);
    };
    Propulsion.prototype.addThrusterBurnYawLeft = function (value) {
        _addThrusterBurn(this._yawLeft, value);
    };
    Propulsion.prototype.addThrusterBurnYawRight = function (value) {
        _addThrusterBurn(this._yawRight, value);
    };
    Propulsion.prototype.addThrusterBurnPitchUp = function (value) {
        _addThrusterBurn(this._pitchUp, value);
    };
    Propulsion.prototype.addThrusterBurnPitchDown = function (value) {
        _addThrusterBurn(this._pitchDown, value);
    };
    Propulsion.prototype.addThrusterBurnRollLeft = function (value) {
        _addThrusterBurn(this._rollLeft, value);
    };
    Propulsion.prototype.addThrusterBurnRollRight = function (value) {
        _addThrusterBurn(this._rollRight, value);
    };
    /**
     * Resets the all the thruster burn levels to zero.
     */
    Propulsion.prototype.resetThrusterBurn = function () {
        var i;
        this._forward.burn = 0;
        this._reverse.burn = 0;
        this._strafeLeft.burn = 0;
        this._strafeRight.burn = 0;
        this._raise.burn = 0;
        this._lower.burn = 0;
        this._yawLeft.burn = 0;
        this._yawRight.burn = 0;
        this._pitchUp.burn = 0;
        this._pitchDown.burn = 0;
        this._rollLeft.burn = 0;
        this._rollRight.burn = 0;
        for (i = 0; i < this._thrusters.length; i++) {
            this._thrusters[i].resetBurn();
        }
    };
    /**
     * Updates the visual representations of all thrusters of this propulsion to represent their current burn levels.
     */
    Propulsion.prototype.updateVisuals = function () {
        var i;
        for (i = 0; i < this._thrusters.length; i++) {
            this._thrusters[i].updateVisuals();
        }
    };
    /**
     * Returns the (relative) volume at which the thruster sound effect should be played for this propulsion accoding to its current
     * state (how much its thrusters are firing)
     * @returns {Number}
     */
    Propulsion.prototype._getSoundVolume = function () {
        var move, turn, max;
        max = this._class.getMaxMoveBurnLevel();
        move = max ? Math.max(
                this._forward.burn, this._reverse.burn,
                this._strafeRight.burn, this._strafeLeft.burn,
                this._raise.burn, this._lower.burn) / max : 0;
        max = this._class.getMaxTurnBurnLevel();
        turn = max ? Math.max(
                this._yawRight.burn, this._yawLeft.burn,
                this._pitchUp.burn, this._pitchDown.burn,
                this._rollRight.burn, this._rollLeft.burn) / max : 0;
        max = Math.round((move + turn) * THRUSTER_SOUND_VOLUME_GRADES) / THRUSTER_SOUND_VOLUME_GRADES;
        return max;
    };
    /**
     * Applies the forces and torques that are created by this propulsion system
     * to the physical object it drives.
     * @param {Number} dt Time passed in the current simulation step, in milliseconds
     * @param {SoundSource} spacecraftSoundSource The sound source belonging to the spacecraft that has this propulsion equipped
     * @param {Boolean} [applyForces=true] If false, the forces and torques generated by the thrusters are not applied to the spacecraft 
     * (only e.g. sound effect volume is updated)
     */
    Propulsion.prototype.simulate = function (dt, spacecraftSoundSource, applyForces) {
        var directionVector, yawAxis, pitchAxis;
        if (applyForces !== false) {
            directionVector = mat.getRowB4(this._drivenPhysicalObject.getOrientationMatrix());
            yawAxis = mat.getRowC4(this._drivenPhysicalObject.getOrientationMatrix());
            pitchAxis = mat.getRowA4(this._drivenPhysicalObject.getOrientationMatrix());
            if (this._forward.burn > 0) {
                this._drivenPhysicalObject.applyForce(this._thrustFactor * this._forward.burn, directionVector[0], directionVector[1], directionVector[2], dt);
            } else if (this._reverse.burn > 0) {
                this._drivenPhysicalObject.applyForce(-this._thrustFactor * this._reverse.burn, directionVector[0], directionVector[1], directionVector[2], dt);
            }
            if (this._strafeRight.burn > 0) {
                this._drivenPhysicalObject.applyForce(this._thrustFactor * this._strafeRight.burn, pitchAxis[0], pitchAxis[1], pitchAxis[2], dt);
            } else if (this._strafeLeft.burn > 0) {
                this._drivenPhysicalObject.applyForce(-this._thrustFactor * this._strafeLeft.burn, pitchAxis[0], pitchAxis[1], pitchAxis[2], dt);
            }
            if (this._raise.burn > 0) {
                this._drivenPhysicalObject.applyForce(this._thrustFactor * this._raise.burn, yawAxis[0], yawAxis[1], yawAxis[2], dt);
            } else if (this._lower.burn > 0) {
                this._drivenPhysicalObject.applyForce(-this._thrustFactor * this._lower.burn, yawAxis[0], yawAxis[1], yawAxis[2], dt);
            }
            if (this._yawRight.burn > 0) {
                this._yawTorque = this._drivenPhysicalObject.addOrRenewTorque(this._yawTorque, this._angularThrustFactor * this._yawRight.burn, yawAxis);
            } else if (this._yawLeft.burn > 0) {
                this._yawTorque = this._drivenPhysicalObject.addOrRenewTorque(this._yawTorque, -this._angularThrustFactor * this._yawLeft.burn, yawAxis);
            }
            if (this._pitchUp.burn > 0) {
                this._pitchTorque = this._drivenPhysicalObject.addOrRenewTorque(this._pitchTorque, -this._angularThrustFactor * this._pitchUp.burn, pitchAxis);
            } else if (this._pitchDown.burn > 0) {
                this._pitchTorque = this._drivenPhysicalObject.addOrRenewTorque(this._pitchTorque, this._angularThrustFactor * this._pitchDown.burn, pitchAxis);
            }
            if (this._rollRight.burn > 0) {
                this._rollTorque = this._drivenPhysicalObject.addOrRenewTorque(this._rollTorque, -this._angularThrustFactor * this._rollRight.burn, directionVector);
            } else if (this._rollLeft.burn > 0) {
                this._rollTorque = this._drivenPhysicalObject.addOrRenewTorque(this._rollTorque, this._angularThrustFactor * this._rollLeft.burn, directionVector);
            }
        }
        if (!this._thrusterSoundClip) {
            this._thrusterSoundClip = this._class.createThrusterSoundClip(spacecraftSoundSource);
            if (this._thrusterSoundClip) {
                this._thrusterSoundClip.setVolume(0);
                this._thrusterSoundClip.play();
            }
        }
        if (this._thrusterSoundClip) {
            this._thrusterSoundClip.rampVolume(this._getSoundVolume() * this._class.getThrusterSoundVolume(), THRUSTER_SOUND_VOLUME_RAMP_DURATION, true, true);
        }
    };
    /**
     * Returns the amount of score points to be added to the total score value of spacecrafts that have this propulsion equipped
     * @returns {Number}
     */
    Propulsion.prototype.getScoreValue = function () {
        return this._class.getScoreValue();
    };
    /**
     * Removes all references stored by this object
     */
    Propulsion.prototype.destroy = function () {
        this._class = null;
        this._drivenPhysicalObject = null;
        this._thrusters = null;
        this._forward = null;
        this._reverse = null;
        this._strafeLeft = null;
        this._strafeRight = null;
        this._raise = null;
        this._lower = null;
        this._yawLeft = null;
        this._yawRight = null;
        this._pitchUp = null;
        this._pitchDown = null;
        this._rollLeft = null;
        this._rollRight = null;
        if (this._thrusterSoundClip) {
            this._thrusterSoundClip.stopPlaying(audio.SOUND_RAMP_DURATION);
            setTimeout(function () {
                this._thrusterSoundClip.destroy();
                this._thrusterSoundClip = null;
            }.bind(this), audio.SOUND_RAMP_DURATION);
        }
    };
    // #########################################################################
    /**
     * @class A class that can translate higher level maneuvering commands given to
     * a spacecraft (by user input or an AI) to low level thruster commands.
     * @param {Spacecraft} spacecraft The spacecraft the thrusters of which this
     * computer controls.
     */
    function ManeuveringComputer(spacecraft) {
        /**
         * The spacecraft the thrusters of which this computer controls.
         * @type Spacecraft
         */
        this._spacecraft = spacecraft;
        /**
         * Whether automatic inertia (drift) compensation is turned on. (combat and cruise flight modes)
         * @type Boolean
         */
        this._assisted = true;
        /**
         * Whether automatic turning restriction is turned on. (cruise flight mode)
         * @type Boolean
         */
        this._restricted = false;
        /**
         * The target angle in radian between the identity orientation and the
         * relative angular velocity matrix on the yawing (XY) plane. The computer
         * will use the yawing thursters to reach this angle.
         * (representing rad / physics.ANGULAR_VELOCITY_MATRIX_DURATION ms turn)
         * @type Number
         */
        this._yawTarget = 0;
        /**
         * The target angle in radian between the identity orientation and the
         * relative angular velocity matrix on the pitching (YZ) plane. The computer
         * will use the pitching thursters to reach this angle.
         * (representing rad / physics.ANGULAR_VELOCITY_MATRIX_DURATION ms turn)
         * @type Number
         */
        this._pitchTarget = 0;
        /**
         * The target angle in radian between the identity orientation and the
         * relative angular velocity matrix on the rolling (XZ) plane. The computer
         * will use the rolling thursters to reach this angle. 
         * (representing rad / physics.ANGULAR_VELOCITY_MATRIX_DURATION ms turn)
         * @type Number
         */
        this._rollTarget = 0;
        /**
         * When true, a speed target will be persistently remembered (with forward/reverse
         * commands increasing/decreasing it) and thrusters will automatically fire to
         * reach / hold it.
         * @type Boolean
         */
        this._holdSpeed = false;
        /**
         * This will be true while the speed target (along the Y axis) is controlled by actions with
         * specific intensity (such as the throttle on a joystick), as in this case the speed target
         * should be displayed to the user, even when not it speed holding mode.
         * @type Boolean
         */
        this._speedThrottled = false;
        /**
         * The target speed along the Y axis (in model space). The computer will
         * use forward and reverse thrusters to reach this speed if interia
         * compensation and speed holding are turned on. (in m/s)
         * @type Number
         */
        this._speedTarget = 0;
        /**
         * The target speed along the X axis (in model space). The computer will
         * use left and right thrusters to reach this speed if interia
         * compensation is turned on. (in m/s)
         * @type Number
         */
        this._strafeTarget = 0;
        /**
         * The target speed along the Z axis (in model space). The computer will
         * use dorsal and lateral thrusters to reach this speed if interia
         * compensation is turned on. (in m/s)
         * @type Number
         */
        this._liftTarget = 0;
        /**
         * When true, the maneuvering computer does not accept new commands.
         * @type Boolean
         */
        this._locked = false;
        /**
         * How much speed should be added to the target when the pilot accelerates
         * continuously for one second, in m/s. This is always updated to be the same
         * as how much the spacecraft can accelerate with the current propulsion, whenever
         * a new propulsion is equipped.
         * @type Number
         */
        this._speedIncrementPerSecond = 0;
        /**
         * How much speed should be added to the target in one control step when
         * the pilot is using continuous acceleration. (in m/s)
         * @type Number
         */
        this._speedIncrement = 0;
        /**
         * In combat mode, the forward speed target cannot exceed this. (in m/s)
         * @type Number
         */
        this._maxCombatForwardSpeed = 0;
        /**
         * In combat mode, the forward speed target cannot go below this. (negative, in m/s)
         * @type Number
         */
        this._maxCombatReverseSpeed = 0;
        /**
         * In cruise mode, the forward speed target cannot exceed this. (in m/s)
         * @type Number
         */
        this._maxCruiseForwardSpeed = 0;
        /**
         * In cruise mode, the forward speed target cannot go below this. (negative, in m/s)
         * @type Number
         */
        this._maxCruiseReverseSpeed = 0;
        /**
         * The maximum angle between vectors of the relative angular acceleration 
         * matrix and the identity axes on each 2D plane (yaw, pitch, roll)
         * (representing rad / physics.ANGULAR_VELOCITY_MATRIX_DURATION ms turn)
         * This is the general limit based on the ship's engines, does not consider flight mode restrictions!
         * @type Number
         */
        this._turningLimit = 0;
        /**
         * Maximum thrust for acceleration is applied at this burn level. (cache variable)
         * @type Number
         */
        this._maxMoveBurnLevel = 0;
        /**
         * Maximum angular thrust for turning is applied at this burn level. (cache variable)
         * @type Number
         */
        this._maxTurnBurnLevel = 0;
        this.updateForNewPropulsion();
    }
    /**
     * Function to reset state before starting to execute the control actions triggered in the current simulation step.
     */
    ManeuveringComputer.prototype.prepareForControl = function () {
        this._speedThrottled = false;
    };
    /**
     * Updates the speed increment per second to how much the ship can accelerate 
     * in one second with the current propulsion system.
     */
    ManeuveringComputer.prototype.updateSpeedIncrementPerSecond = function () {
        this._speedIncrementPerSecond = this._spacecraft.getMaxAcceleration() || 0;
    };
    /**
     * Updates the calculated speed increment according to how much time has
     * elapsed since the last control step.
     * @param {Number} dt The elapsed time since the last control step.
     */
    ManeuveringComputer.prototype.updateSpeedIncrement = function (dt) {
        this._speedIncrement = dt * this._speedIncrementPerSecond / 1000;
    };
    /**
     * Updates the turning limit to how much the ship can accelerate its
     * turning rate to in TURN_ACCELERATION_DURATION_S seconds with the current propulsion system.
     */
    ManeuveringComputer.prototype.updateTurningLimit = function () {
        this._turningLimit = this._spacecraft.getMaxAngularAcceleration() * config.getSetting(config.BATTLE_SETTINGS.TURN_ACCELERATION_DURATION_S) * physics.ANGULAR_VELOCITY_MATRIX_DURATION_S;
    };
    /**
     * Updates all stored state variables to reflect the current state of the propulsion on the spacecraft of this computer
     * @returns {undefined}
     */
    ManeuveringComputer.prototype.updateForNewPropulsion = function () {
        var maxAcceleration = this._spacecraft.getMaxAcceleration();
        this.updateSpeedIncrementPerSecond();
        this._maxCombatForwardSpeed = _maxCombatForwardSpeedFactor * maxAcceleration;
        this._maxCombatReverseSpeed = _maxCombatReverseSpeedFactor * -maxAcceleration;
        this._maxCruiseForwardSpeed = _maxCruiseForwardSpeedFactor * maxAcceleration;
        this._maxCruiseReverseSpeed = _maxCruiseReverseSpeedFactor * -maxAcceleration;
        this.updateTurningLimit();
        this._maxMoveBurnLevel = this._spacecraft.getMaxThrusterMoveBurnLevel();
        this._maxTurnBurnLevel = this._spacecraft.getMaxThrusterTurnBurnLevel();
    };
    /**
     * Returns the turning limit restricted to disallow drifting (use for restricted flight modes)
     * @param {Number} [speed] The speed of the spacecraft at which to calculate the limit. If omitted, the current speed will be used
     * @returns {Number}
     */
    ManeuveringComputer.prototype.getRestrictedTurningLimit = function (speed) {
        return Math.min(
                this._turningLimit,
                this._spacecraft.getMaxTurnRateAtSpeed((speed === undefined) ? this._spacecraft.getRelativeVelocityMatrix()[13] : speed) * physics.ANGULAR_VELOCITY_MATRIX_DURATION_S);
    };
    /**
     * Returns whether the maneuvering computer is currently locked (not accepting new commands)
     * @returns {Boolean}
     */
    ManeuveringComputer.prototype.isLocked = function () {
        return this._locked;
    };
    /**
     * Locks / unlocks the maneuvering computer. While locked, no new commands are accepted.
     * @param {Boolean} value
     */
    ManeuveringComputer.prototype.setLocked = function (value) {
        this._locked = value;
        if (this._locked) {
            this._yawTarget = 0;
            this._pitchTarget = 0;
            this._rollTarget = 0;
        }
    };
    /**
     * Returns a string representation of the current flight mode.
     * @returns {String} enum FlightMode
     */
    ManeuveringComputer.prototype.getFlightMode = function () {
        return this._assisted ?
                (this._restricted ? FlightMode.CRUISE : FlightMode.COMBAT) : FlightMode.FREE;
    };
    /**
     * Switches to the specified (if any) or to the next flight mode. (free / combat / cruise)
     * @param {String} [flightMode]
     * @returns {Boolean} Whether the flight mode change happened.
     */
    ManeuveringComputer.prototype.changeFlightMode = function (flightMode) {
        if (this._locked) {
            return false;
        }
        if (!flightMode) {
            if (!this._assisted) {
                flightMode = FlightMode.COMBAT;
            } else if (!this._restricted) {
                flightMode = FlightMode.CRUISE;
            } else {
                flightMode = FlightMode.FREE;
            }
        }
        switch (flightMode) {
            case FlightMode.COMBAT:
                this._speedTarget = Math.min(Math.max(
                        this._maxCombatReverseSpeed,
                        this._assisted ? this._speedTarget : this._spacecraft.getRelativeVelocityMatrix()[13]),
                        this._maxCombatForwardSpeed);
                this._assisted = true;
                this._restricted = false;
                break;
            case FlightMode.CRUISE:
                this._speedTarget = Math.min(Math.max(
                        this._maxCruiseReverseSpeed,
                        this._assisted ? this._speedTarget : this._spacecraft.getRelativeVelocityMatrix()[13]),
                        this._maxCruiseForwardSpeed);
                this._assisted = true;
                this._restricted = true;
                break;
            case FlightMode.FREE:
                this._assisted = false;
                this._restricted = false;
                break;
            default:
                application.showError("Cannot switch to unknown flight mode: '" + flightMode + "'!");
                return false;
        }
        return true;
    };
    /**
     * Toggles between free and combat flight modes
     * @returns {Boolean} Whether the flight mode change happened.
     */
    ManeuveringComputer.prototype.toggleFlightAssist = function () {
        return this.changeFlightMode(this._assisted ? FlightMode.FREE : FlightMode.COMBAT);
    };
    /**
     * Toggles between cruise and combat flight modes
     * @returns {Boolean} Whether the flight mode change happened.
     */
    ManeuveringComputer.prototype.toggleCruise = function () {
        return this.changeFlightMode(this._restricted ? FlightMode.COMBAT : FlightMode.CRUISE);
    };
    /**
     * Increases the target speed if speed holding is turned on or sets it to maximum otherwise.
     * @param {Number} [intensity] If given, it will be factored into the amount of increase / set target
     */
    ManeuveringComputer.prototype.forward = function (intensity) {
        var maxSpeed;
        if (!this._locked) {
            if (this._assisted) {
                maxSpeed = this._restricted ? this._maxCruiseForwardSpeed : this._maxCombatForwardSpeed;
                this._speedThrottled = (intensity !== undefined);
                this._speedTarget = (this._holdSpeed && !this._speedThrottled) ?
                        Math.min(
                                Math.max(
                                        this._spacecraft.getRelativeVelocityMatrix()[13],
                                        this._speedTarget
                                        ) + this._speedIncrement,
                                maxSpeed) :
                        (intensity || 1) * maxSpeed;
            } else {
                this._speedTarget = Number.MAX_VALUE;
            }
        }
    };
    /**
     * Sets the target speed to the current speed if it is bigger. Only works 
     * in free flight mode.
     */
    ManeuveringComputer.prototype.stopForward = function () {
        var speed;
        if (!this._locked) {
            if (!this._assisted) {
                speed = this._spacecraft.getRelativeVelocityMatrix()[13];
                if (this._speedTarget > speed) {
                    this._speedTarget = speed;
                }
            } else if (!this._holdSpeed) {
                if (this._speedTarget > 0) {
                    this._speedTarget = 0;
                }
            }
        }
    };
    /**
     * Decreases the target speed if speed holding is turned on or sets it to negative maximum otherwise.
     * @param {Number} [intensity] If given, it will be factored into the amount of decrease / set target
     */
    ManeuveringComputer.prototype.reverse = function (intensity) {
        var maxSpeed;
        if (!this._locked) {
            if (this._assisted) {
                maxSpeed = this._restricted ? this._maxCruiseReverseSpeed : this._maxCombatReverseSpeed;
                this._speedThrottled = (intensity !== undefined);
                this._speedTarget = (this._holdSpeed && !this._speedThrottled) ?
                        Math.max(
                                Math.min(
                                        this._spacecraft.getRelativeVelocityMatrix()[13],
                                        this._speedTarget
                                        ) - this._speedIncrement,
                                maxSpeed) :
                        (intensity || 1) * maxSpeed;
            } else {
                this._speedTarget = -Number.MAX_VALUE;
            }
        }
    };
    /**
     * Sets the target speed to the current speed if it is smaller. Only works 
     * in free flight mode.
     */
    ManeuveringComputer.prototype.stopReverse = function () {
        var speed;
        if (!this._locked) {
            if (!this._assisted) {
                speed = this._spacecraft.getRelativeVelocityMatrix()[13];
                if (this._speedTarget < speed) {
                    this._speedTarget = speed;
                }
            } else if (!this._holdSpeed) {
                if (this._speedTarget < 0) {
                    this._speedTarget = 0;
                }
            }
        }
    };
    /**
     * Sets the target speed for strafing to the left to intensity, or if not
     * given, to maximum. This target is reset to zero in each control step after 
     * the thrusters have been ignited accoringly.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.strafeLeft = function (intensity) {
        if (!this._locked) {
            this._strafeTarget = this._restricted ? 0 : ((this._assisted && intensity) ? -intensity : -Number.MAX_VALUE);
        }
    };
    /**
     * Sets the target speed for strafing to zero, if was set to a speed to the
     * left.
     */
    ManeuveringComputer.prototype.stopLeftStrafe = function () {
        if (this._strafeTarget < 0) {
            this._strafeTarget = 0;
        }
    };
    /**
     * Sets the target speed for strafing to the right to intensity, or if not
     * given, to maximum. This target is reset to zero in each control step after 
     * the thrusters have been ignited accoringly.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.strafeRight = function (intensity) {
        if (!this._locked) {
            this._strafeTarget = this._restricted ? 0 : ((this._assisted && intensity) || Number.MAX_VALUE);
        }
    };
    /**
     * Sets the target speed for strafing to zero, if was set to a speed to the
     * right.
     */
    ManeuveringComputer.prototype.stopRightStrafe = function () {
        if (this._strafeTarget > 0) {
            this._strafeTarget = 0;
        }
    };
    /**
     * Sets the target speed for lifting downwards to intensity, or if not
     * given, to maximum. This target is reset to zero in each control step after 
     * the thrusters have been ignited accoringly.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.lower = function (intensity) {
        if (!this._locked) {
            this._liftTarget = this._restricted ? 0 : ((this._assisted && intensity) ? -intensity : -Number.MAX_VALUE);
        }
    };
    /**
     * Sets the target speed for lifting to zero, if was set to a speed to lift
     * downwards
     */
    ManeuveringComputer.prototype.stopLower = function () {
        if (this._liftTarget < 0) {
            this._liftTarget = 0;
        }
    };
    /**
     * Sets the target speed for lifting upwards to intensity, or if not
     * given, to maximum. This target is reset to zero in each control step after 
     * the thrusters have been ignited accoringly.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.raise = function (intensity) {
        if (!this._locked) {
            this._liftTarget = this._restricted ? 0 : ((this._assisted && intensity) || Number.MAX_VALUE);
        }
    };
    /**
     * Sets the target speed for strafing to zero, if was set to a speed to lift
     * upwards.
     */
    ManeuveringComputer.prototype.stopRaise = function () {
        if (this._liftTarget > 0) {
            this._liftTarget = 0;
        }
    };
    /**
     * Toggles speed holding (in assisted flight modes)
     * @returns {Boolean} Whether the speed holding mode has changed
     */
    ManeuveringComputer.prototype.toggleSpeedHolding = function () {
        if (!this._locked) {
            if (this._assisted) {
                this._holdSpeed = !this._holdSpeed;
                if (this._holdSpeed) {
                    this._speedTarget = this._spacecraft.getRelativeVelocityMatrix()[13];
                    if (this._restricted) {
                        this._speedTarget = Math.min(Math.max(
                                this._maxCruiseReverseSpeed,
                                this._speedTarget),
                                this._maxCruiseForwardSpeed);
                    } else {
                        this._speedTarget = Math.min(Math.max(
                                this._maxCombatReverseSpeed,
                                this._speedTarget),
                                this._maxCombatForwardSpeed);
                    }

                }
                return true;
            }
        }
        return false;
    };
    /**
     * Sets speed holding to the passed value
     * @param {Boolean} value
     */
    ManeuveringComputer.prototype.setSpeedHolding = function (value) {
        this._holdSpeed = value;
    };
    /**
     * Resets the target (forward/reverse) speed to zero. (when speed holding is on)
     */
    ManeuveringComputer.prototype.resetSpeed = function () {
        if (!this._locked) {
            if (this._assisted && this._holdSpeed) {
                this._speedTarget = 0;
            }
        }
    };
    /**
     * Sets a new forward/reverse speed target in non-free flight modes.
     * @param {Number} value A positive number means a forward target, a negative one a reverse target, in m/s.
     */
    ManeuveringComputer.prototype.setSpeedTarget = function (value) {
        if (!this._locked) {
            if (this._assisted) {
                this._speedTarget = value;
            }
        }
    };
    /**
     * Return the currently set target for forward (positive) / reverse (negative) speed, in m/s. Only meaningful in assisted flight modes.
     * @returns {Number}
     */
    ManeuveringComputer.prototype.getSpeedTarget = function () {
        return this._speedTarget;
    };
    /**
     * Returns whether the maneuvering computer has a meaningful speed target in its current flight mode.
     * @returns {Boolean}
     */
    ManeuveringComputer.prototype.hasSpeedTarget = function () {
        return this._assisted && (this._holdSpeed || this._speedThrottled);
    };
    /**
     * If the current flight mode imposes a speed limit, returns it. (in m/s) Otherwise returns undefined.
     * @returns {Number}
     */
    ManeuveringComputer.prototype.getMaxSpeed = function () {
        return this._assisted ? (this._restricted ? this._maxCruiseForwardSpeed : this._maxCombatForwardSpeed) : undefined;
    };
    /**
     * Sets the target angular velocity to yaw to the left with the given intensity 
     * multiplied by the turning limit, or if no intensity was given, with the turning
     * limit.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.yawLeft = function (intensity) {
        if (!this._locked) {
            // if no intensity was given for the turn, turn with maximum power (mouse or
            // joystick control can have fine intensity control, while with keyboard,
            // when the key is pressed, we just call this without parameter)
            if (intensity === undefined) {
                this._yawTarget = -this._turningLimit;
                // if a specific intensity was set, set the target to it, capping it out at
                // the maximum allowed turning speed
            } else if (intensity > 0) {
                this._yawTarget = -intensity * (this._restricted ? this.getRestrictedTurningLimit() : this._turningLimit);
                // if a zero or negative intensity was given, set the target to zero,
                // but only if it is set to turn to left
            } else if (this._yawTarget < 0) {
                this._yawTarget = 0;
            }
        }
    };
    /**
     * Sets the target angular velocity to yaw to the right with the given intensity 
     * multiplied by the turning limit, or if no intensity was given, with the turning
     * limit.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.yawRight = function (intensity) {
        if (!this._locked) {
            if (intensity === undefined) {
                this._yawTarget = this._turningLimit;
            } else if (intensity > 0) {
                this._yawTarget = intensity * (this._restricted ? this.getRestrictedTurningLimit() : this._turningLimit);
            } else if (this._yawTarget > 0) {
                this._yawTarget = 0;
            }
        }
    };
    /**
     * Sets the target angular velocity to pitch down with the given intensity 
     * multiplied by the turning limit, or if no intensity was given, with the turning
     * limit.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.pitchDown = function (intensity) {
        if (!this._locked) {
            if (intensity === undefined) {
                this._pitchTarget = -this._turningLimit;
            } else if (intensity > 0) {
                this._pitchTarget = -intensity * (this._restricted ? this.getRestrictedTurningLimit() : this._turningLimit);
            } else if (this._pitchTarget < 0) {
                this._pitchTarget = 0;
            }
        }
    };
    /**
     * Sets the target angular velocity to pitch up with the given intensity 
     * multiplied by the turning limit, or if no intensity was given, with the turning
     * limit.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.pitchUp = function (intensity) {
        if (!this._locked) {
            if (intensity === undefined) {
                this._pitchTarget = this._turningLimit;
            } else if (intensity > 0) {
                this._pitchTarget = intensity * (this._restricted ? this.getRestrictedTurningLimit() : this._turningLimit);
            } else if (this._pitchTarget > 0) {
                this._pitchTarget = 0;
            }
        }
    };
    /**
     * Sets the target angular velocity to roll to the left with the given intensity 
     * multiplied by the turning limit, or if no intensity was given, with the turning
     * limit.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.rollLeft = function (intensity) {
        if (!this._locked) {
            if (intensity === undefined) {
                this._rollTarget = -this._turningLimit;
            } else if (intensity > 0) {
                this._rollTarget = -intensity * this._turningLimit;
            } else if (this._rollTarget < 0) {
                this._rollTarget = 0;
            }
        }
    };
    /**
     * Sets the target angular velocity to roll to the right with the given intensity 
     * multiplied by the turning limit, or if no intensity was given, with the turning
     * limit.
     * @param {Number} [intensity]
     */
    ManeuveringComputer.prototype.rollRight = function (intensity) {
        if (!this._locked) {
            if (intensity === undefined) {
                this._rollTarget = this._turningLimit;
            } else if (intensity > 0) {
                this._rollTarget = intensity * this._turningLimit;
            } else if (this._rollTarget > 0) {
                this._rollTarget = 0;
            }
        }
    };
    /**
     * Sets the burn levels of all the thrusters of the ship according to the
     * current flight mode, flight parameters and control actions issued by the 
     * pilot.
     * @param {Number} dt The elapsed time in this simulation step, in milliseconds.
     */
    ManeuveringComputer.prototype.controlThrusters = function (dt) {
        var
                // grab flight parameters for velocity control
                relativeVelocityMatrix = this._spacecraft.getRelativeVelocityMatrix(),
                speed = relativeVelocityMatrix[13],
                speedThreshold = physics.VELOCITY_MATRIX_ERROR_THRESHOLD,
                // grab flight parameters for turning control
                turningMatrix = this._spacecraft.getTurningMatrix(),
                turnThreshold = physics.ANGULAR_VELOCITY_MATRIX_ERROR_THRESHOLD,
                // cache possibly restricted turn parameters (in rad / ANGULAR_VELOCITY_MATRIX_DURATION ms)
                turningLimit,
                yawTarget = this._yawTarget,
                pitchTarget = this._pitchTarget,
                yawAngle, pitchAngle, rollAngle,
                propulsion = this._spacecraft.getPropulsion();
        // we will add the needed burn levels together, so start from zero
        propulsion.resetThrusterBurn();
        // restrict turning according to current speed in restricted mode
        if (this._restricted && (speed !== 0.0)) {
            // restrict the limit if needed (convert from rad/sec to rad / ANGULAR_VELOCITY_MATRIX_DURATION ms)
            turningLimit = this.getRestrictedTurningLimit(speed);
            //apply the restricted limit
            yawTarget = Math.min(Math.max(yawTarget, -turningLimit), turningLimit);
            pitchTarget = Math.min(Math.max(pitchTarget, -turningLimit), turningLimit);
        }
        // controlling yaw
        yawAngle = Math.sign(turningMatrix[4]) * vec.angle2y(turningMatrix[4], turningMatrix[5]);
        if ((yawTarget - yawAngle) > turnThreshold) {
            propulsion.addThrusterBurnYawRight(Math.min(this._maxTurnBurnLevel, this._spacecraft.getNeededBurnForAngularVelocityChange(yawTarget - yawAngle, dt)));
        } else if ((yawTarget - yawAngle) < -turnThreshold) {
            propulsion.addThrusterBurnYawLeft(Math.min(this._maxTurnBurnLevel, this._spacecraft.getNeededBurnForAngularVelocityChange(yawAngle - yawTarget, dt)));
        }
        // controlling pitch
        pitchAngle = Math.sign(turningMatrix[6]) * vec.angle2x(turningMatrix[5], turningMatrix[6]);
        if ((pitchTarget - pitchAngle) > turnThreshold) {
            propulsion.addThrusterBurnPitchUp(Math.min(this._maxTurnBurnLevel, this._spacecraft.getNeededBurnForAngularVelocityChange(pitchTarget - pitchAngle, dt)));
        } else if ((pitchTarget - pitchAngle) < -turnThreshold) {
            propulsion.addThrusterBurnPitchDown(Math.min(this._maxTurnBurnLevel, this._spacecraft.getNeededBurnForAngularVelocityChange(pitchAngle - pitchTarget, dt)));
        }
        // controlling roll
        rollAngle = Math.sign(-turningMatrix[2]) * vec.angle2x(turningMatrix[0], turningMatrix[2]);
        if ((this._rollTarget - rollAngle) > turnThreshold) {
            propulsion.addThrusterBurnRollRight(Math.min(this._maxTurnBurnLevel, this._spacecraft.getNeededBurnForAngularVelocityChange(this._rollTarget - rollAngle, dt)));
        } else if ((this._rollTarget - rollAngle) < -turnThreshold) {
            propulsion.addThrusterBurnRollLeft(Math.min(this._maxTurnBurnLevel, this._spacecraft.getNeededBurnForAngularVelocityChange(rollAngle - this._rollTarget, dt)));
        }
        // controlling forward/reverse
        if ((this._speedTarget - speed) > speedThreshold) {
            propulsion.addThrusterBurnForward(Math.min(this._maxMoveBurnLevel, this._spacecraft.getNeededBurnForSpeedChange(this._speedTarget - speed, dt)));
        } else if ((this._speedTarget - speed) < -speedThreshold) {
            propulsion.addThrusterBurnReverse(Math.min(this._maxMoveBurnLevel, this._spacecraft.getNeededBurnForSpeedChange(speed - this._speedTarget, dt)));
        }
        // controlling horizontal drift
        if (this._assisted || (this._strafeTarget !== 0)) {
            speed = relativeVelocityMatrix[12];
            if ((this._strafeTarget - speed) > speedThreshold) {
                propulsion.addThrusterBurnRight(Math.min(this._maxMoveBurnLevel, this._spacecraft.getNeededBurnForSpeedChange(this._strafeTarget - speed, dt)));
            } else if ((this._strafeTarget - speed) < -speedThreshold) {
                propulsion.addThrusterBurnLeft(Math.min(this._maxMoveBurnLevel, this._spacecraft.getNeededBurnForSpeedChange(speed - this._strafeTarget, dt)));
            }
        }
        // controlling vertical drift
        if (this._assisted || (this._liftTarget !== 0)) {
            speed = relativeVelocityMatrix[14];
            if ((this._liftTarget - speed) > speedThreshold) {
                propulsion.addThrusterBurnUp(Math.min(this._maxMoveBurnLevel, this._spacecraft.getNeededBurnForSpeedChange(this._liftTarget - speed, dt)));
            } else if ((this._liftTarget - speed) < -speedThreshold) {
                propulsion.addThrusterBurnDown(Math.min(this._maxMoveBurnLevel, this._spacecraft.getNeededBurnForSpeedChange(speed - this._liftTarget, dt)));
            }
        }
        propulsion.updateVisuals();
        // reset the targets, as new controls are needed from the pilot in the
        // next step to keep these targets up (e.g. continuously pressing the
        // key, moving the mouse or keeping the mouse displaced from center)
        this._yawTarget = 0;
        this._pitchTarget = 0;
        this._rollTarget = 0;
        this._strafeTarget = 0;
        this._liftTarget = 0;
    };
    /**
     * Removes all references stored by this object
     */
    ManeuveringComputer.prototype.destroy = function () {
        this._spacecraft = null;
    };
    // #########################################################################
    /**
     * @class This piece of equipment governs the hyperspace jump sequences by managing an internal state about them, triggering 
     * corresponding spacecraft events, controlling the spacecraft itself, adding the appripriate effects to the scene and playing sound 
     * effects
     * @param {JumpEngineClass} jumpEngineClass
     * @param {Spacecraft} spacecraft The spacecraft to equip this jump engine on
     */
    function JumpEngine(jumpEngineClass, spacecraft) {
        /**
         * The class specifying the characteristics of how the jumps should look / sound like
         * @type JumpEngineClass
         */
        this._class = jumpEngineClass;
        /**
         * The spacecraft this engine is equipped on
         * @type Spacecraft
         */
        this._spacecraft = spacecraft;
        /**
         * In which overall stage of the jump sequence are we
         * @type Number
         */
        this._state = JumpEngine.JumpState.NONE;
        /**
         * How much time is left from the current jump state
         * @type Number
         */
        this._timeLeft = 0;
        /**
         * A reference to the currently played sound clip, if any
         * @type SoundClip
         */
        this._soundClip = null;
        /**
         * Stores the flight mode that was set on the spacecraft when the jump sequence was initiated, so that it can be reset if the jump
         * is cancelled.
         * @type String
         */
        this._originalFlightMode = null;
        /**
         * Stores a copy of the original scaling matrix of the spacecraft (it is altered during the jump sequences, stretching the 
         * spacecraft along the Y axis)
         * @type Float32Array
         */
        this._originalScalingMatrix = null;
    }
    /**
     * The threshold for tolerating drift / speed difference when aligning the velocity of the spacecraft for preparation
     * @type Number
     */
    JumpEngine.VELOCITY_TOLERANCE = 1;
    /**
     * @enum Defines the possible states a jump engine can be in
     * @type Object
     */
    JumpEngine.JumpState = {
        /** No jump in progress */
        NONE: 0,
        /** A jump out has been initiated, the correct velocity needs to be reached without drift - controls disabled */
        ALIGNING_VELOCITY: 1,
        /** The engine is powering up for a jump out, spacecraft travelling with the correct velocity */
        PREPARING: 2,
        /** Jump out is in progress, spacecraft rapidly accelerating until it disappears in a flash */
        JUMPING_OUT: 3,
        /** Jump in is in progress, spacecraft rapidly decelerating until it becomes controllable */
        JUMPING_IN: 4
    };
    Object.freeze(JumpEngine.JumpOutState);
    /**
     * Call to make sure all needed resources are going to be loaded
     * @param {JumpEngineClass~ResourceParams} params 
     */
    JumpEngine.prototype.acquireResources = function (params) {
        this._class.acquireResources(params);
    };
    /**
     * Initiates the jump out sequence
     * @param {Boolean} toggle If true, calling the method while the jump out sequence is under way will cancel the jump
     */
    JumpEngine.prototype.jumpOut = function (toggle) {
        var wasPreparing;
        switch (this._state) {
            // initiating jump out sequence
            case JumpEngine.JumpState.NONE:
                this._state = JumpEngine.JumpState.ALIGNING_VELOCITY;
                // setting up the maneuvering computer to guide the spacecraft to the required velocity
                this._originalFlightMode = this._spacecraft.getFlightMode();
                this._spacecraft.changeFlightMode(FlightMode.CRUISE);
                this._spacecraft.setSpeedTarget(this._class.getPrepareVelocity());
                this._spacecraft.lockManeuvering();
                this._spacecraft.disableFiring();
                // the starting sound effect (computer blips) only need to be played for the piloted spacecraft - the event handler should
                // return true if the event handling included the HUD and other piloted spacecraft related updates
                if (this._spacecraft.handleEvent(SpacecraftEvents.JUMP_ENGAGED)) {
                    this._soundClip = this._class.createEngageSoundClip();
                    if (this._soundClip) {
                        this._soundClip.play();
                    }
                }
                break;
                // cancelling jump out sequence
            case JumpEngine.JumpState.ALIGNING_VELOCITY:
            case JumpEngine.JumpState.PREPARING:
                if (toggle) {
                    wasPreparing = this._state === JumpEngine.JumpState.PREPARING;
                    this._state = JumpEngine.JumpState.NONE;
                    this._spacecraft.unlockManeuvering();
                    this._spacecraft.changeFlightMode(this._originalFlightMode);
                    this._spacecraft.enableFiring();
                    if (this._soundClip) {
                        this._soundClip.stopPlaying(audio.SOUND_RAMP_DURATION);
                        this._soundClip = null;
                    }
                    // the disengage sound effect (computer blips) only need to be played for the piloted spacecraft - the event handler should
                    // return true if the event handling included the HUD and other piloted spacecraft related updates
                    if (this._spacecraft.handleEvent(SpacecraftEvents.JUMP_CANCELLED)) {
                        this._soundClip = this._class.createDisengageSoundClip();
                        if (this._soundClip) {
                            this._soundClip.play();
                        }
                    }
                    // the longer cancellation sound (a "power down" type sound effect) is played (for all spacecrafts) and the reference is set
                    // to this one so that it can be stopped if the spacecraft is destroyed while it is playing
                    if (wasPreparing) {
                        this._soundClip = this._class.createCancelSoundClip();
                        if (this._soundClip) {
                            this._soundClip.play();
                        }
                    }
                }
                break;
        }
    };
    /**
     * Initiates the jump in sequence
     */
    JumpEngine.prototype.jumpIn = function () {
        var directionVector, exp, physicalModel;
        // initiating jump in sequence
        if (this._state === JumpEngine.JumpState.NONE) {
            this._state = JumpEngine.JumpState.JUMPING_IN;
            this._timeLeft = this._class.getJumpInDuration();
            this._spacecraft.unlockManeuvering();
            this._spacecraft.setSpeedTarget(0);
            this._spacecraft.lockManeuvering();
            this._spacecraft.disableFiring();
            exp = explosion.getExplosion();
            exp.init(
                    this._class.getJumpInExplosionClass(),
                    this._spacecraft.getPhysicalPositionMatrix(),
                    this._spacecraft.getPhysicalOrientationMatrix(),
                    mat.getRowC43(this._spacecraft.getPhysicalPositionMatrix()),
                    true,
                    true,
                    mat.IDENTITY4);
            exp.addToSceneNow(this._spacecraft.getVisualModel().getNode().getScene().getRootNode(), this._spacecraft.getSoundSource());
            this._originalScalingMatrix = mat.matrix4(this._spacecraft.getVisualModel().getScalingMatrix());
            physicalModel = this._spacecraft.getPhysicalModel();
            directionVector = mat.getRowB4(physicalModel.getOrientationMatrix());
            // calculate and set the starting velocity based on the set final velocity and total deceleration during the jump in sequence
            physicalModel.setVelocityMatrix(mat.translation4v(vec.scaled3(directionVector, this._class.getJumpInVelocity() + this._class.getJumpInDeceleration() * this._class.getJumpInDuration() / 1000)));
            physicalModel.addForce(new physics.Force(physicalModel.getMass() * this._class.getJumpInDeceleration(), vec.scaled3(directionVector, -1), this._class.getJumpInDuration()));
            physicalModel.setDragFactor(0);
            this._soundClip = this._class.createJumpInSoundClip(this._spacecraft.getSoundSource());
            if (this._soundClip) {
                this._soundClip.play();
            }
            this._spacecraft.setAway(false);
            this._spacecraft.handleEvent(SpacecraftEvents.JUMPED_IN);
        }
    };
    /**
     * Call in every simulation step to update the internal state and initiate the appropriate events / effects
     * @param {Number} dt The amount of time passed since the last simulation step, in milliseonds
     */
    JumpEngine.prototype.simulate = function (dt) {
        var velocityMatrix, directionVector, exp, physicalModel, speedTarget;
        switch (this._state) {
            case JumpEngine.JumpState.ALIGNING_VELOCITY:
                velocityMatrix = this._spacecraft.getRelativeVelocityMatrix();
                speedTarget = this._spacecraft.getTopSpeed() ? Math.min(this._spacecraft.getTopSpeed(), this._class.getPrepareVelocity()) : this._class.getPrepareVelocity();
                if ((Math.abs(velocityMatrix[12]) < JumpEngine.VELOCITY_TOLERANCE) &&
                        (Math.abs(velocityMatrix[14]) < JumpEngine.VELOCITY_TOLERANCE) &&
                        (Math.abs(velocityMatrix[13] - speedTarget) < JumpEngine.VELOCITY_TOLERANCE)) {
                    // switching to next state if the alignment is reached
                    this._state = JumpEngine.JumpState.PREPARING;
                    this._timeLeft = this._class.getPrepareDuration();
                    this._soundClip = this._class.createPrepareSoundClip(this._spacecraft.getSoundSource());
                    if (this._soundClip) {
                        this._soundClip.play();
                    }
                }
                break;
            case JumpEngine.JumpState.PREPARING:
                // this event is triggered every step (so that the countdown timer on the HUD can be updated)
                this._spacecraft.handleEvent(SpacecraftEvents.PREPARING_JUMP, {
                    duration: this._class.getPrepareDuration(),
                    timeLeft: this._timeLeft
                });
                // switching to the next state when the time is up
                if (this._timeLeft <= 0) {
                    this._state = JumpEngine.JumpState.JUMPING_OUT;
                    this._timeLeft = this._class.getJumpOutDuration();
                    this._soundClip = this._class.createJumpOutSoundClip(this._spacecraft.getSoundSource());
                    if (this._soundClip) {
                        this._soundClip.play();
                    }
                    physicalModel = this._spacecraft.getPhysicalModel();
                    directionVector = mat.getRowB4(physicalModel.getOrientationMatrix());
                    physicalModel.addForce(new physics.Force(physicalModel.getMass() * this._class.getJumpOutAcceleration(), directionVector, this._class.getJumpOutDuration()));
                    physicalModel.setDragFactor(0);
                    // make sure the forward engines of the spacecraft are firing during the jump out sequence, despite the high velocity it will reach
                    this._spacecraft.unlockManeuvering();
                    this._spacecraft.setSpeedTarget(Number.MAX_VALUE);
                    this._spacecraft.lockManeuvering();
                    this._originalScalingMatrix = mat.matrix4(this._spacecraft.getVisualModel().getScalingMatrix());
                    this._spacecraft.handleEvent(SpacecraftEvents.JUMP_OUT_STARTED);
                }
                this._timeLeft -= dt;
                break;
            case JumpEngine.JumpState.JUMPING_OUT:
                // stretching the spacecraft along the Y axis (by a linearly incrasing factor)
                this._spacecraft.getVisualModel().setScalingMatrix(mat.prod3x3SubOf4(
                        this._originalScalingMatrix,
                        mat.scaling4(1, 1 + (1 - this._timeLeft / this._class.getJumpOutDuration()) * (this._class.getJumpOutScaling() - 1), 1)));
                // finishing up the particle effect when the time is up
                if (this._timeLeft <= 0) {
                    this._state = JumpEngine.JumpState.NONE;
                    exp = explosion.getExplosion();
                    exp.init(
                            this._class.getJumpOutExplosionClass(),
                            this._spacecraft.getPhysicalPositionMatrix(),
                            this._spacecraft.getPhysicalOrientationMatrix(),
                            mat.getRowC43(this._spacecraft.getPhysicalPositionMatrix()),
                            true,
                            true,
                            mat.IDENTITY4);
                    exp.addToSceneNow(this._spacecraft.getVisualModel().getNode().getScene().getRootNode(), this._spacecraft.getSoundSource());
                    this._spacecraft.getVisualModel().setScalingMatrix(this._originalScalingMatrix);
                    this._spacecraft.setAway(true);
                    this._spacecraft.handleEvent(SpacecraftEvents.JUMPED_OUT);
                }
                this._timeLeft -= dt;
                break;
            case JumpEngine.JumpState.JUMPING_IN:
                // the stretching needs to be poperly calculated - do not allow negative timeLeft values
                if (this._timeLeft < 0) {
                    this._timeLeft = 0;
                }
                // stretching the spacecraft along the Y axis (by a linearly decreasing factor)
                this._spacecraft.getVisualModel().setScalingMatrix(mat.prod3x3SubOf4(
                        this._originalScalingMatrix,
                        mat.scaling4(1, 1 + (this._timeLeft / this._class.getJumpInDuration()) * (this._class.getJumpInScaling() - 1), 1)));
                // finishing the sequence if the time is up
                if (this._timeLeft <= 0) {
                    this._state = JumpEngine.JumpState.NONE;
                    this._spacecraft.unlockManeuvering();
                    this._spacecraft.enableFiring();
                    this._spacecraft.handleEvent(SpacecraftEvents.ARRIVED);
                    this._spacecraft.resetDrag();
                }
                this._timeLeft -= dt;
                break;
        }
    };
    /**
     * Deletes stored references, stops sound playback. Call when the spacecraft is destroyed.
     */
    JumpEngine.prototype.destroy = function () {
        this._class = null;
        this._spacecraft = null;
        if (this._soundClip) {
            this._soundClip.destroy();
            this._soundClip = null;
        }
        this._originalScalingMatrix = null;
    };
    // #########################################################################
    /**
     * @class This piece of equipment absorbs incoming damage, preserving the hull integrity of the spacecraft it is
     * equipped on, and regenerates its capacity over time.
     * @param {ShieldClass} shieldClass
     * @param {Spacecraft} spacecraft The spacecraft to equip this shield on
     */
    function Shield(shieldClass, spacecraft) {
        var color;
        /**
         * The class specifying the characteristics of the shield
         * @type ShieldClass
         */
        this._class = shieldClass;
        /**
         * The spacecraft this shield is equipped on
         * @type Spacecraft
         */
        this._spacecraft = spacecraft;
        /**
         * The current capacity (the amount of damage the shield can yet absorb before being depleted)
         * @type Number
         */
        this._capacity = shieldClass.getCapacity();
        /**
         * The amount of time elapsed since the shield was last hit, in milliseconds
         * @type Number
         */
        this._timeSinceHit = 0;
        /**
         * The amount of time elapsed since the shield started recharging, in milliseconds
         * @type Number
         */
        this._timeSinceRecharge = shieldClass ? shieldClass.getRechargeAnimationDuration() : 0;
        /**
         * Current shield state for visuals (RGB color + animation progress)
         * @type Number[4]
         */
        this._state = [0, 0, 0, 0];
        if (shieldClass) {
            color = shieldClass.getRechargeColor();
            this._state[0] = color[0];
            this._state[1] = color[1];
            this._state[2] = color[2];
        }
        /**
         * A reference to the currently played sound clip, if any
         * @type SoundClip
         */
        this._soundClip = null;
    }
    /**
     * Call to make sure all needed resources are going to be loaded
     * @param {ShieldClass~ResourceParams} params 
     */
    Shield.prototype.acquireResources = function (params) {
        this._class.acquireResources(params);
    };
    /**
     * Returns the name of the shield in a way that can be displayed to the user (translated)
     * @returns {String}
     */
    Shield.prototype.getDisplayName = function () {
        return this._class.getDisplayName();
    };
    /**
     * Returns the shield's integrity ratio (current / maximum capacity)
     * @returns {Number}
     */
    Shield.prototype.getIntegrity = function () {
        return this._capacity / this._class.getCapacity();
    };
    /**
     * Returns the shield's current capacity
     * @returns {Number}
     */
    Shield.prototype.getCapacity = function () {
        return this._capacity;
    };
    /**
     * Returns the shield's recharge rate (in capacity / second)
     * @returns {Number}
     */
    Shield.prototype.getRechargeRate = function () {
        return this._class.getRechargeRate();
    };
    /**
     * Returns the state of the shield to be used for visuals (color and animation progress)
     * @returns {Number[4]}
     */
    Shield.prototype.getState = function () {
        return this._state;
    };
    /**
     * Call when the shield (the spacecraft that has the shield) is damaged
     * @param {Number} damage The amount of damage (to be) dealt to the spacecraft
     * @returns {Number} The amount of damage that should be dealt to the armor of the spacecraft (original minus the amount absorbed by the shield)
     */
    Shield.prototype.damage = function (damage) {
        var absorbed = Math.min(this._capacity, damage);
        this._timeSinceHit = 0;
        this._capacity -= absorbed;
        return damage - absorbed;
    };
    /**
     * Startes recharging the shield (skipping any delay that might be left, playing sound/animation even if the shield was already full)
     */
    Shield.prototype.startRecharge = function () {
        this._soundClip = this._class.createRechargeStartSoundClip(this._spacecraft.getSoundSource());
        if (this._soundClip) {
            this._soundClip.play();
        }
        this._timeSinceRecharge = 0;
    };
    /**
     * Call in every simulation step to update the internal state and initiate the appropriate events / effects
     * @param {Number} dt The amount of time passed since the last simulation step, in milliseonds
     */
    Shield.prototype.simulate = function (dt) {
        var duration = this._class.getRechargeAnimationDuration();
        if (this._capacity < this._class.getCapacity()) {
            if (this._timeSinceHit < this._class.getRechargeDelay()) {
                this._timeSinceHit += dt;
                if (this._timeSinceHit >= this._class.getRechargeDelay()) {
                    this.startRecharge();
                }
            } else {
                // recharging
                this._capacity = Math.min(this._class.getCapacity(), this._capacity + this._class.getRechargeRate() * dt * 0.001); // sec -> ms
            }
        }
        this._timeSinceRecharge = Math.min(duration, this._timeSinceRecharge + dt);
        this._state[3] = this._timeSinceRecharge / duration;
    };
    /**
     * Returns the amount of score points to be added to the total score value of spacecrafts that have this shield equipped
     * @returns {Number}
     */
    Shield.prototype.getScoreValue = function () {
        return this._class.getScoreValue();
    };
    /**
     * Deletes stored references. Call when the spacecraft is destroyed.
     */
    Shield.prototype.destroy = function () {
        this._class = null;
        this._spacecraft = null;
        if (this._soundClip) {
            this._soundClip.destroy();
            this._soundClip = null;
        }
    };
    // ##############################################################################
    // initialization
    // obtaining pool references
    _particlePool = pools.getPool(constants.PARTICLE_POOL_NAME, renderableObjects.Particle);
    _projectilePool = pools.getPool(constants.PROJECTILE_POOL_NAME, Projectile);
    _missilePool = pools.getPool(constants.MISSILE_POOL_NAME, Missile);
    _trailSegmentPool = pools.getPool(constants.TRAIL_SEGMENT_POOL_NAME, renderableObjects.TrailSegment);
    // caching configuration settings
    config.executeWhenReady(function () {
        _isSelfFireEnabled = config.getSetting(config.BATTLE_SETTINGS.SELF_FIRE);
        _momentDuration = config.getSetting(config.BATTLE_SETTINGS.MOMENT_DURATION);
        _minimumParticleCountForInstancing = config.getSetting(config.BATTLE_SETTINGS.MINIMUM_PARTICLE_COUNT_FOR_INSTANCING);
        _minimumProjectileCountForInstancing = config.getSetting(config.BATTLE_SETTINGS.MINIMUM_PROJECTILE_COUNT_FOR_INSTANCING);
        _minimumTrailSegmentCountForInstancing = config.getSetting(config.BATTLE_SETTINGS.MINIMUM_TRAIL_SEGMENT_COUNT_FOR_INSTANCING);
        _maxCombatForwardSpeedFactor = config.getSetting(config.BATTLE_SETTINGS.MAX_COMBAT_FORWARD_SPEED_FACTOR);
        _maxCombatReverseSpeedFactor = config.getSetting(config.BATTLE_SETTINGS.MAX_COMBAT_REVERSE_SPEED_FACTOR);
        _maxCruiseForwardSpeedFactor = config.getSetting(config.BATTLE_SETTINGS.MAX_CRUISE_FORWARD_SPEED_FACTOR);
        _maxCruiseReverseSpeedFactor = config.getSetting(config.BATTLE_SETTINGS.MAX_CRUISE_REVERSE_SPEED_FACTOR);
        _showHitboxesForHitchecks = config.getSetting(config.BATTLE_SETTINGS.SHOW_HITBOXES_FOR_HITCHECKS);
        _luminosityFactorsArrayName = config.getSetting(config.GENERAL_SETTINGS.UNIFORM_LUMINOSITY_FACTORS_ARRAY_NAME);
        _groupTransformsArrayName = config.getSetting(config.GENERAL_SETTINGS.UNIFORM_GROUP_TRANSFORMS_ARRAY_NAME);
        _fireSoundStackingTimeThreshold = config.getSetting(config.BATTLE_SETTINGS.FIRE_SOUND_STACKING_TIME_THRESHOLD);
        _fireSoundStackingVolumeFactor = config.getSetting(config.BATTLE_SETTINGS.FIRE_SOUND_STACKING_VOLUME_FACTOR);
        graphics.executeWhenReady(handleGraphicsSettingsChanged);
        graphics.onSettingsChange(handleGraphicsSettingsChanged);
    });
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        FlightMode: FlightMode,
        ThrusterUse: ThrusterUse,
        handleDifficultySet: handleDifficultySet,
        Projectile: Projectile,
        Missile: Missile,
        Weapon: Weapon,
        MissileLauncher: MissileLauncher,
        TargetingComputer: TargetingComputer,
        Propulsion: Propulsion,
        JumpEngine: JumpEngine,
        Shield: Shield,
        ManeuveringComputer: ManeuveringComputer
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides functionality to load and access control configuration and settings for Interstellar Armada.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Element, localStorage, document, window, navigator */

/**
 * @param utils Used to check for touch event support
 * @param application Used to check if the application is in debug mode.
 * @param control This module builds its game-specific functionality on the general control module
 * @param keyboard Used to include keyboard input handling
 * @param mouse Used to include mouse input handling
 * @param gamepad Used to include joystick(/gamepad) input handling
 * @param touch Used to include touch input handling
 * @param cameraController This module uses the CameraController class made for SceneGraph
 * @param game To access screen-changing functionality
 * @param resources Used to access the sound effects triggered by controls
 * @param armadaScreens Used for navigation
 * @param strings Used for translation support
 * @param config Used to access settings
 * @param equipment Used to access enums
 */
define('armada/control',[
    "utils/utils",
    "modules/application",
    "modules/control/control",
    "modules/control/keyboard",
    "modules/control/mouse",
    "modules/control/gamepad",
    "modules/control/touch",
    "modules/camera-controller",
    "modules/game",
    "modules/media-resources",
    "armada/screens/shared",
    "armada/strings",
    "armada/configuration",
    "armada/logic/equipment"
], function (utils, application, control, keyboard, mouse, gamepad, touch, cameraController, game, resources, armadaScreens, strings, config, equipment) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // constants
            KEYBOARD_NAME = "keyboard",
            MOUSE_NAME = "mouse",
            JOYSTICK_NAME = "joystick",
            GAMEPAD_NAME = JOYSTICK_NAME,
            TOUCH_NAME = "touch",
            GENERAL_CONTROLLER_NAME = "general",
            FIGHTER_CONTROLLER_NAME = "fighter",
            CAMERA_CONTROLLER_NAME = "camera",
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * Cached value of the configuration setting for strafe speed factor.
             * @type Number
             */
            _strafeSpeedFactor,
            /**
             * Sound clip for the target switch sound.
             * @type SoundClip
             */
            _targetSwitchSound,
            /**
             * Sound clip for the target switch denied sound.
             * @type SoundClip
             */
            _targetSwitchDeniedSound,
            /**
             * Sound clip for the flight mode switch sound.
             * @type SoundClip
             */
            _flightModeSwitchSound,
            /**
             * Sound clip for the missile change sound.
             * @type SoundClip
             */
            _missileChangeSound,
            /**
             * Sound clip for the missile change denied sound.
             * @type SoundClip
             */
            _missileChangeDeniedSound,
            /**
             * Sound clip for toggling missile salvo mode.
             * @type SoundClip
             */
            _missileSalvoSound,
            /**
             * The context storing the current control settings (controllers, input interpreters) that can be accessed through the interface of this module
             * @type ArmadaControlContext
             */
            _context,
            /**
             * A shortcut reference to the input interpreter that handles mouse input stored in the context
             * @type MouseInputInterpreter
             */
            _mouseInputInterpreter,
            // ------------------------------------------------------------------------------
            // public functions
            playMissileChangeSound = function () {
                if (_missileChangeSound) {
                    _missileChangeSound.play();
                }
            };
    keyboard.setModulePrefix("interstellarArmada_control_");
    mouse.setModulePrefix("interstellarArmada_control_");
    gamepad.setModulePrefix("interstellarArmada_control_");
    touch.setModulePrefix("interstellarArmada_control_");
    // #########################################################################
    /**
     * Creates a general controller object.
     * @class The general controller processes and executes the actions that are related
     * to general game control during a battle, (such as 'pause' or 'quit') and not 
     * associated with any particular object.
     * @param {Object} dataJSON The JSON object which contains the data to load the properties
     * of the recognized actions from.
     * @returns {GeneralController}
     */
    function GeneralController(dataJSON) {
        control.Controller.call(this, dataJSON);
        /**
         * The mission which this controller controls.
         * @type Mission
         */
        this._mission = null;
        /**
         * @type Battle
         */
        this._battle = null;
        // The superclass constructor above loads the data from the JSON, so all action
        // properties should be have been created by now.
        // quitting to the menu
        this.setActionFunction("quit", true, function () {
            this._battle.pauseBattle();
            game.setScreen(armadaScreens.INGAME_MENU_SCREEN_NAME, true, armadaScreens.SUPERIMPOSE_BACKGROUND_COLOR);
        }.bind(this));
        // pausing the game
        this.setActionFunction("pause", true, function () {
            // showing an info box automatically pauses the game as implemented in
            // the BattleScreen class
            game.getScreen().showMessage(strings.get(strings.BATTLE.MESSAGE_PAUSED));
        });
        if (application.isDebugVersion()) {
            this.setActionFunction("stopTime", true, function () {
                this._battle.toggleTime();
            }.bind(this));
            // switching to pilot mode
            this.setActionFunction("switchToPilotMode", true, function () {
                _context.switchToPilotMode(this._mission.getPilotedSpacecraft());
            }.bind(this));
            // switching to spectator mode
            this.setActionFunction("switchToSpectatorMode", true, function () {
                _context.switchToSpectatorMode(true, true);
            });
            // toggling the visibility of hitboxes
            this.setActionFunction("toggleHitboxVisibility", true, function () {
                this._mission.toggleHitboxVisibility();
            }.bind(this));
        }
        // toggling the visibility of development-related info (version, FPS count) on screen
        this.setActionFunction("toggleDevInfoVisibility", true, function () {
            game.getScreen().toggleDevInfoVisibility();
        });
        // toggling the visibility of the HUD
        this.setActionFunction("toggleHUDVisibility", true, function () {
            this._battle.toggleHUDVisibility();
        }.bind(this));
        // toggling the mouse controls
        this.setActionFunction("toggleMouseControls", true, function () {
            _context.getInputInterpreter(MOUSE_NAME).toggleEnabled();
            if (_context.isInPilotMode()) {
                if (_context.getInputInterpreter(MOUSE_NAME).isEnabled()) {
                    document.body.style.cursor = 'none';
                    _context.enableMouseTurning();
                } else {
                    document.body.style.cursor = game.getDefaultCursor();
                }
            }
        });
        // toggling the joystick controls
        this.setActionFunction("toggleJoystickControls", true, function () {
            _context.getInputInterpreter(JOYSTICK_NAME).toggleEnabled();
        });
    }
    GeneralController.prototype = new control.Controller();
    GeneralController.prototype.constructor = GeneralController;
    /**
     * Returns the string representation of the type (domain) of the controller.
     * This will be shown to users on the control settings page, which groups controls
     * based on domains.
     * @returns {String}
     */
    GeneralController.prototype.getType = function () {
        return "general";
    };
    /**
     * Sets the controlled mission to the one passed as parameter.
     * @param {Mission} mission
     */
    GeneralController.prototype.setMission = function (mission) {
        this._mission = mission;
    };
    /**
     * Sets the controlled battle to the one passed as parameter.
     * @param {Battle} battle
     */
    GeneralController.prototype.setBattle = function (battle) {
        this._battle = battle;
    };
    // #########################################################################
    /**
     * Creates a fighter controller object.
     * @class The fighter controller pocesses and executes the actions with which
     * the user can control a space fighter.
     * @extends Controller
     * @param {Object} dataJSON The JSON object which contains the data to load the properties
     * of the recognized actions from.
     * @returns {FighterController}
     */
    function FighterController(dataJSON) {
        control.Controller.call(this, dataJSON);
        /**
         * A reference to the spacecraft (fighter) which this controller controls.
         * @type Spacecraft
         */
        this._controlledSpacecraft = null;
        /**
         * The strafing speed to be used for the controlled spacecraft, in m/s.
         * @type Number
         */
        this._strafeSpeed = 0;
        /**
         * Whether auto-targeting is currently turned on for this controller.
         * @type Boolean
         */
        this._autoTargeting = true;
        /**
         * The angle threshold which should be exceeded to trigger the rotation of non-fixed weapons for auto-aiming, in radians
         * @type Number
         */
        this._weaponAimThreshold = dataJSON.weaponAimThreshold;
        // The superclass constructor above loads the data from the JSON, so all action
        // properties should have been created
        // fire the primary weapons of the fighter
        this.setActionFunction("fire", true, function (i, source) {
            this._controlledSpacecraft.fire(false, i);
            if (source === _mouseInputInterpreter) {
                _context.enableMouseTurning();
            }
        }.bind(this));
        // launch a missile from the active missile launcher of the fighter
        this.setActionFunction("launchMissile", true, function (i, source) {
            if (!this._controlledSpacecraft.launchMissile(i)) {
                if (_missileChangeDeniedSound) {
                    _missileChangeDeniedSound.play();
                }
            }
            if (source === _mouseInputInterpreter) {
                _context.enableMouseTurning();
            }
        }.bind(this));
        // change to a missile launcher with a different missile equipped
        this.setActionFunction("changeMissile", true, function (i) {
            if (this._controlledSpacecraft.changeMissile(i)) {
                if (_missileChangeSound) {
                    _missileChangeSound.play();
                }
            } else {
                if (_missileChangeDeniedSound) {
                    _missileChangeDeniedSound.play();
                }
            }
        }.bind(this));
        // toggle salvo launching mode of missiles
        this.setActionFunction("toggleSalvo", true, function (i) {
            if (this._controlledSpacecraft.toggleSalvo(i)) {
                if (_missileSalvoSound) {
                    _missileSalvoSound.play();
                }
            } else {
                if (_missileChangeDeniedSound) {
                    _missileChangeDeniedSound.play();
                }
            }
        }.bind(this));
        // changing flight mode (free / combat / cruise)
        this.setActionFunction("changeFlightMode", true, function () {
            if (this._controlledSpacecraft.changeFlightMode()) {
                if (_flightModeSwitchSound) {
                    _flightModeSwitchSound.play();
                }
            }
        }.bind(this));
        // toggling between cruise and combat flight modes
        this.setActionFunction("toggleCruise", true, function () {
            if (this._controlledSpacecraft.toggleCruise()) {
                if (_flightModeSwitchSound) {
                    _flightModeSwitchSound.play();
                }
            }
        }.bind(this));
        // toggling between free and combat flight modes
        this.setActionFunction("toggleFlightAssist", true, function () {
            if (this._controlledSpacecraft.toggleFlightAssist()) {
                if (_flightModeSwitchSound) {
                    _flightModeSwitchSound.play();
                }
            }
        }.bind(this));
        // switch to next hostile target
        this.setActionFunction("nextNearestHostileTarget", true, function () {
            if (this._controlledSpacecraft.targetNextNearestHostile()) {
                _targetSwitchSound.play();
            } else {
                _targetSwitchDeniedSound.play();
            }
        }.bind(this));
        // switch to previous hostile target
        this.setActionFunction("previousNearestHostileTarget", true, function () {
            if (this._controlledSpacecraft.targetPreviousNearestHostile()) {
                _targetSwitchSound.play();
            } else {
                _targetSwitchDeniedSound.play();
            }
        }.bind(this));
        // switch to next target (any)
        this.setActionFunction("nextNearestNonHostileTarget", true, function () {
            if (this._controlledSpacecraft.targetNextNearestNonHostile()) {
                _targetSwitchSound.play();
            } else {
                _targetSwitchDeniedSound.play();
            }
        }.bind(this));
        // toggle auto targeting
        this.setActionFunction("toggleAutoTargeting", true, function () {
            this._autoTargeting = !this._autoTargeting;
        }.bind(this));
        // forward burn
        this.setActionFunctions("forward", function (i) {
            this._controlledSpacecraft.forward(i);
        }.bind(this), function () {
            this._controlledSpacecraft.stopForward();
        }.bind(this));
        // reverse burn
        this.setActionFunctions("reverse", function (i) {
            this._controlledSpacecraft.reverse(i);
        }.bind(this), function () {
            this._controlledSpacecraft.stopReverse();
        }.bind(this));
        // strafing to left and right
        this.setActionFunctions("strafeLeft", function (i) {
            if (this._controlledSpacecraft.getFlightMode() === equipment.FlightMode.CRUISE) {
                if (this._controlledSpacecraft.toggleCruise()) {
                    if (_flightModeSwitchSound) {
                        _flightModeSwitchSound.play();
                    }
                }
            }
            this._controlledSpacecraft.strafeLeft(((i !== undefined) ? i : 1) * this._strafeSpeed);
        }.bind(this), function () {
            this._controlledSpacecraft.stopLeftStrafe();
        }.bind(this));
        this.setActionFunctions("strafeRight", function (i) {
            if (this._controlledSpacecraft.getFlightMode() === equipment.FlightMode.CRUISE) {
                if (this._controlledSpacecraft.toggleCruise()) {
                    if (_flightModeSwitchSound) {
                        _flightModeSwitchSound.play();
                    }
                }
            }
            this._controlledSpacecraft.strafeRight(((i !== undefined) ? i : 1) * this._strafeSpeed);
        }.bind(this), function () {
            this._controlledSpacecraft.stopRightStrafe();
        }.bind(this));
        // strafing up and down
        this.setActionFunctions("raise", function (i) {
            if (this._controlledSpacecraft.getFlightMode() === equipment.FlightMode.CRUISE) {
                if (this._controlledSpacecraft.toggleCruise()) {
                    if (_flightModeSwitchSound) {
                        _flightModeSwitchSound.play();
                    }
                }
            }
            this._controlledSpacecraft.raise(((i !== undefined) ? i : 1) * this._strafeSpeed);
        }.bind(this), function () {
            this._controlledSpacecraft.stopRaise();
        }.bind(this));
        this.setActionFunctions("lower", function (i) {
            if (this._controlledSpacecraft.getFlightMode() === equipment.FlightMode.CRUISE) {
                if (this._controlledSpacecraft.toggleCruise()) {
                    if (_flightModeSwitchSound) {
                        _flightModeSwitchSound.play();
                    }
                }
            }
            this._controlledSpacecraft.lower(((i !== undefined) ? i : 1) * this._strafeSpeed);
        }.bind(this), function () {
            this._controlledSpacecraft.stopLower();
        }.bind(this));
        this.setActionFunction("toggleSpeedHolding", true, function () {
            if (this._controlledSpacecraft.toggleSpeedHolding()) {
                if (_flightModeSwitchSound) {
                    _flightModeSwitchSound.play();
                }
            }
        }.bind(this));
        // resetting speed to 0
        this.setActionFunction("resetSpeed", true, function () {
            this._controlledSpacecraft.resetSpeed();
        }.bind(this));
        // turning along the 3 axes
        this.setActionFunction("yawLeft", true, function (i, source) {
            this._controlledSpacecraft.yawLeft(i);
            if (source !== _mouseInputInterpreter) {
                _context.disableMouseTurning();
            }
        }.bind(this));
        this.setActionFunction("yawRight", true, function (i, source) {
            this._controlledSpacecraft.yawRight(i);
            if (source !== _mouseInputInterpreter) {
                _context.disableMouseTurning();
            }
        }.bind(this));
        this.setActionFunction("pitchUp", true, function (i, source) {
            this._controlledSpacecraft.pitchUp(i);
            if (source !== _mouseInputInterpreter) {
                _context.disableMouseTurning();
            }
        }.bind(this));
        this.setActionFunction("pitchDown", true, function (i, source) {
            this._controlledSpacecraft.pitchDown(i);
            if (source !== _mouseInputInterpreter) {
                _context.disableMouseTurning();
            }
        }.bind(this));
        this.setActionFunction("rollLeft", true, function (i) {
            this._controlledSpacecraft.rollLeft(i);
        }.bind(this));
        this.setActionFunction("rollRight", true, function (i) {
            this._controlledSpacecraft.rollRight(i);
        }.bind(this));
        this.setActionFunction("jumpOut", true, function () {
            this._controlledSpacecraft.jumpOut(true);
        }.bind(this));
    }
    FighterController.prototype = new control.Controller();
    FighterController.prototype.constructor = FighterController;
    /**
     * Returns the string representation of the type (domain) of the controller.
     * This will be shown to users on the control settings page, which groups controls
     * based on domains.
     * @returns {String}
     */
    FighterController.prototype.getType = function () {
        return "fighter";
    };
    /**
     * Sets the controlled spacecraft (fighter) for this controller. After called,
     * all controls will take effect on the spacecraft passed here as a parameter.
     * @param {Spacecraft} controlledSpacecraft
     */
    FighterController.prototype.setControlledSpacecraft = function (controlledSpacecraft) {
        this._controlledSpacecraft = controlledSpacecraft;
        if (this._controlledSpacecraft) {
            this._strafeSpeed = _strafeSpeedFactor * this._controlledSpacecraft.getMaxAcceleration();
        }
    };
    /**
     * Same as the method of the parent class, but with a check if there if there is
     * a controlled spacecraft present.
     * @param {Object[]} triggeredActions See Controller.executeActions
     * @param {Number} dt The elapsed time since the last control step, in milliseconds
     */
    FighterController.prototype.executeActions = function (triggeredActions, dt) {
        if (this._controlledSpacecraft) {
            if (!this._controlledSpacecraft.canBeReused()) {
                this._controlledSpacecraft.prepareForControl();
                // executing user-triggered actions
                control.Controller.prototype.executeActions.call(this, triggeredActions);
                // executing automatic actions
                if (this._autoTargeting && !this._controlledSpacecraft.getTarget()) {
                    if (this._controlledSpacecraft.targetNextBestHostile()) {
                        _targetSwitchSound.play();
                    }
                }
                this._controlledSpacecraft.aimWeapons(this._weaponAimThreshold, 0, dt);
            } else {
                this._controlledSpacecraft = null;
            }
        }
    };
    // -------------------------------------------------------------------------
    // private functions
    /**
     * Creates and returns a sound clip based on the name of the configuration settings its data is stored in
     * @param {String} settingName
     * @returns {SoundClip}
     */
    function _initSound(settingName) {
        return resources.getSoundEffect(
                config.getHUDSetting(settingName).name).createSoundClip(
                resources.SoundCategory.SOUND_EFFECT,
                config.getHUDSetting(settingName).volume);
    }
    // #########################################################################
    /**
     * @class The control context used for the game, building on the general control context 
     * @extends ControlContext
     */
    function ArmadaControlContext() {
        control.ControlContext.call(this);
        /**
         * Whether the context is currently in the mode for controlling a spacecraft as a pilot (as opposed to spectator mode, controlling
         * a free camera)
         * @type Boolean
         */
        this._pilotingMode = false;
        /**
         * Whether mouse turning is currently disabled (automatically happens if the player uses another input device for turning)
         * @type Boolean
         */
        this._mouseTurningDisabled = false;
        this.registerInputInterpreterType(KEYBOARD_NAME, keyboard.KeyboardInputInterpreter);
        this.registerInputInterpreterType(MOUSE_NAME, mouse.MouseInputInterpreter);
        this.registerInputInterpreterType(JOYSTICK_NAME, gamepad.GamepadInputInterpreter);
        if (utils.areTouchEventsSupported()) {
            this.registerInputInterpreterType(TOUCH_NAME, touch.TouchInputInterpreter);
        }
        this.registerControllerType(GENERAL_CONTROLLER_NAME, GeneralController);
        this.registerControllerType(FIGHTER_CONTROLLER_NAME, FighterController);
        this.registerControllerType(CAMERA_CONTROLLER_NAME, cameraController.CameraController);
    }
    ArmadaControlContext.prototype = new control.ControlContext();
    ArmadaControlContext.prototype.constructor = ArmadaControlContext;
    /**
     * Returns whether the context is currently in the mode for controlling a spacecraft as a pilot (as opposed to spectator mode, 
     * controlling a free camera)
     * @returns {Boolean}
     */
    ArmadaControlContext.prototype.isInPilotMode = function () {
        return this._pilotingMode;
    };
    /**
     * Switches to piloting game mode, putting the player in the pilot seat of the given spacecraft.
     * @param {Spacecraft} pilotedSpacecraft
     * @param {Boolean} [skipTransition=false] If true, the camera transition will be instantaneous
     */
    ArmadaControlContext.prototype.switchToPilotMode = function (pilotedSpacecraft, skipTransition) {
        if (!pilotedSpacecraft || !pilotedSpacecraft.isAlive() || this._pilotingMode) {
            return;
        }
        this._pilotingMode = true;
        _targetSwitchSound = _initSound(config.BATTLE_SETTINGS.HUD.TARGET_SWITCH_SOUND);
        _targetSwitchDeniedSound = _initSound(config.BATTLE_SETTINGS.HUD.TARGET_SWITCH_DENIED_SOUND);
        _flightModeSwitchSound = _initSound(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_SWITCH_SOUND);
        _missileChangeSound = _initSound(config.BATTLE_SETTINGS.HUD.MISSILE_CHANGE_SOUND);
        _missileChangeDeniedSound = _initSound(config.BATTLE_SETTINGS.HUD.MISSILE_CHANGE_DENIED_SOUND);
        _missileSalvoSound = _initSound(config.BATTLE_SETTINGS.HUD.MISSILE_SALVO_SOUND);
        this.getController(FIGHTER_CONTROLLER_NAME).setControlledSpacecraft(pilotedSpacecraft);
        this.getController(CAMERA_CONTROLLER_NAME).setCameraToFollowObject(
                pilotedSpacecraft.getVisualModel(),
                skipTransition ? 0 : config.getSetting(config.BATTLE_SETTINGS.CAMERA_PILOTING_SWITCH_TRANSITION_DURATION),
                config.getSetting(config.BATTLE_SETTINGS.CAMERA_PILOTING_SWITCH_TRANSITION_STYLE),
                config.getDefaultCamerConfigurationName(pilotedSpacecraft));
        this.disableAction("followNext");
        this.disableAction("followPrevious");
        game.getScreen().setHeaderContent("");
        if (this.getInputInterpreter(MOUSE_NAME).isEnabled()) {
            document.body.style.cursor = 'none';
        }
    };
    /**
     * Switches to spectator mode, in which the player can freely move the camera
     * around or follow and inspect any object in the scene.
     * @param {Boolean} [freeCamera=false] Whether to set the camera free at the current position and location.
     * @param {Boolean} [force=false] If true, the settings for spectator mode will be (re)applied even if the current state is already set
     * as spectator mode (useful for first time initialization and to force switch to free camera when following a spacecraft in spectator 
     * mode)
     */
    ArmadaControlContext.prototype.switchToSpectatorMode = function (freeCamera, force) {
        if (this._pilotingMode || force) {
            this._pilotingMode = false;
            this.getController(FIGHTER_CONTROLLER_NAME).setControlledSpacecraft(null);
            if (freeCamera) {
                this.getController(CAMERA_CONTROLLER_NAME).setToFreeCamera(false);
            }
            this.enableAction("followNext");
            this.enableAction("followPrevious");
            game.getScreen().setHeaderContent(strings.get(strings.BATTLE.SPECTATOR_MODE));
            document.body.style.cursor = game.getDefaultCursor();
        }
    };
    /**
     * Disables the turning related actions from the mouse input interpreter.
     * To be called when the user turn using an input device other than the mouse.
     */
    ArmadaControlContext.prototype.disableMouseTurning = function () {
        if (!this._mouseTurningDisabled) {
            _mouseInputInterpreter.disableAction("yawLeft");
            _mouseInputInterpreter.disableAction("yawRight");
            _mouseInputInterpreter.disableAction("pitchUp");
            _mouseInputInterpreter.disableAction("pitchDown");
            _mouseInputInterpreter.disableAction("rollLeft");
            _mouseInputInterpreter.disableAction("rollRight");
            this._mouseTurningDisabled = true;
        }
    };
    /**
     * Enables the turning related actions from the mouse input interpreter
     * To be called when the user fires using the mouse.
     */
    ArmadaControlContext.prototype.enableMouseTurning = function () {
        if (this._mouseTurningDisabled) {
            _mouseInputInterpreter.enableAction("yawLeft");
            _mouseInputInterpreter.enableAction("yawRight");
            _mouseInputInterpreter.enableAction("pitchUp");
            _mouseInputInterpreter.enableAction("pitchDown");
            _mouseInputInterpreter.enableAction("rollLeft");
            _mouseInputInterpreter.enableAction("rollRight");
            this._mouseTurningDisabled = false;
        }
    };
    /**
     * Returns whether mouse turning has been auto-disabled by the player using another input device for turning.
     * @returns {Boolean}
     */
    ArmadaControlContext.prototype.isMouseTurningDisabled = function () {
        return this._mouseTurningDisabled;
    };
    // -------------------------------------------------------------------------
    // Initialization
    _context = new ArmadaControlContext();
    // -------------------------------------------------------------------------
    // Caching input interpreters
    _context.executeWhenReady(function () {
        _mouseInputInterpreter = _context.getInputInterpreter(MOUSE_NAME);
    });
    // -------------------------------------------------------------------------
    // Caching configuration settings
    config.executeWhenReady(function () {
        _strafeSpeedFactor = config.getSetting(config.BATTLE_SETTINGS.STRAFE_SPEED_FACTOR);
    });
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        KEYBOARD_NAME: KEYBOARD_NAME,
        MOUSE_NAME: MOUSE_NAME,
        JOYSTICK_NAME: JOYSTICK_NAME,
        GAMEPAD_NAME: GAMEPAD_NAME,
        GENERAL_CONTROLLER_NAME: GENERAL_CONTROLLER_NAME,
        FIGHTER_CONTROLLER_NAME: FIGHTER_CONTROLLER_NAME,
        CAMERA_CONTROLLER_NAME: CAMERA_CONTROLLER_NAME,
        KeyBinding: keyboard.KeyBinding,
        loadConfigurationFromJSON: _context.loadConfigurationFromJSON.bind(_context),
        loadSettingsFromJSON: _context.loadSettingsFromJSON.bind(_context),
        loadSettingsFromLocalStorage: _context.loadSettingsFromLocalStorage.bind(_context),
        restoreDefaults: _context.restoreDefaults.bind(_context),
        getControllers: _context.getControllers.bind(_context),
        getController: _context.getController.bind(_context),
        isControllerPriority: _context.isControllerPriority.bind(_context),
        getInputInterpreters: _context.getInputInterpreters.bind(_context),
        getInputInterpreter: _context.getInputInterpreter.bind(_context),
        control: _context.control.bind(_context),
        startListening: _context.startListening.bind(_context),
        stopListening: _context.stopListening.bind(_context),
        isListening: _context.isListening.bind(_context),
        setScreenCenter: _context.setScreenCenter.bind(_context),
        executeWhenReady: _context.executeWhenReady.bind(_context),
        isInPilotMode: _context.isInPilotMode.bind(_context),
        switchToPilotMode: _context.switchToPilotMode.bind(_context),
        switchToSpectatorMode: _context.switchToSpectatorMode.bind(_context),
        isMouseTurningDisabled: _context.isMouseTurningDisabled.bind(_context),
        playMissileChangeSound: playMissileChangeSound
    };
});

/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Implementation of the Spacecraft game-logic-level class
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, Element, Float32Array, performance */

/**
 * @param utils Used for Pi related constants
 * @param vec Vector operations are needed for several logic functions
 * @param mat Matrices are widely used for 3D simulation
 * @param application Used for file loading and logging functionality
 * @param managedGL Used for accessing shader variable types
 * @param egomModel Used for generating 3D models for hitboxes
 * @param physics Used for creating the physical model for spacecrafts and for constants
 * @param resources Used to access the loaded media (graphics and sound) resources
 * @param renderableObjects Used for creating visual models for spacecrafts
 * @param lights Used for creating light sources for spacecrafts
 * @param sceneGraph Used for creating the hitbox nodes
 * @param graphics Used to access graphics settings
 * @param audio Used for creating sound sources for spacecrafts
 * @param config Used to access game settings/configuration
 * @param strings Used for translation support
 * @param control Used to access control sound effects
 * @param classes Used to load and access the classes of Interstellar Armada
 * @param constants Used for light priority values
 * @param SpacecraftEvents Used for event handling
 * @param equipment Used for equipping spacecrafts
 * @param explosion Used to create the explosion for exploding spacecrafts
 */
define('armada/logic/spacecraft',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/managed-gl",
    "modules/egom-model",
    "modules/physics",
    "modules/media-resources",
    "modules/scene/renderable-objects",
    "modules/scene/lights",
    "modules/scene/scene-graph",
    "armada/graphics",
    "armada/audio",
    "armada/logic/classes",
    "armada/configuration",
    "armada/strings",
    "armada/control",
    "armada/logic/constants",
    "armada/logic/SpacecraftEvents",
    "armada/logic/equipment",
    "armada/logic/explosion",
    "utils/polyfill"
], function (
        utils, vec, mat,
        application, managedGL, egomModel, physics, resources,
        renderableObjects, lights, sceneGraph,
        graphics, audio, classes, config, strings, control,
        constants, SpacecraftEvents, equipment, explosion) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // enums
            /**
             * Spacecrafts can take one of these formations (e.g. for placing them initially in a mission or when jumping in)
             * @enum {String}
             */
            SpacecraftFormation = {
                /** X offset is alternating (+/-), all offset factors increase for every second ship */
                WEDGE: "wedge",
                /** The position is randomly generated within the +/- X/2,Y/2,Z/2 around the lead position */
                RANDOM: "random"
            },
            // ------------------------------------------------------------------------------
            // constants
            /**
             * The string to be inserted between the name of the spacecraft and the index of the body of its physical model, when the name for
             * the corresponding hitbox model is created
             * @type String
             */
            HITBOX_BODY_MODEL_NAME = "hitBox",
            /**
             * A nonexistent color to set the original faction color uniform to when there is no faction color set
             * @type Number[4]
             */
            FACTION_COLOR_NONE = [-1, -1, -1, -1],
            /**
             * The name (without prefixes and suffixes) of the uniform variable that stores the original faction color (the color included
             * in the model file) of spacecraft models.
             * @type String
             */
            UNIFORM_ORIGINAL_FACTION_COLOR_NAME = "originalFactionColor",
            /**
             * The name (without prefixes and suffixes) of the uniform variable that stores the faction color of the team of the spacecraft
             * that should replace the original faction color when rendering the spacecraft model.
             * @type String
             */
            UNIFORM_REPLACEMENT_FACTION_COLOR_NAME = "replacementFactionColor",
            /**
             * The name (without prefixes and suffixes) of the uniform variable that determines the state (color and strength) of shield animation
             * @type String
             */
            UNIFORM_SHIELD_STATE_NAME = "shieldState",
            /**
             * The duration while the hum sound effects ramp to their normal volume after being started.
             * In seconds.
             * @type Number
             */
            HUM_SOUND_VOLUME_RAMP_DURATION = 0.020,
            /**
             * Used to create strings which display spacecraft equipment lists to the user
             * @type String
             */
            DEFAULT_EQUIPMENT_STRING_SEPARATOR = ", ",
            /**
             * Used to create strings which display spacecraft weapon range lists to the user
             * @type String
             */
            DEFAULT_WEAPON_RANGE_STRING_SEPARATOR = "/",
            /**
             * The damage indicators will be positioned using a second hitcheck towards the ship center if its hit position is
             * farther from the original hit position that the square root of this value. (i.e. if there was a large enough
             * offset given for the original hitcheck, e.g. when a missile explodes with a proximity fuse several meters away from the
             * ship, the damage indicator should not be positioned where the missile exploded, but on the ship surface, and in this
             * case the ship surface is far away enough from the original hit position that it will be used as the damage indicator
             * position)
             * @type Number
             */
            MINIMUM_DISTANCE_FOR_DAMAGE_INDICATOR_HITCHECK_SQUARED = 0.01,
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * Cached value of the configuration setting of the name of the uniform array storing the luminosity factors for models.
             * @type String
             */
            _luminosityFactorsArrayName = null,
            /**
             * Cached value of the configuration setting of the name of the uniform array storing the group transforms for models.
             * @type String
             */
            _groupTransformsArrayName = null,
            /**
             * Stores the uniform parameter array definitions (what arrays are there and what are their types in
             * name: type format) to use when creating visual models for spacecraft
             * @type Object
             */
            _parameterArrays = null,
            /**
             * A cached value of whether dynamic lights are turned on / available
             * @type Boolean
             */
            _dynamicLights = false,
            /**
             * Cached value of the configuration setting for hit zone visualization color.
             * @type Number[4]
             */
            _hitZoneColor,
            /**
             * Cached value of the configuration setting for the minimum distance at which fire sounds of a spacecraft should be stacked.
             * @type Number
             */
            _weaponFireSoundStackMinimumDistance,
            /**
             * Cached value of the configuratino settings of the factor for score awarded for kills
             * @type Number
             */
            _scoreFactorForKill,
            /**
             * A random function with a specific seed
             * @type Function
             */
            _random;
    // #########################################################################
    /**
     * Needs to be executed whenever the settings in the graphics module change
     */
    function handleGraphicsSettingsChanged() {
        _parameterArrays = {};
        // setting up parameter array declarations (name: type)
        _parameterArrays[_groupTransformsArrayName] = managedGL.ShaderVariableType.MAT4;
        if (graphics.areLuminosityTexturesAvailable()) {
            _parameterArrays[_luminosityFactorsArrayName] = managedGL.ShaderVariableType.FLOAT;
        }
        _dynamicLights = graphics.areDynamicLightsAvailable() && (graphics.getMaxPointLights() > 0);
    }
    function resetRandomSeed() {
        _random = Math.seed(config.getSetting(config.GENERAL_SETTINGS.DEFAULT_RANDOM_SEED));
    }
    // #########################################################################
    /**
     * @class
     * A blinking light on a spacecraft, represented by a particle (dynamically animating) and an accompanied point light source
     * @param {BlinkerDescriptor} descriptor The descriptor object holding the information based on which the particle and light source can
     * be set up
     */
    function Blinker(descriptor) {
        /**
         * Holds the information needed to set up the particle and the light source when the blinker is added to a scene
         * @type BlinkerDescriptor
         */
        this._descriptor = descriptor;
        /**
         * Reference to the particle representing this blinker
         * @type Particle
         */
        this._visualModel = null;
        /**
         * Reference to the light source corresponding to this blinker
         * @type PointLightSource
         */
        this._lightSource = null;
    }
    /**
     * Creates the visual representation (particle and light source) to represent this blinker and adds it to a scene below the passed node
     * @param {RenderableNode} parentNode
     * @param {Boolean} addLightSource Whether to create and add the light source
     */
    Blinker.prototype.addToScene = function (parentNode, addLightSource) {
        this._visualModel = new renderableObjects.Particle(
                this._descriptor.getParticle().getModel(),
                this._descriptor.getParticle().getShader(),
                this._descriptor.getParticle().getTexturesOfTypes(this._descriptor.getParticle().getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                mat.translation4v(this._descriptor.getPosition()),
                this._descriptor.getParticleStates(),
                true,
                this._descriptor.getParticle().getInstancedShader(),
                0);
        parentNode.addSubnode(new sceneGraph.RenderableNode(this._visualModel, false, false, config.getSetting(config.BATTLE_SETTINGS.MINIMUM_BLINKER_PARTICLE_COUNT_FOR_INSTANCING)));
        if (_dynamicLights && (addLightSource === true) && (this._descriptor.getIntensity() > 0)) {
            this._lightSource = new lights.PointLightSource(
                    this._descriptor.getLightColor(),
                    0,
                    this._descriptor.getPosition(),
                    [parentNode.getRenderableObject()],
                    this._descriptor.getLightStates(),
                    true);
            parentNode.getScene().addPointLightSource(this._lightSource, constants.BLINKER_LIGHT_PRIORITY);
        }
    };
    /**
     * Sets the animation state of the particle and the light source to represent the blinking state occurring after the passed amount of 
     * time from  the start
     * @param {Number} elapsedTime In milliseconds. Can be larger than the period of the blinking, the appropriate state will be calculated
     */
    Blinker.prototype.setTime = function (elapsedTime) {
        this._visualModel.setAnimationTime(elapsedTime);
        if (this._lightSource) {
            this._lightSource.setAnimationTime(elapsedTime);
        }
    };
    /**
     * Sets a random animation time within the period of the blinking for the blinker and returns it
     * @returns {Number}
     */
    Blinker.prototype.setRandomTime = function () {
        var time = Math.round(Math.random() * this._descriptor.getPeriod());
        this.setTime(time);
        return time;
    };
    // #########################################################################
    /**
     * @class Represents a specific spacecraft (fighter, warship, freighter, space
     * station etc.) in the game.
     * @param {SpacecraftClass} spacecraftClass The class of the spacecraft that
     * describes its general properties.
     * @param {String} [name] An optional name to identify this spacecraft by.
     * @param {Float32Array} [positionMatrix] The translation matrix describing
     * the initial position of the spacecraft.
     * @param {Float32Array} [orientationMatrix] The rotation matrix describing
     * the initial orientation of the spacecraft.
     * @param {String} [loadoutName] The name of the loadout to use to equip the
     * spacecraft. If not given, the spacecraft will not be equipped.
     * @param {Spacecraft[]} spacecraftArray The array of spacecrafts participating
     * in the same battle simulation as this one.
     * @param {Environment} [environment] The environment the spacecraft is situated in
     */
    function Spacecraft(spacecraftClass, name, positionMatrix, orientationMatrix, loadoutName, spacecraftArray, environment) {
        // ---------------------------------------
        // basic info
        /**
         * The class of this spacecraft that describes its general properties.
         * @type SpacecraftClass
         */
        this._class = null;
        /**
         * A unique string ID that can identify this spacecraft within a mission.
         * @type String
         */
        this._id = null;
        /**
         * An optional name by which this spacecraft can be identified.
         * @type String
         */
        this._name = null;
        /**
         * A cached value of the translated designation of this spacecraft that can be displayed to the user.
         * @type String
         */
        this._displayName = null;
        // ---------------------------------------
        // current state
        /**
         * Set to false when the spacecraft object is destroyed and cannot be used anymore. At this
         * point, some references from it have also been removed. (some are kept as might be required
         * by for example the wingmen status indicator on the HUD to display fallen wingmen with the
         * icon appropriate for their class)
         * @type Boolean
         */
        this._alive = true;
        /**
         * True when the spacecraft has jumped out from or has not jumped in yet to the current mission scene.
         * @type Boolean
         */
        this._away = false;
        /**
         * The number of hitpoints indicate the amount of damage the ship can take. Successful hits by
         * projectiles on the ship reduce the amount of hitpoints based on the damage value of the 
         * projectile, and when it hits zero, the spacecraft explodes.
         * @type Number
         */
        this._hitpoints = 0;
        /**
         * The maximum hitpoints of this spacecraft. Based on the amount of hitpoints its spacecraft class has,
         * but can be modified by other factors (such as difficulty)
         * @type Number
         */
        this._maxHitpoints = 0;
        // ---------------------------------------
        // visuals
        /**
         * The renderable node that represents this spacecraft in a scene.
         * @type ParameterizedMesh
         */
        this._visualModel = null;
        /**
         * The renderable object that is used as the parent for the visual
         * representation of the hitboxes of this craft.
         * @type RenderableNode
         */
        this._hitbox = null;
        /**
         * The blinking lights on the spacecraft
         * @type Blinker[]
         */
        this._blinkers = null;
        /**
         * The point and spot lights attached to the visual model of this spacecraft
         * @type PointLightSource[]
         */
        this._lights = null;
        // ---------------------------------------
        // physics
        /**
         * The object representing the physical properties of this spacecraft.
         * Used to calculate the movement and rotation of the craft as well as
         * check for collisions and hits.
         * @type PhysicalObject
         */
        this._physicalModel = null;
        /**
         * A cache/reuse value for the 3D position vector of the physical model of the spacecraft to avoid
         * creating new arrays every time it is needed
         * @type Number[3]
         */
        this._physicalPositionVector = [0, 0, 0];
        /**
         * Cached value of the matrix representing the relative velocity (translation in m/s in the coordinate space of the spacecraft)
         * of the spacecraft.
         * @type Float32Array
         */
        this._relativeVelocityMatrix = mat.identity4();
        /**
         * Whether the currently stored relative velocity matrix value is up-to-date.
         * @type Boolean
         */
        this._relativeVelocityMatrixValid = false;
        /**
         * Cached value of the matrix representing the turning the current angular velocity of the object causes over 
         * ANGULAR_VELOCITY_MATRIX_DURATION milliseconds in model space.
         * @type Float32Array
         */
        this._turningMatrix = mat.identity4();
        /**
         * Whether the currently stored turning matrix value is up-to-date.
         * @type Boolean
         */
        this._turningMatrixValid = false;
        /**
         * The cached calculated values of the scaling * orientation matrix.
         * @type Float32Array
         */
        this._scaledOriMatrix = mat.identity4();
        // ---------------------------------------
        // equipment
        /**
         * The list of weapons this spacecraft is equipped with.
         * @type Weapon[]
         */
        this._weapons = null;
        /**
         * The list of missile launchers (that are loaded with missiles) this spacecraft is equipped with.
         * @type MissileLauncher[]
         */
        this._missileLaunchers = [];
        /**
         * The index currently active missile launcher (which launches a missile when the launchMissile()
         * method is called)
         * -1 means no active launcher (e.g. no missiles equipped)
         * @type Number
         */
        this._activeMissileLauncherIndex = -1;
        /**
         * An array of all the missile classes of currently equipped missiles on this ship
         * @type MissileClass[]
         */
        this._missileClasses = [];
        /**
         * The targeting computer equipped on this spacecraft.
         * @type TargetingComputer
         */
        this._targetingComputer = null;
        /**
         * While true, the spacecraft is not allowed to fire (for example during jump sequences)
         * @type Boolean
         */
        this._firingDisabled = false;
        /**
         * The propulsion system this spacecraft is equipped with.
         * @type Propulsion
         */
        this._propulsion = null;
        /**
         * The jump engine this spacecraft is equipped with.
         * @type JumpEngine
         */
        this._jumpEngine = null;
        /**
         * The shield this spacecraft is equipped with.
         * @type Shield
         */
        this._shield = null;
        /**
         * The maneuvering computer of this spacecraft that translates high
         * level maneuvering commands issued to this craft into thruster control.
         * @type ManeuveringComputer
         */
        this._maneuveringComputer = null;
        // ---------------------------------------
        // effects
        /**
         * The list of damage indicators that are currently visible on the spacecraft.
         * @type Explosion[]
         */
        this._activeDamageIndicators = [];
        /**
         * A reference to the explosion if the spacecraft is exploding
         * @type Explosion
         */
        this._explosion = null;
        // ---------------------------------------
        // event handling
        /**
         * The functions to call when the various spacecraft events happen (see SpacecraftEvents.js for possible types) to this spacecraft.
         * The keys are the event type IDs, the values are the lists of functions to call for each event.
         * @type Object.<String, Function[]>
         */
        this._eventHandlers = null;
        /**
         * An array of references to the spacecrafts that have this spacecraft targeted currently.
         * @type Spacecraft[]
         */
        this._targetedBy = null;
        // ---------------------------------------
        // affiliation
        /**
         * A reference to the team this spacecraft belongs to (governing who is friend or foe).
         * @type Team
         */
        this._team = null;
        /**
         * A string ID of the squad this spacecraft belongs to.
         * @type String
         */
        this._squad = null;
        /**
         * The index of this spacecraft that specifies its place within its squad.
         * @type Number
         */
        this._indexInSquad = 0;
        // ---------------------------------------
        // sound
        /**
         * Sound clip used for playing the "hum" sound effect for this spacecraft.
         * @type SoundClip
         */
        this._humSoundClip = null;
        /**
         * The (original) volume of the hum sound effect (to be able to restore it after it is set to zero)
         * @type Number
         */
        this._humSoundVolume = 0;
        /**
         * The sound source used to position the sound effects beloning to this spacecraft in 3D sound (=camera) space
         * @type SoundSource
         */
        this._soundSource = null;
        /**
         * Reusable vector for storing the calculated sound source position
         * @type Number[3]
         */
        this._soundSourcePosition = [0, 0, 0];
        // ---------------------------------------
        // statistics
        /**
         * The kill count for this spacecraft (current mission)
         * @type Number
         */
        this._kills = 0;
        /**
         * The current score for this spacecraft (without bonuses)
         * @type Number
         */
        this._score = 0;
        /**
         * The amount of damage dealt to enemies by this spacecraft during the current mission
         * @type Number
         */
        this._damageDealt = 0;
        /**
         * The amount of damage dealt to enemies by this spacecraft using missiles during the current mission
         * @type Number
         */
        this._missileDamageDealt = 0;
        /**
         * A counter for the (projectile weapon) shots fired during the current mission (for hit ratio calculation)
         * @type Number
         */
        this._shotsFired = 0;
        /**
         * A counter for the (projectile weapon) shots that hit an enemy during the current mission (for hit ratio calculation)
         * @type Number
         */
        this._hitsOnEnemies = 0;
        /**
         * A counter for the missiles launched during the current mission (for hit ratio calculation)
         * @type Number
         */
        this._missilesLaunched = 0;
        /**
         * A counter for the launched missiles that hit an enemy during the current mission (for hit ratio calculation)
         * @type Number
         */
        this._missileHitsOnEnemies = 0;
        // ---------------------------------------
        // other
        /**
         * The calculated cached value of how many score points is destroying this spacecraft worth (based on spacecraft class and equipment
         * score values)
         * @type Number
         */
        this._scoreValue = 0;
        /**
         * Negative, while the ship is not destoyed, set to zero upon start of destruction animation so
         * that deletion of the spacecraft can take place at the appropriate time
         * @type Number
         */
        this._timeElapsedSinceDestruction = -1;
        // ---------------------------------------
        // optimization
        /**
         * Cached factor to work with when asking for needed burn for speed change
         * @type Number
         */
        this._burnForSpeedChangeFactor = 0;
        /**
         * Cached factor to work with when asking for needed burn for angular velocity change
         * @type Number
         */
        this._burnForAngularVelocityChangeFactor = 0;
        /**
         * Cached value of the calculated top speed of the spacecraft, using the currently equipped
         * propulsion and the globally set drag coefficient (zero if there is no drag)
         * @type Number
         */
        this._topSpeed = 0;
        // initializing the properties based on the parameters
        if (spacecraftClass) {
            this._init(spacecraftClass, name, positionMatrix, orientationMatrix, loadoutName, spacecraftArray, environment);
        }
    }
    /**
     * Returns the relative position for a spacecraft in a formation
     * @param {SpacecraftEvents~JumpFormationData} formation The descriptor of the formation
     * @param {Number} index The index of the spacecraft within the formation (the lead is 0)
     * @param {Number[3]} [leadPosition] The 3D position vector of the lead ship in the formation
     * @param {Float32Array} [orientation] The 4x4 orientation matrix of the formation
     * @returns {Number[3]}
     */
    Spacecraft.getPositionInFormation = function (formation, index, leadPosition, orientation) {
        var result, factor = Math.ceil(index / 2);
        switch (formation.type) {
            case SpacecraftFormation.WEDGE:
                result = [
                    (((index % 2) === 1) ? 1 : -1) * factor * formation.spacing[0],
                    factor * formation.spacing[1],
                    factor * formation.spacing[2]];
                break;
            case SpacecraftFormation.RANDOM:
                result = [
                    _random() * formation.spacing[0] - formation.spacing[0] / 2,
                    _random() * formation.spacing[1] - formation.spacing[1] / 2,
                    _random() * formation.spacing[2] - formation.spacing[2] / 2
                ];
                break;
            default:
                application.showError("Unknown formation type specified: '" + formation.type + "!");
                return [0, 0, 0];
        }
        if (orientation) {
            vec.mulVec3Mat4(result, orientation);
        }
        if (leadPosition) {
            vec.add3(result, leadPosition);
        }
        return result;
    };
    // initializer
    /**
     * Initializes the properties of the spacecraft. Used by the constructor
     * and the methods that load the data from an external source.
     * @param {SpacecraftClass} spacecraftClass
     * @param {String} [name]
     * @param {Float32Array} [positionMatrix]
     * @param {Float32Array} [orientationMatrix]
     * @param {String} [loadoutName]
     * @param {Spacecraft[]} [spacecraftArray]
     * @param {Environment} [environment]
     * @see Spacecraft
     */
    Spacecraft.prototype._init = function (spacecraftClass, name, positionMatrix, orientationMatrix, loadoutName, spacecraftArray, environment) {
        var i, blinkerDescriptors;
        this._class = spacecraftClass;
        this._name = name || "";
        this._alive = true;
        this._away = false;
        this._hitpoints = this._class.getHitpoints();
        this._maxHitpoints = this._class.getHitpoints();
        this._physicalModel = new physics.PhysicalObject(
                this._class.getMass(),
                positionMatrix || mat.identity4(),
                orientationMatrix || mat.identity4(),
                mat.identity4(),
                mat.identity4(),
                this._class.getBodies(),
                false,
                false,
                this._class.getDragFactor());
        this._weapons = [];
        this._missileLaunchers = [];
        this._missileClasses = [];
        this._activeMissileLauncherIndex = -1;
        this._targetingComputer = new equipment.TargetingComputer(this, spacecraftArray, environment);
        this._firingDisabled = false;
        this._maneuveringComputer = new equipment.ManeuveringComputer(this);
        this._blinkers = [];
        blinkerDescriptors = this._class.getBlinkerDescriptors();
        for (i = 0; i < blinkerDescriptors.length; i++) {
            this._blinkers.push(new Blinker(blinkerDescriptors[i]));
        }
        this._lights = [];
        // equipping the craft if a loadout name was given
        if (loadoutName) {
            this.equipLoadout(this._class.getLoadout(loadoutName));
        }
        this._targetedBy = [];
        this._eventHandlers = {};
        this._team = null;
        this._kills = 0;
        this._score = 0;
        this._damageDealt = 0;
        this._missileDamageDealt = 0;
        this._shotsFired = 0;
        this._hitsOnEnemies = 0;
        this._missilesLaunched = 0;
        this._missileHitsOnEnemies = 0;
        this._hitSounds = {};
        this._hitSoundTimestamp = 0;
        this._updateIDAndName();
        this._updateScoreValue();
        this._updateBurnNeedFactors();
    };
    /**
     * Updates the cached values for the spacecraft ID and display name based on the designation (name / squad) of the spacecraft.
     */
    Spacecraft.prototype._updateIDAndName = function () {
        this._id = (this._name || !this._squad) ?
                this._name :
                this._squad + " " + this._indexInSquad.toString();
        this._displayName = (this._name || !this._squad) ?
                this._name :
                strings.get(strings.SQUAD.PREFIX, this._squad, this._squad) + " " + this._indexInSquad.toString();
    };
    /**
     * Updates the cached values for faster calculation of needed burn levels (depends on propulsion and phyiscal model (mass))
     */
    Spacecraft.prototype._updateBurnNeedFactors = function () {
        this._burnForSpeedChangeFactor = this._propulsion ? (this._physicalModel.getMass() / this._propulsion.getThrust() * this._propulsion.getMaxMoveBurnLevel() * 1000) : 0;
        this._burnForAngularVelocityChangeFactor = this._propulsion ? (1 / physics.ANGULAR_VELOCITY_MATRIX_DURATION_S * this._physicalModel.getMass() / this._propulsion.getAngularThrust() * this._propulsion.getMaxTurnBurnLevel() * 1000) : 0;
    };
    // direct getters and setters
    /**
     * Returns whether the spacecraft object is alive (has valid data) - does not refer to the spacecraft itself, check hitpoints for that,
     * as the object stays alive for some time during the explosion
     * @returns {Boolean}
     */
    Spacecraft.prototype.isAlive = function () {
        return this._alive;
    };
    /**
     * Returns true when the spacecraft has jumped out from or has not jumped in yet to the current mission scene.
     * @returns {Boolean}
     */
    Spacecraft.prototype.isAway = function () {
        return this._away;
    };
    /**
     * Sets a new away state for the spacecraft (to be used when it jumps in/out to/from the battlefield)
     * @param {Boolean} value 
     */
    Spacecraft.prototype.setAway = function (value) {
        var i, p;
        if (this._away !== value) {
            this._away = value;
            if (this._away) {
                this.setTarget(null);
                p = this.getPhysicalPositionMatrix();
                if (this._visualModel && (!this._visualModel.isWireframe() || ((p[12] === 0) && (p[13] === 0) && (p[14] === 0)))) {
                    this._visualModel.getNode().hide();
                }
                if (this._lights) {
                    for (i = 0; i < this._lights.length; i++) {
                        this._lights[i].hide();
                    }
                }
                if (this._physicalModel) {
                    this._physicalModel.reset();
                }
                if (this._humSoundClip) {
                    this._humSoundClip.stopPlaying(audio.SOUND_RAMP_DURATION);
                }
                if (this._propulsion) {
                    this._propulsion.resetThrusterBurn();
                    this._propulsion.simulate(0, this.getSoundSource(), false);
                    this._propulsion.resetForcesAndTorques();
                }
            } else {
                if (this._visualModel) {
                    this._visualModel.getNode().show();
                }
                if (this._lights) {
                    for (i = 0; i < this._lights.length; i++) {
                        this._lights[i].show();
                    }
                }
            }
        }
    };
    /**
     * Sets a new team affiliation for the spacecraft.
     * @param {Team} value The team to set.
     */
    Spacecraft.prototype.setTeam = function (value) {
        this._team = value;
    };
    /**
     * Returns the team this spacecraft belongs to.
     * @returns {Team}
     */
    Spacecraft.prototype.getTeam = function () {
        return this._team;
    };
    /**
     * Sets a new squad and related index for this spacecraft.
     * @param {String} squadName
     * @param {Number} indexInSquad
     */
    Spacecraft.prototype.setSquad = function (squadName, indexInSquad) {
        this._squad = squadName;
        this._indexInSquad = indexInSquad;
        this._updateIDAndName();
    };
    /**
     * Returns the string ID of the squad this spacecraft belongs to.
     * @returns {String}
     */
    Spacecraft.prototype.getSquad = function () {
        return this._squad;
    };
    /**
     * Returns whether the passed spacecraft is friendly to this one.
     * @param {Spacecraft} spacecraft
     * @returns {Boolean}
     */
    Spacecraft.prototype.isFriendly = function (spacecraft) {
        return (spacecraft.getTeam() === this._team);
    };
    /**
     * Returns whether the passed spacecraft is hostile to this one.
     * @param {Spacecraft} spacecraft
     * @returns {Boolean}
     */
    Spacecraft.prototype.isHostile = function (spacecraft) {
        return (spacecraft.getTeam() !== this._team);
    };
    /**
     * Returns the object describing class of this spacecraft.
     * @returns {SpacecraftClass}
     */
    Spacecraft.prototype.getClass = function () {
        return this._class;
    };
    /**
     * Returns whether this spacecraft belongs to a fighter class.
     * @returns {Boolean}
     */
    Spacecraft.prototype.isFighter = function () {
        return this._class.isFighterClass();
    };
    /**
     * Returns the id of this spacecraft that can be used to identify it within a mission.
     * @returns {String}
     */
    Spacecraft.prototype.getID = function () {
        return this._id;
    };
    /**
     * Returns the name of this spacecraft that can be displayed to the user.
     * @returns {String}
     */
    Spacecraft.prototype.getDisplayName = function () {
        return this._displayName;
    };
    /**
     * Returns the current amount of hit points this spacecraft has left.
     * @returns {Number}
     */
    Spacecraft.prototype.getHitpoints = function () {
        return this._hitpoints;
    };
    /**
     * Returns the current hull integrity ratio of the spacecraft - a number between 0.0 (indicating zero
     * integrity at which the spacecraft is destroyed) and 1.0 (indicating full hull integrity).
     * @returns {Number}
     */
    Spacecraft.prototype.getHullIntegrity = function () {
        return this._hitpoints / this._maxHitpoints;
    };
    /**
     * Returns whether the spacecraft has a shield equipped.
     * @returns {Boolean}
     */
    Spacecraft.prototype.hasShield = function () {
        return !!this._shield;
    };
    /**
     * Returns the name of the shield equipped on this spacecraft in a way that can be presented to the user (translated)
     * @returns {String}
     */
    Spacecraft.prototype.getShieldDisplayName = function () {
        return this._shield.getDisplayName();
    };
    /**
     * Returns the current shield integrity ratio of the spacecraft - a number between 0.0 (indicating a depleted shield) and 1.0 (indicating a fully charged shield).
     * @returns {Number}
     */
    Spacecraft.prototype.getShieldIntegrity = function () {
        return this._shield ? this._shield.getIntegrity() : 0;
    };
    /**
     * Returns the current capacity of the equipped shield (if any)
     * @returns {Number}
     */
    Spacecraft.prototype.getShieldCapacity = function () {
        return this._shield ? this._shield.getCapacity() : 0;
    };
    /**
     * Returns the recharge rate (in capacity / second) of the equipped shield (if any)
     * @returns {Number}
     */
    Spacecraft.prototype.getShieldRechargeRate = function () {
        return this._shield ? this._shield.getRechargeRate() : 0;
    };
    /**
     * Returns the state of the shield to be used for visuals (color and animation progress)
     * @returns {Number[4]}
     */
    Spacecraft.prototype.getShieldState = function () {
        return this._shield ? this._shield.getState() : vec.NULL4;
    };
    /**
     * Starts recharging the shield of the spacecraft (skipping any recharge delay that might be due)
     */
    Spacecraft.prototype.rechargeShield = function () {
        this._shield.startRecharge();
    };
    /**
     * Multiplies the amount of current and maximum hitpoints of the spacecraft has by the passed factor.
     * @param {Number} factor
     */
    Spacecraft.prototype.multiplyMaxHitpoints = function (factor) {
        this._hitpoints *= factor;
        this._maxHitpoints *= factor;
    };
    /**
     * Returns the renderable object that represents this spacecraft in a scene.
     * @returns {RenderableObject}
     */
    Spacecraft.prototype.getVisualModel = function () {
        return this._visualModel;
    };
    /**
     * Returns the object used for the physics simulation of this spacecraft.
     * @returns {PhysicalObject}
     */
    Spacecraft.prototype.getPhysicalModel = function () {
        return this._physicalModel;
    };
    /**
     * Returns the explosion of this spacecraft (if it is being destroyed, otherwise just null)
     * @returns {Explosion}
     */
    Spacecraft.prototype.getExplosion = function () {
        return this._explosion;
    };
    // indirect getters and setters
    /**
     * Returns the name (ID) of the class of this spacecraft. (e.g. falcon or aries)
     * @returns {String}
     */
    Spacecraft.prototype.getClassName = function () {
        return this._class.getName();
    };
    /**
     * Returns the name (ID) of the type of this spacecraft. (e.g. interceptor or corvette)
     * @returns {String}
     */
    Spacecraft.prototype.getTypeName = function () {
        return this._class.getSpacecraftType().getName();
    };
    /**
     * Returns whether this spacecraft is supposed to be effective against the passed spacecraft, based on the spacecraft types.
     * @param {Spacecraft} otherCraft
     * @returns {Boolean}
     */
    Spacecraft.prototype.isGoodAgainst = function (otherCraft) {
        return this._class.getSpacecraftType().isGoodAgainst(otherCraft.getClass().getSpacecraftType());
    };
    /**
     * Returns whether this spacecraft is supposed to be particularly non-effective against the passed spacecraft, based on the spacecraft
     * types.
     * @param {Spacecraft} otherCraft
     * @returns {Boolean}
     */
    Spacecraft.prototype.isBadAgainst = function (otherCraft) {
        return this._class.getSpacecraftType().isBadAgainst(otherCraft.getClass().getSpacecraftType());
    };
    /**
     * Resets the drag factor of the physical model of the spacecraft to to its original value based on the spacecraft's class
     */
    Spacecraft.prototype.resetDrag = function () {
        return this._physicalModel.setDragFactor(this._class.getDragFactor());
    };
    /**
     * Returns the (first) object view associated with this spacecraft that has the given name.
     * @param {String} name
     * @returns {ObjectView}
     */
    Spacecraft.prototype.getView = function (name) {
        return this._class.getView(name);
    };
    /**
     * Re-enables firing if it is disabled.
     */
    Spacecraft.prototype.enableFiring = function () {
        this._firingDisabled = false;
    };
    /**
     * After calling this, rotating weapons will assume their default positions and calling fire() will have no effect (until firing
     * controls are re-enabled)
     */
    Spacecraft.prototype.disableFiring = function () {
        this._firingDisabled = true;
    };
    /**
     * Returns the whether the spacecraft has any weapons equipped.
     * @returns {Boolean}
     */
    Spacecraft.prototype.hasWeapons = function () {
        return this._weapons && (this._weapons.length > 0);
    };
    /**
     * Returns the array of weapon equipped on this spacecraft.
     * @returns {Weapon[]}
     */
    Spacecraft.prototype.getWeapons = function () {
        return this._weapons;
    };
    /**
     * Returns a text listing the weapons of the spacecraft in a way that can be displayed to the user (translated)
     * @param {String} [separator=DEFAULT_EQUIPMENT_STRING_SEPARATOR]
     * @returns {String}
     */
    Spacecraft.prototype.getWeaponsDisplayText = function (separator) {
        var i, result = "", weaponCounts = {}, weaponName, weaponNames;
        separator = separator || DEFAULT_EQUIPMENT_STRING_SEPARATOR;
        for (i = 0; i < this._weapons.length; i++) {
            weaponName = this._weapons[i].getDisplayName();
            if (!weaponCounts[weaponName]) {
                weaponCounts[weaponName] = 1;
            } else {
                weaponCounts[weaponName] += 1;
            }
        }
        weaponNames = Object.keys(weaponCounts);
        for (i = 0; i < weaponNames.length; i++) {
            result += ((i > 0) ? separator : "") + weaponCounts[weaponNames[i]] + " × " + weaponNames[i];
        }
        return result;
    };
    /**
     * Returns a text listing the ranges of the weapons of the spacecraft in a way that can be displayed to the user
     * @param {String} [separator=DEFAULT_WEAPON_RANGE_STRING_SEPARATOR]
     * @returns {String}
     */
    Spacecraft.prototype.getWeaponRangesDisplayText = function (separator) {
        separator = separator || DEFAULT_WEAPON_RANGE_STRING_SEPARATOR;
        var i, range, ranges = [];
        for (i = 0; i < this._weapons.length; i++) {
            range = this._weapons[i].getRange();
            if (ranges.indexOf(range) < 0) {
                ranges.push(range);
            }
        }
        return ranges.join(separator);
    };
    /**
     * Returns the sum of the firepower the weapons on this spacecraft have, that is, the total damage per second
     * they could do to a target with the passed armor rating. (not consider that it might be impossible to aim 
     * all weapons at the same target, depending their positioning, gimbal and the size of the target)
     * @param {Number} [armorRating=0]
     * @returns {Number}
     */
    Spacecraft.prototype.getFirepower = function (armorRating) {
        var result = 0, i;
        for (i = 0; i < this._weapons.length; i++) {
            result += this._weapons[i].getFirepower(armorRating);
        }
        return result;
    };
    /**
     * Returns the whether the spacecraft has any missiles equipped.
     * @returns {Boolean}
     */
    Spacecraft.prototype.hasMissiles = function () {
        var i;
        if (this._missileLaunchers) {
            for (i = 0; i < this._missileLaunchers.length; i++) {
                if (this._missileLaunchers[i].getMissileCount() > 0) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Returns a text listing the missiles of the spacecraft in a way that can be displayed to the user (translated)
     * @param {String} [separator=DEFAULT_EQUIPMENT_STRING_SEPARATOR]
     * @returns {String}
     */
    Spacecraft.prototype.getMissilesDisplayText = function (separator) {
        var i, result = "", missileCounts = {}, missileName, missileNames;
        separator = separator || DEFAULT_EQUIPMENT_STRING_SEPARATOR;
        for (i = 0; i < this._missileLaunchers.length; i++) {
            missileName = this._missileLaunchers[i].getDisplayName();
            if (!missileCounts[missileName]) {
                missileCounts[missileName] = this._missileLaunchers[i].getMissileCount();
            } else {
                missileCounts[missileName] += this._missileLaunchers[i].getMissileCount();
            }
        }
        missileNames = Object.keys(missileCounts);
        for (i = 0; i < missileNames.length; i++) {
            result += ((i > 0) ? separator : "") + missileCounts[missileNames[i]] + " × " + missileNames[i];
        }
        return result;
    };
    /**
     * Returns a text listing the ranges of the missile of the spacecraft in a way that can be displayed to the user
     * @param {String} [separator=DEFAULT_WEAPON_RANGE_STRING_SEPARATOR]
     * @returns {String}
     */
    Spacecraft.prototype.getMissileRangesDisplayText = function (separator) {
        separator = separator || DEFAULT_WEAPON_RANGE_STRING_SEPARATOR;
        var i, range, ranges = [];
        for (i = 0; i < this._missileLaunchers.length; i++) {
            range = this._missileLaunchers[i].getNominalRange().toFixed(0);
            if (ranges.indexOf(range) < 0) {
                ranges.push(range);
            }
        }
        return ranges.join(separator);
    };
    /**
     * Returns the sum of the firepower the missiles on this spacecraft have, that is, the total damage 
     * they could do to a target with the passed armor rating.
     * @param {Number} [armorRating=0]
     * @returns {Number}
     */
    Spacecraft.prototype.getMissileFirepower = function (armorRating) {
        var result = 0, i;
        for (i = 0; i < this._missileLaunchers.length; i++) {
            result += this._missileLaunchers[i].getFirepower(armorRating || 0);
        }
        return result;
    };
    /**
     * Returns whether this spacecraft object can be reused to represent a new
     * spacecraft.
     * @returns {Boolean}
     */
    Spacecraft.prototype.canBeReused = function () {
        return !this._alive;
    };
    /**
     * Returns the hit ratio (only counting hitting the enemy) during the current mission
     * @returns {Number}
     */
    Spacecraft.prototype.getHitRatio = function () {
        return this._shotsFired ? (this._hitsOnEnemies / this._shotsFired) : 0;
    };
    /**
     * Returns the number of enemy spacecrafts destroyed (last hit delivered) by this spacecraft during the current mission
     * @returns {Number}
     */
    Spacecraft.prototype.getKills = function () {
        return this._kills;
    };
    /**
     * Increases the number of kills for this spacecraft
     * @type Number
     */
    Spacecraft.prototype.gainKill = function () {
        this._kills++;
    };
    /**
     * Returns the (base) score this spacecraft acquired during the current mission
     * @returns {Number}
     */
    Spacecraft.prototype.getScore = function () {
        return this._score;
    };
    /**
     * Increases the score of this spacecraft by the passed amount
     * @param {Number} score
     */
    Spacecraft.prototype.gainScore = function (score) {
        this._score += score;
    };
    /**
     * Returns the amount of damage dealt to enemies by this spacecraft during the current mission
     * @returns {Number}
     */
    Spacecraft.prototype.getDamageDealt = function () {
        return this._damageDealt;
    };
    /**
     * Returns the amount of damage dealt to enemies by this spacecraft using missiles during the current mission
     * @returns {Number}
     */
    Spacecraft.prototype.getMissileDamageDealt = function () {
        return this._missileDamageDealt;
    };
    /**
     * Call if this spacecrafts deals damage to an enemy to update the stored total of damage dealt
     * @param {Number} damage The amount of damage dealt to the enemy
     * @param {Boolean} [byMissile=false] Whether the damage was dealt using a missile
     */
    Spacecraft.prototype.gainDamageDealt = function (damage, byMissile) {
        this._damageDealt += damage;
        if (byMissile) {
            this._missileDamageDealt += damage;
        }
    };
    /**
     * Number of missiles launched during the current mission
     * @returns Number
     */
    Spacecraft.prototype.getMissilesLaunched = function () {
        return this._missilesLaunched;
    };
    /**
     * Number of launched missiles that hit an enemy during the current mission
     * @returns Number
     */
    Spacecraft.prototype.getMissileHitsOnEnemies = function () {
        return this._missileHitsOnEnemies;
    };
    /**
     * Returns the ratio of missiles that hit an enemy out of all launched missiles during the current mission
     * @returns {Number}
     */
    Spacecraft.prototype.getMissileHitRatio = function () {
        return this._missileHitsOnEnemies / this._missilesLaunched;
    };
    /**
     * Returns how much score destroying this spacecraft should grant (completely, including dealing damage and scoring the final hit)
     * @returns {Number}
     */
    Spacecraft.prototype.getScoreValue = function () {
        return this._scoreValue;
    };
    /**
     * Sets a new position matrix for the physical model of the spacecrafts based on the passed 3D vector.
     * @param {Number[3]} vector
     */
    Spacecraft.prototype.setPhysicalPosition = function (vector) {
        this._physicalModel.setPositionMatrix(mat.translation4v(vector));
    };
    /**
     * Sets a new position matrix (directly) for the physical model of the spacecrafts.
     * @param {Float32Array} value
     */
    Spacecraft.prototype.setPhysicalPositionMatrix = function (value) {
        this._physicalModel.setPositionMatrix(value);
    };
    /**
     * Returns the 4x4 translation matrix describing the position of this 
     * spacecraft in world space.
     * @returns {Float32Array}
     */
    Spacecraft.prototype.getPhysicalPositionMatrix = function () {
        return this._physicalModel.getPositionMatrix();
    };
    /**
     * Returns the 3D vector describing the position of this spacecraft in world space.
     * @returns {Number[3]}
     */
    Spacecraft.prototype.getPhysicalPositionVector = function () {
        this._physicalModel.copyPositionToVector(this._physicalPositionVector);
        return this._physicalPositionVector;
    };
    /**
     * Sets a new orientation matrix (directly) for the physical model of the spacecrafts.
     * @param {Float32Array} value
     */
    Spacecraft.prototype.setPhysicalOrientationMatrix = function (value) {
        this._physicalModel.setOrientationMatrix(value);
    };
    /**
     * Returns the 4x4 rotation matrix describing the orientation of this 
     * spacecraft in world space.
     * @returns {Float32Array}
     */
    Spacecraft.prototype.getPhysicalOrientationMatrix = function () {
        return this._physicalModel.getOrientationMatrix();
    };
    /**
     * Returns the 4x4 scaling matrix describing the scaling of the meshes and
     * physical model representing this spacecraft in world space.
     * @returns {Float32Array}
     */
    Spacecraft.prototype.getPhysicalScalingMatrix = function () {
        return this._physicalModel.getScalingMatrix();
    };
    /**
     * Updates (recalculates) the cached value of the scaling * orientation matrix.
     */
    Spacecraft.prototype.updateScaledOriMatrix = function () {
        mat.setProd3x3SubOf4(this._scaledOriMatrix, this.getPhysicalScalingMatrix(), this.getPhysicalOrientationMatrix());
    };
    /**
     * Returns a 4x4 matrix describing the current scaling and rotation of this spacecraft.
     * @returns {Float32Array}
     */
    Spacecraft.prototype.getScaledOriMatrix = function () {
        return this._scaledOriMatrix;
    };
    /**
     * A shortcut method
     * @returns {Float32Array}
     */
    Spacecraft.prototype.getPositionMatrixInCameraSpace = function () {
        return this._visualModel.getPositionMatrixInCameraSpace(this._visualModel.getNode().getScene().getCamera());
    };
    /**
     * Returns the 4x4 translation matrix describing the current velocity of this spacecraft in world space.
     * @returns {Float32Array}
     */
    Spacecraft.prototype.getVelocityMatrix = function () {
        return this._physicalModel.getVelocityMatrix();
    };
    /**
     * Returns the 4x4 translation matrix describing the current velocity of this spacecraft in relative (model) space. Uses caching.
     * @returns {Float32Array}
     */
    Spacecraft.prototype.getRelativeVelocityMatrix = function () {
        if (!this._relativeVelocityMatrixValid) {
            mat.setProdTranslationRotation4(this._relativeVelocityMatrix,
                    this._physicalModel.getVelocityMatrix(),
                    mat.rotation4m4Aux(this._physicalModel.getRotationMatrixInverse()));
            this._relativeVelocityMatrixValid = true;
        }
        return this._relativeVelocityMatrix;
    };
    /**
     * Returns the 4x4 rotation matrix describing the current rotation of this spacecraft in relative (model) space.
     * @returns {Float32Array}
     */
    Spacecraft.prototype.getTurningMatrix = function () {
        if (!this._turningMatrixValid) {
            mat.setProd3x3SubOf4(this._turningMatrix,
                    mat.prod3x3SubOf4Aux(
                            this._physicalModel.getOrientationMatrix(),
                            this._physicalModel.getAngularVelocityMatrix()),
                    mat.rotation4m4Aux(this._physicalModel.getRotationMatrixInverse()));
            this._turningMatrixValid = true;
        }
        return this._turningMatrix;
    };
    /**
     * Returns the maximum acceleration the spacecraft can achieve using its currently equipped propulsion system.
     * @returns {?Number} The acceleration, in m/s^2. Null, if no propulsion is equipped.
     */
    Spacecraft.prototype.getMaxAcceleration = function () {
        return this._propulsion ?
                this._propulsion.getThrust() / this._physicalModel.getMass() :
                null;
    };
    /**
     * Returns the maximum forward speed the spacecraft can achieve in "combat" flight mode using its currently equipped propulsion system.
     * @returns {Number} The speed, in m/s. Zero, if no propulsion is equipped.
     */
    Spacecraft.prototype.getMaxCombatSpeed = function () {
        return (this.getMaxAcceleration() * config.getSetting(config.BATTLE_SETTINGS.MAX_COMBAT_FORWARD_SPEED_FACTOR)) || 0;
    };
    /**
     * Returns the maximum angular acceleration the spacecraft can achieve using its currently equipped propulsion system.
     * @returns {Number} The angular acceleration, in rad/s^2. Zero, if no propulsion is equipped.
     */
    Spacecraft.prototype.getMaxAngularAcceleration = function () {
        return this._propulsion ?
                this._propulsion.getAngularThrust() / this._physicalModel.getMass() :
                0;
    };
    /**
     * Returns the maximum turn rate the spacecraft can achieve in "combat" flight mode using its currently equipped propulsion system.
     * @returns {Number} The turn rate, in degrees/s. Zero, if no propulsion is equipped.
     */
    Spacecraft.prototype.getMaxCombatTurnRate = function () {
        return (this.getMaxAngularAcceleration() * utils.DEG * config.getSetting(config.BATTLE_SETTINGS.TURN_ACCELERATION_DURATION_S)) || 0;
    };
    /**
     * Returns the maximum thruster move burn level for the current propulsion
     * @returns {Number}
     */
    Spacecraft.prototype.getMaxThrusterMoveBurnLevel = function () {
        return this._propulsion ? this._propulsion.getMaxMoveBurnLevel() : 0;
    };
    /**
     * Returns the maximum thruster turn burn level for the current propulsion
     * @returns {Number}
     */
    Spacecraft.prototype.getMaxThrusterTurnBurnLevel = function () {
        return this._propulsion ? this._propulsion.getMaxTurnBurnLevel() : 0;
    };
    /**
     * Returns the maximum turning rate the spacecraft can keep at the passed
     * speed while providing the needed centripetal force with its thrusters
     * to keep itself on a circular path.
     * @param {Number} speed The speed in m/s.
     * @returns {Number} The turning rate in rad/s.
     */
    Spacecraft.prototype.getMaxTurnRateAtSpeed = function (speed) {
        var sinTurn = Math.abs(this._propulsion.getThrust() / (this._physicalModel.getMass() * speed));
        return (sinTurn <= 1) ? Math.asin(sinTurn) : Number.MAX_VALUE;
    };
    /**
     * Returns the managed textures to be used for rendering the hitboxes of this spacecraft, in an associated array, by texture types.
     * @returns {Object.<String, ManagedTexture>}
     */
    Spacecraft.prototype.getHitboxTextures = function () {
        var
                textureTypes = graphics.getManagedShader(config.getSetting(config.BATTLE_SETTINGS.HITBOX_SHADER_NAME)).getTextureTypes(),
                textureResource = graphics.getTexture(config.getSetting(config.BATTLE_SETTINGS.HITBOX_TEXTURE_NAME), {types: textureTypes});
        return textureResource.getManagedTexturesOfTypes(textureTypes, graphics.getTextureQualityPreferenceList());
    };
    /**
     * Returns the thruster burn level that is needed to produce the passed difference in speed using the current propulsion system for the
     * given duration.
     * @param {Number} speedDifference The speed difference that needs to be produced, in m/s.
     * @param {Number} duration The length of time during which the difference needs to be produced, in milliseconds
     * @returns {Number}
     */
    Spacecraft.prototype.getNeededBurnForSpeedChange = function (speedDifference, duration) {
        return speedDifference * this._burnForSpeedChangeFactor / duration;
    };
    /**
     * Returns the thruster burn level that is needed to produce the passed difference in angular velocity using the current propulsion 
     * system for the given duration.
     * @param {Number} angularVelocityDifference The angular velocity difference that needs to be produced, in rad / physics.ANGULAR_VELOCITY_MATRIX_DURATION ms !!.
     * * @param {Number} duration The length of time during which the difference needs to be produced, in milliseconds
     * @returns {Number}
     */
    Spacecraft.prototype.getNeededBurnForAngularVelocityChange = function (angularVelocityDifference, duration) {
        return angularVelocityDifference * this._burnForAngularVelocityChangeFactor / duration;
    };
    /**
     * Calculated top speed of the spacecraft, using the currently equipped
     * propulsion and the globally set drag coefficient (zero if there is no drag)
     * @returns {Number}
     */
    Spacecraft.prototype.getTopSpeed = function () {
        return this._topSpeed;
    };
    // methods
    /**
     * Initializes the properties of this spacecraft based on the data stored
     * in the passed JSON object.
     * @param {Object} dataJSON
     * @param {Spacecraft[]} [spacecraftArray=null] The array of spacecrafts
     * participating in the same battle.
     * @param {Environment} [environment] The environment the spacecraft is 
     * situated in
     */
    Spacecraft.prototype.loadFromJSON = function (dataJSON, spacecraftArray, environment) {
        var loadout, squadData;
        this._init(
                classes.getSpacecraftClass(dataJSON.class),
                dataJSON.name,
                dataJSON.position ? mat.translation4v(dataJSON.position) : null,
                mat.rotation4FromJSON(dataJSON.rotations),
                undefined,
                spacecraftArray,
                environment);
        if (dataJSON.squad) {
            squadData = dataJSON.squad.split(" ");
            this.setSquad(squadData[0], parseInt(squadData[1], 10));
        }
        // equipping the created spacecraft
        if (dataJSON.loadout) {
            // if a loadout is referenced, look up that loadout and equip according to that
            this.equipLoadout(this._class.getLoadout(dataJSON.loadout));
        } else if (dataJSON.equipment) {
            // if a custom loadout is specified, simply create it from the given object, and equip that
            loadout = new classes.Loadout(dataJSON.equipment);
            this.equipLoadout(loadout);
        // if there is no equipment specified, attempt to load the default loadout
        } else if (this._class.getDefaultLoadout()) {
            this.equipLoadout(this._class.getLoadout(this._class.getDefaultLoadout()));
        }
        if (dataJSON.away) {
            this.setAway(true);
        }
    };
    /**
     * Function to reset state before starting to execute the control actions triggered in the current simulation step.
     */
    Spacecraft.prototype.prepareForControl = function () {
        this._maneuveringComputer.prepareForControl();
    };
    /**
     * Returns whether the maneuvering computer is currently locked (not accepting new maneuvering commands)
     * @returns {Boolean}
     */
    Spacecraft.prototype.isManeuveringLocked = function () {
        return this._maneuveringComputer.isLocked();
    };
    /**
     * Locks maneuvering controls.
     */
    Spacecraft.prototype.lockManeuvering = function () {
        this._maneuveringComputer.setLocked(true);
    };
    /**
     * Unlocks maneuvering controls.
     */
    Spacecraft.prototype.unlockManeuvering = function () {
        this._maneuveringComputer.setLocked(false);
    };
    /**
     * Returns a string representation of the current flight mode set for this
     * craft. (free / combat / cruise)
     * @returns {String}
     */
    Spacecraft.prototype.getFlightMode = function () {
        return this._maneuveringComputer.getFlightMode();
    };
    /**
     * Switches to the given / next available flight mode.
     * @param {String} [flightMode]
     * @returns {Boolean} Whether the flight mode change happened.
     */
    Spacecraft.prototype.changeFlightMode = function (flightMode) {
        return this._maneuveringComputer.changeFlightMode(flightMode);
    };
    /**
     * Toggles between free and combat flight modes
     * @returns {Boolean} Whether the flight mode change happened.
     */
    Spacecraft.prototype.toggleFlightAssist = function () {
        return this._maneuveringComputer.toggleFlightAssist();
    };
    /**
     * Toggles between cruise and combat flight modes
     * @returns {Boolean} Whether the flight mode change happened.
     */
    Spacecraft.prototype.toggleCruise = function () {
        return this._maneuveringComputer.toggleCruise();
    };
    /**
     * Control command for forward thrust for the maneuvering computer.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.forward = function (intensity) {
        this._maneuveringComputer.forward(intensity);
    };
    /**
     * Control command for stopping forward thrust for the maneuvering computer.
     */
    Spacecraft.prototype.stopForward = function () {
        this._maneuveringComputer.stopForward();
    };
    /**
     * Control command for reverse thrust for the maneuvering computer.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.reverse = function (intensity) {
        this._maneuveringComputer.reverse(intensity);
    };
    /**
     * Control command for stopping reverse thrust for the maneuvering computer.
     */
    Spacecraft.prototype.stopReverse = function () {
        this._maneuveringComputer.stopReverse();
    };
    /**
     * Control command for strafing to the left for the maneuvering computer.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.strafeLeft = function (intensity) {
        this._maneuveringComputer.strafeLeft(intensity);
    };
    /**
     * Control command for stopping strafing to the left for the maneuvering computer.
     */
    Spacecraft.prototype.stopLeftStrafe = function () {
        this._maneuveringComputer.stopLeftStrafe();
    };
    /**
     * Control command for strafing to the right for the maneuvering computer.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.strafeRight = function (intensity) {
        this._maneuveringComputer.strafeRight(intensity);
    };
    /**
     * Control command for stopping strafing to the right for the maneuvering computer.
     */
    Spacecraft.prototype.stopRightStrafe = function () {
        this._maneuveringComputer.stopRightStrafe();
    };
    /**
     * Control command for lifting upwards for the maneuvering computer.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.raise = function (intensity) {
        this._maneuveringComputer.raise(intensity);
    };
    /**
     * Control command for stopping lifting upwards for the maneuvering computer.
     */
    Spacecraft.prototype.stopRaise = function () {
        this._maneuveringComputer.stopRaise();
    };
    /**
     * Control command for lifting downwards for the maneuvering computer.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.lower = function (intensity) {
        this._maneuveringComputer.lower(intensity);
    };
    /**
     * Control command for stopping lifting downwards for the maneuvering computer.
     */
    Spacecraft.prototype.stopLower = function () {
        this._maneuveringComputer.stopLower();
    };
    /**
     * Control command for the maneuvering computer to toggle speed holding mode.
     * @returns {Boolean} Whether the speed holding mode has changed
     */
    Spacecraft.prototype.toggleSpeedHolding = function () {
        return this._maneuveringComputer.toggleSpeedHolding();
    };
    /**
     * Sets the speed holding mode of the maneuvering computer to the passed value.
     * @param {Boolean} value
     */
    Spacecraft.prototype.setSpeedHolding = function (value) {
        this._maneuveringComputer.setSpeedHolding(value);
    };
    /**
     * Control command for the maneuvering computer to reset the target speed to zero.
     */
    Spacecraft.prototype.resetSpeed = function () {
        this._maneuveringComputer.resetSpeed();
    };
    /**
     * Sets a new forward/reverse speed target in non-free flight modes.
     * @param {Number} value A positive number means a forward target, a negative one a reverse target, in m/s.
     */
    Spacecraft.prototype.setSpeedTarget = function (value) {
        this._maneuveringComputer.setSpeedTarget(value);
    };
    /**
     * Return the currently set target for forward (positive) / reverse (negative) speed, in m/s. Only meaningful in assisted flight modes.
     * @returns {Number}
     */
    Spacecraft.prototype.getSpeedTarget = function () {
        return this._maneuveringComputer.getSpeedTarget();
    };
    /**
     * Returns whether the spacecraft has a meaningful speed target in its current flight mode.
     * @returns {Boolean}
     */
    Spacecraft.prototype.hasSpeedTarget = function () {
        return this._maneuveringComputer.hasSpeedTarget();
    };
    /**
     * If the current flight mode imposes a speed limit, returns it. (in m/s) Otherwise returns undefined.
     * @returns {Number}
     */
    Spacecraft.prototype.getMaxSpeed = function () {
        return this._maneuveringComputer.getMaxSpeed();
    };
    /**
     * Control command for the maneuvering computer to yaw to the left.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.yawLeft = function (intensity) {
        this._maneuveringComputer.yawLeft(intensity);
    };
    /**
     * Control command for the maneuvering computer to yaw to the right.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.yawRight = function (intensity) {
        this._maneuveringComputer.yawRight(intensity);
    };
    /**
     * Control command for the maneuvering computer to pitch upwards.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.pitchUp = function (intensity) {
        this._maneuveringComputer.pitchUp(intensity);
    };
    /**
     * Control command for the maneuvering computer to pitch downwards.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.pitchDown = function (intensity) {
        this._maneuveringComputer.pitchDown(intensity);
    };
    /**
     * Control command for the maneuvering computer to roll to the left.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.rollLeft = function (intensity) {
        this._maneuveringComputer.rollLeft(intensity);
    };
    /**
     * Control command for the maneuvering computer to roll to the right.
     * @param {Number} [intensity] Optional intensity for the command, if the
     * player uses an input device that has intensity control (e.g. mouse, joystick)
     */
    Spacecraft.prototype.rollRight = function (intensity) {
        this._maneuveringComputer.rollRight(intensity);
    };
    /**
     * Adds a renderable object that represents the index'th body of the physical
     * model of this spacecraft.
     * @param {Number} index The index of the body to represent.
     */
    Spacecraft.prototype._addHitboxModel = function (index) {
        var
                phyModel =
                resources.getOrAddModel(
                        egomModel.cuboidModel(
                                HITBOX_BODY_MODEL_NAME,
                                1,
                                1,
                                1,
                                _hitZoneColor)),
                hitZoneMesh = new renderableObjects.ShadedLODMesh(
                        phyModel.getEgomModel(),
                        graphics.getManagedShader(config.getSetting(config.BATTLE_SETTINGS.HITBOX_SHADER_NAME)),
                        this.getHitboxTextures(),
                        mat.translation4m4(this._class.getBodies()[index].getPositionMatrix()),
                        this._class.getBodies()[index].getOrientationMatrix(),
                        mat.scaling4(
                                this._class.getBodies()[index].getWidth(),
                                this._class.getBodies()[index].getHeight(),
                                this._class.getBodies()[index].getDepth()),
                        false);
        hitZoneMesh.setUniformValueFunction(renderableObjects.UNIFORM_COLOR_NAME, function () {
            return _hitZoneColor;
        });
        hitZoneMesh.setUniformValueFunction(_groupTransformsArrayName, function () {
            return graphics.getGroupTransformIdentityArray();
        });
        this._hitbox.addSubnode(new sceneGraph.RenderableNode(hitZoneMesh, false));
    };
    /**
     * Returns the renderable node storing the hitbox models for this spacecraft.
     * @returns {RenerableNode}
     */
    Spacecraft.prototype.getHitbox = function () {
        return this._hitbox;
    };
    /**
     * @param {Boolean} hitbox
     * @param {SpacecraftClass~ResourceParams} params
     */
    Spacecraft.prototype.acquireResources = function (hitbox, params) {
        application.log_DEBUG("Requesting resources for spacecraft (" + this._class.getName() + ")...", 2);
        if (hitbox) {
            graphics.getShader(config.getSetting(config.BATTLE_SETTINGS.HITBOX_SHADER_NAME));
            graphics.getTexture(config.getSetting(config.BATTLE_SETTINGS.HITBOX_TEXTURE_NAME));
        }
        this._class.acquireResources(params);
        resources.executeWhenReady(function () {
            if (this.isAlive()) {
                this._physicalModel.setScalingMatrix(mat.scaling4(this._class.getModel().getScale()));
            }
        }.bind(this));
    };
    /**
     * @typedef {Object} Spacecraft~Supplements
     * @property {Boolean} hitboxes
     * @property {Boolean} weapons
     * @property {Boolean} missilesInLaunchers Whether to add the loaded missiles
     * into the launch tubes (at least the first one for each tube)
     * @property {Boolean} allMissilesInLaunchers Whether to add the additional
     * loaded missiles behind the first one into the launch tubes (for displaying
     * missile loadout in wireframe)
     * @property {Boolean} thrusterParticles
     * @property {Boolean} projectileResources
     * @property {Boolean} missileResources
     * @property {Boolean} explosion
     * @property {Boolean} damageIndicators
     * @property {Boolean} cameraConfigurations
     * @property {Boolean} lightSources
     * @property {Boolean} blinkers
     * @property {Boolean} jumpEngine
     * @property {Boolean} shield
     * @property {Boolean} sound
     * @property {Boolean} [self=true]
     */
    /**
     * @typedef {Object} Spacecraft~AddToSceneParams
     * @property {Boolean} [skipResources=false] If true, resources will not be acquired
     * @property {String} [shaderName]
     * @property {Float32Array} [positionMatrix]
     * @property {Float32Array} [orientationMatrix]
     * @property {Float32Array} [scalingMatrix]
     * @property {Boolean} [replaceVisualModel=false] If true, the visual model of the spacecraft will be replaced by the newly created one, 
     * if it exists.
     * @property {Number[4]} [factionColor] If given, the faction color of the spacecraft will be replaced by this color (otherwise it is
     * based on the team's faction color)
     * @property {ParameterizedMesh} [visualModel] If a visual model for the spacecraft itself is not created (self from supplements is 
     * false), a visual model can be specified in this parameter that will be used instead of the existing one (when adding supplements)
     * @property {Boolean} [randomAnimationTime=false] If true, the blinking lights on the spacecraft will be set to a random animation
     * state (the same state for all of them)
     * @property {Number} [smallestSizeWhenDrawn]
     */
    /**
     * Adds the spacecraft's visual representation to a scene, assuming that its resources have already been loaded.
     * @param {Scene} scene See addToScene()
     * @param {Number} [lod] See addToScene()
     * @param {Boolean} [wireframe=false] See addToScene()
     * @param {Spacecraft~Supplements} addSupplements See addToScene()
     * @param {Spacecraft~AddToSceneParams} params See addToScene()
     * @param {logic~addToSceneCallback} [callback] See addToScene()
     * @param {logic~addToSceneCallback} [weaponCallback] See addToScene()
     * @param {logic~addToSceneCallback} [missileCallback] See addToScene()
     */
    Spacecraft.prototype.addToSceneNow = function (scene, lod, wireframe, addSupplements, params, callback, weaponCallback, missileCallback) {
        var i, shader, node, exp, lightSources, originalFactionColor, replacementFactionColor, visualModel, light, emittingObjects, animationTime, weaponParams, missileParams;
        if (!this._class) {
            application.log_DEBUG("WARNING! Cannot add spacecraft to scene because it has already been destroyed!");
            return;
        }
        application.log_DEBUG("Adding spacecraft (" + this._class.getName() + ") to scene...", 2);
        if (addSupplements.self !== false) {
            shader = params.shaderName ? graphics.getManagedShader(params.shaderName) : this._class.getShader();
            visualModel = new renderableObjects.ParameterizedMesh(
                    this._class.getModel(),
                    shader,
                    this._class.getTexturesOfTypes(shader.getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                    params.positionMatrix || this._physicalModel.getPositionMatrix(),
                    params.orientationMatrix || this._physicalModel.getOrientationMatrix(),
                    params.scalingMatrix || mat.scaling4(this._class.getModel().getScale()),
                    (wireframe === true),
                    lod,
                    params.smallestSizeWhenDrawn,
                    _parameterArrays);
            if (!this._visualModel || params.replaceVisualModel) {
                this._visualModel = visualModel;
            }
            if (this._name) {
                visualModel.setName(this._name);
            }
            originalFactionColor = this._class.getFactionColor() || FACTION_COLOR_NONE;
            replacementFactionColor = params.factionColor || (this._team && this._team.getColor()) || originalFactionColor;
            visualModel.setUniformValueFunction(UNIFORM_ORIGINAL_FACTION_COLOR_NAME, function () {
                return originalFactionColor;
            });
            visualModel.setUniformValueFunction(UNIFORM_REPLACEMENT_FACTION_COLOR_NAME, function () {
                return replacementFactionColor;
            });
            visualModel.setUniformValueFunction(UNIFORM_SHIELD_STATE_NAME, function () {
                return this.getShieldState();
            }.bind(this));
            // setting the starting values of the parameter arrays
            // setting an identity transformation for all transform groups
            if (visualModel.hasParameterArray(_groupTransformsArrayName)) {
                visualModel.setParameterArray(_groupTransformsArrayName, graphics.getGroupTransformIdentityArray());
            }
            // setting the default luminosity for all luminosity groups
            if (graphics.areLuminosityTexturesAvailable() && visualModel.hasParameterArray(_luminosityFactorsArrayName)) {
                visualModel.setParameterArray(_luminosityFactorsArrayName, this._class.getDefaultGroupLuminosityFactors());
            }
            node = scene.addObject(visualModel);
            if (params.visualModel) {
                application.showError("Attempting to specify a visual model for the Spacecraft.addToScene() operation while a new one is also created!", application.ErrorSeverity.MINOR);
            }
        } else {
            visualModel = params.visualModel || this._visualModel;
            node = visualModel.getNode();
        }
        // visualize physical model (hitboxes)
        if (addSupplements.hitboxes === true) {
            shader = shader || (params.shaderName ? graphics.getManagedShader(params.shaderName) : this._class.getShader());
            // add the parent objects for the hitboxes
            this._hitbox = new sceneGraph.RenderableNode(new renderableObjects.RenderableObject3D(
                    shader,
                    false,
                    false), false);
            // add the models for the hitboxes themselves
            for (i = 0; i < this._class.getBodies().length; i++) {
                this._addHitboxModel(i);
            }
            this._hitbox.hide();
            node.addSubnode(this._hitbox);
        }
        // add the weapons
        if (addSupplements.weapons === true) {
            weaponParams = {shaderName: params.shaderName};
            for (i = 0; i < this._weapons.length; i++) {
                this._weapons[i].addToSceneNow(node, lod, wireframe, weaponParams, weaponCallback);
            }
        }
        // add missiles into the launchers
        if (addSupplements.missilesInLaunchers === true) {
            missileParams = {shaderName: params.shaderName, allMissiles: addSupplements.allMissilesInLaunchers};
            for (i = 0; i < this._missileLaunchers.length; i++) {
                this._missileLaunchers[i].addToSceneNow(node, lod, wireframe, missileParams, missileCallback);
            }
        }
        // add the thruster particles
        if (addSupplements.thrusterParticles === true) {
            if (this._propulsion) {
                this._propulsion.addToScene(node);
            }
        }
        // add projectile resources
        if (addSupplements.projectileResources === true) {
            for (i = 0; i < this._weapons.length; i++) {
                this._weapons[i].addProjectileResourcesToScene(scene);
            }
        }
        // add missile resources
        if (addSupplements.missileResources === true) {
            for (i = 0; i < this._missileLaunchers.length; i++) {
                this._missileLaunchers[i].addMissileResourcesToScene(scene);
            }
        }
        // add projectile resources
        if (addSupplements.explosion === true) {
            exp = new explosion.Explosion(this._class.getExplosionClass(), mat.IDENTITY4, mat.IDENTITY4, vec.NULL3, true);
            exp.addResourcesToScene(scene);
        }
        // add comera configurations
        if (addSupplements.cameraConfigurations === true) {
            this._addCameraConfigurationsForViews();
        }
        // add light sources
        if (_dynamicLights && addSupplements.lightSources === true) {
            lightSources = this._class.getLightSources();
            this._lights.length = 0;
            emittingObjects = [visualModel];
            for (i = 0; i < lightSources.length; i++) {
                if (lightSources[i].spotDirection) {
                    light = new lights.SpotLightSource(lightSources[i].color, lightSources[i].intensity, lightSources[i].position, lightSources[i].spotDirection, lightSources[i].spotCutoffAngle, lightSources[i].spotFullIntensityAngle, emittingObjects);
                    this._lights.push(light);
                    scene.addSpotLightSource(light);
                } else {
                    light = new lights.PointLightSource(lightSources[i].color, lightSources[i].intensity, lightSources[i].position, emittingObjects);
                    scene.addPointLightSource(light, constants.SPACECRAFT_LIGHT_PRIORITY);
                    this._lights.push(light);
                }
            }
        }
        // add blinking lights
        if (addSupplements.blinkers === true) {
            for (i = 0; i < this._blinkers.length; i++) {
                this._blinkers[i].addToScene(node, addSupplements.lightSources);
                if (params.randomAnimationTime) {
                    if (i === 0) {
                        animationTime = this._blinkers[i].setRandomTime();
                    } else {
                        this._blinkers[i].setTime(animationTime);
                    }
                }
            }
        }
        // if the spacecraft is away, hide the visuals
        if (this._away) {
            this._away = false;
            this.setAway(true);
        }
        if (callback) {
            callback(visualModel);
        }
    };
    /**
     * Creates and adds the renderable objects to represent this spacecraft to
     * the passed scene.
     * @param {Scene} scene The scene to which the objects will be added.
     * @param {Number} [lod] The level of detail to use for adding the models.
     * If not given, all available LODs will be added for dynamic LOD rendering.
     * @param {Boolean} [wireframe=false] Whether to add the models in wireframe
     * drawing mode (or in solid).
     * @param {Spacecraft~Supplements} [addSupplements] An object describing what additional
     * supplementary objects / resources to add to the scene along with the
     * basic representation of the ship. Contains boolean properties for each
     * possible supplement, marking if that particular supplement should be 
     * added.
     * @param {Spacecraft~AddToSceneParams} [params]
     * @param {logic~addToSceneCallback} [callback]
     * @param {logic~addToSceneCallback} [weaponCallback]
     * @param {logic~addToSceneCallback} [missileCallback]
     */
    Spacecraft.prototype.addToScene = function (scene, lod, wireframe, addSupplements, params, callback, weaponCallback, missileCallback) {
        var i, blinkerDescriptors, weaponParams, missileParams;
        addSupplements = addSupplements || utils.EMPTY_OBJECT;
        params = params || utils.EMPTY_OBJECT;
        // getting resources
        if (!params.skipResources) {
            this.acquireResources((addSupplements.hitboxes === true), {
                omitShader: !!params.shaderName,
                explosion: addSupplements.explosion,
                damageIndicators: addSupplements.damageIndicators,
                blinkers: addSupplements.blinkers,
                sound: addSupplements.sound
            });
            if (params.shaderName) {
                graphics.getShader(params.shaderName);
            }
            if (addSupplements.weapons === true) {
                weaponParams = {omitShader: !!params.shaderName, projectileResources: addSupplements.projectileResources, sound: addSupplements.sound};
                for (i = 0; i < this._weapons.length; i++) {
                    this._weapons[i].acquireResources(weaponParams);
                }
            }
            if (addSupplements.missileResources === true) {
                missileParams = {omitShader: !!params.shaderName, missileOnly: false, sound: addSupplements.sound, trail: true};
                for (i = 0; i < this._missileLaunchers.length; i++) {
                    this._missileLaunchers[i].acquireResources(missileParams);
                }
            } else if (addSupplements.missilesInLaunchers === true) {
                missileParams = {omitShader: !!params.shaderName, missileOnly: true, sound: addSupplements.sound};
                for (i = 0; i < this._missileLaunchers.length; i++) {
                    this._missileLaunchers[i].acquireResources(missileParams);
                }
            }
            // add the thruster particles
            if (addSupplements.thrusterParticles === true) {
                if (this._propulsion) {
                    this._propulsion.addThrusters(this._class.getThrusterSlots());
                    this._propulsion.acquireResources({sound: addSupplements.sound});
                }
            }
            if (addSupplements.jumpEngine === true) {
                if (this._jumpEngine) {
                    this._jumpEngine.acquireResources({sound: addSupplements.sound});
                }
            }
            if (addSupplements.shield === true) {
                if (this._shield) {
                    this._shield.acquireResources({sound: addSupplements.sound});
                }
            }
            if (addSupplements.explosion === true) {
                this._class.getExplosionClass().acquireResources({sound: addSupplements.sound});
            }
            if (addSupplements.blinkers === true) {
                blinkerDescriptors = this._class.getBlinkerDescriptors();
                for (i = 0; i < blinkerDescriptors.length; i++) {
                    blinkerDescriptors[i].acquireResources();
                }
            }
        }
        resources.executeWhenReady(this.addToSceneNow.bind(this, scene, lod, wireframe, addSupplements, params, callback, weaponCallback, missileCallback));
    };
    /**
     * Creates and returns a camera configuration set up for following the spacecraft according to the view's parameters.
     * @param {ObjectView} view
     * @returns {CameraConfiguration} The created camera configuration.
     */
    Spacecraft.prototype.createCameraConfigurationForView = function (view) {
        return view.createCameraConfiguration(this._visualModel,
                config.getDefaultCameraBaseOrientation(),
                config.getDefaultCameraPointToFallback(),
                config.getDefaultCameraFOV(),
                config.getDefaultCameraSpan());
    };
    /**
     * Adds camera configuration objects that correspond to the views defined for this 
     * spacecraft type and follow this specific spacecraft.
     */
    Spacecraft.prototype._addCameraConfigurationsForViews = function () {
        var i;
        for (i = 0; i < this._class.getViews().length; i++) {
            this._visualModel.getNode().addCameraConfiguration(this.createCameraConfigurationForView(this._class.getViews()[i]));
        }
    };
    /**
     * Calculates and caches the score value. Needs to be called when the equipment changes
     */
    Spacecraft.prototype._updateScoreValue = function () {
        var i;
        this._scoreValue = this._class.getScoreValue();
        for (i = 0; i < this._weapons.length; i++) {
            this._scoreValue += this._weapons[i].getScoreValue();
        }
        for (i = 0; i < this._missileLaunchers.length; i++) {
            this._scoreValue += this._missileLaunchers[i].getScoreValue();
        }
        if (this._propulsion) {
            this._scoreValue += this._propulsion.getScoreValue();
        }
        if (this._shield) {
            this._scoreValue += this._shield.getScoreValue();
        }
    };
    /**
     * Equips a weapon of the given class on the ship.
     * @param {WeaponClass} weaponClass The class of the weapon to equip.
     * @param {Number} [slotIndex] The index of the weapon slot to equip the weapon to. If not given (or negative), the weapon will be 
     * equipped to the next slot (based on the number of already equipped weapons)
     */
    Spacecraft.prototype._addWeapon = function (weaponClass, slotIndex) {
        var slot, weaponSlots = this._class.getWeaponSlots();
        if ((slotIndex === undefined) || (slotIndex < 0)) {
            slotIndex = this._weapons.length;
        }
        if (slotIndex < weaponSlots.length) {
            slot = weaponSlots[slotIndex];
            this._weapons.push(new equipment.Weapon(weaponClass, this, slot));
        }
    };
    /**
     * Set the current active missile launcher to the one with the passed index (also updating targeting computer state for missile locking)
     * @param {Number} index
     */
    Spacecraft.prototype._setActiveMissileLauncherIndex = function (index) {
        this._activeMissileLauncherIndex = index;
        this._targetingComputer.setMissileLauncher((this._activeMissileLauncherIndex >= 0) ? this._missileLaunchers[this._activeMissileLauncherIndex] : null);
    };
    /**
     * Equips a number of missiles of the given class into a launcher on the ship.
     * @param {MissileClass} missileClass The class of the missiles to equip.
     * @param {Number} amount The amount of missiles to equip. (this many missiles
     * will be loaded into the launcher regardless of available capacity)
     * @param {Number} [launcherIndex] The index of the missile launcher to load the
     * missiles to. If not given (or negative), the first available launcher will be used.
     */
    Spacecraft.prototype._addMissiles = function (missileClass, amount, launcherIndex) {
        var descriptor, launchers = this._class.getMissileLaunchers();
        if ((launcherIndex === undefined) || (launcherIndex < 0)) {
            launcherIndex = this._missileLaunchers.length;
        }
        if (launcherIndex < launchers.length) {
            descriptor = launchers[launcherIndex];
            this._missileLaunchers.push(new equipment.MissileLauncher(missileClass, this, descriptor, amount));
            if (this._activeMissileLauncherIndex < 0) {
                this._setActiveMissileLauncherIndex(0);
            }
            if (this._missileClasses.indexOf(missileClass) < 0) {
                this._missileClasses.push(missileClass);
            }
        }
    };
    /**
     * Equips a propulsion system of the given class to the ship, replacing the
     * previous propulsion system, if one was equipped.
     * @param {PropulsionClass} propulsionClass
     */
    Spacecraft.prototype._addPropulsion = function (propulsionClass) {
        this._propulsion = new equipment.Propulsion(propulsionClass, this._physicalModel);
        this._maneuveringComputer.updateForNewPropulsion();
        this._maneuveringComputer.updateTurningLimit();
        this._topSpeed = (physics.getDrag() && this._class.getDragFactor()) ? Math.sqrt(this.getMaxAcceleration() / (physics.getDrag() * this._class.getDragFactor())) : 0;
        this._updateBurnNeedFactors();
    };
    /**
     * Equips a jump engine of the given class to the ship, replacing the
     * previous jump engine, if one was equipped.
     * @param {JumpEngineClass} jumpEngineClass
     */
    Spacecraft.prototype._addJumpEngine = function (jumpEngineClass) {
        this._jumpEngine = new equipment.JumpEngine(jumpEngineClass, this);
    };
    /**
     * Equips a shield of the given class to the ship, replacing the
     * previous shield, if one was equipped.
     * @param {ShieldClass} shieldClass
     */
    Spacecraft.prototype._addShield = function (shieldClass) {
        this._shield = new equipment.Shield(shieldClass, this);
    };
    /**
     * Removes all equipment from the spacecraft.
     */
    Spacecraft.prototype.unequip = function () {
        var i;
        for (i = 0; i < this._weapons.length; i++) {
            this._weapons[i].destroy();
        }
        this._weapons = [];
        for (i = 0; i < this._missileLaunchers.length; i++) {
            this._missileLaunchers[i].destroy();
        }
        this._missileLaunchers = [];
        this._missileClasses = [];
        this._setActiveMissileLauncherIndex(-1);
        if (this._propulsion) {
            this._propulsion.destroy();
        }
        this._propulsion = null;
        this._maneuveringComputer.updateForNewPropulsion();
        this._maneuveringComputer.updateTurningLimit();
        this._updateScoreValue();
    };
    /**
     * Equips the spacecraft according to the specifications in the given loadout.
     * @param {Loadout} [loadout]
     */
    Spacecraft.prototype.equipLoadout = function (loadout) {
        var i, weaponDescriptors, missileDescriptors;
        if (loadout) {
            weaponDescriptors = loadout.getWeaponDescriptors();
            for (i = 0; i < weaponDescriptors.length; i++) {
                this._addWeapon(classes.getWeaponClass(weaponDescriptors[i].className), weaponDescriptors[i].slotIndex);
            }
            missileDescriptors = loadout.getMissileDescriptors();
            for (i = 0; i < missileDescriptors.length; i++) {
                this._addMissiles(classes.getMissileClass(missileDescriptors[i].className), missileDescriptors[i].amount, missileDescriptors[i].launcherIndex);
            }
            if (loadout.getPropulsionDescriptor() !== null) {
                this._addPropulsion(classes.getPropulsionClass(loadout.getPropulsionDescriptor().className));
            }
            if (loadout.getJumpEngineDescriptor() !== null) {
                this._addJumpEngine(classes.getJumpEngineClass(loadout.getJumpEngineDescriptor().className));
            }
            if (loadout.getShieldDescriptor() !== null) {
                this._addShield(classes.getShieldClass(loadout.getShieldDescriptor().className));
            }
        } else {
            application.log_DEBUG("WARNING: equipping empty loadout on " + this._class.getName() + "!");
        }
        this._updateScoreValue();
    };
    /**
     * Returns the list of names (IDs) of the available loadouts for this spacecraft.
     * @returns {String[]}
     */
    Spacecraft.prototype.getLoadoutNames = function () {
        return this._class.getLoadoutNames();
    };
    /**
     * Returns the sound source of the ship if it is far away enough from the camera that fire/launch sound effects should
     * be stacked on it, otherwise returns null
     * @returns {SoundSource}
     */
    Spacecraft.prototype.getSoundSourceForFireSound = function () {
        var posInCameraSpace;
        posInCameraSpace = mat.translationVector3(this.getPositionMatrixInCameraSpace());
        if ((Math.abs(posInCameraSpace[0]) <= _weaponFireSoundStackMinimumDistance) &&
                (Math.abs(posInCameraSpace[1]) <= _weaponFireSoundStackMinimumDistance) &&
                (Math.abs(posInCameraSpace[2]) <= _weaponFireSoundStackMinimumDistance)) {
            return null;
        }
        return this.getSoundSource();
    };
    /**
     * Fires all of the ship's weapons.
     * @param {Boolean} onlyIfAimedOrFixed Only those weapons are fired which are fixed (cannot be rotated) and those that can be rotated
     * and are currently aimed at their target.
     */
    Spacecraft.prototype.fire = function (onlyIfAimedOrFixed) {
        var i, scaledOriMatrix, fired = false, projectileCount;
        if (!this._firingDisabled) {
            scaledOriMatrix = this.getScaledOriMatrix();
            for (i = 0; i < this._weapons.length; i++) {
                projectileCount = this._weapons[i].fire(scaledOriMatrix, onlyIfAimedOrFixed, this.getSoundSourceForFireSound());
                fired = (projectileCount > 0) || fired;
                this._shotsFired += projectileCount;
            }
            // executing callbacks
            if (fired) {
                for (i = 0; i < this._targetedBy.length; i++) {
                    this._targetedBy[i].handleEvent(SpacecraftEvents.TARGET_FIRED);
                }
                this.handleEvent(SpacecraftEvents.FIRED);
            }
        }
    };
    /**
     * Automatically switch to the next launcher with the same missile class or to the first non-empty launcher if the current one is empty
     */
    Spacecraft.prototype._autoChangeMissileLauncher = function () {
        var originalIndex, missileClass, salvo;
        originalIndex = this._activeMissileLauncherIndex;
        missileClass = this._missileLaunchers[originalIndex].getMissileClass();
        salvo = this._missileLaunchers[originalIndex].isInSalvoMode();
        // first, try to find another launcher that has the same missile class and has missiles left to launch
        do {
            this._activeMissileLauncherIndex = (this._activeMissileLauncherIndex + 1) % this._missileLaunchers.length;
        } while ((this._activeMissileLauncherIndex !== originalIndex) &&
                (!this._missileLaunchers[this._activeMissileLauncherIndex].hasMissilesLeftToLaunch() ||
                        (this._missileLaunchers[this._activeMissileLauncherIndex].getMissileClass() !== missileClass)));
        // if there is no other launcher with still available missiles of the same class, and we are out of missiles in
        // the current launcher, try to find a launcher with a different missile class (if we are not out of missiles
        // in the current launcher, we will settle for it once again and wait for it to load the next missile)
        if ((this._activeMissileLauncherIndex === originalIndex) && !this._missileLaunchers[originalIndex].hasMissilesLeftToLaunch()) {
            do {
                this._activeMissileLauncherIndex = (this._activeMissileLauncherIndex + 1) % this._missileLaunchers.length;
            } while ((this._activeMissileLauncherIndex !== originalIndex) &&
                    !this._missileLaunchers[this._activeMissileLauncherIndex].hasMissilesLeftToLaunch());
        }
        if (this._activeMissileLauncherIndex === originalIndex) {
            if (this._missileLaunchers[originalIndex].getMissileCount() <= 0) {
                // current launcher is out of missiles (even queued ones) and we haven't found any others with missiles either
                this._setActiveMissileLauncherIndex(-1);
            }
        } else {
            this._setActiveMissileLauncherIndex(this._activeMissileLauncherIndex);
            if (this._missileLaunchers[this._activeMissileLauncherIndex].getMissileClass() === missileClass) {
                this._missileLaunchers[this._activeMissileLauncherIndex].setSalvoMode(salvo);
            } else {
                this._missileLaunchers[this._activeMissileLauncherIndex].setMinimumCooldown(config.getBattleSetting(config.BATTLE_SETTINGS.MISSILE_AUTO_CHANGE_COOLDOWN));
                if (config.getBattleSetting(config.BATTLE_SETTINGS.DEFAULT_SALVO_MODE)) {
                    this._missileLaunchers[this._activeMissileLauncherIndex].setSalvoMode(true);
                }
                control.playMissileChangeSound();
            }
        }
    };
    /**
     * If the currently active missile launcher is ready, launches a missile / starts a salvo from that launcher.
     * @returns {Missile} The missile that has been launched, if any
     */
    Spacecraft.prototype.launchMissile = function () {
        var i, scaledOriMatrix, missile;
        if (!this._firingDisabled && (this._activeMissileLauncherIndex >= 0) && this._targetingComputer.isMissileLocked()) {
            scaledOriMatrix = this.getScaledOriMatrix();
            missile = this._missileLaunchers[this._activeMissileLauncherIndex].launch(scaledOriMatrix, this.getSoundSourceForFireSound(), false);
            // executing callbacks
            if (missile) {
                this._missilesLaunched++;
                for (i = 0; i < this._targetedBy.length; i++) {
                    this._targetedBy[i].handleEvent(SpacecraftEvents.TARGET_FIRED);
                }
                this.handleEvent(SpacecraftEvents.FIRED);
                this._autoChangeMissileLauncher();
            }
            return missile;
        }
        return null;
    };
    /**
     * To be called when a missile launcher launches a missile automatically as part of a salvo
     */
    Spacecraft.prototype.handleSalvoMissileLaunched = function () {
        this._missilesLaunched++;
        if ((this._activeMissileLauncherIndex >= 0) && (this._missileLaunchers[this._activeMissileLauncherIndex].getMissileCount() <= 0)) {
            this._autoChangeMissileLauncher();
        }
    };
    /**
     * Change to a missile launcher with a different missile equipped
     * @returns {Boolean} Whether the active missile launcher has been changed
     */
    Spacecraft.prototype.changeMissile = function () {
        var originalIndex, missileClass, changed;
        if (this._activeMissileLauncherIndex >= 0) {
            originalIndex = this._activeMissileLauncherIndex;
            missileClass = this._missileLaunchers[originalIndex].getMissileClass();
            do {
                this._activeMissileLauncherIndex = (this._activeMissileLauncherIndex + 1) % this._missileLaunchers.length;
            } while ((this._activeMissileLauncherIndex !== originalIndex) &&
                    (!this._missileLaunchers[this._activeMissileLauncherIndex].hasMissilesLeftToLaunch() ||
                            (this._missileLaunchers[this._activeMissileLauncherIndex].getMissileClass() === missileClass)));
            changed = this._activeMissileLauncherIndex !== originalIndex;
            if (changed) {
                this._setActiveMissileLauncherIndex(this._activeMissileLauncherIndex);
                if (config.getBattleSetting(config.BATTLE_SETTINGS.DEFAULT_SALVO_MODE)) {
                    this._missileLaunchers[this._activeMissileLauncherIndex].setSalvoMode(true);
                }
            }
            return changed;
        }
        return false;
    };
    /**
     * Toggle salvo launch mode for the current active missile launcher
     * @returns {Boolean} Whether the salvo mode has been changed
     */
    Spacecraft.prototype.toggleSalvo = function () {
        if (this._activeMissileLauncherIndex >= 0) {
            return this._missileLaunchers[this._activeMissileLauncherIndex].toggleSalvoMode();
        }
        return false;
    };
    /**
     * An array of all the missile classes of currently equipped missiles on this ship
     * @returns {MissileClass[]}
     */
    Spacecraft.prototype.getMissileClasses = function () {
        return this._missileClasses;
    };
    /**
     * The currently active missile launcher of the spacecraft
     * @returns {MissileLauncher}
     */
    Spacecraft.prototype.getActiveMissileLauncher = function () {
        return (this._activeMissileLauncherIndex >= 0) ? this._missileLaunchers[this._activeMissileLauncherIndex] : null;
    };
    /**
     * The amount of missiles of the passed class currently equipped on this spacecraft
     * @param {MissileClass} missileClass
     * @returns {Number}
     */
    Spacecraft.prototype.getMissileCount = function (missileClass) {
        var i, result = 0;
        for (i = 0; i < this._missileLaunchers.length; i++) {
            if (this._missileLaunchers[i].getMissileClass() === missileClass) {
                result += this._missileLaunchers[i].getMissileCount();
            }
        }
        return result;
    };
    /*
     * Increases the number of hits on enemies registered for this spacecraft (for hit ratio calculation)
     * @param {Boolean} byMissile Whether the hit was by a missile
     */
    Spacecraft.prototype.increaseHitsOnEnemies = function (byMissile) {
        if (byMissile) {
            this._missileHitsOnEnemies++;
        } else {
            this._hitsOnEnemies++;
        }
    };
    /**
     * Sets up this spacecraft as being targeted by the passed spacecraft. (updating target reference list and executing the related callback)
     * @param {spacecraft} targetedBy
     */
    Spacecraft.prototype.setBeingTargeted = function (targetedBy) {
        if (this._targetedBy) {
            this._targetedBy.push(targetedBy);
            this.handleEvent(SpacecraftEvents.BEING_TARGETED, {
                spacecraft: targetedBy
            });
        }
    };
    /**
     * Sets up this spacecraft as not being targeted by the passed spacecraft anymore.
     * @param {Spacecraft} targetedBy
     */
    Spacecraft.prototype.setBeingUntargeted = function (targetedBy) {
        if (this._targetedBy) {
            this._targetedBy.splice(this._targetedBy.indexOf(targetedBy), 1);
        }
    };
    /**
     * Returns the array of spacecrafts targeting this one
     * @returns {Spacecraft[]}
     */
    Spacecraft.prototype.getTargetingSpacecrafts = function () {
        return this._targetedBy;
    };
    /**
     * Targets the given spacecraft and executes related operations, such as changing target views. 
     * @param {Spacecraft|null} target If null is given, the current target will be canceled.
     */
    Spacecraft.prototype.setTarget = function (target) {
        this._targetingComputer.setTarget(target);
    };
    /**
     * Targets the next hostile spacecraft, ordering the hostiles based on the angle between the spacecraft's direction and the vector
     * pointing to the hostile spacecraft
     * @returns {Boolean} Whether a new spacecraft has been targeted
     */
    Spacecraft.prototype.targetNextNearestHostile = function () {
        return this._targetingComputer.targetNextNearestHostile();
    };
    /**
     * Targets the previous hostile spacecraft, ordering the hostiles based on the angle between the spacecraft's direction and the vector
     * pointing to the hostile spacecraft
     * @returns {Boolean} Whether a new spacecraft has been targeted
     */
    Spacecraft.prototype.targetPreviousNearestHostile = function () {
        return this._targetingComputer.targetPreviousNearestHostile();
    };
    /**
     * Targets the next hostile spacecraft, ordering the hostiles based on a complex evaluation of how fitting targets they are.
     * (to be used by the AI)
     * @returns {Boolean} Whether a new spacecraft has been targeted
     */
    Spacecraft.prototype.targetNextBestHostile = function () {
        return this._targetingComputer.targetNextBestHostile();
    };
    /**
     * Targets the next non-hostile (friendly or neutral) spacecraft, ordering the hostiles based on the angle between the spacecraft's 
     * direction and the vector pointing to the hostile spacecraft
     * @returns {Boolean} Whether a new spacecraft has been targeted
     */
    Spacecraft.prototype.targetNextNearestNonHostile = function () {
        return this._targetingComputer.targetNextNearestNonHostile();
    };
    /**
     * Returns the currently targeted spacecraft.
     * @returns {Spacecraft|null}
     */
    Spacecraft.prototype.getTarget = function () {
        return this._targetingComputer.getTarget();
    };
    /**
     * Returns the estimated position towards which the spacecraft needs to fire to hit its current target in case both itself and the 
     * target retain their current velocity, based on the speed of the projectile fired from the first barrel of the first equipped weapon.
     * @returns {Number[3]}
     */
    Spacecraft.prototype.getTargetHitPosition = function () {
        return this._targetingComputer.getTargetHitPosition();
    };
    /**
     * Returns the progress ratio of the process of the currently active missile launcher locking on to the current target (0: not locked, 1: missile locked)
     * @returns {Number}
     */
    Spacecraft.prototype.getMissileLockRatio = function () {
        return this._targetingComputer.getMissileLockRatio();
    };
    /**
     * 
     * @returns {Propulsion}
     */
    Spacecraft.prototype.getPropulsion = function () {
        return this._propulsion;
    };
    /**
     * Returns the name of the propulsion system equipped on this spacecraft in a way that can be presented to the user (translated)
     * @returns {String}
     */
    Spacecraft.prototype.getPropulsionDisplayName = function () {
        return this._propulsion.getDisplayName();
    };
    /**
     * Resets all the thruster burn levels of the spacecraft to zero.
     */
    Spacecraft.prototype.resetThrusterBurn = function () {
        this._propulsion.resetThrusterBurn();
    };
    /**
     * Adds to the current burn level to all thrusters that have the specified
     * use.
     * @param {String} use The use of the thrusters to add burn to (e.g. "forward")
     * @param {Number} value The value to add to the current burn level.
     */
    Spacecraft.prototype.addThrusterBurn = function (use, value) {
        this._propulsion.addThrusterBurn(use, value);
    };
    /**
     * Updates the visual representation the propulsion of this spacecraft to represent its current state.
     */
    Spacecraft.prototype.updatePropulsionVisuals = function () {
        this._propulsion.updateVisuals();
    };
    /**
     * Show the models representing the hitboxes of this spacecraft.
     */
    Spacecraft.prototype.showHitbox = function () {
        this._hitbox.show();
    };
    /**
     * Hide the models representing the hitboxes of this spacecraft.
     */
    Spacecraft.prototype.hideHitbox = function () {
        this._hitbox.hide();
    };
    /**
     * Toggles the visibility of the models representing the hitboxes of this
     * spacecraft.
     */
    Spacecraft.prototype.toggleHitboxVisibility = function () {
        this._hitbox.toggleVisibility();
    };
    /**
     * Resets the parameters (position and orientation) of the cameras that 
     * correspond to the different views fixed on this spacecraft in the scene.
     */
    Spacecraft.prototype.resetViewCameras = function () {
        this._visualModel.getNode().resetCameraConfigurations();
    };
    /**
     * Simulates what happens when a given amount of damage is dealt to the spacecraft at a specific
     * point, coming from source coming from a specific direction.
     * @param {Number} damage The amount of damage done to the spacecraft (hitpoints)
     * @param {Number[4]} damagePosition The relative position vector of where the damage occured.
     * Needs to take into consideration the position, orientation and scaling of the spacecraft.
     * @param {Number[3]} damageDir The relative direction whector indicating where the damage came from.
     * Also needs to take into consideration the orientation of the spacecraft.
     * @param {Spacecraft} hitBy The spacecraft that caused the damage (fired the hitting projectile)
     * @param {Boolean} byMissile Whether the damage was caused by missile hit
     * @param {Number} offset The offset value that was used during the hitcheck (the distance by which
     * the hitbox sides have been extended outward)
     */
    Spacecraft.prototype.damage = function (damage, damagePosition, damageDir, hitBy, byMissile, offset) {
        var i, damageIndicator, hitpointThreshold, exp, liveHit, scoreValue, damageIndicatorPosition, dirToCenter, distToCenter;
        // shield absorbs damage
        if (this._shield) {
            damage = this._shield.damage(damage);
        }
        // armor rating decreases damage
        damage = Math.max(0, damage - this._class.getArmor());
        liveHit = this._hitpoints > 0;
        // logic simulation: modify hitpoints
        this._hitpoints -= damage;
        if (this._hitpoints <= 0) {
            // granting kill and score to the spacecraft that destroyed this one
            if (liveHit && hitBy && this.isHostile(hitBy)) {
                scoreValue = this.getScoreValue();
                damage += this._hitpoints; // this subtracts the overkill hitpoints
                hitBy.gainDamageDealt(damage, byMissile);
                // gain score for dealing the damage
                hitBy.gainScore((1 - _scoreFactorForKill) * damage / this._maxHitpoints * scoreValue);
                // gain score and kill for delivering the final hit
                hitBy.gainScore(_scoreFactorForKill * scoreValue);
                hitBy.gainKill();
            }
            this._hitpoints = 0;
        } else {
            // visual simulation: add damage indicators if needed
            for (i = 0; i < this._class.getDamageIndicators().length; i++) {
                damageIndicator = this._class.getDamageIndicators()[i];
                hitpointThreshold = damageIndicator.hullIntegrity / 100 * this._maxHitpoints;
                if ((this._hitpoints <= hitpointThreshold) && (this._hitpoints + damage > hitpointThreshold)) {
                    // the original hitcheck might have had a large offset and so the hit position could be away from the ship
                    // putting the damage indicator there would look weird, so let's try to find a point that is on the ship (hitbox) surface
                    if (offset > 0) {
                        // first, try to elongate the path of the projectile that hit
                        damageIndicatorPosition = [0, 0, 0, 1];
                        distToCenter = this._physicalModel.getBodySize();
                        vec.setSum3(damageIndicatorPosition, damagePosition, vec.scaled3(damageDir, -distToCenter));
                        damageIndicatorPosition = this._physicalModel.checkHitRelative(damageIndicatorPosition, vec.scaled3(damageDir, -1), distToCenter, 0);
                        if (!damageIndicatorPosition) {
                            // if that doesn't work, do a second hitcheck towards the ship center with 0 offset and compare this new point on the ship surface, if far away enough, 
                            // use it for damage indicator position instead of the original hit position
                            dirToCenter = vec.scaled3(damagePosition, -1);
                            distToCenter = vec.extractLength3(dirToCenter);
                            damageIndicatorPosition = this._physicalModel.checkHitRelative(vec.NULL4W1, dirToCenter, distToCenter, 0);
                        }
                        if (!damageIndicatorPosition || (vec.length3Squared(damageIndicatorPosition, damagePosition) < MINIMUM_DISTANCE_FOR_DAMAGE_INDICATOR_HITCHECK_SQUARED)) {
                            // the new position is close to the original one, just use the original one for the damage indicator
                            damageIndicatorPosition = damagePosition;
                        } else {
                            // if we got the new indicator position from the second hitcheck towards the center, change damage direction accordingly
                            if (dirToCenter) {
                                damageDir = vec.scaled3(dirToCenter, -1);
                            }
                        }
                    } else {
                        damageIndicatorPosition = damagePosition;
                    }
                    exp = explosion.getExplosion();
                    exp.init(
                            damageIndicator.explosionClass,
                            mat.translation4vAux(damageIndicatorPosition),
                            mat.IDENTITY4,
                            damageDir,
                            true);
                    exp.addToSceneNow(this._visualModel.getNode(), this.getSoundSource());
                    this._activeDamageIndicators.push(exp);
                }
            }
            // granting score to the spacecraft that hit this one for the damage
            if (liveHit && hitBy && hitBy.isAlive() && this.isHostile(hitBy)) {
                hitBy.gainDamageDealt(damage, byMissile);
                hitBy.gainScore((1 - _scoreFactorForKill) * damage / this._maxHitpoints * this.getScoreValue());
            }
        }
        // callbacks
        this.handleEvent(SpacecraftEvents.BEING_HIT, {spacecraft: hitBy, hitPosition: damagePosition});
        if (hitBy.isAlive() && !hitBy.isAway()) {
            if (hitBy.getTarget() === this) {
                hitBy.handleEvent(SpacecraftEvents.TARGET_HIT);
            }
            hitBy.handleEvent(SpacecraftEvents.ANY_SPACECRAFT_HIT, {
                spacecraft: this
            });
        }
        if (this.isHostile(hitBy)) {
            hitBy.increaseHitsOnEnemies(byMissile);
        }
    };
    /**
     * Rotates all the non-fixed weapons of the spacecraft to aim towards the calculated hitting position of the current target.
     * @param {Number} turnThreshold Weapons will only be rotated if the angle between their current and the target direction is greater 
     * than this value, in radians.
     * @param {Number} fireThreshold Weapons will only report an aimed status if the angle between their current and the target direction is 
     * less than this value, in radians.
     * @param {Number} dt the elapsed time since the last simulation step, based on which the amount of rotation will be calculated.
     */
    Spacecraft.prototype.aimWeapons = function (turnThreshold, fireThreshold, dt) {
        var futureTargetPosition, i, target = this.getTarget();
        if (target && (this._weapons.length > 0)) {
            futureTargetPosition = this.getTargetHitPosition();
        }
        for (i = 0; i < this._weapons.length; i++) {
            if (target && !this._firingDisabled) {
                this._weapons[i].aimTowards(futureTargetPosition, turnThreshold, fireThreshold, this.getScaledOriMatrix(), dt);
            } else {
                this._weapons[i].rotateToDefaultPosition(turnThreshold, dt);
            }
        }
    };
    /**
     * Engages jump engines to leave the scene of the mission
     * @param {Boolean} toggle If true, calling the method while the jump out sequence is under way will cancel the jump
     */
    Spacecraft.prototype.jumpOut = function (toggle) {
        if (!this._away && this._jumpEngine) {
            this._jumpEngine.jumpOut(toggle);
        } else {
            application.log_DEBUG("Warning! Spacecraft '" + this.getDisplayName() + "' cannot jump out because it is already away or has no jump engines!");
        }
    };
    /**
     * Engages jump engines to enter the scene of the mission
     */
    Spacecraft.prototype.jumpIn = function () {
        if (this._away && this._jumpEngine) {
            this._jumpEngine.jumpIn();
        } else {
            application.log_DEBUG("Warning! Spacecraft '" + this.getDisplayName() + "' cannot jump in because it is already present or has no jump engines!");
        }
    };
    /**
     * Returns a 3D vector that can be used to position the sound source of this spacecraft in the soundscape
     * @returns {Number[3]}
     */
    Spacecraft.prototype._getSoundSourcePosition = function () {
        var pos = this.getPositionMatrixInCameraSpace();
        this._soundSourcePosition[0] = Math.round(pos[12] * 10) * 0.1;
        this._soundSourcePosition[1] = Math.round(pos[13] * 10) * 0.1;
        this._soundSourcePosition[2] = Math.round(pos[14] * 10) * 0.1;
        return this._soundSourcePosition;
    };
    /**
     * Returns the sound source beloning to this spacecraft (that can be used to play sound effects positioned in 3D)
     * @returns {SoundSource}
     */
    Spacecraft.prototype.getSoundSource = function () {
        if (!this._soundSource) {
            this._soundSource = audio.createSoundSource([0, 0, 0]);
        }
        return this._soundSource;
    };
    /**
     * Starts the playback of the spacecraft hum sound effect (ramping the volume up from zero to avoid popping)
     */
    Spacecraft.prototype._startHumSound = function () {
        this._humSoundClip.setVolume(0);
        this._humSoundClip.play();
        this._humSoundClip.rampVolume(this._humSoundVolume, HUM_SOUND_VOLUME_RAMP_DURATION, true, true);
    };
    /**
     * If the spacecraft object was not destroyed upon its destruction (by setting an onDestructed handler returning false), it retains its
     * data and can be respawned (returned to full hitpoints) using this method
     * @param {Boolean} [randomAnimationTime=false] If true, the blinking lights on the spacecraft will be set to a random blinking 
     * animation state (otherwise start from the beginning)
     */
    Spacecraft.prototype.respawn = function (randomAnimationTime) {
        var i;
        this._alive = true;
        this._hitpoints = this._maxHitpoints;
        this._timeElapsedSinceDestruction = -1;
        if (this._humSoundClip) {
            this._startHumSound();
        }
        for (i = 0; i < this._blinkers.length; i++) {
            if (randomAnimationTime) {
                this._blinkers[i].setRandomTime();
            } else {
                this._blinkers[i].setTime(0);
            }
        }
    };
    /**
     * Sets the hitpoints (hull integrity) of the spacecraft, causing it to explode the next time its simulate() method is called
     */
    Spacecraft.prototype.setHitpointsToZero = function () {
        this._hitpoints = 0;
    };
    /**
     * @typedef {Object} Spacecraft~SimulateParams
     * The named parameters that can be submitted to the simulate() method of spacecrafts
     * @property {Boolean} controlThrusters If false, the maneuvering computer will not control the thrusters in this simulation step
     * @property {Boolean} applyThrusterForces If false, the forces and torques from thrusters will not be applied to the spacecraft in this
     * simulation step
     */
    /**
     * The default parameters for simulate() calls (to avoid creating a new object every time)
     * @memberOf Spacecraft
     * @type Spacecraft~SimulateParams
     */
    Spacecraft.DEFAULT_SIMULATE_PARAMS = {
        controlThrusters: true,
        applyThrusterForces: true
    };
    /**
     * Performs all the phyics and logic simulation of this spacecraft.
     * @param {Number} dt The elapsed time since the last simulation step, in
     * milliseconds.
     * @param {Spacecraft~SimulateParams} [params=Spacecraft.DEFAULT_SIMULATE_PARAMS] Optional additional parameters affecting the behaviour
     * of the method
     */
    Spacecraft.prototype.simulate = function (dt, params) {
        var i, p;
        if (!this._alive) {
            return;
        }
        if (this._away) {
            return;
        }
        params = params || Spacecraft.DEFAULT_SIMULATE_PARAMS;
        this._targetingComputer.simulate(dt);
        // update the sound source position - will be used either way (for the explosion or for hum / thrusters / weapons... )
        p = this._getSoundSourcePosition();
        this.getSoundSource().setPosition(p[0], p[1], p[2]);
        // destruction of the spacecraft
        if (this._hitpoints <= 0) {
            if (this._timeElapsedSinceDestruction < 0) {
                this._timeElapsedSinceDestruction = 0;
                if (this._humSoundClip) {
                    this._humSoundClip.stopPlaying(audio.SOUND_RAMP_DURATION);
                }
                if (this._propulsion) {
                    this._propulsion.resetThrusterBurn();
                    this._propulsion.simulate(0, this.getSoundSource(), false);
                }
                this._explosion = explosion.getExplosion();
                this._explosion.init(
                        this._class.getExplosionClass(),
                        this._physicalModel.getPositionMatrix(),
                        this._physicalModel.getOrientationMatrix(),
                        mat.getRowC43(this._physicalModel.getPositionMatrix()),
                        true,
                        true,
                        this._physicalModel.getVelocityMatrix());
                this._explosion.addToScene(this._visualModel.getNode().getScene().getRootNode(), this.getSoundSource());
                for (i = 0; i < this._activeDamageIndicators; i++) {
                    this._activeDamageIndicators[i].finish();
                }
            } else {
                this._timeElapsedSinceDestruction += dt;
                if (this._timeElapsedSinceDestruction > (this._class.getExplosionClass().getTotalDuration() * this._class.getShowTimeRatioDuringExplosion())) {
                    this._alive = false;
                    if (this.handleEvent(SpacecraftEvents.DESTRUCTED) !== false) {
                        this.destroy(true);
                    }
                    return;
                }
            }
        } else {
            // updating onboard systems, if the spacecraft is still functioning
            for (i = 0; i < this._weapons.length; i++) {
                this._weapons[i].simulate(dt);
            }
            for (i = 0; i < this._missileLaunchers.length; i++) {
                this._missileLaunchers[i].simulate(dt);
                if ((this._activeMissileLauncherIndex < 0) && this._missileLaunchers[i].hasMissilesLeftToLaunch()) {
                    this._setActiveMissileLauncherIndex(i);
                }
            }
            if (this._propulsion) {
                if (params.controlThrusters) {
                    this._maneuveringComputer.controlThrusters(dt);
                }
                this._propulsion.simulate(dt, this._soundSource, params.applyThrusterForces);
            }
            if (this._jumpEngine) {
                this._jumpEngine.simulate(dt);
            }
            if (this._shield) {
                this._shield.simulate(dt);
            }
            if (this._class.hasHumSound()) {
                if (!this._humSoundClip) {
                    this._humSoundClip = this._class.createHumSoundClip(this._soundSource);
                    this._humSoundVolume = this._humSoundClip.getVolume();
                    if (this._humSoundClip) {
                        this._startHumSound();
                    }
                }
            }
        }
        this._physicalModel.simulate(dt);
        this._relativeVelocityMatrixValid = false;
        this._turningMatrixValid = false;
        this.updateScaledOriMatrix();
        this._visualModel.setPositionMatrix(this._physicalModel.getPositionMatrix());
        this._visualModel.setOrientationMatrix(this._physicalModel.getOrientationMatrix());
        if (this._propulsion) {
            this._maneuveringComputer.updateSpeedIncrement(dt);
        }
    };
    /**
     * Adds a new event handler function for events of the passed type
     * @param {String} eventID Identifies the event type - see SpacecraftEvents
     * @param {Function} handler The function to call when an event of the given type happens with this spacecraft
     */
    Spacecraft.prototype.addEventHandler = function (eventID, handler) {
        this._eventHandlers[eventID] = this._eventHandlers[eventID] || [];
        this._eventHandlers[eventID].push(handler);
    };
    /**
     * Executes the previously added event handlers for the passed event type.
     * Public, because equipment (e.g. jump engine) can trigger events for the spacecraft it is placed on.
     * @param {String} eventID (enum SpacecraftEvents)
     * @param {Object} data Data to pass to the event handlers (the exact structure depends on the event type)
     * @returns {Boolean} Returns true if all event handlers return true 
     */
    Spacecraft.prototype.handleEvent = function (eventID, data) {
        var i, result;
        if (this._eventHandlers && this._eventHandlers[eventID]) {
            result = true;
            for (i = 0; i < this._eventHandlers[eventID].length; i++) {
                result = this._eventHandlers[eventID][i](data) && result;
            }
        }
        return result;
    };
    /**
     * Returns the highest number of projectiles that might be used for the weapons of this spacecraft simultaneously in one battle.
     * @returns {Number}
     */
    Spacecraft.prototype.getMaxProjectileCount = function () {
        var result = 0, i;
        for (i = 0; i < this._weapons.length; i++) {
            result += this._weapons[i].getMaxProjectileCount();
        }
        return result;
    };
    /**
     * Returns the highest number of missiles that might be used (flying, rendered) for the missile launchers of this 
     * spacecraft simultaneously in one battle.
     * @returns {Number}
     */
    Spacecraft.prototype.getMaxMissileCount = function () {
        var result = 0, i;
        for (i = 0; i < this._missileLaunchers.length; i++) {
            result += this._missileLaunchers[i].getMaxMissileCount();
        }
        return result;
    };
    /**
     * Returns the highest number of explosions that might be used for this spacecraft simultaneously in one battle.
     * @returns {Number}
     */
    Spacecraft.prototype.getMaxExplosionCount = function () {
        var result = 0, i;
        result += 1; // main explosion when ship is destroyed
        result += this._class.getDamageIndicators().length;
        for (i = 0; i < this._weapons.length; i++) {
            result += this._weapons[i].getMaxExplosionCount();
        }
        for (i = 0; i < this._missileLaunchers.length; i++) {
            result += this._missileLaunchers[i].getMaxExplosionCount();
        }
        return result;
    };
    /**
     * Returns the highest number of particles that might be used for this spacecraft simultaneously in one battle.
     * @returns {Number}
     */
    Spacecraft.prototype.getMaxParticleCount = function () {
        var result = 0, i, damageIndicators;
        result += this._class.getExplosionClass().getMaxParticleCount();
        damageIndicators = this._class.getDamageIndicators();
        for (i = 0; i < damageIndicators.length; i++) {
            result += damageIndicators[i].explosionClass.getMaxParticleCount();
        }
        for (i = 0; i < this._weapons.length; i++) {
            result += this._weapons[i].getMaxParticleCount();
        }
        for (i = 0; i < this._missileLaunchers.length; i++) {
            result += this._missileLaunchers[i].getMaxParticleCount();
        }
        return result;
    };
    /**
     * When locking on to this spacecraft with a missile, the time it takes to achieve lock is multiplied by this factor
     * (smaller for larger ships, larger for more stealthy ships)
     * @returns {Number}
     */
    Spacecraft.prototype.getLockingTimeFactor = function () {
        return this._class.getLockingTimeFactor();
    };
    /**
     * Cancels the held references and marks the renderable object, its node and its subtree as reusable.
     * @param {Boolean} [preserveClass=false] If true, the reference to the spacecraft's class is preserved (spacecraft classes objects are 
     * not destroyed during the game anyway, and this way it can be known, what type of spacecraft this was (for example for showing 
     * destroyed wingmen in the wingmen status panel during a mission)
     */
    Spacecraft.prototype.destroy = function (preserveClass) {
        var i;
        if (!preserveClass) {
            this._class = null;
        }
        if (this._weapons) {
            for (i = 0; i < this._weapons.length; i++) {
                if (this._weapons[i]) {
                    this._weapons[i].destroy();
                    this._weapons[i] = null;
                }
            }
        }
        this._weapons = null;
        if (this._missileLaunchers) {
            for (i = 0; i < this._missileLaunchers.length; i++) {
                if (this._missileLaunchers[i]) {
                    this._missileLaunchers[i].destroy();
                    this._missileLaunchers[i] = null;
                }
            }
        }
        this._missileLaunchers = null;
        this._missileClasses = null;
        if (this._propulsion) {
            this._propulsion.destroy();
            this._propulsion = null;
        }
        if (this._jumpEngine) {
            this._jumpEngine.destroy();
            this._jumpEngine = null;
        }
        if (this._shield) {
            this._shield.destroy();
            this._shield = null;
        }
        if (this._maneuveringComputer) {
            this._maneuveringComputer.destroy();
            this._maneuveringComputer = null;
        }
        if (this._targetingComputer) {
            this._targetingComputer.destroy();
            this._targetingComputer = null;
        }
        this._targetedBy = null;
        this._eventHandlers = null;
        this._explosion = null; // do not destroy the explosion - it might still be animating!
        if (this._hitbox) {
            this._hitbox.markAsReusable(true);
        }
        this._hitbox = null;
        if (this._visualModel && this._visualModel.getNode() && !this._visualModel.getNode().canBeReused()) {
            this._visualModel.getNode().markAsReusable(true);
        }
        this._visualModel = null;
        this._lights = null;
        this._physicalModel = null;
        if (this._activeDamageIndicators) {
            // damage indicators are pooled objects (Explosions), so we do not destroy them (properties and reusability state need to be 
            // preserved for reuse)
            this._activeDamageIndicators = null;
        }
        this._alive = false;
        if (this._humSoundClip) {
            this._humSoundClip.destroy();
            this._humSoundClip = null;
        }
        if (this._soundSource) {
            // do not destroy it, the explosion sound might still be playing, just remove the reference
            // the node will automatically be removed after playback finishes
            this._soundSource = null;
        }
    };
    // caching configuration settings
    config.executeWhenReady(function () {
        _luminosityFactorsArrayName = config.getSetting(config.GENERAL_SETTINGS.UNIFORM_LUMINOSITY_FACTORS_ARRAY_NAME);
        _groupTransformsArrayName = config.getSetting(config.GENERAL_SETTINGS.UNIFORM_GROUP_TRANSFORMS_ARRAY_NAME);
        _hitZoneColor = config.getSetting(config.BATTLE_SETTINGS.HITBOX_COLOR);
        _weaponFireSoundStackMinimumDistance = config.getSetting(config.BATTLE_SETTINGS.WEAPON_FIRE_SOUND_STACK_MINIMUM_DISTANCE);
        _scoreFactorForKill = config.getSetting(config.BATTLE_SETTINGS.SCORE_FRACTION_FOR_KILL);
        resetRandomSeed();
        graphics.executeWhenReady(handleGraphicsSettingsChanged);
        graphics.onSettingsChange(handleGraphicsSettingsChanged);
    });
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        SpacecraftFormation: SpacecraftFormation,
        resetRandomSeed: resetRandomSeed,
        Spacecraft: Spacecraft
    };
});
/**
 * Copyright 2016-2020 Krisztián Nagy
 * @file A stateful module providing a collection to which AIs of different types (at the moment only one type, an AI for fighters) can be
 * added which control their respective spacecraft when the control function of the module is called.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 0.1
 */

/*global define */

/**
 * @param utils Used for PI related constants
 * @param vec Used for vector operations the AIs need to calculate their actions.
 * @param mat Used for matrix operations the AIs need to calculate their actions.
 * @param application Used for displaying error messages
 * @param physics Used for accessing the constant of how long rotation does a rotation matrix represent.
 * @param config Used for accessing game configuration/settings.
 * @param SpacecraftEvents Used for setting spacecraft event handlers
 * @param classes used for accessing spacecraft turn style enum type
 * @param spacecraft Used for formations
 * @param equipment Used to access the FlightMode enum
 */
define('armada/logic/ai',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/physics",
    "armada/configuration",
    "armada/logic/SpacecraftEvents",
    "armada/logic/classes",
    "armada/logic/spacecraft",
    "armada/logic/equipment",
    "utils/polyfill"
], function (utils, vec, mat, application, physics, config, SpacecraftEvents, classes, spacecraft, equipment) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // enums
            /**
             * The types (IDs) of spacecraft commands that AIs can interpret and execute
             * @enum {String}
             */
            SpacecraftCommand = {
                /** A command to activate the jump engines of the spacecraft (to jump in / out) */
                JUMP: "jump",
                /** A command to set a list of target spacecrafts */
                TARGET: "target",
                /** A command to stand down and do nothing */
                STAND_DOWN: "standDown"
            },
            /**
             * Specifies the direction of jump commands
             * @enum {String}
             */
            JumpCommandWay = {
                IN: "in",
                OUT: "out"
            },
            /**
             * @enum {Number}
             * The possible phases of the charge action of fighters.
             */
            ChargePhase = {
                /**
                 * The phase when the fighter is not performing a charge action.
                 */
                NONE: -1,
                /**
                 * The phase when the fighter is charging at its target with increased speed.
                 */
                APPROACH_ATTACK: 0,
                /**
                 * The phase when the fighter is evading its target to avoid collision and heads towards a destination beyond it.
                 */
                EVADE: 1
            },
            // ------------------------------------------------------------------------------
            // constants
            /**
             * The type identifier to be used when creating fighter AIs.
             * @type String
             */
            FIGHTER_AI_NAME = "fighter",
            /**
             * The type identifier to be used when creating ship AIs.
             * @type String
             */
            SHIP_AI_NAME = "ship",
            /**
             * Spacecrafts will stop turning towards the specified direction when reaching this angle (in radians).
             * @type Number
             */
            TURN_THRESHOLD_ANGLE = 0.001,
            /**
             * The factor to apply when converting angular velocity (turning) matrix angles to rad / s.
             * @type Number
             */
            ANGULAR_VELOCITY_CONVERSION_FACTOR = 1000 / physics.ANGULAR_VELOCITY_MATRIX_DURATION,
            /**
             * Both yaw and pitch needs to be below this angle to consider a fighter facing its target. (in radians)
             * @type Number
             */
            TARGET_FACING_ANGLE_THRESHOLD = Math.radians(45),
            /**
             * When starting a new attack run, fighters will approach their targets to at least the distance that is their weapon range
             * multiplied by this factor.
             * @type Number
             */
            BASE_MAX_DISTANCE_FACTOR = 0.3,
            /**
             * When closing in on a target because of having difficulties hitting it at the current distance, the maximum approach distance 
             * factor will be decreased to this value maximum (gradually).
             * @type Number
             */
            CLOSE_MAX_DISTANCE_FACTOR = 0.125,
            /**
             * When closing in on a target because of having difficulties hitting it at the current distance, the maximum approach distance 
             * is decreased this much in one step.
             * @type Number
             */
            MAX_DISTANCE_FACTOR_DECREMENT = 0.05,
            /**
             * The maximum approach ditance factor will be decreased by one step (decrement) after this many missed shots at the target.
             * @type Number
             */
            CLOSE_IN_TRIGGER_MISS_COUNT = 5,
            /**
             * During normal (not charge) attacks, fighters will keep a distance of at least its weapon range multiplied by this factor
             * from the target.
             * @type Number
             */
            MIN_DISTANCE_FACTOR = 0.06,
            /**
             * Fighters will start evasive maneuvers if their current target fires at them from a distance farther than their range 
             * multiplied by this number.
             * @type Number
             */
            MIN_EVADE_DISTANCE_FACTOR = 0.5,
            /**
             * During normal (not charge) attacks, fighters will approach / back off with a maximum speed equal to their acceleration
             * multiplied by this factor.
             * @type Number
             */
            APPROACH_SPEED_FACTOR = 2,
            /**
             * During charge attacks, fighters will approach with a maximum speed equal to their acceleration multiplied by this 
             * factor.
             * @type Number
             */
            CHARGE_SPEED_FACTOR = 4,
            /**
             * During charge attacks, fighters will evade with a maximum speed equal to their acceleration multiplied by this 
             * factor.
             * @type Number
             */
            CHARGE_EVADE_SPEED_FACTOR = 2,
            /**
             * Fighters will initiate a charge attack if they are unable to hit their target after firing this many shots at it.
             * @type Number
             */
            CHARGE_TRIGGER_MISS_COUNT = 15,
            /**
             * Fighters will initiate a charge attack if they are hit by spacecrafts other than their current target this many times.
             * @type Number
             */
            CHARGE_TRIGGER_HIT_COUNT = 4,
            /**
             * When strafing to avoid a spacecraft blocking the current firing path, fighters will strafe (along each axis) with a maximum
             * speed equal to their acceleration multiplied by this factor.
             * @type Number
             */
            BLOCK_AVOIDANCE_SPEED_FACTOR = 1,
            /**
             * Fighters will open fire if they are able to aim within an angle under which an object of the size of their target multiplied
             * by this factor is visible at the current target distance.
             * @type Number
             */
            FIRE_THRESHOLD_ANGLE_FACTOR = 0.25,
            /**
             * Fighters will initiate a rolling maneuver after missing their target for this many shots.
             * @type Number
             */
            ROLL_CORRECTION_TRIGGERING_MISS_COUNT = 3,
            /**
             * Fighters will roll this much during one roll correction maneuver (in radians).
             * @type Number
             */
            ROLL_CORRECTION_ANGLE = Math.radians(45),
            /**
             * The distance within which a spacecraft has to be from a certain place (destination vector) to be considered being at that 
             * place, in meters.
             * @type Number
             */
            EXACT_PLACE_RANGE = 1,
            /**
             * When charge attacking, fighters will start the evade maneuver after reaching a critical distance, with an evade vector that
             * is 45 degrees from the attack vector and has a length of the critical distance multiplied by this factor.
             * @type Number
             */
            CHARGE_EVADE_VECTOR_LENGTH_FACTOR = 1,
            /**
             * When performing evasive maneuvers, fighters will strafe with a maximum speed equal to their acceleration mutliplied by this
             * factor.
             * @type Number
             */
            EVASIVE_MANEUVER_SPEED_FACTOR = 1,
            /**
             * Fighters will perform one evasive maneuver for this long, in milliseconds.
             * @type Number
             */
            EVASIVE_MANEUVER_DURATION = 1000,
            /**
             * Fighters will update the offset vector they use to aim at their target in this interval, in milliseconds.
             * @type Number
             */
            TARGET_OFFSET_UPDATE_INTERVAL = 1500,
            /**
             * When starting a new attack run, a random aiming error will be calculated for fighter in the range of +/- this many degrees
             * along both axes
             * @type Number
             */
            MAX_AIM_ERROR = Math.radians(2),
            /**
             * Every time a new target offset is calculated, if it is not significantly different from the previous one, the maximum aiming
             * error is reduced by multiplying the current maximum by this factor. (otherwise, a new aiming error with the same maximum is
             * calculated)
             * @type Number
             */
            AIM_ERROR_REDUCTION_FACTOR = 0.5,
            /**
             * The square of the length of the difference between a newly calculated and the previous target offset needs to be less than 
             * this number in order to reduce the aiming error. (in meters)
             * @type Number
             */
            AIM_ERROR_REDUCTION_THRESHOLD = 25 * 25,
            /**
             * Once aimed, fighters will start firing after this time elapses, in milliseconds. (to simulate a reaction time)
             * @type Number
             */
            FIRE_DELAY = 350,
            /**
             * Fighters will start their evasive maneuvers this much time after triggered, in milliseconds. (to simulate a reaction time)
             * @type Number
             */
            EVASIVE_MANEUVER_DELAY = 200,
            /**
             * When attacking an enemy, ships will approach their targets to at least the distance that is their weapon range
             * multiplied by this factor.
             * @type Number
             */
            SHIP_MAX_DISTANCE_FACTOR = 0.9,
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * Cached value of the configuration setting determining for maximum how long should spacecrafts accelerate their turning, in
             * seconds.
             * @type Number
             */
            _turnAccelerationDuration = 0,
            /**
             * Cached value of the constant part of the expression calculating the intensity for turning (yawing and pitching), that only 
             * depends on constant configuration values.
             * @type Number
             */
            _turnIntensityBaseFactor = 0,
            /**
             * The random generator for creating positions for anchor-distance-based jump in sequences, so that it runs from the
             * same seed (the seed itself is random generated currently, but can be fixed for testing purposes / later use)
             * @type Function
             */
            _jumpInPositionSeed,
            /**
             * An associative array storing the constructors for the various types of AI by the string identifiers of the types.
             * @type Object
             */
            _aiConstructors,
            /**
             * The default AI context (storing the actual AIs) the methods of which are exposed by this module.
             * @type AIContext
             */
            _context;
    // ##############################################################################
    /**
     * Returns a list of all the valid AI types
     * @returns {String[]}
     */
    function getAITypes() {
        return Object.keys(_aiConstructors);
    }
    // ##############################################################################
    /**
     * @class
     * An abstract AI class that provides some generally useful methods for controlling a spacecraft.
     * @param {Spacecraft} spacecraft The AI will control this spacecraft.
     * @param {Mission} mission The mission within which this AI will control the spacecraft
     */
    function SpacecraftAI(spacecraft, mission) {
        /**
         * The spacecraft this AI is controlling.
         * @type Spacecraft
         */
        this._spacecraft = spacecraft;
        /**
         * The mission within which this AI controls the spacecraft.
         * @type Mission
         */
        this._mission = mission;
        /**
         * While true, the spacecraft should come to a halt and not engage any targets.
         * @type Boolean
         */
        this._standingDown = false;
        /**
         * The list of targets this spacecraft should destroy, in order of priority
         * @type Spacecraft
         */
        this._targetList = null;
        /**
         * While true, the spacecraft should not engage spacecrafts outside of its target list (even if provoked)
         * @type Boolean
         */
        this._priorityTargets = false;
        /**
         * The number of hits suffered from ships that are not the current target while facing the current target (reset when not facing the
         * target or when a new attack run starts)
         * @type Number
         */
        this._hitCountByNonTarget = 0;
        /**
         * Cached value of the range of the first weapon of the controlled spacecraft (at still position).
         * @type Number
         */
        this._weaponRange = (this._spacecraft && (this._spacecraft.getWeapons().length > 0)) ? this._spacecraft.getWeapons()[0].getRange() : 0;
        /**
         * Whether the controlled spacecraft is currently attacking its target
         * Needs to be updated by the overridden control() method!!
         * @type Boolean
         */
        this._attackingTarget = false;
        // attaching handlers to the spacecraft events
        if (this._spacecraft) {
            this._spacecraft.setSpeedHolding(true);
            this._spacecraft.addEventHandler(SpacecraftEvents.BEING_HIT, this._handleBeingHit.bind(this));
            this._spacecraft.addEventHandler(SpacecraftEvents.COMMAND_RECEIVED, this._handleCommand.bind(this));
        }
    }
    /**
     * Controls the spacecraft to turn (yaw and pitch) in the desired direction specified by two angles.
     * @param {Number} yaw The yaw angle of the direction to turn towards, with a positive number meaning a direction to the left, in radians.
     * @param {Number} pitch The pitch angle of the direction to turn towards, with a positive number meaning a direction upwards, in radians.
     * @param {Number} dt The time passed since the last turn command in milliseconds - for an estimation of the time the set yaw and pitch 
     * angular velocity will be in effect, so that they can be limited to avoid overshooting the desired angles
     */
    SpacecraftAI.prototype.turn = function (yaw, pitch, dt) {
        var turningMatrix, angularVelocity, angularAcceleration, turnStopAngle, turnIntensityFactor;
        turningMatrix = this._spacecraft.getTurningMatrix();
        angularAcceleration = this._spacecraft.getMaxAngularAcceleration();
        // a turn intensity of 1 means to accelerate the angular velocity to TURN_ACCELERATION_DURATION_S * acceleration (in rad / sec) and
        // lower values represent a linear portion of this intended angular velocity
        // the base intensity factor converts dt to seconds and counts in TURN_ACCELERATION_DURATION_S
        // based on angle = angular velocity * time, we choose an angular velocity that will not overshoot the intended angle in the next dt
        // milliseconds (which will mean about the next simulation step with relatively stable framerates)
        turnIntensityFactor = _turnIntensityBaseFactor / (angularAcceleration * dt);
        // calculating how much will the spacecraft turn at the current angular velocity if it starts decelerating right now
        angularVelocity = Math.sign(turningMatrix[4]) * vec.angle2y(turningMatrix[4], turningMatrix[5]) * ANGULAR_VELOCITY_CONVERSION_FACTOR;
        turnStopAngle = Math.max(angularVelocity * angularVelocity / (2 * angularAcceleration), TURN_THRESHOLD_ANGLE);
        if (yaw > turnStopAngle) {
            this._spacecraft.yawLeft(Math.min(Math.max(0, turnIntensityFactor * (yaw - turnStopAngle)), 1));
        } else if (yaw < -turnStopAngle) {
            this._spacecraft.yawRight(Math.min(Math.max(0, turnIntensityFactor * (-yaw - turnStopAngle)), 1));
        }
        angularVelocity = Math.sign(turningMatrix[6]) * vec.angle2x(turningMatrix[5], turningMatrix[6]) * ANGULAR_VELOCITY_CONVERSION_FACTOR;
        turnStopAngle = Math.max(angularVelocity * angularVelocity / (2 * angularAcceleration), TURN_THRESHOLD_ANGLE);
        if (pitch > turnStopAngle) {
            this._spacecraft.pitchUp(Math.min(Math.max(0, turnIntensityFactor * (pitch - turnStopAngle)), 1));
        } else if (pitch < -turnStopAngle) {
            this._spacecraft.pitchDown(Math.min(Math.max(0, turnIntensityFactor * (-pitch - turnStopAngle)), 1));
        }
    };
    /**
     * Controls the spacecraft to turn (roll and yaw) in the desired direction specified by two angles.
     * @param {Number} roll The roll angle of the direction to turn towards
     * @param {Number} yaw The yaw angle of the direction to turn towards
     * @param {Number} dt The time passed since the last turn command in milliseconds - for an estimation of the time the set yaw and pitch 
     * angular velocity will be in effect, so that they can be limited to avoid overshooting the desired angles
     */
    SpacecraftAI.prototype.rollAndYaw = function (roll, yaw, dt) {
        var turningMatrix, angularVelocity, angularAcceleration, turnStopAngle, turnIntensityFactor;
        turningMatrix = this._spacecraft.getTurningMatrix();
        angularAcceleration = this._spacecraft.getMaxAngularAcceleration();
        // a turn intensity of 1 means to accelerate the angular velocity to TURN_ACCELERATION_DURATION_S * acceleration (in rad / sec) and
        // lower values represent a linear portion of this intended angular velocity
        // the base intensity factor converts dt to seconds and counts in TURN_ACCELERATION_DURATION_S
        // based on angle = angular velocity * time, we choose an angular velocity that will not overshoot the intended angle in the next dt
        // milliseconds (which will mean about the next simulation step with relatively stable framerates)
        turnIntensityFactor = _turnIntensityBaseFactor / (angularAcceleration * dt);
        // calculating how much will the spacecraft turn at the current angular velocity if it starts decelerating right now
        angularVelocity = Math.sign(turningMatrix[2]) * vec.angle2x(turningMatrix[0], turningMatrix[2]) * ANGULAR_VELOCITY_CONVERSION_FACTOR;
        turnStopAngle = Math.max(angularVelocity * angularVelocity / (2 * angularAcceleration), TURN_THRESHOLD_ANGLE);
        if (roll > turnStopAngle) {
            this._spacecraft.rollLeft(Math.min(Math.max(0, turnIntensityFactor * (roll - turnStopAngle)), 1));
        } else if (roll < -turnStopAngle) {
            this._spacecraft.rollRight(Math.min(Math.max(0, turnIntensityFactor * (-roll - turnStopAngle)), 1));
        }
        angularVelocity = Math.sign(turningMatrix[4]) * vec.angle2y(turningMatrix[4], turningMatrix[5]) * ANGULAR_VELOCITY_CONVERSION_FACTOR;
        turnStopAngle = Math.max(angularVelocity * angularVelocity / (2 * angularAcceleration), TURN_THRESHOLD_ANGLE);
        if (yaw > turnStopAngle) {
            this._spacecraft.yawLeft(Math.min(Math.max(0, turnIntensityFactor * (yaw - turnStopAngle)), 1));
        } else if (yaw < -turnStopAngle) {
            this._spacecraft.yawRight(Math.min(Math.max(0, turnIntensityFactor * (-yaw - turnStopAngle)), 1));
        }
    };
    /**
     * Controls the spacecraft to turn (roll and pitch) in the desired direction specified by two angles.
     * @param {Number} roll The roll angle of the direction to turn towards
     * @param {Number} pitch The pitch angle of the direction to turn towards
     * @param {Number} dt The time passed since the last turn command in milliseconds - for an estimation of the time the set yaw and pitch 
     * angular velocity will be in effect, so that they can be limited to avoid overshooting the desired angles
     */
    SpacecraftAI.prototype.rollAndPitch = function (roll, pitch, dt) {
        var turningMatrix, angularVelocity, angularAcceleration, turnStopAngle, turnIntensityFactor;
        turningMatrix = this._spacecraft.getTurningMatrix();
        angularAcceleration = this._spacecraft.getMaxAngularAcceleration();
        turnIntensityFactor = _turnIntensityBaseFactor / (angularAcceleration * dt);
        angularVelocity = Math.sign(turningMatrix[2]) * vec.angle2x(turningMatrix[0], turningMatrix[2]) * ANGULAR_VELOCITY_CONVERSION_FACTOR;
        turnStopAngle = Math.max(angularVelocity * angularVelocity / (2 * angularAcceleration), TURN_THRESHOLD_ANGLE);
        if (roll > turnStopAngle) {
            this._spacecraft.rollLeft(Math.min(Math.max(0, turnIntensityFactor * (roll - turnStopAngle)), 1));
        } else if (roll < -turnStopAngle) {
            this._spacecraft.rollRight(Math.min(Math.max(0, turnIntensityFactor * (-roll - turnStopAngle)), 1));
        }
        angularVelocity = Math.sign(turningMatrix[6]) * vec.angle2x(turningMatrix[5], turningMatrix[6]) * ANGULAR_VELOCITY_CONVERSION_FACTOR;
        turnStopAngle = Math.max(angularVelocity * angularVelocity / (2 * angularAcceleration), TURN_THRESHOLD_ANGLE);
        if (pitch > turnStopAngle) {
            this._spacecraft.pitchUp(Math.min(Math.max(0, turnIntensityFactor * (pitch - turnStopAngle)), 1));
        } else if (pitch < -turnStopAngle) {
            this._spacecraft.pitchDown(Math.min(Math.max(0, turnIntensityFactor * (-pitch - turnStopAngle)), 1));
        }
    };
    /**
     * Can be used to set an appropriate forward / reverse speed for the controlled spacecraft so that its distance from a target it is
     * pointing towards is within a desired range.
     * @param {Number} currentDistance The distance from the target to approach (the spacecraft must be pointing towards this target, at least roughly)
     * @param {Number} maxDistance The upper limit of the desired distance from the target. If the spacecraft is farther, it will close in. (move forward)
     * @param {Number} minDistance The lower limit of the desired distance from the target. If the spacecraft is closer, it will back off. (move backward)
     * @param {Number} maxSpeed The maximum forward/reverse speed to use when closing in / backing off.
     */
    SpacecraftAI.prototype.approach = function (currentDistance, maxDistance, minDistance, maxSpeed) {
        var speed, stopDistance;
        speed = this._spacecraft.getRelativeVelocityMatrix()[13];
        // calculate the distance the spacecraft will travel if we reset the speed to zero right away so that we can start slowing down in time
        stopDistance = speed * speed / (2 * this._spacecraft.getMaxAcceleration());
        if (speed < 0) {
            stopDistance = -stopDistance;
        }
        if (currentDistance - stopDistance > maxDistance) {
            this._spacecraft.setSpeedTarget(maxSpeed);
        } else if ((minDistance >= 0) && (currentDistance - stopDistance < minDistance)) {
            this._spacecraft.setSpeedTarget(-maxSpeed);
        } else {
            this._spacecraft.resetSpeed();
        }
    };
    /**
     * Updates the AI state in case a new target has been selected by the spacecraft.
     */
    SpacecraftAI.prototype._handleTargetSwitch = function () {
        this._hitCountByNonTarget = 0;
    };
    /**
     * Returns whether the passed spacecraft should be kept in the target list
     * @param {Spacecraft} spacecraft
     * @returns {Boolean}
     */
    SpacecraftAI._targetListFilterFunction = function (spacecraft) {
        return spacecraft.isAlive();
    };
    /**
     * Sets the appropriate target for the controlled spacecraft based on the current internal state of the AI
     * @param {Spacecraft} [newTarget] When given, this target will be set if the current state allows it (e.g. not
     * standing down, no higher priority current target set)
     */
    SpacecraftAI.prototype._updateTarget = function (newTarget) {
        var i, oldTarget;
        // not engaging any targets while standing down
        if (this._standingDown) {
            this._spacecraft.setTarget(null);
            return;
        }
        oldTarget = this._spacecraft.getTarget();
        // remove destroyed spacecrafts from target list
        if (this._targetList) {
            this._targetList = this._targetList.filter(SpacecraftAI._targetListFilterFunction);
        }
        // if there is a target list set...
        if (this._targetList && (this._targetList.length > 0)) {
            // if the targets are priority...
            if (this._priorityTargets) {
                //only allow switching to new targets within the list
                if (newTarget) {
                    if (this._targetList.indexOf(newTarget) >= 0) {
                        this._spacecraft.setTarget(newTarget);
                    }
                } else {
                    // find new targets from within the list first, and also try to find a new target, if the current
                    // one is not from the list (for example switch when a priority target jumps in)
                    if (!oldTarget || (this._targetList.indexOf(oldTarget) < 0)) {
                        for (i = 0; i < this._targetList.length; i++) {
                            if (!this._targetList[i].isAway()) {
                                this._spacecraft.setTarget(this._targetList[i]);
                                break;
                            }
                        }
                        if (!oldTarget && (i >= this._targetList.length)) {
                            this._spacecraft.targetNextBestHostile();
                        }
                    }
                }
            } else {
                // for non-priority targets, allow switching to any new target (for example when provoked)
                if (newTarget) {
                    this._spacecraft.setTarget(newTarget);
                } else if (!oldTarget) {
                    // find a new target from the list, if possible, and any hostile, if not
                    for (i = 0; i < this._targetList.length; i++) {
                        if (!this._targetList[i].isAway()) {
                            this._spacecraft.setTarget(this._targetList[i]);
                            break;
                        }
                    }
                    if (i >= this._targetList.length) {
                        this._spacecraft.targetNextBestHostile();
                    }
                }
            }
        } else {
            // if there is no specific target list, switch to the new target, if specified, otherwise just find
            // a new target if the current one has been destroyed
            if (newTarget) {
                this._spacecraft.setTarget(newTarget);
            } else if (!oldTarget) {
                this._spacecraft.targetNextBestHostile();
            }
        }
        // call the appropriate handler if the target changed
        if (this._spacecraft.getTarget() !== oldTarget) {
            this._handleTargetSwitch();
        }
    };
    /**
     * Updates the AI state for when the spacecraft has been hit.
     * @param {SpacecraftEvents~BeingHitData} data 
     */
    SpacecraftAI.prototype._handleBeingHit = function (data) {
        var spacecraft = data.spacecraft;
        // if being hit by a (still alive and present) hostile ship while having different target
        if (
                this._spacecraft && !this._spacecraft.canBeReused() &&
                !spacecraft.canBeReused() && !spacecraft.isAway() && spacecraft.isHostile(this._spacecraft) &&
                this._spacecraft.getTarget() && (this._spacecraft.getTarget() !== spacecraft)) {
            // switch target in case the current target is not targeting us anyway or is out of range
            if ((this._spacecraft.getTarget().getTarget() !== this._spacecraft) || !this._attackingTarget) {
                this._updateTarget(spacecraft);
            }
            this._hitCountByNonTarget++;
        }
    };
    /**
     * Executes the command that the spacecraft received
     * @param {SpacecraftEvents~CommandData} data
     */
    SpacecraftAI.prototype._handleCommand = function (data) {
        var
                /**@type Number*/ i,
                /**@type String*/ way,
                /**@type Spacecraft*/ anchor, target;
        switch (data.command) {
            case SpacecraftCommand.JUMP:
                // handling jump command
                // determining jump direction (inward / outward)
                if (data.jump && data.jump.way) {
                    way = data.jump.way;
                } else {
                    way = this._spacecraft.isAway() ? JumpCommandWay.IN : JumpCommandWay.OUT;
                }
                if (way === JumpCommandWay.IN) {
                    if (this._spacecraft.isAway()) {
                        // processing parameters for inward jumps
                        if (data.jump) {
                            if (data.lead && (data.index > 0) && (data.jump.formation)) {
                                // setting position and orientation based on a formation
                                this._spacecraft.setPhysicalPosition(spacecraft.Spacecraft.getPositionInFormation(data.jump.formation, data.index, data.lead.getPhysicalPositionVector(), data.lead.getPhysicalOrientationMatrix()));
                                this._spacecraft.setPhysicalOrientationMatrix(mat.matrix4(data.lead.getPhysicalOrientationMatrix()));
                            } else if (data.jump.anchor) {
                                // clear cached reference to the anchor spacecraft for every new execution of the command
                                if (data.clearCache) {
                                    data.jump.anchorSpacecraft = null;
                                    data.clearCache = false;
                                }
                                // setting position and orientation based on an anchor ship
                                anchor = data.jump.anchorSpacecraft || this._mission.getSpacecraft(data.jump.anchor);
                                if (anchor) {
                                    data.jump.anchorSpacecraft = anchor;
                                    // setting random position with matching orientation at given distance
                                    if (data.jump.distance) {
                                        this._spacecraft.setPhysicalOrientationMatrix(mat.prod3x3SubOf4(
                                                mat.rotationX4Aux((_jumpInPositionSeed() - 0.5) * Math.PI),
                                                mat.rotationZ4Aux(_jumpInPositionSeed() * utils.DOUBLE_PI)));
                                        this._spacecraft.setPhysicalPosition(vec.scaled3(
                                                mat.getRowB4(this._spacecraft.getPhysicalOrientationMatrix()),
                                                -data.jump.distance));
                                    } else {
                                        // overwriting position
                                        if (data.jump.position) {
                                            this._spacecraft.setPhysicalPosition(data.jump.position);
                                        }
                                        // overwriting orientation
                                        if (data.jump.rotations) {
                                            this._spacecraft.setPhysicalOrientationMatrix(mat.rotation4FromJSON(data.jump.rotations));
                                        }
                                    }
                                    // transforming to anchor-relative position and orientation
                                    if (data.jump.relative) {
                                        this._spacecraft.setPhysicalPositionMatrix(mat.prodTranslationRotation4(
                                                this._spacecraft.getPhysicalPositionMatrix(),
                                                anchor.getPhysicalOrientationMatrix()));
                                        this._spacecraft.setPhysicalOrientationMatrix(mat.prod4(
                                                this._spacecraft.getPhysicalOrientationMatrix(),
                                                anchor.getPhysicalOrientationMatrix()));
                                    }
                                    // adding position of the anchor ship
                                    this._spacecraft.setPhysicalPosition(vec.sum3(
                                            this._spacecraft.getPhysicalPositionVector(),
                                            anchor.getPhysicalPositionVector()));
                                } else if (data.jump.fallbackPosition) {
                                    // fallback to a specified position if the anchor spacecraft has been destroyed (will not be deterministic, depends on camera location)
                                    this._spacecraft.setPhysicalPosition(data.jump.fallbackPosition);
                                    if (data.jump.fallbackRotations) {
                                        this._spacecraft.setPhysicalOrientationMatrix(mat.rotation4FromJSON(data.jump.fallbackRotations));
                                    }
                                } else {
                                    application.log_DEBUG("Warning: '" + this._spacecraft.getDisplayName() + "' has an invalid anchor for inward jump: '" + data.jump.anchor + "' and no fallback specified. Jump will be skipped. Might be because the anchor is already destroyed.");
                                    break;
                                }
                            }
                        }
                        this._spacecraft.jumpIn();
                    }
                } else {
                    this._spacecraft.jumpOut(false);
                }
                break;
            case SpacecraftCommand.TARGET:
                // handling target command
                if (data.target) {
                    // clear cached reference to the target spacecrafts for every new execution of the command
                    if (data.clearCache) {
                        data.target.targetSpacecrafts = null;
                        data.clearCache = false;
                    }
                    // if the target spacecrafts have already been queried, just copy the list
                    if (data.target.targetSpacecrafts) {
                        this._targetList = data.target.targetSpacecrafts.slice();
                    } else {
                        // otherwise query them, create and save the list now:
                        if (data.target.single) {
                            // selecting a single target
                            target = this._mission.getSpacecraft(data.target.single);
                            if (target) {
                                this._targetList = [target];
                            } else {
                                application.log_DEBUG("Warning: '" + this._spacecraft.getDisplayName() + "' has an invalid target specified: '" + data.target.single + "'. Might be because the ship is already destroyed.");
                            }
                        } else if (data.target.list) {
                            // selecting a target list
                            this._targetList = [];
                            for (i = 0; i < data.target.list.length; i++) {
                                target = this._mission.getSpacecraft(data.target.list[i]);
                                if (target) {
                                    this._targetList.push(target);
                                } else {
                                    application.log_DEBUG("Warning: '" + this._spacecraft.getDisplayName() + "' has an invalid target specified: '" + data.target.list[i] + "'. Might be because the ship is already destroyed.");
                                }
                            }
                        } else if (data.target.squads) {
                            // selecting a list of squads as target
                            this._targetList = [];
                            for (i = 0; i < data.target.squads.length; i++) {
                                this._targetList = this._targetList.concat(this._mission.getSpacecraftsInSquad(data.target.squads[i]));
                            }
                        } else if (data.target.none) {
                            this._targetList = null;
                        } else {
                            application.showError("'" + this._spacecraft.getDisplayName() + "' has no target specified for targeting command!");
                        }
                        // save the target list for further spacecrafts executing the same command
                        if (this._targetList) {
                            data.target.targetSpacecrafts = this._targetList.slice();
                        }
                    }
                    if (this._targetList && (this._targetList.length > 0)) {
                        this._spacecraft.setTarget(this._targetList[0]);
                        this._standingDown = false;
                    } else if (data.target.none) {
                        this._spacecraft.setTarget(null);
                    }
                    this._priorityTargets = (data.target.priority === true);
                }
                break;
            case SpacecraftCommand.STAND_DOWN:
                // handling stand down command
                this._standingDown = true;
                break;
            default:
                application.showError("Unknown spacecraft command: '" + data.command + "'!");
        }
    };
    // ##############################################################################
    /**
     * @class
     * @extends SpacecraftAI
     * An AI that is suitable to control a fighter - that is a spacecraft with the assumptions that it is small, maneuverable and has its
     * guns pointing forward, requiring it to face its target when firing.
     * @param {Spacecraft} fighter The fighter to control
     * @param {Mission} mission The mission within which this AI will control the fighter
     */
    function FighterAI(fighter, mission) {
        var reactionTimeFactor = ((mission.getPilotedSpacecraft() && mission.getPilotedSpacecraft().isHostile(fighter)) ? mission.getDifficultyLevel().getEnemyReactionTimeFactor() : 1);
        SpacecraftAI.call(this, fighter, mission);
        /**
         * The time elapsed since finishing the last roll movement while firing (reset when not firing or when a new attack run starts), in 
         * milliseconds.
         * @type Number
         */
        this._timeSinceLastRoll = 0;
        /**
         * The time elapsed since last hitting the current target while firing (reset when not facing the target or when a new attack run 
         * starts), in milliseconds.
         * @type Number
         */
        this._timeSinceLastTargetHit = 0;
        /**
         * The time elapsed since last closing in (decreasing the approach distance by one decrement) while firing (reset when not facing 
         * the target or when a new attack run starts), in milliseconds.
         * @type Number
         */
        this._timeSinceLastClosingIn = 0;
        /**
         * The amount of time left before starting an evasive maneuver, in milliseconds.
         * @type Number
         */
        this._evasiveManeuverDelayLeft = 0;
        /**
         * The amount of time to wait before starting evasive maneuvers, in milliseconds.
         * @type Number
         */
        this._evasiveManeuverDelay = EVASIVE_MANEUVER_DELAY * reactionTimeFactor;
        /**
         * The time elapsed since the current evasive maneuver started, in milliseconds, or -1 if there is no evasive maneuver in progress.
         * @type Number
         */
        this._evasiveManeuverTime = -1;
        /**
         * The 2D vector describing the strafing velocity (horizontal and vertical) with which the current evasive maneuver should be 
         * carried out.
         * @type Number
         */
        this._evasiveVelocityVector = [0, 0];
        /**
         * The time elapsed since the start of the current roll maneuver in milliseconds, or -1 if the fighter is not rolling currently.
         * @type Number
         */
        this._rollTime = -1;
        /**
         * The current phase of the charge maneuver the fighter is performing. (enum ChargePhase)
         * @type Number
         */
        this._chargePhase = ChargePhase.NONE;
        /**
         * The 3D vector describing the world-space position of the destination point where the fighter should head to during the evade 
         * phase of the charge maneuver. (in meters)
         * @type Number
         */
        this._chargeDestination = [0, 0, 0];
        /**
         * When peforming a normal (not charge) attack, the fighter will approach its target to be at a maximum distance which equals the
         * range of its weapons multiplied by this factor. This starts out at a base value and is decreased gradually if the fighter 
         * cannot hit its target at the current distance.
         * @type Number
         */
        this._maxDistanceFactor = BASE_MAX_DISTANCE_FACTOR;
        /**
         * If the firing path of the fighter is blocked by another spacecraft, a reference of that spacecraft is stored in this variable
         * so that a detailed check about whether the blocking still persists can be performed for this specific craft (but doesn't need
         * to be performed for other spacecrafts). It is null if the firing path isn't blocked.
         * @type Spacecraft|null
         */
        this._isBlockedBy = null;
        /**
         * Cached value of whether the controlled spacecraft is currently facing its target.
         * @type Boolean
         */
        this._facingTarget = false;
        /**
         * Cached value of the distance to the current target of the controled spacecraft.
         * @type Boolean
         */
        this._targetDistance = 0;
        /**
         * When aiming at the target, this regularly (but not continuously) updated offset vector is used to compensate for (approximate) 
         * its movement
         * @type Array
         */
        this._targetOffset = [0, 0, 0];
        /**
         * Countdown timer for when to update the stored target offset vector. In milliseconds.
         * @type Number
         */
        this._targetOffsetUpdateTimeLeft = 0;
        /**
         * The current maximum to use when calculating the next aiming error.
         * @type Number
         */
        this._maxAimError = 0;
        /**
         * The current aiming error by which the aim angles are offset. (yaw, pitch)
         * @type Array
         */
        this._aimError = [0, 0];
        /**
         * The amount of time left before starting to fire, in milliseconds.
         * @type Number
         */
        this._fireDelayLeft = 0;
        /**
         * The amount of time to wait before starting to fire after aiming, in milliseconds.
         * @type Number
         */
        this._fireDelay = FIRE_DELAY * reactionTimeFactor;
        /**
         * The list of missiles that we fired at the current target (to avoid overkill by launching too many)
         * @type Missile[]
         */
        this._missilesOnTarget = [];
        // attaching handlers to the various spacecraft events
        this._spacecraft.addEventHandler(SpacecraftEvents.TARGET_HIT, this._handleTargetHit.bind(this));
        this._spacecraft.addEventHandler(SpacecraftEvents.ANY_SPACECRAFT_HIT, this._handleAnySpacecraftHit.bind(this));
        this._spacecraft.addEventHandler(SpacecraftEvents.TARGET_FIRED, this._handleTargetFired.bind(this));
    }
    FighterAI.prototype = new SpacecraftAI();
    FighterAI.prototype.constructor = FighterAI;
    /**
     * Calculates a new random aiming error based on the current maximum.
     */
    FighterAI.prototype._updateAimError = function () {
        this._aimError[0] = (Math.random() - 0.5) * 2 * this._maxAimError;
        this._aimError[1] = (Math.random() - 0.5) * 2 * this._maxAimError;
    };
    /**
     * Sets up the state of the AI to perform a new attack run, to be used when switching to a new target or after a charge maneuver has 
     * been finished. The approach distance, attack path blocking state and triggers for charge, close-in, roll are reset. Does not cancel
     * in progress evasive maneuvers.
     */
    FighterAI.prototype._startNewAttackRun = function () {
        this._chargePhase = ChargePhase.NONE;
        this._spacecraft.changeFlightMode(equipment.FlightMode.COMBAT);
        this._hitCountByNonTarget = 0;
        this._timeSinceLastTargetHit = 0;
        this._timeSinceLastClosingIn = 0;
        this._timeSinceLastRoll = 0;
        this._maxDistanceFactor = BASE_MAX_DISTANCE_FACTOR;
        this._isBlockedBy = null;
        this._rollTime = -1;
        this._targetOffset = [0, 0, 0];
        this._targetOffsetUpdateTimeLeft = TARGET_OFFSET_UPDATE_INTERVAL;
        this._maxAimError = MAX_AIM_ERROR;
        this._fireDelayLeft = this._fireDelay;
        this._updateAimError();
    };
    /**
     * @override
     */
    FighterAI.prototype._handleTargetSwitch = function () {
        SpacecraftAI.prototype._handleTargetSwitch.call(this);
        this._missilesOnTarget.length = 0;
        this._startNewAttackRun();
    };
    /**
     * If there is no evasive maneuver in progress, triggers a new one, which will start after the evasive maneuver delay (reaction time)
     * @returns {Boolean} Whether a new evasive maneuver has been triggered
     */
    FighterAI.prototype._triggerEvasiveManeuver = function () {
        if (this._evasiveManeuverTime < 0) {
            this._evasiveManeuverDelayLeft = this._evasiveManeuverDelay;
            this._evasiveManeuverTime = 0;
            return true;
        }
        return false;
    };
    /**
     * @override
     * @param {SpacecraftEvents~BeingHitData} data 
     */
    FighterAI.prototype._handleBeingHit = function (data) {
        // initiating a new evasive maneuver in case one is not already in progress
        // if the attack path is blocked by a spacecraft, then we are already strafing, so no evasive maneuver is started
        if (!this._isBlockedBy) {
            if (this._triggerEvasiveManeuver()) {
                // marking the direction opposite to the hit position so an appropriate evasive vector can be calculated
                this._evasiveVelocityVector[0] = -data.hitPosition[0];
                this._evasiveVelocityVector[1] = -data.hitPosition[2];
                vec.normalize2(this._evasiveVelocityVector);
            }
        }
        SpacecraftAI.prototype._handleBeingHit.call(this, data);
    };
    /**
     * Updates the AI state for when the controlled fighter has successfully hit its current target.
     */
    FighterAI.prototype._handleTargetHit = function () {
        this._timeSinceLastTargetHit = 0;
    };
    /**
     * Updates the AI state for when the controlled fighter has hit any spacecraft (including itself and its current target)
     * @param {SpacecraftEvents~AnySpacecraftHitData} data
     */
    FighterAI.prototype._handleAnySpacecraftHit = function (data) {
        var spacecraft = data.spacecraft;
        // if a spacecraft other than the controlled one or the current target is hit while performing either a normal or charge attack
        // (but not evading) we mark the hit spacecraft as blocking the firing path, triggering blocker avoidance strafing maneuvers
        // if a blocking spacecraft is already mark, we overwrite it only if it is hostile, as the new one might be friendly, which means
        // we should not continue firing until the path is clear again
        if (this._spacecraft && !this._spacecraft.canBeReused() && (spacecraft !== this._spacecraft) && (this._chargePhase !== ChargePhase.EVADE) && (spacecraft !== this._spacecraft.getTarget()) && (!this._isBlockedBy || (this._isBlockedBy.isHostile(this._spacecraft)))) {
            this._isBlockedBy = spacecraft;
            // block avoidance controls strafing just like evasive maneuvers, therefore both cannot be active at the same time
            this._evasiveManeuverTime = -1;
            // charge attacks are canceled so we do not run into the blocking spacecraft
            this._chargePhase = ChargePhase.NONE;
            this._spacecraft.changeFlightMode(equipment.FlightMode.COMBAT);
        }
    };
    /**
     * Updates the AI state for when the current target of the controlled spacecraft fires.
     */
    FighterAI.prototype._handleTargetFired = function () {
        var angle;
        // if we see the current target firing at us, start a random evasive maneuver
        if (!this._isBlockedBy &&
                this._facingTarget && this._spacecraft && this._spacecraft.getTarget() && (this._spacecraft.getTarget().getTarget() === this._spacecraft) &&
                (this._targetDistance > this._weaponRange * MIN_EVADE_DISTANCE_FACTOR)) {
            if (this._triggerEvasiveManeuver()) {
                angle = Math.random() * utils.DOUBLE_PI;
                this._evasiveVelocityVector[0] = 1;
                this._evasiveVelocityVector[1] = 0;
                vec.rotate2(this._evasiveVelocityVector, angle);
            }
        }
    };
    /**
     * Updates the AI state for the case when the battle scene with all objects has been moved by a vector, updating stored world-space
     * positions.
     * @param {Number[3]} vector
     */
    FighterAI.prototype.handleSceneMoved = function (vector) {
        vec.add3(this._chargeDestination, vector);
    };
    /**
     * Performs all spacecraft controlling actions (turning, rolling, targeting, firing, strafing, setting speed etc) based on the current
     * state of the AI and updates the state accordingly. Should be called once in every battle simulation step.
     * @param {Number} dt The time elapsed since the last control step, in milliseconds.
     */
    FighterAI.prototype.control = function (dt) {
        var
                /** @type Spacecraft */
                target,
                /** @type Missile */
                missile,
                /** @type Number[3] */
                positionVector, targetPositionVector, vectorToTarget, newOffset,
                directionToTarget, relativeTargetDirection, relativeBlockerPosition,
                /** @type Number */
                i,
                targetHitTime, hitpoints,
                ownSize, targetSize,
                fireThresholdAngle,
                acceleration, minDistance, maxDistance, speed, blockAvoidanceSpeed, baseDistance,
                weaponCooldown,
                rollDuration, rollWaitTime,
                angularAcceleration, maxAngularVelocity,
                worldProjectileVelocity,
                closeInTriggerTime,
                /** @type Object */
                targetYawAndPitch,
                /** @type Boolean */
                stillBlocked, strafingHandled,
                /** @type Array */
                weapons,
                /** @type Float32Array */
                inverseOrientationMatrix;
        // only perform anything if the controlled spacecraft still exists
        if (this._spacecraft) {
            // if the controlled spacecraft has been destroyed, remove the reference
            if (this._spacecraft.canBeReused()) {
                this._spacecraft = null;
                return;
            }
            // if the spacecraft is not on the battlefield, don't do anything
            if (this._spacecraft.isAway()) {
                return;
            }
            // .................................................................................................
            // state setup
            strafingHandled = false;
            // .................................................................................................
            // targeting
            this._updateTarget();
            // .................................................................................................
            // caching / referencing commonly needed variables
            acceleration = this._spacecraft.getMaxAcceleration();
            ownSize = this._spacecraft.getVisualModel().getScaledSize();
            // caching / referencing needed variables
            positionVector = mat.translationVector3(this._spacecraft.getPhysicalPositionMatrix());
            inverseOrientationMatrix = mat.inverseOfRotation4Aux(this._spacecraft.getPhysicalOrientationMatrix());
            speed = this._spacecraft.getRelativeVelocityMatrix()[13];
            target = this._spacecraft.getTarget();
            this._attackingTarget = false;
            // updating missile on target array
            for (i = 0; i < this._missilesOnTarget.length; i++) {
                if (this._missilesOnTarget[i].getTarget() !== target) {
                    this._missilesOnTarget.splice(i, 1);
                    i--;
                }
            }
            // .................................................................................................
            // evade phase of charge maneuver
            if (this._chargePhase === ChargePhase.EVADE) {
                this._attackingTarget = !!target;
                vectorToTarget = vec.diff3(this._chargeDestination, positionVector);
                relativeTargetDirection = vec.prodVec3Mat4Aux(
                        vectorToTarget,
                        inverseOrientationMatrix);
                this._targetDistance = vec.extractLength3(relativeTargetDirection);
                targetYawAndPitch = vec.getYawAndPitch(relativeTargetDirection);
                this.turn(targetYawAndPitch.yaw, targetYawAndPitch.pitch, dt);
                this._spacecraft.setSpeedTarget(acceleration * CHARGE_EVADE_SPEED_FACTOR);
                if ((this._targetDistance <= EXACT_PLACE_RANGE) || (relativeTargetDirection[1] < 0) || (speed < 0)) {
                    this._startNewAttackRun();
                }
                // .................................................................................................
                // attacking current target
            } else if (target) {
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // setting up variables
                targetPositionVector = mat.translationVector3(target.getPhysicalPositionMatrix());
                // updating target offset and aim error, if it is time
                if (this._targetOffsetUpdateTimeLeft <= 0) {
                    this._targetOffsetUpdateTimeLeft = TARGET_OFFSET_UPDATE_INTERVAL;
                    newOffset = vec.diff3(this._spacecraft.getTargetHitPosition(), targetPositionVector);
                    if (vec.length3Squared(vec.diff3(this._targetOffset, newOffset)) < AIM_ERROR_REDUCTION_THRESHOLD) {
                        this._maxAimError *= AIM_ERROR_REDUCTION_FACTOR;
                    } else {
                        this._maxAimError = MAX_AIM_ERROR;
                    }
                    this._targetOffset = newOffset;
                    this._updateAimError();
                } else {
                    this._targetOffsetUpdateTimeLeft -= dt;
                }
                vec.add3(targetPositionVector, this._targetOffset);
                vectorToTarget = vec.diff3(targetPositionVector, positionVector);
                relativeTargetDirection = vec.prodVec3Mat4Aux(
                        vectorToTarget,
                        inverseOrientationMatrix);
                this._targetDistance = vec.extractLength3(relativeTargetDirection);
                targetYawAndPitch = vec.getYawAndPitch(relativeTargetDirection);
                targetYawAndPitch.yaw += this._aimError[0];
                targetYawAndPitch.pitch += this._aimError[1];
                this._facingTarget = (Math.abs(targetYawAndPitch.yaw) < TARGET_FACING_ANGLE_THRESHOLD) && (Math.abs(targetYawAndPitch.pitch) < TARGET_FACING_ANGLE_THRESHOLD);
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // turning towards target
                this.turn(targetYawAndPitch.yaw, targetYawAndPitch.pitch, dt);
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // handling if another spacecraft blocks the attack path
                if (this._isBlockedBy) {
                    stillBlocked = false;
                    if (!this._isBlockedBy.canBeReused() && this._facingTarget) {
                        // checking if the blocking spacecraft is still in the way
                        if (this._isBlockedBy.getPhysicalModel().checkHit(targetPositionVector, vectorToTarget, 1000, ownSize / 2)) {
                            relativeBlockerPosition = vec.prodVec3Mat4Aux(
                                    vec.diff3Aux(
                                            mat.translationVector3(this._isBlockedBy.getPhysicalPositionMatrix()),
                                            positionVector),
                                    inverseOrientationMatrix);
                            blockAvoidanceSpeed = acceleration * BLOCK_AVOIDANCE_SPEED_FACTOR;
                            if (relativeBlockerPosition[0] < 0) {
                                this._spacecraft.strafeRight(blockAvoidanceSpeed);
                                stillBlocked = true;
                            } else {
                                this._spacecraft.strafeLeft(blockAvoidanceSpeed);
                                stillBlocked = true;
                            }
                            if (relativeBlockerPosition[2] > 0) {
                                this._spacecraft.lower(blockAvoidanceSpeed);
                                stillBlocked = true;
                            } else {
                                this._spacecraft.raise(blockAvoidanceSpeed);
                                stillBlocked = true;
                            }
                        }
                    }
                    if (!stillBlocked) {
                        this._isBlockedBy = null;
                        this._spacecraft.stopLeftStrafe();
                        this._spacecraft.stopRightStrafe();
                        this._spacecraft.stopLower();
                        this._spacecraft.stopRaise();
                    }
                    strafingHandled = true;
                }
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // actions based on weapons
                weapons = this._spacecraft.getWeapons();
                if (weapons && weapons.length > 0) {
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // firing
                    targetSize = target.getVisualModel().getScaledSize();
                    fireThresholdAngle = Math.atan(FIRE_THRESHOLD_ANGLE_FACTOR * targetSize / this._targetDistance);
                    worldProjectileVelocity = weapons[0].getProjectileVelocity() + speed;
                    targetHitTime = this._targetDistance / worldProjectileVelocity * 1000;
                    weaponCooldown = weapons[0].getCooldown();
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // aiming turnable weapons towards target
                    this._spacecraft.aimWeapons(TURN_THRESHOLD_ANGLE, fireThresholdAngle, dt);
                    if (!this._facingTarget) {
                        this._timeSinceLastClosingIn = 0;
                        this._timeSinceLastTargetHit = 0;
                        this._hitCountByNonTarget = 0;
                    }
                    if (vec.length3(vec.diff3Aux(this._spacecraft.getTargetHitPosition(), positionVector)) <= weapons[0].getRange(speed)) {
                        // within range...
                        this._attackingTarget = true;
                        if ((Math.abs(targetYawAndPitch.yaw) < fireThresholdAngle) &&
                                (Math.abs(targetYawAndPitch.pitch) < fireThresholdAngle) &&
                                (!this._isBlockedBy || this._isBlockedBy.isHostile(this._spacecraft))) {
                            // finished aiming...
                            if (this._fireDelayLeft > 0) {
                                this._fireDelayLeft -= dt;
                            } else {
                                this._spacecraft.fire();
                                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                // if we are not hitting the target despite not being blocked and firing in the right direction, roll the spacecraft
                                if (!this._isBlockedBy) {
                                    this._timeSinceLastRoll += dt;
                                    this._timeSinceLastTargetHit += dt;
                                    this._timeSinceLastClosingIn += dt;
                                    // starting roll if needed
                                    rollWaitTime = targetHitTime + ROLL_CORRECTION_TRIGGERING_MISS_COUNT * weaponCooldown;
                                    if ((this._timeSinceLastRoll > rollWaitTime) && (this._timeSinceLastTargetHit > rollWaitTime)) {
                                        this._rollTime = 0;
                                    }
                                    // performing coll
                                    if (this._rollTime >= 0) {
                                        this._spacecraft.rollLeft();
                                        this._timeSinceLastRoll = 0;
                                        this._rollTime += dt;
                                        // calculating the duration of rolling based on the angle we would like to roll (in seconds)
                                        angularAcceleration = this._spacecraft.getMaxAngularAcceleration();
                                        maxAngularVelocity = angularAcceleration * _turnAccelerationDuration;
                                        rollDuration = (ROLL_CORRECTION_ANGLE > maxAngularVelocity * _turnAccelerationDuration) ?
                                                _turnAccelerationDuration + (ROLL_CORRECTION_ANGLE - (maxAngularVelocity * _turnAccelerationDuration)) / maxAngularVelocity :
                                                Math.sqrt(4 * ROLL_CORRECTION_ANGLE / angularAcceleration) / 2;
                                        // stopping roll (converting to milliseconds)
                                        if (this._rollTime > rollDuration * 1000) {
                                            this._rollTime = -1;
                                        }
                                    }
                                }
                            }
                        } else {
                            this._timeSinceLastRoll = 0;
                            this._fireDelayLeft = this._fireDelay;
                        }
                    } else {
                        this._timeSinceLastRoll = 0;
                        this._fireDelayLeft = this._fireDelay;
                    }
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // launching missiles
                    if (this._spacecraft.getActiveMissileLauncher()) {
                        // do not launch anti-ship missiles against fighters or vice versa
                        if (this._spacecraft.getActiveMissileLauncher().getMissileClass().isAntiShip() === target.isFighter()) {
                            this._spacecraft.changeMissile();
                        } else {
                            // do not launch additional missiles if there are already enough of them on their way to destroy the target (launched by us)
                            hitpoints = target.getHitpoints() + target.getShieldCapacity();
                            for (i = 0; i < this._missilesOnTarget.length; i++) {
                                hitpoints -= this._missilesOnTarget[i].getClass().getDamage(0);
                            }
                            if (hitpoints > 0) {
                                missile = this._spacecraft.launchMissile();
                                if (missile) {
                                    this._missilesOnTarget.push(missile);
                                }
                            }
                        }
                    }
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // initiating charge
                    if ((this._chargePhase === ChargePhase.NONE) && ((this._hitCountByNonTarget >= CHARGE_TRIGGER_HIT_COUNT) || ((this._timeSinceLastTargetHit > targetHitTime + CHARGE_TRIGGER_MISS_COUNT * weaponCooldown)))) {
                        this._chargePhase = ChargePhase.APPROACH_ATTACK;
                        this._spacecraft.changeFlightMode(equipment.FlightMode.CRUISE);
                    }
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // managing distance from target based on weapons range
                    // normal (non-charging behaviour)
                    if (this._chargePhase === ChargePhase.NONE) {
                        // closing in the distance if we are unable to hit the target at the current range
                        closeInTriggerTime = targetHitTime + CLOSE_IN_TRIGGER_MISS_COUNT * weaponCooldown;
                        if ((this._timeSinceLastClosingIn > closeInTriggerTime) && (this._timeSinceLastTargetHit > closeInTriggerTime) && (this._maxDistanceFactor > CLOSE_MAX_DISTANCE_FACTOR)) {
                            this._maxDistanceFactor = Math.max(this._maxDistanceFactor - MAX_DISTANCE_FACTOR_DECREMENT, CLOSE_MAX_DISTANCE_FACTOR);
                            this._timeSinceLastClosingIn = 0;
                        }
                        baseDistance = 0.5 * (ownSize + targetSize);
                        maxDistance = baseDistance + this._maxDistanceFactor * this._weaponRange;
                        minDistance = baseDistance + MIN_DISTANCE_FACTOR * this._weaponRange;
                        if (!this._facingTarget) {
                            this._spacecraft.resetSpeed();
                        } else {
                            this.approach(this._targetDistance, maxDistance, minDistance, acceleration * APPROACH_SPEED_FACTOR);
                        }
                        // charge attack behaviour (closing in at higher speed, without slowing)
                    } else if (this._chargePhase === ChargePhase.APPROACH_ATTACK) {
                        // calculating the distance at which the spacecraft will be able to avoid collision at charge speed
                        maxDistance = Math.sqrt((targetSize + ownSize * 0.5) * 2 / acceleration) * acceleration * CHARGE_SPEED_FACTOR;
                        if (!this._facingTarget) {
                            this._chargePhase = ChargePhase.NONE;
                            this._spacecraft.changeFlightMode(equipment.FlightMode.COMBAT);
                            this._spacecraft.resetSpeed();
                        } else {
                            this._spacecraft.setSpeedTarget(acceleration * CHARGE_SPEED_FACTOR);
                            // when the critical distance is reached, mark a destination beyond the target to head towards it
                            if (this._targetDistance <= maxDistance) {
                                this._chargePhase = ChargePhase.EVADE;
                                this._spacecraft.changeFlightMode(equipment.FlightMode.COMBAT);
                                directionToTarget = vec.normal3(vectorToTarget);
                                this._chargeDestination = vec.sum3(
                                        positionVector,
                                        vec.scaled3(
                                                vec.diff3(
                                                        vec.sum3(
                                                                targetPositionVector,
                                                                vec.scaled3(vec.normalize3(vec.prodVec3Mat3Aux(vec.perpendicular3(directionToTarget), mat.rotation3Aux(directionToTarget, Math.random() * utils.DOUBLE_PI))), maxDistance)),
                                                        positionVector),
                                                CHARGE_EVADE_VECTOR_LENGTH_FACTOR));
                            }
                        }
                    }
                } else {
                    this._spacecraft.resetSpeed();
                }
            } else {
                this._facingTarget = false;
                this._targetDistance = 0;
                this._spacecraft.resetSpeed();
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // aiming turnable weapons towards default position
                this._spacecraft.aimWeapons(TURN_THRESHOLD_ANGLE, 0, dt);
            }
            if (!strafingHandled) {
                // .................................................................................................
                // performing evasive maneuver when hit
                if ((this._evasiveManeuverTime >= 0) && (this._evasiveManeuverDelayLeft <= 0)) {
                    // when initiating an evasive maneuver, the evasive velocity vector is a unit vector pointin in the opposite direction
                    // to where the spacecraft has been hit, so we scale it to the required speed and randomly rotate it -90 to +90 degrees
                    if (this._evasiveManeuverTime === 0) {
                        this._evasiveVelocityVector[0] *= acceleration * EVASIVE_MANEUVER_SPEED_FACTOR;
                        this._evasiveVelocityVector[1] *= acceleration * EVASIVE_MANEUVER_SPEED_FACTOR;
                        vec.rotate2(this._evasiveVelocityVector, (Math.random() - 0.5) * Math.PI);
                    }
                    // setting the appropriate strafing speeds
                    if (this._evasiveVelocityVector[0] > 0) {
                        this._spacecraft.strafeRight(this._evasiveVelocityVector[0]);
                    } else if (this._evasiveVelocityVector[0] < 0) {
                        this._spacecraft.strafeLeft(-this._evasiveVelocityVector[0]);
                    } else {
                        this._spacecraft.stopLeftStrafe();
                        this._spacecraft.stopRightStrafe();
                    }
                    if (this._evasiveVelocityVector[1] > 0) {
                        this._spacecraft.raise(this._evasiveVelocityVector[1]);
                    } else if (this._evasiveVelocityVector[1] < 0) {
                        this._spacecraft.lower(-this._evasiveVelocityVector[1]);
                    } else {
                        this._spacecraft.stopLower();
                        this._spacecraft.stopRaise();
                    }
                    this._evasiveManeuverTime += dt;
                    if (this._evasiveManeuverTime > EVASIVE_MANEUVER_DURATION) {
                        this._evasiveManeuverTime = -1;
                    }
                    // if no evasive maneuver is in progress and the firing path is not blocked, cancel all strafing
                } else {
                    if (this._evasiveManeuverDelayLeft > 0) {
                        this._evasiveManeuverDelayLeft -= dt;
                    }
                    this._spacecraft.stopLeftStrafe();
                    this._spacecraft.stopRightStrafe();
                    this._spacecraft.stopLower();
                    this._spacecraft.stopRaise();
                }
            }
        }
    };
    // ##############################################################################
    /**
     * @class
     * @extends SpacecraftAI
     * An AI that is suitable to control a ship - that is a spacecraft with the assumptions that it is larger, its weapons are rotatable,
     * it has an attack vector and threshold angle defined which determine the direction of the ship while attacking and it has a turning
     * style defined which governs how to orient itself to the proper direction.
     * @param {Spacecraft} ship the ship to control
     * @param {Mission} mission The mission within which this AI will control the ship
     */
    function ShipAI(ship, mission) {
        SpacecraftAI.call(this, ship, mission);
    }
    ShipAI.prototype = new SpacecraftAI();
    ShipAI.prototype.constructor = ShipAI;
    /**
     * Updates the AI state for the case when the battle scene with all objects has been moved by a vector, updating stored world-space
     * positions.
     */
    ShipAI.prototype.handleSceneMoved = function () {
        return;
    };
    /**
     * Performs all spacecraft controlling actions (turning, orienting, targeting, firing, setting speed etc) based on the current
     * state of the AI and updates the state accordingly. Should be called once in every battle simulation step.
     * @param {Number} dt The time elapsed since the last control step, in milliseconds.
     */
    ShipAI.prototype.control = function (dt) {
        var
                /** @type Spacecraft */
                target,
                /** @type Number[3] */
                positionVector, targetPositionVector, vectorToTarget,
                relativeTargetDirection,
                /** @type Number[2] */
                angles, angleDifference,
                /** @type Number */
                targetDistance,
                ownSize, targetSize, fireThresholdAngle,
                acceleration, maxDistance, baseDistance,
                thresholdAngle,
                /** @type Object */
                targetYawAndPitch, targetAngles,
                /** @type Boolean */
                facingTarget, hostileTarget,
                /** @type Array */
                weapons,
                /** @type Float32Array */
                inverseOrientationMatrix;
        // only perform anything if the controlled spacecraft still exists
        if (this._spacecraft) {
            // if the controlled spacecraft has been destroyed, remove the reference
            if (this._spacecraft.canBeReused()) {
                this._spacecraft = null;
                return;
            }
            // if the spacecraft is not on the battlefield, don't do anything
            if (this._spacecraft.isAway()) {
                return;
            }
            // .................................................................................................
            // targeting
            this._updateTarget();
            // .................................................................................................
            // caching / referencing commonly needed variables
            acceleration = this._spacecraft.getMaxAcceleration();
            ownSize = this._spacecraft.getVisualModel().getScaledSize();
            // caching / referencing needed variables
            positionVector = mat.translationVector3(this._spacecraft.getPhysicalPositionMatrix());
            inverseOrientationMatrix = mat.inverseOfRotation4Aux(this._spacecraft.getPhysicalOrientationMatrix());
            target = this._spacecraft.getTarget();
            this._attackingTarget = false;
            if (target) {
                hostileTarget = target.isHostile(this._spacecraft);
                targetPositionVector = mat.translationVector3(target.getPhysicalPositionMatrix());
                vectorToTarget = vec.diff3(targetPositionVector, positionVector);
                relativeTargetDirection = vec.prodVec3Mat4(
                        vectorToTarget,
                        inverseOrientationMatrix);
                targetDistance = vec.extractLength3(relativeTargetDirection);
                if (hostileTarget) {
                    targetYawAndPitch = vec.getYawAndPitch(relativeTargetDirection);
                    facingTarget = (Math.abs(targetYawAndPitch.yaw) < TARGET_FACING_ANGLE_THRESHOLD) && (Math.abs(targetYawAndPitch.pitch) < TARGET_FACING_ANGLE_THRESHOLD);
                }
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // actions based on weapons
                weapons = this._spacecraft.getWeapons();
                if (weapons && weapons.length > 0) {
                    targetSize = target.getVisualModel().getScaledSize();
                    fireThresholdAngle = Math.atan(FIRE_THRESHOLD_ANGLE_FACTOR * targetSize / targetDistance);
                    if (hostileTarget) {
                        baseDistance = 0.25 * ownSize;
                        maxDistance = baseDistance + SHIP_MAX_DISTANCE_FACTOR * this._weaponRange;
                    }
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // aiming turnable weapons towards target
                    this._spacecraft.aimWeapons(TURN_THRESHOLD_ANGLE, fireThresholdAngle, dt);
                    if (hostileTarget) {
                        if (!facingTarget) {
                            this._spacecraft.resetSpeed();
                        } else {
                            this.approach(targetDistance, maxDistance, 0, acceleration * APPROACH_SPEED_FACTOR);
                        }
                        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        // turning towards target
                        if (targetDistance > maxDistance) {
                            this.turn(targetYawAndPitch.yaw, targetYawAndPitch.pitch, dt);
                        } else {
                            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            // orienting into attack position
                            angles = this._spacecraft.getClass().getAttackVectorAngles();
                            thresholdAngle = this._spacecraft.getClass().getAttackThresholdAngle();
                            switch (this._spacecraft.getClass().getTurnStyle()) {
                                case classes.SpacecraftTurnStyle.YAW_PITCH:
                                    if ((Math.abs(targetYawAndPitch.yaw - angles[0]) > thresholdAngle) || (Math.abs(targetYawAndPitch.pitch - angles[1]) > thresholdAngle)) {
                                        this.turn(targetYawAndPitch.yaw - angles[0], targetYawAndPitch.pitch - angles[1], dt);
                                    }
                                    break;
                                case classes.SpacecraftTurnStyle.ROLL_YAW:
                                    targetAngles = vec.getRollAndYaw(relativeTargetDirection, true);
                                    angleDifference = [targetAngles.roll - angles[0], targetAngles.yaw - angles[1]];
                                    if ((Math.abs(angleDifference[0]) > thresholdAngle) || (Math.abs(angleDifference[1]) > thresholdAngle)) {
                                        if (Math.abs(angleDifference[1]) > utils.HALF_PI) {
                                            angleDifference[0] = 0;
                                        } else if (Math.abs(angleDifference[0]) > utils.HALF_PI) {
                                            angleDifference[1] = 0;
                                        }
                                        this.rollAndYaw(angleDifference[0], angleDifference[1], dt);
                                    }
                                    break;
                                case classes.SpacecraftTurnStyle.ROLL_PITCH:
                                    targetAngles = vec.getRollAndPitch(relativeTargetDirection, true);
                                    angleDifference = [targetAngles.roll - angles[0], targetAngles.pitch - angles[1]];
                                    if ((Math.abs(angleDifference[0]) > thresholdAngle) || (Math.abs(angleDifference[1]) > thresholdAngle)) {
                                        if (Math.abs(angleDifference[1]) > utils.HALF_PI) {
                                            angleDifference[0] = 0;
                                        } else if (Math.abs(angleDifference[0] - Math.sign(angleDifference[0]) * Math.PI) < Math.abs(angleDifference[0])) {
                                            angleDifference[0] -= Math.sign(angleDifference[0]) * Math.PI;
                                            targetAngles.pitch = -targetAngles.pitch;
                                        }
                                        this.rollAndPitch(angleDifference[0], targetAngles.pitch - angles[1], dt);
                                    }
                                    break;
                            }
                        }
                        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        // firing
                        if (vec.length3(vec.diff3(this._spacecraft.getTargetHitPosition(), positionVector)) - baseDistance <=
                                weapons[0].getRange(this._spacecraft.getRelativeVelocityMatrix()[13])) {
                            this._spacecraft.fire(true);
                            this._attackingTarget = true;
                        }
                    } else {
                        // friendly target
                        this._spacecraft.resetSpeed();
                    }
                }
            } else {
                // if there is no target...
                this._spacecraft.resetSpeed();
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // aiming turnable weapons towards default position
                this._spacecraft.aimWeapons(TURN_THRESHOLD_ANGLE, 0, dt);
            }
        }
    };
    // ##############################################################################
    /**
     * @class
     * Stores and manages a list of AIs that belong to the same battle simulation.
     */
    function AIContext() {
        /**
         * The list of managed AIs.
         * @type Array
         */
        this._ais = [];
    }
    /**
     * Removes all the stored AIs.
     */
    AIContext.prototype.clearAIs = function () {
        this._ais = [];
    };
    /**
     * Adds a new AI of the type associated with the passed type name and sets it up to control the passed spacecraft.
     * @param {String} aiTypeName
     * @param {Spacecraft} spacecraft
     * @param {Mission} mission 
     */
    AIContext.prototype.addAI = function (aiTypeName, spacecraft, mission) {
        this._ais.push(new _aiConstructors[aiTypeName](spacecraft, mission));
    };
    /**
     * Performs the control step for all the stored AIs.
     * @param {Number} dt the time elapsed since the last control step, in milliseconds.
     */
    AIContext.prototype.control = function (dt) {
        var i;
        for (i = 0; i < this._ais.length; i++) {
            this._ais[i].control(dt);
        }
    };
    /**
     * Updates the state of all the stored AIs for the case when the scene where the battle simulation happens (all the object in it) has 
     * been moved by the given vector.
     * @param {Number[3]} vector
     */
    AIContext.prototype.handleSceneMoved = function (vector) {
        var i;
        for (i = 0; i < this._ais.length; i++) {
            this._ais[i].handleSceneMoved(vector);
        }
    };
    // setting up the associative array of AI constructors
    _aiConstructors = {};
    _aiConstructors[FIGHTER_AI_NAME] = FighterAI;
    _aiConstructors[SHIP_AI_NAME] = ShipAI;
    // creating the default context
    _context = new AIContext(_aiConstructors);
    // caching frequently used configuration values
    config.executeWhenReady(function () {
        _turnAccelerationDuration = config.getSetting(config.BATTLE_SETTINGS.TURN_ACCELERATION_DURATION_S);
        _turnIntensityBaseFactor = 1000 / _turnAccelerationDuration;
        _jumpInPositionSeed = Math.seed(Math.random());
    });
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        FIGHTER_AI_NAME: FIGHTER_AI_NAME,
        SHIP_AI_NAME: SHIP_AI_NAME,
        SpacecraftCommand: SpacecraftCommand,
        JumpCommandWay: JumpCommandWay,
        getAITypes: getAITypes,
        clearAIs: _context.clearAIs.bind(_context),
        addAI: _context.addAI.bind(_context),
        control: _context.control.bind(_context),
        handleSceneMoved: _context.handleSceneMoved.bind(_context)
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Implementation of loading and managing missions - including the main game simulation loop
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, localStorage */

/**
 * @param utils Used for format strings and useful constants
 * @param types Used for type checking when loading from local storage
 * @param mat Matrices are widely used for 3D simulation
 * @param application Used for file loading and logging functionality
 * @param game Used to dispatch messages to BattleScreen
 * @param asyncResource LogicContext is a subclass of AsyncResource
 * @param resources Used to access the loaded media (graphics and sound) resources
 * @param resourceManager Used for storing the mission descriptors in a resource manager 
 * @param pools Used to access the pools for particles and projectiles
 * @param egomModel Used to create models (e.g. grid) for mission preview
 * @param physics Used to set up global drag based on mission environment
 * @param camera Used for creating camera configurations for views
 * @param renderableObjects Used for creating visual models for game objects
 * @param constants Used for Accessing global localStorage prefixes
 * @param graphics Used to access graphics settings
 * @param classes Used to load and access the classes of Interstellar Armada
 * @param config Used to access game settings/configuration
 * @param strings Used for translation support
 * @param logicConstants Used for accessing pool names
 * @param environments Used for creating environments
 * @param SpacecraftEvents Used to trigger spacecraft events
 * @param spacecraft Used for creating spacecrafts
 * @param equipment Used for accessing the common projectile pool
 * @param explosion Used for explosion pool management
 * @param ai Used for setting the artificial intelligence pilots when creating a mission.
 */
define('armada/logic/missions',[
    "utils/utils",
    "utils/types",
    "utils/matrices",
    "modules/application",
    "modules/game",
    "modules/async-resource",
    "modules/resource-manager",
    "modules/media-resources",
    "modules/pools",
    "modules/egom-model",
    "modules/physics",
    "modules/scene/camera",
    "modules/scene/renderable-objects",
    "armada/constants",
    "armada/graphics",
    "armada/logic/classes",
    "armada/configuration",
    "armada/strings",
    "armada/logic/constants",
    "armada/logic/environments",
    "armada/logic/SpacecraftEvents",
    "armada/logic/spacecraft",
    "armada/logic/equipment",
    "armada/logic/explosion",
    "armada/logic/ai",
    "utils/polyfill"
], function (
        utils, types, mat,
        application, game, asyncResource, resourceManager, resources, pools, egomModel, physics,
        camera, renderableObjects,
        constants, graphics, classes, config, strings,
        logicConstants, environments, SpacecraftEvents, spacecraft, equipment, explosion, ai) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // enums
            TriggerWhich = {
                /** All the conditions need to be true / false (see TriggerWhen) for the trigger to fire */
                ALL: "all",
                /** Any of the conditions being true / false (see TriggerWhen) causes the trigger to fire */
                ANY: "any"
            },
            TriggerWhen = {
                /** The trigger fires when all / any (see TriggerWhich) of its conditions become true */
                BECOMES_TRUE: "becomesTrue",
                /** The trigger fires when all / any (see TriggerWhich) of its conditions become false */
                BECOMES_FALSE: "becomesFalse"
            },
            ConditionType = {
                /** The condition is evaluated true when all of its subjects are destroyed */
                DESTROYED: "destroyed",
                /** The condition is evaluated true based on the count of still alive spacecrafts from its subjects */
                COUNT: "count",
                /** The condition is evaluated true based on the time elapsed since the start of the mission or the firing of a trigger */
                TIME: "time"
            },
            DestroyedConditionWhich = {
                /** All the subjects need to be destroyed for the condition to be fulfilled */
                ALL: "all",
                /** Any of the subjects can be destroyed for the condition to be fulfilled */
                ANY: "any"
            },
            CountConditionRelation = {
                /** The condition is satisfied when there are less subjects alive than the specified count */
                BELOW: "below",
                /** The condition is satisfied when there are more subjects alive than the specified count */
                ABOVE: "above",
                /** The condition is satisfied when there are exactly as many subjects alive as the specified count */
                EQUALS: "equals"
            },
            TimeConditionWhen = {
                /** The condition is satisfied from the beginning of the mission until the specified time has elapsed (after start) */
                BEFORE: "before",
                /** The condition is satisfied starting from when the specified time has elapsed (after start) */
                AFTER: "after",
                /** The condition is satisfied after start, within the specified time */
                WITHIN: "within",
                /** The condition is satisfied when exactly the specified time has elapsed (after start) */
                ONCE: "once",
                /** The condition is satisfied every time the specified time has been elapsed (after start), in a looping fashion */
                REPEAT: "repeat"
            },
            ActionType = {
                /** Executing this action queues a message to be displayed on the HUD */
                MESSAGE: "message",
                /** Executing this action clears the HUD message queue */
                CLEAR_MESSAGES: "clearMessages",
                /** Executing this action sends a command to the subject spacecrafts (to be processed by their AIs) */
                COMMAND: "command",
                /** Executing this action changes the state of the HUD on the piloted spacecraft (e.g. hide / show / highlight an element) */
                HUD: "hud",
                /** Executing this action marks the mission as complete */
                WIN: "win",
                /** Executing this action marks the mission as failed */
                LOSE: "lose"
            },
            MissionState = {
                // in progress states
                /** There is no player or no objectives for the player, and no ships hostile to each other (peaceful sandbox) */
                NONE: 0,
                /** There is no player or no objectives for the player, but there are hostiles battling each other (demo, battle sandbox) */
                BATTLE: 1,
                /** There are objectives left to complete (regular mission) */
                IN_PROGRESS: 2,
                // finished states
                /** All the objectives have been completed, the mission is a success */
                COMPLETED: 3,
                /** The player failed at least one objective, the mission is a failure */
                FAILED: 4,
                /** The player's spacecraft has been destroyed */
                DEFEAT: 5,
                /** A battle without a piloted spacecraft (player) has ended */
                ENDED: 6
            },
            /**
             * Objectives displayed on the HUD are colored based on this
             */
            ObjectiveState = {
                IN_PROGRESS: 0,
                COMPLETED: 1,
                FAILED: 2
            },
            // ------------------------------------------------------------------------------
            // constants
            /**
             * The ID for mission performance indicating that the mission failed. Performance level IDs for successful missions are defined
             * in config.json
             * @type String
             */
            FAILED_MISSION_PERFORMACE = "failed",
            /**
             * Mission related local storage IDs start with this prefix
             * @type String
             */
            MODULE_LOCAL_STORAGE_PREFIX = constants.LOCAL_STORAGE_PREFIX + "missions_",
            /**
             * The key identifying the location where the default difficulty setting is stored in local storage.
             * @type String
             */
            DIFFICULTY_LOCAL_STORAGE_ID = MODULE_LOCAL_STORAGE_PREFIX + "difficulty",
            /**
             * Used to choose the array of mission descriptors when loading the configuration of the mission resource manager
             * @type String
             */
            MISSION_ARRAY_NAME = "missions",
            /**
             * When adding ships without a team to a mission in demo mode, they will be automatically put into a team with
             * this faction, with an index that equals the index of the spacecraft added + 1 (converted to string).
             * @type String
             */
            NUMBERED_FACTION_NAME = "numbered",
            GRID_MODEL_NAME = "grid",
            MARKER_MODEL_NAME = "marker",
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * Cached value of the configuration setting for toggling hitbox visibility based on for which objects are hitchecks calculated.
             * @type Boolean
             */
            _showHitboxesForHitchecks,
            /**
             * Cached value of the configuration setting of the name of the uniform array storing the group transforms for models.
             * @type String
             */
            _groupTransformsArrayName = null,
            /**
             * A pool containing dynamic particles (such as particles for muzzle flashes and explosions) for reuse, so that creation of
             * new particle objects can be decreased for optimization.
             * @type Pool
             */
            _particlePool,
            /**
             * A pool containing projectiles for reuse, so that creation of new projectile objects can be decreased for optimization.
             * @type Pool
             */
            _projectilePool,
            /**
             * A pool containing missiles for reuse, so that creation of new missile objects can be decreased for optimization.
             * @type Pool
             */
            _missilePool,
            /**
             * A pool containing trail segments for reuse, so that creation of objects while creating trails can be decreased for optimization.
             * @type Pool
             */
            _trailSegmentPool,
            /**
             * A pool containing explosions for reuse, so that creation of new explosion objects can be decreased for optimization.
             * @type Pool
             */
            _explosionPool,
            /**
             * The context storing the current settings and game data that can be accessed through the interface of this module
             * @type MissionContext
             */
            _context,
            /**
             * Contains the constructor function of the Condition subclass for each ConditionType identifier.
             * @type Object.<String, Function>
             */
            _conditionConstructors,
            /**
             * Contains the constructor function of the Action subclass for each ActionType identifier.
             * @type Object.<String, Function>
             */
            _actionConstructors,
            /**
             * This string is available to other modules through a public function so that an arbitrary piece of information from this 
             * module can be exposed for debug purposes.
             * @type String
             */
            _debugInfo = "";
    // -------------------------------------------------------------------------
    // Freezing enums
    Object.freeze(TriggerWhich);
    Object.freeze(TriggerWhen);
    Object.freeze(ConditionType);
    Object.freeze(TimeConditionWhen);
    Object.freeze(ActionType);
    Object.freeze(MissionState);
    // -------------------------------------------------------------------------
    // Public functions
    /**
     * Queries a module-level string for debug purposes.
     * @returns {String}
     */
    function getDebugInfo() {
        return _debugInfo;
    }
    // #########################################################################
    /**
     * @class
     * A team to which spacecrafts can belong to that determines which spacecrafts are hostile and friendly towards each other.
     * @param {String|Object} nameOrParams
     */
    function Team(nameOrParams) {
        /**
         * The unique string ID of this team, also used for choosing the translated displayed name.
         * @type String
         */
        this._name = null;
        /**
         * Which faction this team belongs to.
         * @type String
         */
        this._faction = null;
        /**
         * The replacements to pass when formatting the display name for this team
         * @type Number
         */
        this._displayNameReplacements = {
            index: -1
        };
        /**
         * The color to use when replacing original faction colors of spacecrafts belonging to this team.
         * @tpye Number[4]
         */
        this._color = null;
        if (typeof nameOrParams === "string") {
            this._name = nameOrParams;
            this._faction = nameOrParams;
        } else if (typeof nameOrParams === "object") {
            this._name = nameOrParams.name || nameOrParams.faction || application.showError("Team defined without a name or faction!");
            this._faction = nameOrParams.faction;
            this._displayNameReplacements.index = nameOrParams.index;
            this._color = nameOrParams.color || null;
        } else {
            application.showError("Invalid parameter specified for Team constructor!");
        }
        /**
         * The number of spacecrafts belonging to this team at the start of the current mission
         * @type Number
         */
        this._initialCount = 0;
        /**
         * Stores the names and craft references for all squads that are part of this team (i.e. for the wingmen status indicator)
         * (includes references to already destroyed spacecrafts)
         * format of one entry: {name: String (name (id) of squad), crafts: Array (references to the spacecrafts in the squad)}
         * @type Array
         */
        this._squads = [];
    }
    /**
     * Returns the unique string ID of this team.
     * @returns {String}
     */
    Team.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the translated, human-readable unique name of this team.
     * @returns {String}
     */
    Team.prototype.getDisplayName = function () {
        return utils.formatString(strings.get(strings.FACTION.PREFIX, this._faction, this._faction || this._name), this._displayNameReplacements);
    };
    /**
     * Returns the color to use when replacing original faction colors of spacecrafts belonging to this team.
     * @returns {Number[4]}
     */
    Team.prototype.getColor = function () {
        return this._color;
    };
    /**
     * Returns the number of spacecrafts belonging to this team at the start of the current mission
     * @returns {Number}
     */
    Team.prototype.getInitialCount = function () {
        return this._initialCount;
    };
    /**
     * Registers the passed spacecraft as part of this team
     * @param {Spacecraft} craft 
     */
    Team.prototype.addSpacecraft = function (craft) {
        var i, maxMembers, squad = craft.getSquad();
        craft.setTeam(this);
        // setting squad info so that it can be queried later (for example to show wingmen status for this team)
        if (squad) {
            // if the squad of this new spacecraft is already registered, add the craft to it
            for (i = 0; i < this._squads.length; i++) {
                if (squad === this._squads[i].name) {
                    this._squads[i].crafts.push(craft);
                    break;
                }
            }
            // ...if not register the new squad
            if (i >= this._squads.length) {
                this._squads.push({
                    name: squad,
                    crafts: [craft]
                });
            }
            maxMembers = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_CRAFT_POSITIONS).length;
            if (this._squads[i].crafts.length > maxMembers) {
                application.showError("Warning: squad '" + squad + "' of team '" + this._name + "' has more than " + maxMembers + " members, and thus cannot be displayed correctly in the wingmen status panel!");
            }
        }
        // using this counter the survival rate can be calculated at the end of the mission (and in case of the player's team, whether it
        // is/was a team mission)
        this._initialCount++;
    };
    /**
     * Returns the names and craft references for all squads that are part of this team (i.e. for the wingmen status indicator)
     * (includes references to already destroyed spacecrafts)
     * format of one entry: {name: String (name (id) of squad), crafts: Array (references to the spacecrafts in the squad)}
     * @returns {Array}
     */
    Team.prototype.getSquads = function () {
        return this._squads;
    };
    // #########################################################################
    /**
     * @class
     * An octree node that is used to partition spacecrafts. Recursively divides the given list of spacecrafts among its subnodes and can
     * retrieve a subset of this list belonging to an area in space by choosing the appropriate subnodes.
     * @param {Spacecraft[]} objects The list of spacecrafts belonging to this node. (to be divided among its subnodes)
     * @param {Number} maximumDepth The maximum number of levels below this node that should be created when dividing the objects.
     * @param {Number} maximumObjectCount If the node has this much or fewer objects, it will not divide them further (become a leaf node)
     * @param {Boolean} [isRootNode=false] If true, the node will calculate boundaries based on the contained spacecrafts and whenever
     * asked for spacecrafts in a region outside these boundaries, it will return an emptry list instead of recursively checking its
     * subnodes.
     */
    function Octree(objects, maximumDepth, maximumObjectCount, isRootNode) {
        /**
         * The list of spacecrafts belonging to this node.
         * @type Spacecraft[]
         */
        this._objects = objects;
        /**
         * The world coordinates of the point in space which divides the region beloning to this node to 8 subregions (2x2x2), which belong
         * to its subnodes. Null in the case of leaf nodes.
         * @type Number[3]
         */
        this._center = null;
        /*
         * The minimum and maximum coordinates for the 3 axes where any part of any of the contained spacecrafts reside.
         * @type Number[2][3]
         */
        this._boundaries = null;
        if (this._objects.length > 0) {
            this._calculateCenter(isRootNode);
        }
        /**
         * The subnodes of this node, or null in case of leaf nodes.
         * @type Octree[8]
         */
        this._subnodes = (maximumDepth > 0) && (this._objects.length > maximumObjectCount) ? this._generateSubnodes(maximumDepth - 1, maximumObjectCount) : null;
    }
    /**
     * Calculates and saves the center point for this node based on the associated spacecrafts. (their average position)
     * @param {Boolean} [isRootNode=false] If true, also calculates and saves boundaries.
     */
    Octree.prototype._calculateCenter = function (isRootNode) {
        var i, n, x = 0, y = 0, z = 0, p, s;
        if (isRootNode) {
            p = this._objects[0].getPhysicalModel().getPositionMatrix();
            s = this._objects[0].getPhysicalModel().getSize();
            this._boundaries = [[p[0] - s, p[0] + s], [p[1] - s, p[1] + s], [p[2] - s, p[2] + s]];
        }
        for (i = 0, n = this._objects.length; i < n; i++) {
            p = this._objects[i].getPhysicalModel().getPositionMatrix();
            x += p[12];
            y += p[13];
            z += p[14];
            if (isRootNode) {
                s = this._objects[i].getPhysicalModel().getSize();
                if ((p[12] - s) < this._boundaries[0][0]) {
                    this._boundaries[0][0] = p[12] - s;
                }
                if ((p[12] + s) > this._boundaries[0][1]) {
                    this._boundaries[0][1] = p[12] + s;
                }
                if ((p[13] - s) < this._boundaries[1][0]) {
                    this._boundaries[1][0] = p[13] - s;
                }
                if ((p[13] + s) > this._boundaries[1][1]) {
                    this._boundaries[1][1] = p[13] + s;
                }
                if ((p[14] - s) < this._boundaries[2][0]) {
                    this._boundaries[2][0] = p[14] - s;
                }
                if ((p[14] + s) > this._boundaries[2][1]) {
                    this._boundaries[2][1] = p[14] + s;
                }
            }
        }
        x /= n;
        y /= n;
        z /= n;
        this._center = [x, y, z];
    };
    /**
     * Creates and returns the list of subnodes for this node by dividing its objects among them based on its center point and the given 
     * parameters.
     * @param {Number} maximumDepth The subnodes will generate further subnodes up to this many times.
     * @param {Number} maximumObjectCount Nodes containing this much or fewer spacecrafts will become leaf nodes and not divide them 
     * further.
     * @returns {Octree[8]}
     */
    Octree.prototype._generateSubnodes = function (maximumDepth, maximumObjectCount) {
        var
                /** @type Number */
                i, n, size,
                /** @type Object */
                o,
                /** @type Float32Array */
                p,
                /** [l]ow/[h]igh[x]/[y]/[z] 
                 * @type Array */
                lxlylz, lxlyhz, lxhylz, lxhyhz, hxlylz, hxlyhz, hxhylz, hxhyhz, result;
        for (i = 0, n = this._objects.length; i < n; i++) {
            o = this._objects[i];
            p = o.getPhysicalModel().getPositionMatrix();
            size = o.getPhysicalModel().getSize();
            if ((p[12] - size) < this._center[0]) {
                if ((p[13] - size) < this._center[1]) {
                    if ((p[14] - size) < this._center[2]) {
                        lxlylz = lxlylz || [];
                        lxlylz.push(o);
                    }
                    if ((p[14] + size) >= this._center[2]) {
                        lxlyhz = lxlyhz || [];
                        lxlyhz.push(o);
                    }
                }
                if ((p[13] + size) >= this._center[1]) {
                    if ((p[14] - size) < this._center[2]) {
                        lxhylz = lxhylz || [];
                        lxhylz.push(o);
                    }
                    if ((p[14] + size) >= this._center[2]) {
                        lxhyhz = lxhyhz || [];
                        lxhyhz.push(o);
                    }
                }
            }
            if ((p[12] + size) >= this._center[0]) {
                if ((p[13] - size) < this._center[1]) {
                    if ((p[14] - size) < this._center[2]) {
                        hxlylz = hxlylz || [];
                        hxlylz.push(o);
                    }
                    if ((p[14] + size) >= this._center[2]) {
                        hxlyhz = hxlyhz || [];
                        hxlyhz.push(o);
                    }
                }
                if ((p[13] + size) >= this._center[1]) {
                    if ((p[14] - size) < this._center[2]) {
                        hxhylz = hxhylz || [];
                        hxhylz.push(o);
                    }
                    if ((p[14] + size) >= this._center[2]) {
                        hxhyhz = hxhyhz || [];
                        hxhyhz.push(o);
                    }
                }
            }
        }
        result = new Array(8);
        result[0] = new Octree(lxlylz || utils.EMPTY_ARRAY, maximumDepth, maximumObjectCount, false);
        result[1] = new Octree(lxlyhz || utils.EMPTY_ARRAY, maximumDepth, maximumObjectCount, false);
        result[2] = new Octree(lxhylz || utils.EMPTY_ARRAY, maximumDepth, maximumObjectCount, false);
        result[3] = new Octree(lxhyhz || utils.EMPTY_ARRAY, maximumDepth, maximumObjectCount, false);
        result[4] = new Octree(hxlylz || utils.EMPTY_ARRAY, maximumDepth, maximumObjectCount, false);
        result[5] = new Octree(hxlyhz || utils.EMPTY_ARRAY, maximumDepth, maximumObjectCount, false);
        result[6] = new Octree(hxhylz || utils.EMPTY_ARRAY, maximumDepth, maximumObjectCount, false);
        result[7] = new Octree(hxhyhz || utils.EMPTY_ARRAY, maximumDepth, maximumObjectCount, false);
        return result;
    };
    /**
     * Returns the list of spacecrafts inside the region specified by the given boundaries using the spatial partitions represented by this
     * node and its subnodes.
     * @param {Number} minX
     * @param {Number} maxX
     * @param {Number} minY
     * @param {Number} maxY
     * @param {Number} minZ
     * @param {Number} maxZ
     * @returns {Spacecraft[]}
     */
    Octree.prototype.getObjects = function (minX, maxX, minY, maxY, minZ, maxZ) {
        var result;
        if (!this._subnodes) {
            return this._objects;
        }
        if (this._boundaries) {
            if ((maxX < this._boundaries[0][0]) || (minX > this._boundaries[0][1]) ||
                    (maxY < this._boundaries[1][0]) || (minY > this._boundaries[1][1]) ||
                    (maxZ < this._boundaries[2][0]) || (minZ > this._boundaries[2][1])) {
                return utils.EMPTY_ARRAY;
            }
        }
        result = [];
        if (minX < this._center[0]) {
            if (minY < this._center[1]) {
                if (minZ < this._center[2]) {
                    result = result.concat(this._subnodes[0].getObjects(minX, maxX, minY, maxY, minZ, maxZ));
                }
                if (maxZ >= this._center[2]) {
                    result = result.concat(this._subnodes[1].getObjects(minX, maxX, minY, maxY, minZ, maxZ));
                }
            }
            if (maxY >= this._center[1]) {
                if (minZ < this._center[2]) {
                    result = result.concat(this._subnodes[2].getObjects(minX, maxX, minY, maxY, minZ, maxZ));
                }
                if (maxZ >= this._center[2]) {
                    result = result.concat(this._subnodes[3].getObjects(minX, maxX, minY, maxY, minZ, maxZ));
                }
            }
        }
        if (maxX >= this._center[0]) {
            if (minY < this._center[1]) {
                if (minZ < this._center[2]) {
                    result = result.concat(this._subnodes[4].getObjects(minX, maxX, minY, maxY, minZ, maxZ));
                }
                if (maxZ >= this._center[2]) {
                    result = result.concat(this._subnodes[5].getObjects(minX, maxX, minY, maxY, minZ, maxZ));
                }
            }
            if (maxY >= this._center[1]) {
                if (minZ < this._center[2]) {
                    result = result.concat(this._subnodes[6].getObjects(minX, maxX, minY, maxY, minZ, maxZ));
                }
                if (maxZ >= this._center[2]) {
                    result = result.concat(this._subnodes[7].getObjects(minX, maxX, minY, maxY, minZ, maxZ));
                }
            }
        }
        return result;
    };
    // #########################################################################
    /**
     * @typedef {Object} Missions~SubjectsDescriptor
     * @property {String[]} [spacecrafts] 
     * @property {String[]} [squads] 
     * @property {String[]} [teams] 
     */
    /**
     * @class Represents a group of spacecrafts within a mission. (which can be subjects of conditions or actions)
     * @param {Missions~SubjectsDescriptor} dataJSON
     */
    function SubjectGroup(dataJSON) {
        /**
         * Contains the IDs of the spacecrafts, squads and teams this group consists of
         * @type Missions~SubjectsDescriptor
         */
        this._descriptor = dataJSON || {};
        /**
         * References to the actual spacecrafts in the mission that are identified by instance are stored in this field for quicker 
         * access
         * @type Spacecraft[]
         */
        this._spacecrafts = null;
        /**
         * The cached string that can be used to display the subjects to the user in a short way, to be used on the HUD
         * @type String
         */
        this._shortString = null;
    }
    /**
     * Returns whether the passed spacecraft is a subject belonging to this subject group
     * @param {Spacecraft} spacecraft
     * @returns {Boolean}
     */
    SubjectGroup.prototype.has = function (spacecraft) {
        return (this._descriptor.spacecrafts && (this._descriptor.spacecrafts.indexOf(spacecraft.getID()) >= 0)) ||
                (this._descriptor.squads && (this._descriptor.squads.indexOf(spacecraft.getSquad()) >= 0)) ||
                (this._descriptor.teams && (this._descriptor.teams.indexOf(spacecraft.getTeam().getName()) >= 0));
    };
    /**
     * Gathers and caches references to the spacecrafts in the passed mission that are in this subject group, for faster future use
     * @param {Mission} mission
     */
    SubjectGroup.prototype._cacheSpacecrafts = function (mission) {
        var i, spacecrafts;
        this._spacecrafts = [];
        spacecrafts = mission.getSpacecrafts();
        for (i = 0; i < spacecrafts.length; i++) {
            if (this.has(spacecrafts[i])) {
                this._spacecrafts.push(spacecrafts[i]);
            }
        }
    };
    /**
     * Returns an array with the spacecrafts that are in this subject group (based on the passed mission)
     * @param {Mission} mission
     * @param {Boolean} [reload=false] If true, the list of spacecrafts is queried from the mission again, even if 
     * it has been cached before (and thus will not include ships that were destroyed, for example)
     * @returns {Spacecraft[]}
     */
    SubjectGroup.prototype.getSpacecrafts = function (mission, reload) {
        if (mission && (!this._spacecrafts || reload)) {
            this._cacheSpacecrafts(mission);
        }
        return this._spacecrafts;
    };
    /**
     * Whether this subject group (potentially) includes multiple spacecrafts
     * @returns {Boolean}
     */
    SubjectGroup.prototype.isMulti = function () {
        return (this._descriptor.spacecrafts && (this._descriptor.spacecrafts.length > 1)) ||
                (this._descriptor.squads && (this._descriptor.squads.length > 0)) ||
                (this._descriptor.teams && (this._descriptor.teams.length > 0));
    };
    /**
     * 
     * @param {String} subjectID
     * @returns {String}
     */
    SubjectGroup._mapSpacecraftID = function (subjectID) {
        return strings.getDefiniteArticleForWord(subjectID) + " <strong>" + subjectID + "</strong>";
    };
    /**
     * 
     * @param {Array} subjectIDs
     * @returns {String}
     */
    SubjectGroup._getMappedSpacecraftIDs = function (subjectIDs) {
        return strings.getList(subjectIDs.map(SubjectGroup._mapSpacecraftID));
    };
    /**
     * 
     * @param {String} subjectID
     * @returns {String}
     */
    SubjectGroup._mapSquadID = function (subjectID) {
        subjectID = strings.get(strings.SQUAD.PREFIX, subjectID, subjectID);
        return strings.getDefiniteArticleForWord(subjectID) + " <strong>" + subjectID + "</strong>";
    };
    /**
     * 
     * @param {Array} subjectIDs
     * @returns {String}
     */
    SubjectGroup._getMappedSquadIDs = function (subjectIDs) {
        return strings.getList(subjectIDs.map(SubjectGroup._mapSquadID));
    };
    /**
     * 
     * @param {String} subjectID
     * @returns {String}
     */
    SubjectGroup._mapTeamID = function (subjectID) {
        subjectID = strings.get(strings.FACTION.PREFIX, subjectID, subjectID);
        return strings.getDefiniteArticleForWord(subjectID) + " <strong>" + subjectID + "</strong>";
    };
    /**
     * 
     * @param {Array} subjectIDs
     * @returns {String}
     */
    SubjectGroup._getMappedTeamIDs = function (subjectIDs) {
        return strings.getList(subjectIDs.map(SubjectGroup._mapTeamID));
    };
    /**
     * Returns a translated string that can be used to display the subjects to the player (used in the Missions screen)
     * @returns {String}
     */
    SubjectGroup.prototype.toString = function () {
        var result = "";
        if (this._descriptor.spacecrafts) {
            result += SubjectGroup._getMappedSpacecraftIDs(this._descriptor.spacecrafts);
        }
        if (this._descriptor.squads) {
            if (result.length > 0) {
                result += "; ";
            }
            result += utils.formatString(strings.get((this._descriptor.squads.length > 1) ?
                    strings.MISSIONS.OBJECTIVE_SUBJECTS_SQUADS :
                    strings.MISSIONS.OBJECTIVE_SUBJECTS_SQUAD), {
                ids: SubjectGroup._getMappedSquadIDs(this._descriptor.squads)
            });
        }
        if (this._descriptor.teams) {
            if (result.length > 0) {
                result += "; ";
            }
            result += utils.formatString(strings.get((this._descriptor.teams.length > 1) ?
                    strings.MISSIONS.OBJECTIVE_SUBJECTS_TEAMS :
                    strings.MISSIONS.OBJECTIVE_SUBJECTS_TEAM), {
                ids: SubjectGroup._getMappedTeamIDs(this._descriptor.teams)
            });
        }
        return result;
    };
    /**
     * Returns how many of the subjects are still alive
     * @param {Boolean} [presentOnly=false] If true, only the spacecrafts that are present (not away) are counted 
     * @returns {Number}
     */
    SubjectGroup.prototype.getLiveSubjectCount = function (presentOnly) {
        var result = 0, i;
        for (i = 0; i < this._spacecrafts.length; i++) {
            if (this._spacecrafts[i].isAlive() && (!presentOnly || !this._spacecrafts[i].isAway())) {
                result++;
            }
        }
        return result;
    };
    /**
     * Returns a short translated string that can be used to display the subjects to the player (used on the HUD in battle)
     * @returns {String}
     */
    SubjectGroup.prototype.getShortString = function () {
        if (!this._shortString) {
            if (this._descriptor.spacecrafts && !this._descriptor.squads && !this._descriptor.teams) {
                if (this._spacecrafts.length > 1) {
                    this._shortString = utils.formatString(strings.get(strings.BATTLE.OBJECTIVE_SUBJECTS_SPACECRAFTS), {count: this._spacecrafts.length});
                } else {
                    this._shortString = this._spacecrafts[0].getDisplayName();
                }
            } else if (!this._descriptor.spacecrafts && this._descriptor.squads && !this._descriptor.teams) {
                if (this._descriptor.squads.length > 1) {
                    this._shortString = utils.formatString(strings.get(strings.BATTLE.OBJECTIVE_SUBJECTS_SQUADS), {count: this._descriptor.squads.length});
                } else {
                    this._shortString = strings.get(strings.SQUAD.PREFIX, this._descriptor.squads[0], this._descriptor.squads[0]);
                }
            } else if (!this._descriptor.spacecrafts && !this._descriptor.squads && this._descriptor.teams) {
                if (this._descriptor.teams.length > 1) {
                    this._shortString = utils.formatString(strings.get(strings.BATTLE.OBJECTIVE_SUBJECTS_TEAMS), {count: this._descriptor.teams.length});
                } else {
                    this._shortString = strings.get(strings.FACTION.PREFIX, this._descriptor.teams[0], this._descriptor.teams[0]);
                }
            } else {
                this._shortString = utils.formatString(strings.get(strings.BATTLE.OBJECTIVE_SUBJECTS_SPACECRAFTS), {count: this._spacecrafts.length});
            }
        }
        return this._shortString;
    };
    // #########################################################################
    /**
     * @class A condition that can be evaluated in every simulation step of the mission to be found either true (satisfied) or false, and 
     * can be used to fire triggers.
     * This is a base class that needs to be subclassed for each different condition type:
     * - implement _checkParams() and isSatisfied() (see existing condition classes for details)
     * - add a new corresponding ConditionType and register the subclass for it in _conditionConstructors
     * - if the condition can correspond to a mission objective, implement 
     *   getObjectiveString(), getObjectiveStateString(), getTargetSpacecrafts() and getEscortedSpacecrafts() (see existing condition classes for details)
     * @param {Object} dataJSON The object storing the data for the condition
     */
    function Condition(dataJSON) {
        /**
         * (enum ConditionType) 
         * The nature of this condition, ultimately decides how the condition is evaluated
         * @type String
         */
        this._type = dataJSON ? utils.getSafeEnumValue(ConditionType, dataJSON.type, null) : null;
        /**
         * The spacecrafts / groups of spacecrafts that determine the subjects of the condition
         * @type SubjectGroup
         */
        this._subjects = dataJSON ? new SubjectGroup(dataJSON.subjects) : null;
        if (dataJSON) {
            this._checkParams(dataJSON.params);
        }
    }
    /**
     * Shows the error message indicating that there was a problem validating the parameters defined for this condition
     */
    Condition.prototype._handleWrongParams = function () {
        application.showError("Wrong parameters specified for condition of type: '" + this._type + "'!");
    };
    /**
     * Returns true if this condition has a chance of becoming impossible to satisfy
     * @returns {Boolean}
     */
    Condition.prototype.canBeImpossible = function () {
        return false;
    };
    /**
     * Returns true if this condition can not be satisfied anymore during the current mission
     * @returns {Boolean}
     */
    Condition.prototype.isImpossible = function () {
        return false;
    };
    /**
     * For mission objective conditions, whether the objective corresponding to this condition should be considered active
     * @returns {Boolean}
     */
    Condition.prototype.isActive = function () {
        return true;
    };
    /**
     * Whether this condition can change between being satisfied and not multiple times during the mission
     * @returns {Boolean}
     */
    Condition.prototype.canChangeMultipleTimes = function () {
        return false;
    };
    // ##############################################################################
    /**
     * @class A condition that is satisfied when all of its subjects have been destroyed
     * @extends Condition
     * @param {Object} dataJSON
     */
    function DestroyedCondition(dataJSON) {
        Condition.call(this, dataJSON);
    }
    DestroyedCondition.prototype = new Condition();
    DestroyedCondition.prototype.constructor = DestroyedCondition;
    /**
     * @typedef DestroyedCondition~Params
     * @property {String} [which] (enum DestroyedConditionWhich)
     */
    /**
     * @param {DestroyedCondition~Params} params
     * @returns {Boolean}
     */
    DestroyedCondition.prototype._checkParams = function (params) {
        /**
         * @type DestroyedCondition~Params
         */
        this._params = params;
        if (this._params && this._params.which &&
                !utils.getSafeEnumValue(DestroyedConditionWhich, this._params.which)) {
            this._handleWrongParams();
            return false;
        }
        /**
         * @type Boolean
         */
        this._all = !this._params || !this._params.which || (this._params.which === DestroyedConditionWhich.ALL);
        return true;
    };
    /**
     * @param {Mission} mission
     * @returns {Boolean}
     */
    DestroyedCondition.prototype.isSatisfied = function (mission) {
        var i, spacecrafts = this._subjects.getSpacecrafts(mission);
        for (i = 0; i < spacecrafts.length; i++) {
            if (spacecrafts[i].isAlive() === this._all) {
                return !this._all;
            }
        }
        return this._all;
    };
    /**
     * @param {Object} stringPrefix 
     * @returns {String}
     */
    DestroyedCondition.prototype.getObjectiveString = function (stringPrefix) {
        var result = utils.formatString(strings.get(stringPrefix,
                this._subjects.isMulti() ?
                (this._all ? strings.OBJECTIVE.DESTROY_SUFFIX.name : strings.OBJECTIVE.DESTROY_ANY_SUFFIX.name) :
                strings.OBJECTIVE.DESTROY_ONE_SUFFIX.name), {
            subjects: this._subjects.toString()
        });
        result = result.charAt(0).toUpperCase() + result.slice(1);
        return result;
    };
    /**
     * @param {Object} stringPrefix 
     * @returns {String}
     */
    DestroyedCondition.prototype.getObjectiveStateString = function (stringPrefix) {
        var result, count, suffix;
        if (!this._subjects.getSpacecrafts()) {
            return "";
        }
        count = this._subjects.getLiveSubjectCount(true);
        suffix = (count > 1) ? (" (" + count + ")") : "";
        result = utils.formatString(strings.get(stringPrefix, strings.OBJECTIVE.DESTROY_SUFFIX.name), {
            subjects: this._subjects.getShortString()
        }) + suffix;
        result = result.charAt(0).toUpperCase() + result.slice(1);
        return result;
    };
    /**
     * Note: this is only correct if this condition belongs to the trigger of a WIN event
     * @param {Mission} mission 
     * @returns {Spacecraft[]}
     */
    DestroyedCondition.prototype.getTargetSpacecrafts = function (mission) {
        return this._subjects.getSpacecrafts(mission);
    };
    /**
     * Note: this is only correct if this condition belongs to the trigger of a LOSE event
     * @param {Mission} mission 
     * @returns {Spacecraft[]}
     */
    DestroyedCondition.prototype.getEscortedSpacecrafts = function (mission) {
        return this._subjects.getSpacecrafts(mission);
    };
    // ##############################################################################
    /**
     * @class A condition that is satisfied based on the number of its currently alive subjects
     * @extends Condition
     * @param {Object} dataJSON
     */
    function CountCondition(dataJSON) {
        Condition.call(this, dataJSON);
    }
    CountCondition.prototype = new Condition();
    CountCondition.prototype.constructor = CountCondition;
    /**
     * @typedef CountCondition~Params
     * @property {Number} count The number relative to which to evaluate the number of alive subjects
     * @property {String} relation (enum CountConditionRelation) The relation determining when is this condition satisfied
     */
    /**
     * @param {CountCondition~Params} params
     * @returns {Boolean}
     */
    CountCondition.prototype._checkParams = function (params) {
        /**
         * @type CountCondition~Params
         */
        this._params = params;
        if (!this._params ||
                ((typeof this._params.count) !== "number") ||
                !utils.getSafeEnumValue(CountConditionRelation, this._params.relation)) {
            this._handleWrongParams();
            return false;
        }
        return true;
    };
    /**
     * @param {Mission} mission
     * @returns {Boolean}
     */
    CountCondition.prototype.isSatisfied = function (mission) {
        var i, count, spacecrafts = this._subjects.getSpacecrafts(mission);
        count = 0;
        for (i = 0; i < spacecrafts.length; i++) {
            if (spacecrafts[i].isAlive()) {
                count++;
            }
        }
        switch (this._params.relation) {
            case CountConditionRelation.BELOW:
                return count < this._params.count;
            case CountConditionRelation.ABOVE:
                return count > this._params.count;
            case CountConditionRelation.EQUALS:
                return count === this._params.count;
        }
        return false;
    };
    /**
     * @param {Object} stringPrefix
     * @returns {String}
     */
    CountCondition.prototype.getObjectiveString = function (stringPrefix) {
        var result;
        if (this._params.relation !== CountConditionRelation.BELOW) {
            application.showError("Count conditions for mission objectives must have relation set to '" + CountConditionRelation.BELOW + "'!");
            return null;
        }
        result = utils.formatString(strings.get(stringPrefix, strings.OBJECTIVE.COUNT_BELOW_SUFFIX.name), {
            subjects: this._subjects.toString(),
            count: this._params.count
        });
        result = result.charAt(0).toUpperCase() + result.slice(1);
        return result;
    };
    /**
     * @param {Object} stringPrefix 
     * @returns {String}
     */
    CountCondition.prototype.getObjectiveStateString = function (stringPrefix) {
        var result, count;
        if (!this._subjects.getSpacecrafts()) {
            return "";
        }
        count = this._subjects.getLiveSubjectCount();
        result = utils.formatString(strings.get(stringPrefix, strings.OBJECTIVE.COUNT_BELOW_SUFFIX.name), {
            subjects: this._subjects.getShortString(),
            count: this._params.count,
            live: count,
            remaining: Math.max(0, count - this._params.count)
        });
        result = result.charAt(0).toUpperCase() + result.slice(1);
        return result;
    };
    /**
     * Note: this is only correct if this condition belongs to the trigger of a WIN event
     * @param {Mission} mission 
     * @returns {Spacecraft[]}
     */
    CountCondition.prototype.getTargetSpacecrafts = function (mission) {
        return this._subjects.getSpacecrafts(mission);
    };
    /**
     * Note: this is only correct if this condition belongs to the trigger of a LOSE event
     * @param {Mission} mission 
     * @returns {Spacecraft[]}
     */
    CountCondition.prototype.getEscortedSpacecrafts = function (mission) {
        return this._subjects.getSpacecrafts(mission);
    };
    // ##############################################################################
    /**
     * @class A condition that is satisfied based on the time elapsed since a start event (start of mission or
     * first firing of a specified trigger)
     * @extends Condition
     * @param {Object} dataJSON
     */
    function TimeCondition(dataJSON) {
        Condition.call(this, dataJSON);
        /**
         * Whether the timer for this condition is currently running.
         * @type Boolean
         */
        this._running = !this._params || !this._params.start;
        /**
         * A reference to the trigger setting off the timer for this condition (if any)
         * @type Trigger
         */
        this._trigger = null;
        /**
         * The time elapsed while running the timer for this condition, in milliseconds
         * @type Number
         */
        this._timeElapsed = this._params ? this._params.startValue || 0 : 0;
        /**
         * The number of times this condition has already been satisfied (for repeat mode)
         * @type Number
         */
        this._count = 0;
        /**
         * When this condition can become impossible to be satisfied
         * @type Boolean
         */
        this._canBeImpossible = this._params ? (this._params.when === TimeConditionWhen.BEFORE) ||
                (this._params.when === TimeConditionWhen.WITHIN) ||
                (this._params.when === TimeConditionWhen.ONCE) ||
                ((this._params.when === TimeConditionWhen.REPEAT) && this._params.maxCount) : false;
        /**
         * Cached value of whether the time condition has the 'when' param set to 'before'
         * @type Boolean
         */
        this._before = !!this._params && (this._params.when === TimeConditionWhen.BEFORE);
        /**
         * Whether this condition cannot be satisfied anymore
         * @type Boolean
         */
        this._impossible = false;
    }
    TimeCondition.prototype = new Condition();
    TimeCondition.prototype.constructor = TimeCondition;
    /**
     * @typedef TimeCondition~Params
     * @property {Number} time The amount of time this condition refers to, in milliseconds
     * @property {String} when (enum TimeConditionWhen) How to determine when the condition is satisfied
     * @property {String} [start] The name of the event starting the timer for this condition (not set: start of mission)
     * @property {Number} [maxCount] The maximum number of times this condition can be satisfied (only for repeat mode)
     * @property {Number} [startValue] The value of the timer when started (for repeat mode)
     */
    /**
     * @param {TimeCondition~Params} params 
     * @returns {Boolean}
     */
    TimeCondition.prototype._checkParams = function (params) {
        /**
         * @type TimeCondition~Params
         */
        this._params = params;
        if (!this._params ||
                ((typeof this._params.time) !== "number") ||
                !(utils.getSafeEnumValue(TimeConditionWhen, this._params.when)) ||
                ((this._params.start !== undefined) && (typeof this._params.start !== "string")) ||
                ((this._params.when !== TimeConditionWhen.REPEAT) && (this._params.maxCount !== undefined)) ||
                ((this._params.when === TimeConditionWhen.REPEAT) && (this._params.maxCount !== undefined) && (typeof this._params.maxCount !== "number")) ||
                ((this._params.startValue !== undefined) && (typeof this._params.startValue !== "number"))) {
            this._handleWrongParams();
            return false;
        }
        return true;
    };
    /**
     * @param {Mission} mission
     * @param {Number} dt
     * @returns {Boolean}
     */
    TimeCondition.prototype.isSatisfied = function (mission, dt) {
        var result = false;
        if (this._params.start && !this._trigger) {
            this._trigger = mission.getEvent(this._params.start) && mission.getEvent(this._params.start).getTrigger();
            if (!this._trigger) {
                this._params.start = null;
            }
        }
        if (!this._running && !this._impossible && this._trigger && this._trigger.hasFired()) {
            this._running = true;
        }
        if (this._running) {
            this._timeElapsed += dt;
            switch (this._params.when) {
                case TimeConditionWhen.BEFORE:
                case TimeConditionWhen.WITHIN:
                    if (this._timeElapsed < this._params.time) {
                        return true;
                    } else {
                        this._impossible = true;
                    }
                    break;
                case TimeConditionWhen.AFTER:
                    if (this._timeElapsed > this._params.time) {
                        return true;
                    }
                    break;
                case TimeConditionWhen.ONCE:
                    if ((this._timeElapsed >= this._params.time) && (this._count === 0)) {
                        this._running = false;
                        this._count = 1;
                        this._impossible = true;
                        return true;
                    }
                    break;
                case TimeConditionWhen.REPEAT:
                    if (!this._params.maxCount || (this._count < this._params.maxCount)) {
                        while (this._timeElapsed >= this._params.time) {
                            this._timeElapsed -= this._params.time;
                            result = true;
                        }
                        if (result) {
                            this._count++;
                            return true;
                        }
                    } else {
                        this._running = false;
                        this._impossible = true;
                    }
                    break;
            }
        }
        return this._before ? (this._timeElapsed < this._params.time) : false;
    };
    /**
     * @param {Object} stringPrefix
     * @param {Boolean} multipleConditions
     * @returns {String}
     */
    TimeCondition.prototype.getObjectiveString = function (stringPrefix, multipleConditions) {
        var result;
        if (!multipleConditions && (!this._params || (this._params.when !== TimeConditionWhen.AFTER))) {
            application.showError("Single time conditions for mission objectives must have 'when' = '" + TimeConditionWhen.AFTER + "'!");
            return null;
        }
        if (multipleConditions && (!this._params || (this._params.when !== TimeConditionWhen.BEFORE))) {
            application.showError("Time conditions used in combination with other conditions for mission objectives must have 'when' = '" + TimeConditionWhen.BEFORE + "'!");
            return null;
        }
        result = utils.formatString(strings.get(stringPrefix, multipleConditions ? strings.OBJECTIVE.TIME_MULTI_SUFFIX.name : strings.OBJECTIVE.TIME_SUFFIX.name), {
            time: utils.formatTimeToMinutes(this._params.time)
        });
        if (!multipleConditions) {
            result = result.charAt(0).toUpperCase() + result.slice(1);
        }
        return result;
    };
    /**
     * @param {Object} stringPrefix 
     * @param {Boolean} multipleConditions
     * @returns {String}
     */
    TimeCondition.prototype.getObjectiveStateString = function (stringPrefix, multipleConditions) {
        var result, timeRemaining;
        timeRemaining = Math.ceil(Math.max(0, this._params.time - this._timeElapsed) * 0.001) * 1000;
        result = utils.formatString(strings.get(stringPrefix, multipleConditions ? strings.OBJECTIVE.TIME_MULTI_SUFFIX.name : strings.OBJECTIVE.TIME_SUFFIX.name), {
            time: utils.formatTimeToMinutes(timeRemaining)
        });
        result = result.charAt(0).toUpperCase() + result.slice(1);
        return result;
    };
    /**
     * @returns {Spacecraft[]}
     */
    TimeCondition.prototype.getTargetSpacecrafts = function () {
        return utils.EMPTY_ARRAY;
    };
    /**
     * @returns {Spacecraft[]}
     */
    TimeCondition.prototype.getEscortedSpacecrafts = function () {
        return utils.EMPTY_ARRAY;
    };
    /**
     * @override
     * @returns {Boolean}
     */
    TimeCondition.prototype.canBeImpossible = function () {
        return this._canBeImpossible;
    };
    /**
     * @override
     * @returns {Boolean}
     */
    TimeCondition.prototype.isImpossible = function () {
        return this._impossible;
    };
    /**
     * @override
     * @returns {Boolean}
     */
    TimeCondition.prototype.isActive = function () {
        return this._running && (!this._params || (this._timeElapsed < this._params.time));
    };
    /**
     * @override
     * @returns {Boolean}
     */
    TimeCondition.prototype.canChangeMultipleTimes = function () {
        return this._params.when === TimeConditionWhen.REPEAT;
    };
    /**
     * @param {Object} dataJSON
     * @returns {DestroyedCondition|CountCondition|TimeCondition|Condition}
     */
    function createCondition(dataJSON) {
        return new (_conditionConstructors[dataJSON.type] || Condition)(dataJSON);
    }
    // #########################################################################
    /**
     * @callback Trigger~onFireCallback
     * @param {Mission} mission 
     */
    /**
     * @typedef {Object} ObjectiveWithState
     * @property {String} text A translated text to display the objective and its current progress state to the player on the HUD
     * @property {Number} state (enum ObjectiveState)
     * @property {Boolean} completable Whether this is a completable objective (if not, it is completed (if not failed) upon finishing the mission)
     */
    /**
     * @class Missions contain triggers, which fire based on a set of conditions that they evaluate in every simulation step, and can have
     * callbacks added to them which are invoked upon firing
     * that can be 
     * @param {Object} dataJSON
     */
    function Trigger(dataJSON) {
        var i, when, which;
        /**
         * The list of conditions to evaluate when deciding whether to fire
         * @type Condition[]
         */
        this._conditions = null;
        if (dataJSON.conditions && (dataJSON.conditions.length > 0)) {
            this._conditions = [];
            for (i = 0; i < dataJSON.conditions.length; i++) {
                this._conditions.push(createCondition(dataJSON.conditions[i]));
            }
        }
        /**
         * (enum TriggerWhich) 
         * Determines the logical operation used to combine the conditions when deciding whether to fire
         * @type String
         */
        which = utils.getSafeEnumValue(TriggerWhich, dataJSON.which, TriggerWhich.ALL);
        /**
         * Cached value of whether we need to check for the state of all conditions to be true / false
         * @type Boolean
         */
        this._all = (which === TriggerWhich.ALL);
        /**
         * (enum TriggerWhen)
         * Determines at what logic state (or state change) should the trigger fire
         * @type String
         */
        when = utils.getSafeEnumValue(TriggerWhen, dataJSON.when, TriggerWhen.BECOMES_TRUE);
        /**
         * Cached value of whether we need to check for false values of conditions rather then true
         * @type Boolean
         */
        this._falsy = (when === TriggerWhen.BECOMES_FALSE);
        if (!this._all) {
            this._falsy = !this._falsy;
        }
        /**
         * When true, the trigger can only fire once during a mission, and then it does not evaluate its conditions anymore
         * @type Boolean
         */
        this._once = true;
        if (dataJSON.once !== undefined) {
            this._once = dataJSON.once;
        } else if (this._conditions) {
            for (i = 0; i < this._conditions.length; i++) {
                if (this._conditions[i].canChangeMultipleTimes()) {
                    this._once = false;
                    break;
                }
            }
        }
        /**
         * If this is set (to a larger than 0 value), the trigger will fire this much later after the first
         * time it is evaluated true, in milliseconds. "once" must be set to true.
         * @type Number
         */
        this._delay = dataJSON.delay || 0;
        /**
         * A flag to indicate whether the countdown for delayed firing has been started.
         * @type Boolean
         */
        this._countDown = false;
        /**
         * The callbacks attached which should be invoked when the trigger fires
         * @type Trigger~onFireCallback[]
         */
        this._onFireHandlers = [];
        /**
         * The result of the condition evaluation in the last simulation step, to track condition changes
         * @type Boolean
         */
        this._previousConditionState = false;
        /**
         * Whether this trigger has already fired (at least once) during the current mission
         * @type Boolean
         */
        this._fired = false;
        /**
         * Whether based on its conditions, this trigger can possibly become impossible to fire
         */
        this._canBeImpossible = true;
        if (!this._falsy && this._conditions) {
            this._canBeImpossible = !this._all;
            for (i = 0; i < this._conditions.length; i++) {
                if (this._conditions[i].canBeImpossible()) {
                    this._canBeImpossible = this._all;
                    break;
                }
            }
        }
        // invalid state checks
        if (!this._conditions && !this._once) {
            application.showError("A trigger has no conditions, 'once' cannot be set to false!");
            this._once = true;
        }
        if (!this._once && this._delay) {
            application.showError("Triggers without 'once' cannot have delays!");
            this._delay = 0;
        }
    }
    /**
     * Adds the passed callback function to be executed whenever this trigger fires
     * @param {Trigger~onFireCallback} value
     */
    Trigger.prototype.addFireHandler = function (value) {
        this._onFireHandlers.push(value);
    };
    /**
     * Fires the trigger, invoking every callback previously added to it
     * @param {Mission} mission 
     */
    Trigger.prototype.fire = function (mission) {
        var i;
        if (this._delay > 0) {
            this._countDown = true;
            return;
        }
        for (i = 0; i < this._onFireHandlers.length; i++) {
            this._onFireHandlers[i](mission);
        }
        this._fired = true;
    };
    /**
     * Returns whether the trigger has already fired (at least once) during this mission
     * @returns {Boolean}
     */
    Trigger.prototype.hasFired = function () {
        return this._fired;
    };
    /**
     * Checks the state of the passed mission to determine whether the trigger should fire, and fires it if necessary.
     * Should be called in every simulation step of the mission.
     * @param {Mission} mission
     * @param {Number} dt The time elapsed since the last simulation step, in milliseconds
     */
    Trigger.prototype.simulate = function (mission, dt) {
        var conditionState, i;
        if (this._once) {
            if (this._fired) {
                return;
            }
            if (this._countDown) {
                this._delay -= dt;
                if (this._delay <= 0) {
                    this.fire(mission);
                }
                return;
            }
        }
        if (!this._conditions) {
            this.fire(mission);
            return;
        }
        conditionState = this._all;
        for (i = 0; i < this._conditions.length; i++) {
            // need to loop all conditions, to make sure timers are all updated with dt
            if (this._conditions[i].isSatisfied(mission, dt) === this._falsy) {
                conditionState = !this._all;
            }
        }
        if ((this._previousConditionState === this._falsy) && (conditionState !== this._falsy)) {
            this.fire(mission);
        }
        this._previousConditionState = conditionState;
    };
    /**
     * Returns the number of mission objectives corresponding to this trigger
     * @param {Boolean} triggersWinAction Whether this trigger firing causes the player to win 
     * @returns {Number}
     */
    Trigger.prototype.getObjectiveCount = function (triggersWinAction) {
        return triggersWinAction ? this._conditions.length : 1;
    };
    /**
     * Returns the list of HTML strings that can be used to display the objectives associated with the conditions of this trigger.
     * @param {Object} stringPrefix The translation string descriptor containing the prefix to be used to decide whether the conditions 
     * should be considered win or lose conditions
     * @param {Boolean} triggersWinAction Whether this trigger firing causes the player to win 
     * @returns {String[]}
     */
    Trigger.prototype.getObjectiveStrings = function (stringPrefix, triggersWinAction) {
        var i, result = [], multi, text;
        if (!this._conditions) {
            application.showError("Win and lose events must have conditions!");
            return null;
        }
        if (!this._all) {
            application.showError("Triggers for mission objectives must be set to 'which' = '" + TriggerWhich.ALL + "'!");
            return null;
        }
        if (this._falsy) {
            application.showError("Triggers for mission objectives must be set to 'when' = '" + TriggerWhen.BECOMES_TRUE + "'!");
            return null;
        }
        multi = this._conditions.length > 1;
        if (triggersWinAction) {
            for (i = 0; i < this._conditions.length; i++) {
                result.push(this._conditions[i].getObjectiveString(stringPrefix, multi));
            }
        } else {
            text = "";
            for (i = 0; i < this._conditions.length; i++) {
                text += ((i > 0) ? " " : "") + this._conditions[i].getObjectiveString(stringPrefix, multi);
            }
            result.push(text);
        }
        return result;
    };
    /**
     * Updates the passed array starting from the passed index with the objectives and their states
     * belonging to this trigger.
     * To be used for the HUD objective indicator.
     * @param {Boolean} triggersWinAction Whether this trigger firing causes the player to win 
     * @param {Mission} mission 
     * @param {Boolean} missionEnded Whether the mission has already ended (and we are gathering objective 
     * states for display on the debriefing screen)
     * @param {ObjectiveWithState[]} [objectivesState] The array to update
     * @param {Number} [index] The starting index in the array to start the update from
     * @returns {Number} The index coming after the last updated element of the array
     */
    Trigger.prototype.getObjectivesState = function (triggersWinAction, mission, missionEnded, objectivesState, index) {
        var i, multi = this._conditions.length > 1, satisfied, impossible, text, state;
        if (triggersWinAction) {
            for (i = 0; i < this._conditions.length; i++) {
                state = this._conditions[i].isSatisfied(mission, 0) ?
                        ((this._conditions[i].canBeImpossible() && !missionEnded) ?
                                ((mission.getState() === MissionState.COMPLETED) ?
                                        ObjectiveState.COMPLETED :
                                        ObjectiveState.IN_PROGRESS) :
                                ObjectiveState.COMPLETED) :
                        this._conditions[i].isImpossible() ? ObjectiveState.FAILED : ObjectiveState.IN_PROGRESS;
                if ((state !== ObjectiveState.IN_PROGRESS) || this._conditions[i].isActive() || missionEnded) {
                    objectivesState[index].text = this._conditions[i].getObjectiveStateString(strings.BATTLE.OBJECTIVE_WIN_PREFIX, multi);
                    objectivesState[index].state = state;
                    objectivesState[index].completable = true;
                    index++;
                }
            }
        } else {
            satisfied = true;
            impossible = false;
            for (i = 0; i < this._conditions.length; i++) {
                if (!this._conditions[i].isSatisfied(mission, 0)) {
                    satisfied = false;
                    if (this._conditions[i].isImpossible()) {
                        impossible = true;
                        break;
                    }
                }
            }
            text = (this._conditions.length > 0) ? this._conditions[0].getObjectiveStateString(strings.BATTLE.OBJECTIVE_LOSE_PREFIX, multi) : "";
            state = satisfied ? ObjectiveState.FAILED : (impossible || missionEnded || (mission.getState() === MissionState.COMPLETED)) ? ObjectiveState.COMPLETED : ObjectiveState.IN_PROGRESS;
            if (state === ObjectiveState.IN_PROGRESS) {
                for (i = 1; i < this._conditions.length; i++) {
                    if (this._conditions[i].isActive()) {
                        text += " " + this._conditions[i].getObjectiveStateString(strings.BATTLE.OBJECTIVE_LOSE_PREFIX, multi);
                    }
                }
            }
            if (text) {
                objectivesState[index].text = text;
                objectivesState[index].state = state;
                objectivesState[index].completable = this._canBeImpossible;
                index++;
            }
        }
        return index;
    };
    /**
     * If the event of the trigger corresponds to a mission objective that requires the player to destroy some spacecrafts, this 
     * method returns the list of these target spacecrafts.
     * @param {Mission} mission 
     * @returns {Spacecraft[]}
     */
    Trigger.prototype.getTargetSpacecrafts = function (mission) {
        var i, result = [];
        for (i = 0; i < this._conditions.length; i++) {
            result = result.concat(this._conditions[i].getTargetSpacecrafts(mission));
        }
        return result;
    };
    /**
     * If the event of the trigger corresponds to a mission objective that requires the player to escort (protect) some spacecrafts, this 
     * method returns the list of these escorted spacecrafts.
     * @param {Mission} mission 
     * @returns {Spacecraft[]}
     */
    Trigger.prototype.getEscortedSpacecrafts = function (mission) {
        var i, result = [];
        for (i = 0; i < this._conditions.length; i++) {
            result = result.concat(this._conditions[i].getEscortedSpacecrafts(mission));
        }
        return result;
    };
    /**
     * Whether based on its conditions, this trigger can possibly become impossible to fire
     * @returns {Boolean}
     */
    Trigger.prototype.canBeImpossible = function () {
        return this._canBeImpossible;
    };
    // #########################################################################
    /**
     * @class 
     * An action to be executed whenever the associated trigger fires during the simulation of the mission
     * This is a base class, subclasses need to be created for each specific action type that is supported.
     * The subclasses need to implement _checkParams() and _execute().
     * @param {Object} dataJSON The object storing the data to initialize this action
     * @param {Trigger} trigger
     */
    function Action(dataJSON, trigger) {
        /**
         * (enum ActionType) Determines what the action to execute actually is
         * @type String
         */
        this._type = dataJSON ? utils.getSafeEnumValue(ActionType, dataJSON.type, null) : null;
        /**
         * The time that needs to be elapsed after the trigger fires before executing the action, in milliseconds
         * @type Number
         */
        this._delay = dataJSON ? dataJSON.delay || 0 : 0;
        /**
         * A reference to the trigger that needs to fire to execute this action
         * @type Trigger
         */
        this._trigger = trigger;
        if (this._trigger) {
            this._trigger.addFireHandler(this._addToExecutionQueue.bind(this));
        }
        /**
         * The subjects of this action (used in action types that do things with spacecrafts)
         * @type SubjectGroup
         */
        this._subjects = dataJSON ? new SubjectGroup(dataJSON.subjects) : null;
        if (dataJSON) {
            this._checkParams(dataJSON.params);
        }
    }
    /**
     * Return the value that identifies the nature of this action - i.e. what it does
     * @returns {String} (enum ActionType) 
     */
    Action.prototype.getType = function () {
        return this._type;
    };
    /**
     * Shows the error message indicating that there was a problem validating the parameters defined for this action
     */
    Action.prototype._handleWrongParams = function () {
        application.showError("Wrong parameters specified for action of type: '" + this._type + "'!");
    };
    /**
     * If the action has a delay set, it is added to the execution queue of the passed mission with the set delay, otherwise
     * it is executed right away
     * @param {Mission} mission
     */
    Action.prototype._addToExecutionQueue = function (mission) {
        if (this._delay > 0) {
            mission.queueAction(this, this._delay);
        } else {
            this.execute(mission);
        }
    };
    /**
     * Whether the trigger belonging to this action has a chance of becoming impossible to fire
     * @returns {Boolean}
     */
    Action.prototype.triggerCanBeImpossible = function () {
        return this._trigger.canBeImpossible();
    };
    // #########################################################################
    /**
     * @class 
     * @extends Action
     * @param {Object} dataJSON
     * @param {Trigger} trigger
     */
    function WinAction(dataJSON, trigger) {
        Action.call(this, dataJSON, trigger);
    }
    WinAction.prototype = new Action();
    WinAction.prototype.constructor = WinAction;
    /**
     * @override
     * @returns {Boolean}
     */
    WinAction.prototype._checkParams = function () {
        return true;
    };
    /**
     * @override
     * @param {Mission} mission 
     */
    WinAction.prototype.execute = function (mission) {
        mission.completeMission();
    };
    /**
     * Returns the number of mission objectives corresponding to this action
     * @returns {Number}
     */
    WinAction.prototype.getObjectiveCount = function () {
        return this._trigger.getObjectiveCount(true);
    };
    /**
     * @returns {String[]}
     */
    WinAction.prototype.getObjectiveStrings = function () {
        return this._trigger.getObjectiveStrings(strings.MISSIONS.OBJECTIVE_WIN_PREFIX, true);
    };
    /**
     * @param {Mission} mission
     * @param {Boolean} missionEnded
     * @param {ObjectiveWithState[]} [objectivesState]
     * @param {Number} [index]
     * @returns {Number}
     */
    WinAction.prototype.getObjectivesState = function (mission, missionEnded, objectivesState, index) {
        return this._trigger.getObjectivesState(true, mission, missionEnded, objectivesState, index);
    };
    // #########################################################################
    /**
     * @class 
     * @extends Action
     * @param {Object} dataJSON
     * @param {Trigger} trigger
     */
    function LoseAction(dataJSON, trigger) {
        Action.call(this, dataJSON, trigger);
    }
    LoseAction.prototype = new Action();
    LoseAction.prototype.constructor = LoseAction;
    /**
     * @override
     * @returns {Boolean}
     */
    LoseAction.prototype._checkParams = function () {
        return true;
    };
    /**
     * @override
     * @param {Mission} mission 
     */
    LoseAction.prototype.execute = function (mission) {
        mission.failMission();
    };
    /**
     * Returns the number of mission objectives corresponding to this action
     * @returns {Number}
     */
    LoseAction.prototype.getObjectiveCount = function () {
        return this._trigger.getObjectiveCount(false);
    };
    /**
     * @returns {String[]}
     */
    LoseAction.prototype.getObjectiveStrings = function () {
        return this._trigger.getObjectiveStrings(strings.MISSIONS.OBJECTIVE_LOSE_PREFIX, false);
    };
    /**
     * @param {Mission} mission
     * @param {Boolean} missionEnded
     * @param {ObjectiveWithState[]} [objectivesState]
     * @param {Number} [index]
     * @returns {Number}
     */
    LoseAction.prototype.getObjectivesState = function (mission, missionEnded, objectivesState, index) {
        return this._trigger.getObjectivesState(false, mission, missionEnded, objectivesState, index);
    };
    // #########################################################################
    /**
     * @class 
     * @extends Action
     * @param {Object} dataJSON
     * @param {Trigger} trigger
     */
    function MessageAction(dataJSON, trigger) {
        Action.call(this, dataJSON, trigger);
    }
    MessageAction.prototype = new Action();
    MessageAction.prototype.constructor = MessageAction;
    /**
     * @typedef MessageAction~Params
     * @property {String|Object} [text] The text of the message (formatted, can contain '\n'-s). Used when no
     * translation (or no translation ID) is available. Alternatively, an object can be given with multiple language
     * versions of the text, with the language IDs as the keys.
     * @property {String} [textID] The translation ID to use for the text to be displayed. The full translation
     * ID will be mission.<missionName>.messages.<textID>
     * If a translation is found, it overrides the value of the text property.
     * @property {String} [source] The name (id) of the spacecraft that this message originates from. Its display name will be added at the beginning
     * of the message, and the message is not played if the ship is already destroyed
     * @property {Number} [duration] The duration to display the message for, in milliseconds. If not given, an automatic
     * duration will be set based on the length of the text
     * @property {Boolean} [permanent] If true, the message keeps being displayed until a new urgent
     * message is added or the queue is cleared
     * @property {Boolean} [urgent] Whether the message should be displayed before non-urgent messages (interrupting already displayed
     * non-urgent messages)
     * @property {Number[4]} [color] When given, the message should be displayed using this text color 
     */
    /**
     * @override
     * @param {MessageAction~Params} params 
     * @returns {Boolean}
     */
    MessageAction.prototype._checkParams = function (params) {
        /**
         * @type MessageAction~Params
         */
        this._params = params;
        if (!this._params ||
                ((!this._params.text) && (!this._params.textID)) ||
                ((this._params.text !== undefined) && (typeof this._params.text !== "string") && (typeof this._params.text !== "object")) ||
                ((this._params.textID !== undefined) && (typeof this._params.textID !== "string")) ||
                ((this._params.source !== undefined) && (typeof this._params.source !== "string")) ||
                ((this._params.duration !== undefined) && (typeof this._params.duration !== "number")) ||
                ((this._params.permanent !== undefined) && (typeof this._params.permanent !== "boolean")) ||
                ((this._params.urgent !== undefined) && (typeof this._params.urgent !== "boolean")) ||
                ((this._params.color !== undefined) && ((typeof this._params.color !== "object") || !(this._params.color instanceof Array)))) {
            this._handleWrongParams();
            return false;
        }
        return true;
    };
    /**
     * @override
     * @param {Mission} mission 
     */
    MessageAction.prototype.execute = function (mission) {
        var source;
        if (this._params.source) {
            source = mission.getSpacecraft(this._params.source);
            if (!source) {
                application.log_DEBUG("Warning: message not played, because the source spacecraft '" + this._params.source + "' does not exist (might have been destroyed)!");
                return;
            }
        }
        game.getScreen().queueHUDMessage({
            text: (this._params.source ? ("{spacecrafts/" + this._params.source + "}: ") : "") + strings.get(
                    strings.MISSION.PREFIX,
                    utils.getFilenameWithoutExtension(mission.getName()) + strings.MISSION.MESSAGES_SUFFIX.name + this._params.textID,
                    (typeof this._params.text === "object") ? this._params.text[strings.getLanguage()] : this._params.text),
            duration: this._params.duration,
            appearAnimation: true,
            permanent: this._params.permanent,
            color: this._params.color,
            source: source
        }, this._params.urgent);
    };
    // #########################################################################
    /**
     * @class 
     * @extends Action
     * @param {Object} dataJSON
     * @param {Mission} mission
     */
    function ClearMessagesAction(dataJSON, mission) {
        Action.call(this, dataJSON, mission);
    }
    ClearMessagesAction.prototype = new Action();
    ClearMessagesAction.prototype.constructor = ClearMessagesAction;
    /**
     * @override
     * @returns {Boolean}
     */
    ClearMessagesAction.prototype._checkParams = function () {
        return true;
    };
    /**
     * @override
     */
    ClearMessagesAction.prototype.execute = function () {
        game.getScreen().clearHUDMessages();
    };
    // #########################################################################
    /**
     * @class 
     * @extends Action
     * @param {Object} dataJSON
     * @param {Trigger} trigger
     */
    function CommandAction(dataJSON, trigger) {
        Action.call(this, dataJSON, trigger);
    }
    CommandAction.prototype = new Action();
    CommandAction.prototype.constructor = CommandAction;
    /**
     * @override
     * @param {SpacecraftEvents~CommandData} params 
     * @returns {Boolean}
     */
    CommandAction.prototype._checkParams = function (params) {
        /**
         * @type SpacecraftEvents~CommandData
         */
        this._params = params;
        if (!this._params ||
                ((this._params.command !== undefined) && (typeof this._params.command !== "string"))) {
            this._handleWrongParams();
            return false;
        }
        return true;
    };
    /**
     * @override
     * @param {Mission} mission 
     */
    CommandAction.prototype.execute = function (mission) {
        var i, spacecrafts = this._subjects.getSpacecrafts(mission, true);
        if (spacecrafts.length > 0) {
            this._params.lead = spacecrafts[0];
            this._params.clearCache = true;
            for (i = 0; i < spacecrafts.length; i++) {
                this._params.index = i;
                spacecrafts[i].handleEvent(SpacecraftEvents.COMMAND_RECEIVED, this._params);
            }
        }
    };
    // #########################################################################
    /**
     * @class 
     * @extends Action
     * @param {Object} dataJSON
     * @param {Trigger} trigger
     */
    function HUDAction(dataJSON, trigger) {
        Action.call(this, dataJSON, trigger);
    }
    HUDAction.prototype = new Action();
    HUDAction.prototype.constructor = HUDAction;
    /**
     * @override
     * @param {SpacecraftEvents~HUDData} params 
     * @returns {Boolean}
     */
    HUDAction.prototype._checkParams = function (params) {
        /**
         * @type SpacecraftEvents~HUDData
         */
        this._params = params;
        if (!this._params ||
                ((this._params.state !== undefined) && (typeof this._params.state !== "string"))) {
            this._handleWrongParams();
            return false;
        }
        return true;
    };
    /**
     * @override
     * @param {Mission} mission 
     */
    HUDAction.prototype.execute = function (mission) {
        var spacecraft = mission.getPilotedSpacecraft();
        if (spacecraft) {
            spacecraft.handleEvent(SpacecraftEvents.HUD, this._params);
        }
    };
    // #########################################################################
    /**
     * @class A game event is a set of actions that are executed whenever an associated trigger (a set of conditions and parameters) fires 
     * during the mission.
     * @param {Object} dataJSON
     */
    function MissionEvent(dataJSON) {
        var i;
        /**
         * A string to identify this event Might be needed to refer to it for example, as a timed trigger might start its countdown after 
         * a referred event happens.
         * @type String
         */
        this._name = dataJSON.name;
        /**
         * The trigger that is checked every simulation step whether to fire and invoke the associated actions or not
         * @type Trigger[]
         */
        this._trigger = new Trigger(dataJSON.trigger);
        /**
         * Actions that are executed in every simulation step when their associated triggers fire
         * @type Action[]
         */
        this._actions = [];
        for (i = 0; i < dataJSON.actions.length; i++) {
            this._actions.push(new (_actionConstructors[dataJSON.actions[i].type] || Action)(dataJSON.actions[i], this._trigger));
        }
    }
    /**
     * Returns the string that identifies this event within the mission.
     * @returns {String}
     */
    MissionEvent.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the trigger that sets this event off.
     * @returns {Trigger}
     */
    MissionEvent.prototype.getTrigger = function () {
        return this._trigger;
    };
    /**
     * Returns the set of actions that are executed when this event happens.
     * @returns {Action[]}
     */
    MissionEvent.prototype.getActions = function () {
        return this._actions;
    };
    /**
     * Checks the triggers and executes the actions if needed for the current mission simulation step.
     * @param {Mission} mission The mission we are simulating.
     * @param {Number} dt The time elapsed since the last simulation step, in milliseconds
     */
    MissionEvent.prototype.simulate = function (mission, dt) {
        this._trigger.simulate(mission, dt);
    };
    // #########################################################################
    /**
     * @class Represents a battle scene with an environment, spacecrafts, 
     * projectiles. Can create scenes for visual representation using the held
     * references as well as perform the game logic and physics simulation
     * among the contained objects.
     * @param {String} name The name of the mission (typically same as the filename e.g. someMission.json)
     */
    function Mission(name) {
        /**
         * The name of the mission (typically same as the filename e.g. someMission.json)
         * @type String
         */
        this._name = name;
        /**
         * The name of the mission that should be played after completing this one (typically same as the filename e.g. someMission.json)
         * @type String
         */
        this._nextMissionName = null;
        /**
         * Stores the attributes of the environment where this mission is situated.
         * @type Environment
         */
        this._environment = null;
        /**
         * Whether this mission has an own environment created by itself (described in the mission JSON)
         * or just refers one from the common environments. (if the latter is the case, the referred environment cannot be destroyed when
         * this mission is destroyed)
         * @type Boolean
         */
        this._ownsEnvironment = false;
        /**
         * The ID (resource name) of the music that should play during anticipation phase within this mission (if not given, a random one is chosen
         * from the available anticipation themes each time the mission starts)
         * @type String
         */
        this._anticipationTheme = null;
        /**
         * The ID (resource name) of the music that should play while in combat within this mission (if not given, a random one is chosen
         * from the available combat themes each time the mission starts)
         * @type String
         */
        this._combatTheme = null;
        /**
         * The list of views that will be used to add camera configurations to the scene of this mission. The first element of this list
         * will be the starting camera configuration.
         * @type SceneView[]
         */
        this._views = null;
        /**
         * The list of valid string IDs for teams in this mission (so that IDs can be validated against this list to detect typos)
         * @type String[]
         */
        this._teams = null;
        /**
         * The events that can happen during this mission. 
         * @type MissionEvent[]
         */
        this._events = null;
        /**
         * An array of all the actions that are scheduled to be executed and the corresponding time left before the execution (in milliseconds)
         * @type {action: Action, delay: Number}[]
         */
        this._actionQueue = null;
        /**
         * References to those actions of the mission that, when executed, cause it to be completed 
         * @type Action[]
         */
        this._winActions = null;
        /**
         * References to those actions of the mission that, when executed, cause it to be failed 
         * @type Action[]
         */
        this._loseActions = null;
        /**
         * The list of spacecrafts that are placed on the map of this mission.
         * @type Spacecraft[]
         */
        this._spacecrafts = null;
        /**
         * A reference to the spacecraft piloted by the player.
         * @type Spacecraft
         */
        this._pilotedCraft = null;
        /**
         * A list of references to all the physical objects that take part in
         * collision / hit check in this mission to easily pass them to such
         * simulation methods.
         * @type PhysicalObject[]
         */
        this._hitObjects = null;
        /**
         * Tracks the state of mission objective completion.
         * @type Number
         */
        this._state = MissionState.NONE;
        /**
         * Whether this mission has the implicit default objective (as it lacks any explicit completable objectives)
         * @type Boolean
         */
        this._defaultObjective = true;
        /**
         * A cached value of the last calculated objectives state
         * @type ObjectiveWithState[]
         */
        this._objectivesState = null;
        /**
         * How much score falls on the player in this mission, based on the total score that can be achieved and the number of teammates.
         * (e.g. in a 3v3 match, this would be the score value of one enemy, in a 3v6 match, the value of 2 enemies etc)
         * Needs to be calculated at the start of missions.
         * @type Number
         */
        this._referenceScore = 0;
        /**
         * The cached list of spacecrafts that needs to be destroyed by the player to complete this mission.
         * @type Spacecrafts
         */
        this._targetSpacecrafts = null;
        /**
         * The cached list of spacecrafts that needs to be escorted (protected) by the player for this mission.
         * @type Spacecrafts
         */
        this._escortedSpacecrafts = null;
        /**
         * @type DifficultyLevel
         */
        this._difficultyLevel = null;
    }
    /**
     * Return the name identifying this mission (typically same as the filename e.g. someMission.json)
     * @returns {String}
     */
    Mission.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the name of the mission that should be played after completing this one (typically same as the filename e.g. someMission.json)
     * @returns {String}
     */
    Mission.prototype.getNextMissionName = function () {
        return this._nextMissionName;
    };
    /**
     * Returns the ID (resource name) of the music that should play during anticipation phase within this mission (if it is specified)
     * @returns {String}
     */
    Mission.prototype.getAnticipationTheme = function () {
        return this._anticipationTheme;
    };
    /**
     * Returns the ID (resource name) of the music that should play while in combat within this mission (if it is specified)
     * @returns {String}
     */
    Mission.prototype.getCombatTheme = function () {
        return this._combatTheme;
    };
    /**
     * Returns the currently piloted spacecraft.
     * @returns {Spacecraft}
     */
    Mission.prototype.getPilotedSpacecraft = function () {
        return this._pilotedCraft;
    };
    /**
     * Returns the spacecraft added to this mission that is identified by the given id. Returns null if such spacecraft does not exist.
     * @param {String} id
     * @returns {Spacecraft}
     */
    Mission.prototype.getSpacecraft = function (id) {
        var i;
        for (i = 0; i < this._spacecrafts.length; i++) {
            if (this._spacecrafts[i].getID() === id) {
                return this._spacecrafts[i];
            }
        }
        return null;
    };
    /**
     * Returns the list of spacecrafts (that are alive) in this mission
     * @returns {Spacecraft[]}
     */
    Mission.prototype.getSpacecrafts = function () {
        return this._spacecrafts;
    };
    /**
     * Returns the list of spacecrafts (that are alive) that are members of the passed squad
     * @param {String} squad The string ID of the squad
     * @returns {Spacecraft[]}
     */
    Mission.prototype.getSpacecraftsInSquad = function (squad) {
        var i, result = [];
        for (i = 0; i < this._spacecrafts.length; i++) {
            if (this._spacecrafts[i].getSquad() === squad) {
                result.push(this._spacecrafts[i]);
            }
        }
        return result;
    };
    /**
     * Calls the passed function for every spacecraft this mission has, passing each of the spacecrafts as its single argument
     * @param {Function} method
     */
    Mission.prototype.applyToSpacecrafts = function (method) {
        var i;
        for (i = 0; i < this._spacecrafts.length; i++) {
            method(this._spacecrafts[i]);
        }
    };
    /**
     * Return a value from the enum MissionState
     * @returns {Number}
     */
    Mission.prototype.getState = function () {
        return this._state;
    };
    /**
     * Returns whether the mission is in one of the finishes state (it has been completed, failed, or it was a sandbox battle that has ended)
     * @returns {Boolean}
     */
    Mission.prototype.isFinished = function () {
        return (this._state === MissionState.COMPLETED) ||
                (this._state === MissionState.FAILED) ||
                (this._state === MissionState.DEFEAT) ||
                (this._state === MissionState.ENDED);
    };
    /**
     * Returns the list of spacecrafts that needs to be destroyed by the player to complete this mission.
     * @returns {Spacecraft[]}
     */
    Mission.prototype.getTargetSpacecrafts = function () {
        return this._targetSpacecrafts;
    };
    /**
     * Returns the list of spacecrafts that needs to be escorted (protected) by the player for this mission.
     * @returns {Spacecraft[]}
     */
    Mission.prototype.getEscortedSpacecrafts = function () {
        return this._escortedSpacecrafts;
    };
    /**
     * 
     * @returns {DifficultyLevel}
     */
    Mission.prototype.getDifficultyLevel = function () {
        return this._difficultyLevel;
    };
    /**
     * Marks the mission as completed (by achieving its objectives)
     */
    Mission.prototype.completeMission = function () {
        if (this._state === MissionState.IN_PROGRESS) {
            this._state = MissionState.COMPLETED;
        }
    };
    /**
     * Marks the mission as failed (by failing one of its objectives)
     */
    Mission.prototype.failMission = function () {
        // a completed mission can still be failed, if one of the lose conditions is satisfied after the win condition
        if (((this._state === MissionState.IN_PROGRESS) || (this._state === MissionState.COMPLETED)) && (this._pilotedCraft && !this._pilotedCraft.isAway())) {
            this._state = MissionState.FAILED;
        }
    };
    /**
     * Updates the stored mission state value based on the current situation.
     */
    Mission.prototype._updateState = function () {
        var i, completed;
        // first check for missions with a player
        if (this._pilotedCraft) {
            if (!this._pilotedCraft.isAway()) {
                // update stored objectives state
                this._updateObjectivesState();
            }
            // if the player is destroyed, the mission state is always defeat
            if (this._pilotedCraft.canBeReused()) {
                this._state = MissionState.DEFEAT;
                return;
            } else {
                // a battle with a player can be completed if there are no hostiles left
                if (this._state === MissionState.BATTLE) {
                    for (i = 0; i < this._spacecrafts.length; i++) {
                        if (this._spacecrafts[i] && !this._spacecrafts[i].canBeReused() && this._pilotedCraft.isHostile(this._spacecrafts[i])) {
                            return;
                        }
                    }
                    this._state = MissionState.COMPLETED;
                    return;
                } else if ((this._state === MissionState.IN_PROGRESS) && !this._pilotedCraft.isAway()) {
                    // check the objectives - if any objective is failed, lose, if all of them are complete, win
                    completed = true;
                    for (i = 0; i < this._objectivesState.length; i++) {
                        if (this._objectivesState[i].state === ObjectiveState.FAILED) {
                            this._state = MissionState.FAILED;
                            return;
                        }
                        completed = completed && ((this._objectivesState[i].state === ObjectiveState.COMPLETED) || !this._objectivesState[i].completable) && this._objectivesState[i].text;
                    }
                    if (completed) {
                        this._state = MissionState.COMPLETED;
                        return;
                    }
                }
            }
        } else {
            // checking for missions without a player (demo, sandbox) - these go to the ENDED state after there are no hostiles left
            if (this._state === MissionState.BATTLE) {
                if (this.noHostilesPresent()) {
                    this._state = MissionState.ENDED;
                    return;
                }
            }
        }
    };
    /**
     * Returns whether there are no spacecrafts present in the mission that are hostiles towards each other
     * @returns {Boolean}
     */
    Mission.prototype.noHostilesPresent = function () {
        var i, team = null, spacecraftTeam;
        for (i = 0; i < this._spacecrafts.length; i++) {
            if (this._spacecrafts[i] && !this._spacecrafts[i].canBeReused()) {
                spacecraftTeam = this._spacecrafts[i].getTeam();
                if (spacecraftTeam && team && (spacecraftTeam !== team)) {
                    return false;
                }
                team = spacecraftTeam;
            }
        }
        return true;
    };
    /**
     * Returns how many spacecrafts are currently alive in the passed team
     * @param {Team} team
     * @returns {Number}
     */
    Mission.prototype.getSpacecraftCountForTeam = function (team) {
        var i, result = 0;
        for (i = 0; i < this._spacecrafts.length; i++) {
            if (this._spacecrafts[i] && !this._spacecrafts[i].canBeReused()) {
                if (this._spacecrafts[i].getTeam() === team) {
                    result++;
                }
            }
        }
        return result;
    };
    /**
     * Returns how many spacecrafts hostile to the given spacecraft are currently alive 
     * @param {Spacecraft} craft
     * @param {Boolean} [presentOnly=false] Whether to count only present (= already jumped in, has not jumpoed out yet) spacecrafts
     * @returns {Number}
     */
    Mission.prototype.getHostileSpacecraftCount = function (craft, presentOnly) {
        var i, result = 0;
        for (i = 0; i < this._spacecrafts.length; i++) {
            if (this._spacecrafts[i] && !this._spacecrafts[i].canBeReused() && (!presentOnly || !this._spacecrafts[i].isAway())) {
                if (this._spacecrafts[i].isHostile(craft)) {
                    result++;
                }
            }
        }
        return result;
    };
    /**
     * Returns the spacecraft from this mission that the current view is following in the passed scene, if any.
     * @param {Scene} scene
     * @returns {Spacecraft|null}
     */
    Mission.prototype.getFollowedSpacecraftForScene = function (scene) {
        var visualModel, i;
        if (scene.getCamera().getFollowedNode()) {
            visualModel = scene.getCamera().getFollowedNode().getRenderableObject();
            for (i = 0; i < this._spacecrafts.length; i++) {
                if (this._spacecrafts[i].getVisualModel() === visualModel) {
                    return this._spacecrafts[i];
                }
            }
        }
        return null;
    };
    /**
     * Returns the environment of this mission
     * @returns {Environment}
     */
    Mission.prototype.getEnvironment = function () {
        return this._environment;
    };
    /**
     * Returns the team with the given ID from the list of teams added to this mission.
     * @param {String} name
     * @returns {Team}
     */
    Mission.prototype.getTeam = function (name) {
        var i;
        for (i = 0; i < this._teams.length; i++) {
            if (this._teams[i].getName() === name) {
                return this._teams[i];
            }
        }
        application.showError("No team exists with name '" + name + "'!");
        return null;
    };
    /**
     * Returns the event identified by the passed string
     * @param {String} name
     * @returns {MissionEvent}
     */
    Mission.prototype.getEvent = function (name) {
        var i;
        for (i = 0; i < this._events.length; i++) {
            if (this._events[i].getName() === name) {
                return this._events[i];
            }
        }
        application.showError("No mission event exists with name '" + name + "'!");
        return null;
    };
    /**
     * Returns a list of translated HTML strings that can be used to dislay the objectives of this mission to the player.
     * @returns {String[]}
     */
    Mission.prototype.getObjectives = function () {
        var i, result = [];
        if (this._defaultObjective) {
            result.push(strings.get(strings.MISSIONS.OBJECTIVE_WIN_PREFIX, strings.OBJECTIVE.DESTROY_ALL_SUFFIX.name));
        }
        for (i = 0; i < this._winActions.length; i++) {
            result = result.concat(this._winActions[i].getObjectiveStrings());
        }
        for (i = 0; i < this._loseActions.length; i++) {
            result = result.concat(this._loseActions[i].getObjectiveStrings());
        }
        return result;
    };
    /**
     * Returns a list of translated strings along with objective state values for displaying the current state of mission objectives for
     * the player on the HUD
     * @param {Boolean} missionEnded
     * @returns {ObjectiveWithState[]}
     */
    Mission.prototype.getObjectivesState = function (missionEnded) {
        if (missionEnded) {
            this._updateObjectivesState(missionEnded);
        }
        return this._objectivesState;
    };
    /**
     * Updates the stores mission objective states
     * @param {Boolean} missionEnded
     */
    Mission.prototype._updateObjectivesState = function (missionEnded) {
        var i, index = 0, suffix, hostiles, craft;
        // handling the default "destroy all enemies" implicit mission objective
        if (this._defaultObjective) {
            craft = this.getPilotedSpacecraft();
            suffix = "";
            if (craft) {
                hostiles = this.getHostileSpacecraftCount(craft, true);
                if (hostiles > 0) {
                    suffix = " (" + hostiles + ")";
                }
            }
            this._objectivesState[0].text = strings.get(strings.BATTLE.OBJECTIVE_WIN_PREFIX, strings.OBJECTIVE.DESTROY_ALL_SUFFIX.name) + suffix;
            this._objectivesState[0].state = (craft && craft.isAlive()) ? ((this.getHostileSpacecraftCount(craft, false) > 0) ? ObjectiveState.IN_PROGRESS : ObjectiveState.COMPLETED) : ObjectiveState.FAILED;
            this._objectivesState[0].completable = true;
            index++;
        }
        // handling explicit mission objectives
        for (i = 0; i < this._winActions.length; i++) {
            index = this._winActions[i].getObjectivesState(this, missionEnded, this._objectivesState, index);
        }
        for (i = 0; i < this._loseActions.length; i++) {
            index = this._loseActions[i].getObjectivesState(this, missionEnded, this._objectivesState, index);
        }
        // we might not have all the objectives active
        while (index < this._objectivesState.length) {
            this._objectivesState[index].text = "";
            index++;
        }
    };
    // #########################################################################
    // methods
    /**
     * Loads the required data and sets up the environment for this mission, so that its data can be accessed
     * @param {Object} dataJSON The object storing the mission data
     */
    Mission.prototype.loadEnvironment = function (dataJSON) {
        if ((typeof dataJSON.environment) === "string") {
            this._environment = environments.getEnvironment(dataJSON.environment);
            if (!this._environment) {
                application.showError("Cannot load environment '" + dataJSON.environment + "' for mission: no such environment exists!");
            }
            this._ownsEnvironment = false;
        } else if ((typeof dataJSON.environment) === "object") {
            this._environment = new environments.Environment(dataJSON.environment);
            this._ownsEnvironment = true;
        } else {
            application.showError("Invalid environment specified for mission!");
        }
    };
    /**
     * Loads the required data and sets up the triggers and actions for this mission, so that mission objectives can be determined
     * @param {Object} dataJSON The object storing the mission data
     */
    Mission.prototype.loadObjectives = function (dataJSON) {
        var i, j, actions, actionType, count;
        this._events = [];
        if (dataJSON.events) {
            for (i = 0; i < dataJSON.events.length; i++) {
                this._events.push(new MissionEvent(dataJSON.events[i], this));
            }
        }
        this._actionQueue = [];
        this._state = MissionState.NONE;
        this._winActions = [];
        this._loseActions = [];
        for (i = 0; i < this._events.length; i++) {
            actions = this._events[i].getActions();
            for (j = 0; j < actions.length; j++) {
                actionType = actions[j].getType();
                if (actionType === ActionType.WIN) {
                    this._winActions.push(actions[j]);
                } else if (actionType === ActionType.LOSE) {
                    this._loseActions.push(actions[j]);
                }
            }
        }
        this._defaultObjective = (this._winActions.length === 0);
        if (this._defaultObjective) {
            for (i = 0; i < this._loseActions.length; i++) {
                if (this._loseActions[i].triggerCanBeImpossible()) {
                    this._defaultObjective = false;
                    break;
                }
            }
        }
        count = (this._defaultObjective ? 1 : 0);
        if (this._pilotedCraft) {
            for (i = 0; i < this._winActions.length; i++) {
                count += this._winActions[i].getObjectiveCount();
            }
            for (i = 0; i < this._loseActions.length; i++) {
                count += this._loseActions[i].getObjectiveCount();
            }
        }
        this._objectivesState = new Array(count);
        for (i = 0; i < count; i++) {
            this._objectivesState[i] = {};
        }
        if ((this._winActions.length > 0) || (this._loseActions.length > 0)) {
            this._state = MissionState.IN_PROGRESS;
        }
    };
    /**
     * Adds the passed Action to the list of actions scheduled for execution with the passed delay
     * @param {Action} action
     * @param {Number} delay In milliseconds
     */
    Mission.prototype.queueAction = function (action, delay) {
        this._actionQueue.push({action: action, delay: delay});
    };
    /**
     * Returns the how much base score falls on the player in this mission (out of the total enemy score value, based on the team)
     * @returns {Number}
     */
    Mission.prototype.getReferenceScore = function () {
        return this._referenceScore;
    };
    /**
     * Whether the directional lights in the mission environment should cast shadows
     * @returns {Boolean}
     */
    Mission.prototype.hasShadows = function () {
        return this._environment.hasShadows();
    };
    /**
     * Loads all the data describing this mission from the passed JSON object.
     * @param {Object} dataJSON
     * @param {String} difficulty The string ID of the difficulty level to use
     * @param {Boolean} demoMode If true, the data from the JSON object will be loaded in demo mode, so that the piloted craft is not set
     * and a suitable AI is added to all spacecrafts if possible.
     */
    Mission.prototype.loadFromJSON = function (dataJSON, difficulty, demoMode) {
        var i, j, shadows, craft, teamID, team, aiType, actions, count, factor, squad, names, loadouts, pilotedIndex, positions, formation, orientation, spacecrafts, spacecraftDataTemplate, spacecraftData;
        application.log_DEBUG("Loading mission from JSON file...", 2);
        this._difficultyLevel = _context.getDifficultyLevel(difficulty);
        equipment.handleDifficultySet(this._difficultyLevel);
        spacecraft.resetRandomSeed();
        this._nextMissionName = dataJSON.nextMission || null;
        this.loadEnvironment(dataJSON);
        shadows = graphics.isShadowMappingEnabled();
        if (this._environment.hasShadows()) {
            graphics.setShadowMapping();
        } else {
            graphics.setShadowMapping(false, false);
        }
        if (shadows !== graphics.isShadowMappingEnabled()) {
            graphics.handleSettingsChanged();
        }
        physics.setDrag(this._environment.getDrag(), this._environment.getAngularDrag());
        this._anticipationTheme = dataJSON.anticipationTheme;
        this._combatTheme = dataJSON.combatTheme;
        this._teams = [];
        if (dataJSON.teams) {
            for (i = 0; i < dataJSON.teams.length; i++) {
                this._teams.push(new Team((typeof dataJSON.teams[i] === "string") ? dataJSON.teams[i] : Object.assign({index: (i + 1).toString()}, dataJSON.teams[i])));
            }
        }
        this._views = [];
        if (dataJSON.views) {
            for (i = 0; i < dataJSON.views.length; i++) {
                this._views.push(new classes.SceneView(dataJSON.views[i]));
            }
        }
        this._spacecrafts = [];
        this._hitObjects = [];
        ai.clearAIs();
        // expand squad entries in the spacecrafts array
        spacecrafts = [];
        for (i = 0; i < dataJSON.spacecrafts.length; i++) {
            if (dataJSON.spacecrafts[i].count) {
                // extracting data used for generating differing spacecraft data properties
                // NOTE: MissionDescriptor.getPilotedSpacecraftDescriptor() also does this extraction!
                squad = dataJSON.spacecrafts[i].squad;
                names = dataJSON.spacecrafts[i].names;
                loadouts = dataJSON.spacecrafts[i].loadouts;
                pilotedIndex = dataJSON.spacecrafts[i].pilotedIndex;
                positions = dataJSON.spacecrafts[i].positions;
                formation = dataJSON.spacecrafts[i].formation;
                orientation = mat.rotation4FromJSON(dataJSON.spacecrafts[i].rotations);
                // creating a template to be copied for individual spacecraft data objects, without the proprties that don't refer to individual spacecrafts
                spacecraftDataTemplate = utils.deepCopy(dataJSON.spacecrafts[i]);
                delete spacecraftDataTemplate.count;
                delete spacecraftDataTemplate.names;
                delete spacecraftDataTemplate.loadouts;
                delete spacecraftDataTemplate.pilotedIndex;
                delete spacecraftDataTemplate.positions;
                delete spacecraftDataTemplate.formation;
                for (j = 0; j < dataJSON.spacecrafts[i].count; j++) {
                    spacecraftData = utils.deepCopy(spacecraftDataTemplate);
                    if (squad) {
                        spacecraftData.squad = squad + " " + (j + 1).toString();
                    }
                    if (names) {
                        spacecraftData.name = names[j];
                    }
                    if (loadouts) {
                        spacecraftData.loadout = loadouts[j % loadouts.length];
                    }
                    if (pilotedIndex === (j + 1)) {
                        spacecraftData.piloted = true;
                        delete spacecraftData.ai;
                    }
                    if (positions) {
                        spacecraftData.position = positions[j];
                    }
                    if (formation) {
                        if (positions) {
                            application.showError("Both positions and formation have been defined for spacecraft group - formation will be used!", application.ErrorSeverity.MINOR);
                        }
                        spacecraftData.position = spacecraft.Spacecraft.getPositionInFormation(formation, j, spacecraftData.position, orientation);
                    }
                    spacecrafts.push(spacecraftData);
                }
            } else {
                spacecrafts.push(dataJSON.spacecrafts[i]);
            }
        }
        // loading spacecrafts from expanded array
        for (i = 0; i < spacecrafts.length; i++) {
            craft = new spacecraft.Spacecraft();
            craft.loadFromJSON(spacecrafts[i], this._hitObjects, this._environment);
            if (!demoMode && spacecrafts[i].piloted) {
                this._pilotedCraft = craft;
                craft.multiplyMaxHitpoints(this._difficultyLevel.getPlayerHitpointsFactor());
            }
            teamID = spacecrafts[i].team;
            if (teamID) {
                team = this.getTeam(teamID);
                if (team) {
                    team.addSpacecraft(craft);
                } else {
                    application.showError("Invalid team ID '" + teamID + "' specified for " + craft.getClassName() + "!");
                }
            } else if (demoMode) {
                team = new Team({
                    faction: NUMBERED_FACTION_NAME,
                    index: (this._teams.length + 1).toString()
                });
                this._teams.push(team);
                craft.setTeam(team);
            }
            this._spacecrafts.push(craft);
        }
        // going through ships a second round
        // loading predefined initial targets, calculating reference score (both require that all the spacecrafts already exist),
        // applying difficulty hitpoint factor for friendly spacecrafts
        // adding AI
        this._referenceScore = 0;
        team = this._pilotedCraft && this._pilotedCraft.getTeam();
        count = 0;
        factor = this._difficultyLevel.getFriendlyHitpointsFactor();
        for (i = 0; i < spacecrafts.length; i++) {
            craft = this._spacecrafts[i];
            if (spacecrafts[i].initialTarget) {
                craft.setTarget(this.getSpacecraft(spacecrafts[i].initialTarget));
            }
            if (this._pilotedCraft) {
                if (!spacecrafts[i].excludeFromReferenceScore && this._pilotedCraft.isHostile(craft)) {
                    this._referenceScore += craft.getScoreValue();
                }
                if (this._pilotedCraft.isFriendly(craft)) {
                    if (craft !== this._pilotedCraft) {
                        craft.multiplyMaxHitpoints(factor);
                    }
                    count++;
                }
            }
            aiType = spacecrafts[i].ai;
            if (!aiType && demoMode) {
                if (craft.isFighter()) {
                    aiType = config.getSetting(config.BATTLE_SETTINGS.DEMO_FIGHTER_AI_TYPE);
                } else {
                    aiType = config.getSetting(config.BATTLE_SETTINGS.DEMO_SHIP_AI_TYPE);
                }
            }
            if (aiType) {
                ai.addAI(aiType, craft, this);
            }
        }
        if (count > 0) {
            this._referenceScore /= count;
        }
        // load events and mission objectives
        this.loadObjectives(dataJSON);
        // cache target spacecrafts
        this._targetSpacecrafts = [];
        for (i = 0; i < this._events.length; i++) {
            actions = this._events[i].getActions();
            for (j = 0; j < actions.length; j++) {
                if (actions[j].getType() === ActionType.WIN) {
                    this._targetSpacecrafts = this._targetSpacecrafts.concat(this._events[i].getTrigger().getTargetSpacecrafts(this));
                }
            }
        }
        // cache escorted spacecrafts
        this._escortedSpacecrafts = [];
        for (i = 0; i < this._events.length; i++) {
            actions = this._events[i].getActions();
            for (j = 0; j < actions.length; j++) {
                if (actions[j].getType() === ActionType.LOSE) {
                    this._escortedSpacecrafts = this._escortedSpacecrafts.concat(this._events[i].getTrigger().getEscortedSpacecrafts(this));
                }
            }
        }
        // it doesn't matter if we have objectives when there in no player craft
        if (!this._pilotedCraft) {
            this._state = MissionState.NONE;
        }
        // missions without objectives or player count as battles if there are hostile ships
        if ((this._state === MissionState.NONE) && !this.noHostilesPresent()) {
            this._state = MissionState.BATTLE;
        }
        application.log_DEBUG("Mission successfully loaded.", 2);
    };
    /**
     * Returns whether the mission is starting (has been started) with the player having teammates.
     * @returns {Boolean}
     */
    Mission.prototype.isTeamMission = function () {
        return this.getPilotedSpacecraft() && this.getPilotedSpacecraft().getTeam() && (this.getPilotedSpacecraft().getTeam().getInitialCount() > 1);
    };
    /**
     * Returns an object containing the final score and score breakdown granted in this mission for the performance described by the passed 
     * metrics.
     * @param {Number} baseScore The score achieved by the player before adding any bonuses
     * @param {Number} hitRatio Number of hits / fired projectiles
     * @param {Number} hullIntegrity Current / full hitpoints
     * @param {Number} teamSurvival Surviving / initial teammates
     * @param {Number} missileHitRatio Number of missile hits / launched missiles
     * @returns {Object}
     */
    Mission.prototype.getScoreStatistics = function (baseScore, hitRatio, hullIntegrity, teamSurvival, missileHitRatio) {
        var
                isTeamMission = this.isTeamMission(),
                hitRatioBonus, hullIntegrityBonus, teamSurvivalBonus, score;
        baseScore = Math.round(baseScore);
        hitRatioBonus = Math.round((baseScore || 0) * (hitRatio || ((missileHitRatio || 0) * config.getSetting(config.BATTLE_SETTINGS.MISSILE_HIT_RATIO_FACTOR))));
        hullIntegrityBonus = Math.round(hullIntegrity * (isTeamMission ?
                config.getSetting(config.BATTLE_SETTINGS.SCORE_BONUS_FOR_HULL_INTEGRITY_TEAM) :
                config.getSetting(config.BATTLE_SETTINGS.SCORE_BONUS_FOR_HULL_INTEGRITY)));
        if (isTeamMission) {
            teamSurvivalBonus = Math.round(teamSurvival * config.getSetting(config.BATTLE_SETTINGS.SCORE_BONUS_FOR_TEAM_SURVIVAL));
        }
        score = baseScore + hitRatioBonus + hullIntegrityBonus + (isTeamMission ? teamSurvivalBonus : 0);
        return {
            baseScore: baseScore,
            hitRatioBonus: hitRatioBonus,
            hullIntegrityBonus: hullIntegrityBonus,
            teamSurvivalBonus: teamSurvivalBonus,
            score: score
        };
    };
    /**
     * Returns an object containing the score breakdown and performance information achieved by the player in this mission.
     * (assuming the mission has been completed successfully)
     * @returns {Object}
     */
    Mission.prototype.getPerformanceStatistics = function () {
        var
                /**@type Spacecraft */craft = this.getPilotedSpacecraft(),
                /**@type Boolean */isTeamMission = this.isTeamMission(),
                /**@type Number */teamSurvival = isTeamMission ? (this.getSpacecraftCountForTeam(craft.getTeam()) - (craft.isAlive() ? 1 : 0)) / (craft.getTeam().getInitialCount() - 1) : 0,
                /**@type Object */scoreStats = this.getScoreStatistics(craft.getScore(), craft.getHitRatio(), craft.getHullIntegrity(), teamSurvival, craft.getMissileHitRatio()),
                /**@type Object */perfInfo = _context.getPerformanceInfo(this, scoreStats.score);
        return {
            baseScore: scoreStats.baseScore,
            hitRatioBonus: scoreStats.hitRatioBonus,
            hullIntegrityBonus: scoreStats.hullIntegrityBonus,
            teamSurvival: isTeamMission ? teamSurvival : undefined,
            teamSurvivalBonus: scoreStats.teamSurvivalBonus,
            score: scoreStats.score,
            performance: perfInfo.performance,
            nextPerformance: perfInfo.nextPerformance,
            nextPerformanceScore: perfInfo.nextPerformanceScore
        };
    };
    /**
     * Returns an object containing the required scores for the mission for all the stored mission performance levels.
     * The keys are the IDs of the performance levels and the values are the scores.
     * @returns {Object}
     */
    Mission.prototype.getPerformanceLevelScores = function () {
        return _context.getPerformanceLevelScores(this);
    };
    /**
     * Creates and returns a camera configuration for this given view set up according to the scene view's parameters.
     * @param {SceneView} view
     * @param {Scene} scene
     * @returns {CameraConfiguration} The created camera configuration.
     */
    Mission.prototype.createCameraConfigurationForSceneView = function (view, scene) {
        var positionConfiguration, orientationConfiguration, angles = mat.getYawAndPitch(view.getOrientationMatrix());
        positionConfiguration = new camera.CameraPositionConfiguration(
                !view.isMovable(),
                view.turnsAroundObjects(),
                view.movesRelativeToObject(),
                view.getPositionFollowedObjectsForScene(scene),
                view.startsWithRelativePosition(),
                mat.matrix4(view.getPositionMatrix()),
                view.getDistanceRange(),
                view.getConfines(),
                view.resetsWhenLeavingConfines());
        orientationConfiguration = new camera.CameraOrientationConfiguration(
                !view.isTurnable(),
                view.pointsTowardsObjects(),
                view.isFPS(),
                view.getOrientationFollowedObjectsForScene(scene),
                mat.matrix4(view.getOrientationMatrix()),
                Math.degrees(angles.yaw), Math.degrees(angles.pitch),
                view.getAlphaRange(),
                view.getBetaRange(),
                view.getBaseOrientation() || config.getDefaultCameraBaseOrientation(),
                view.getPointToFallback() || config.getDefaultCameraPointToFallback());
        return new camera.CameraConfiguration(
                view.getName(),
                positionConfiguration, orientationConfiguration,
                view.getFOV() || config.getDefaultCameraFOV(),
                view.getFOVRange(),
                view.getSpan() || config.getDefaultCameraSpan(),
                view.resetsOnFocusChange());
    };
    /**
     * Spacecrafts that start away and jump in during the mission need to be added to the hitObjects when they jump in, so that other will
     * be able to hit them
     * @param {Spacecraft} spacecraft
     */
    Mission.prototype._handleSpacecraftJumpIn = function (spacecraft) {
        if (this._hitObjects.indexOf(spacecraft) <= 0) {
            this._hitObjects.push(spacecraft);
        }
    };
    /**
     * Returns the highest number of projectiles that might be used by the spacecrafts of this mission simultaneously.
     * @returns {Number}
     */
    Mission.prototype.getMaxProjectileCount = function () {
        var result = 0, i;
        for (i = 0; i < this._spacecrafts.length; i++) {
            result += this._spacecrafts[i].getMaxProjectileCount();
        }
        return result;
    };
    /**
     * Returns the highest number of missiles that might be used by the spacecrafts of this mission simultaneously.
     * @returns {Number}
     */
    Mission.prototype.getMaxMissileCount = function () {
        var result = 0, i;
        for (i = 0; i < this._spacecrafts.length; i++) {
            result += this._spacecrafts[i].getMaxMissileCount();
        }
        return result;
    };
    /**
     * Returns the highest number of explosions that might be used by the spacecrafts of this mission simultaneously.
     * @returns {Number}
     */
    Mission.prototype.getMaxExplosionCount = function () {
        var result = 0, i;
        for (i = 0; i < this._spacecrafts.length; i++) {
            result += this._spacecrafts[i].getMaxExplosionCount();
        }
        return result;
    };
    /**
     * Returns the highest number of particles that might be used by the spacecrafts of this mission simultaneously.
     * @returns {Number}
     */
    Mission.prototype.getMaxParticleCount = function () {
        var result = 0, i;
        for (i = 0; i < this._spacecrafts.length; i++) {
            result += this._spacecrafts[i].getMaxParticleCount();
        }
        return result;
    };
    /**
     * @typedef {Object} PreviewParams
     * @property {String} spacecraftShaderName
     * @property {String} gridShaderName
     * @property {String} markerShaderName
     * @property {Number[4]} gridColor
     * @property {Number} gridCount
     * @property {Number} smallestGridSize
     * @property {Number} markerSize
     * @property {Number[4]} markerColor
     * @property {Number[4]} friendlyColor 
     * @property {Number[4]} hostileColor 
     * @property {Number} smallestSizeWhenDrawn
     * @property {Number} awayColorFactor
     * @property {Number} awayAlphaFactor
     */
    /**
     * Adds renderable objects representing all visual elements of the mission to
     * the passed scene.
     * @param {Scene} battleScene
     * @param {Scene} targetScene
     * @param {PreviewParams} [previewParams]
     */
    Mission.prototype.addToScene = function (battleScene, targetScene, previewParams) {
        var i, preview = !!previewParams,
                friendly, friendlyColor, hostileColor, markerColor, callback,
                white = [1, 1, 1],
                getSpacecraftColor;
        if (this._environment) {
            this._environment.addToScene(battleScene);
        }
        if (preview) {
            // add grids
            graphics.getShader(previewParams.gridShaderName);
            graphics.getShader(previewParams.markerShaderName);
            markerColor = previewParams.markerColor;
            resources.getOrAddModel(egomModel.gridModel(GRID_MODEL_NAME, 2 * previewParams.smallestGridSize, 2 * previewParams.smallestGridSize, 2 * previewParams.smallestGridSize + 1, 2 * previewParams.smallestGridSize + 1, white));
            resources.getOrAddModel(egomModel.positionMarkerModel(MARKER_MODEL_NAME, 8, white));
            resources.executeWhenReady(function () {
                var i, size, grid,
                        gridColor = previewParams.gridColor,
                        shader = graphics.getManagedShader(previewParams.gridShaderName),
                        model = graphics.getModel(GRID_MODEL_NAME).getEgomModel();
                size = previewParams.smallestGridSize;
                for (i = 0; i < previewParams.gridCount; i++) {
                    grid = new renderableObjects.ShadedLODMesh(model, shader, {}, mat.identity4(), mat.identity4(), mat.scaling4(size), true, 0, previewParams.smallestSizeWhenDrawn);
                    grid.setUniformValueFunction(renderableObjects.UNIFORM_COLOR_NAME, function () {
                        return gridColor;
                    });
                    grid.setUniformValueFunction(_groupTransformsArrayName, function () {
                        return graphics.getGroupTransformIdentityArray();
                    });
                    battleScene.addObject(grid, false);
                    size *= previewParams.smallestGridSize;
                }
            });
            // set up the callback to be used on added spacecrafts
            friendlyColor = previewParams.friendlyColor;
            hostileColor = previewParams.hostileColor;
            getSpacecraftColor = function (spacecraft, color) {
                return spacecraft.isAway() ?
                        [
                            previewParams.awayColorFactor * color[0],
                            previewParams.awayColorFactor * color[1],
                            previewParams.awayColorFactor * color[2],
                            previewParams.awayAlphaFactor * color[3]
                        ] :
                        color;
            };
            callback = function (spacecraft, color, model) {
                var marker, position = model.getPositionMatrix(), ownColor = getSpacecraftColor(spacecraft, color);
                model.setUniformValueFunction(renderableObjects.UNIFORM_COLOR_NAME, function () {
                    return ownColor;
                });
                if (position[14] !== 0) {
                    marker = new renderableObjects.ShadedLODMesh(resources.getModel(MARKER_MODEL_NAME).getEgomModel(), graphics.getManagedShader(previewParams.markerShaderName), {},
                            mat.translation4(position[12], position[13], 0), mat.identity4(), mat.scaling4(previewParams.markerSize, previewParams.markerSize, position[14]), true, 0, previewParams.smallestSizeWhenDrawn);
                    marker.setUniformValueFunction(renderableObjects.UNIFORM_COLOR_NAME, function () {
                        return markerColor;
                    });
                    battleScene.addObject(marker, false);
                }
            };
        }
        for (i = 0; i < this._spacecrafts.length; i++) {
            if (preview) {
                friendly = !this.getPilotedSpacecraft() || !this._spacecrafts[i].isHostile(this.getPilotedSpacecraft());
            }
            this._spacecrafts[i].addToScene(battleScene, undefined, preview, {
                hitboxes: application.isDebugVersion(),
                weapons: true,
                missilesInLaunchers: graphics.areMissilesInLaunchersVisible(),
                thrusterParticles: !preview,
                projectileResources: !preview,
                missileResources: !preview,
                explosion: !preview,
                damageIndicators: !preview,
                cameraConfigurations: !preview,
                lightSources: !preview,
                blinkers: !preview,
                jumpEngine: !preview,
                shield: !preview,
                sound: !preview
            }, {
                randomAnimationTime: true,
                smallestSizeWhenDrawn: preview ? previewParams.smallestSizeWhenDrawn : undefined,
                shaderName: preview ? previewParams.spacecraftShaderName : null
            }, preview ? callback.bind(this, this._spacecrafts[i], friendly ? friendlyColor : hostileColor) : null);
            if (targetScene) {
                this._spacecrafts[i].addToScene(targetScene, graphics.getMaxLoadedLOD(), true, {
                    weapons: true
                }, {
                    shaderName: config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_VIEW_TARGET_ITEM_SHADER)
                });
            }
            if (!this._spacecrafts[i].isAway()) {
                this._hitObjects.push(this._spacecrafts[i]);
            } else {
                this._spacecrafts[i].addEventHandler(SpacecraftEvents.JUMPED_IN, this._handleSpacecraftJumpIn.bind(this, this._spacecrafts[i]));
            }
        }
        if (!preview) {
            resources.executeWhenReady(function () {
                if (this._views.length > 0) {
                    for (i = 0; i < this._views.length; i++) {
                        battleScene.addCameraConfiguration(this.createCameraConfigurationForSceneView(this._views[i], battleScene));
                        if (i === 0) {
                            battleScene.getCamera().followNode(null, true, 0);
                        }
                    }
                } else if (this.getPilotedSpacecraft()) {
                    battleScene.getCamera().followNode(this.getPilotedSpacecraft().getVisualModel().getNode(), true, 0, null, config.getDefaultCamerConfigurationName(this.getPilotedSpacecraft()));
                }
                battleScene.getCamera().update(0);
                // prefilling the pools with objects to avoid creating lots of new objects at the start of the mission as the pools grow
                _particlePool.prefill(Math.ceil(this.getMaxParticleCount() * config.getSetting(config.BATTLE_SETTINGS.PARTICLE_POOL_PREFILL_FACTOR)));
                _projectilePool.prefill(Math.ceil(this.getMaxProjectileCount() * config.getSetting(config.BATTLE_SETTINGS.PROJECTILE_POOL_PREFILL_FACTOR)), function (proj) {
                    proj.createVisualModel();
                });
                _missilePool.prefill(Math.ceil(this.getMaxMissileCount() * config.getSetting(config.BATTLE_SETTINGS.MISSILE_POOL_PREFILL_FACTOR)), function (miss) {
                    miss.createVisualModel();
                });
                _explosionPool.prefill(Math.ceil(this.getMaxExplosionCount() * config.getSetting(config.BATTLE_SETTINGS.EXPLOSION_POOL_PREFILL_FACTOR)), function (exp) {
                    exp.createVisualModel();
                });
                _trailSegmentPool.prefill(Math.ceil(this.getMaxMissileCount() * config.getSetting(config.BATTLE_SETTINGS.MISSILE_POOL_PREFILL_FACTOR) * config.getSetting(config.BATTLE_SETTINGS.TRAIL_SEGMENT_POOL_PREFILL_FACTOR)));
            }.bind(this));
        }
    };
    /**
     * Toggles the visibility of the hitboxes of all spacecrafts in the mission.
     */
    Mission.prototype.toggleHitboxVisibility = function () {
        var i;
        for (i = 0; i < this._spacecrafts.length; i++) {
            this._spacecrafts[i].toggleHitboxVisibility();
        }
    };
    /**
     * Function to execute during every simulation step on projectiles taken from the projectile pool
     * @param {Number} dt The elapsed time since the last simulation step
     * @param {Octree} octree An octree containing the objects that can be hit by the projectiles
     * @param {Projectile} projectile The projectile to handle 
     * @param {Number} indexInPool The index of the projectile within the projectile pool
     */
    Mission._handleProjectile = function (dt, octree, projectile, indexInPool) {
        projectile.simulate(dt, octree, this._pilotedCraft);
        if (projectile.canBeReused()) {
            _projectilePool.markAsFree(indexInPool);
        }
    };
    /**
     * Function to execute during every simulation step on missiles taken from the missile pool
     * @param {Number} dt The elapsed time since the last simulation step
     * @param {Octree} octree An octree containing the objects that can be hit by the missiles
     * @param {Missile} missile The missile to handle
     * @param {Number} indexInPool The index of the missile within the missile pool
     */
    Mission._handleMissile = function (dt, octree, missile, indexInPool) {
        missile.simulate(dt, octree, this._pilotedCraft);
        if (missile.canBeReused()) {
            _missilePool.markAsFree(indexInPool);
        }
    };
    /**
     * Function to execute during every simulation step on trail segments taken from the pool
     * @param {TrailSegment} segment The trail segment to handle
     * @param {Number} indexInPool The index of the segment within the pool
     */
    Mission._handleTrailSegment = function (segment, indexInPool) {
        if (segment.canBeReused()) {
            _trailSegmentPool.markAsFree(indexInPool);
        }
    };
    /**
     * Function to execute during every simulation step on explosions taken from the explosion pool
     * @param {Explosion} explosion The explosion to handle
     * @param {Number} indexInPool The index of the explosion within the explosion pool
     */
    Mission._handleExplosion = function (explosion, indexInPool) {
        if (explosion.canBeReused()) {
            _explosionPool.markAsFree(indexInPool);
        }
    };
    /**
     * Function to execute during every simulation step on particles taken from the particle pool
     * @param {Particle} particle The particle to handle
     * @param {Number} indexInPool The index of the particle within the particle pool
     */
    Mission._handleParticle = function (particle, indexInPool) {
        if (particle.canBeReused()) {
            _particlePool.markAsFree(indexInPool);
        }
    };
    /**
     * Function to filter out those actions from the scheduled action list that still need to be executed after this simulation step
     * @param {Object} actionEntry
     * @returns {Boolean}
     */
    Mission._filterActionEntry = function (actionEntry) {
        return actionEntry.delay > 0;
    };
    /**
     * Call after resources have been loaded and the mission is ready to be started to finish off preparations.
     * Adds the particle systems to the scene and sets up their initial position.
     * @param {Scene} scene
     * @returns {Boolean}
     */
    Mission.prototype.prepareScene = function (scene) {
        if (this._environment.addParticleEffectsToScene(scene)) {
            this._environment.simulate();
            return true;
        }
        return false;
    };
    /**
     * Performs the physics and game logic simulation of all the object in the mission.
     * @param {Number} dt The time passed since the last simulation step, in milliseconds.
     * @param {Scene} mainScene When given, this scene is updated according to the simulation.
     */
    Mission.prototype.tick = function (dt, mainScene) {
        var i, v, octree, index;
        if (this._environment) {
            this._environment.simulate();
        }
        for (i = 0; i < this._actionQueue.length; i++) {
            this._actionQueue[i].delay -= dt;
            if (this._actionQueue[i].delay <= 0) {
                this._actionQueue[i].action.execute(this);
            }
        }
        this._actionQueue = this._actionQueue.filter(Mission._filterActionEntry);
        for (i = 0; i < this._events.length; i++) {
            this._events[i].simulate(this, (!this._pilotedCraft || !this._pilotedCraft.isAway()) ? dt : 0); // event timers are stopped when the player jumps out
        }
        for (i = 0; i < this._spacecrafts.length; i++) {
            this._spacecrafts[i].simulate(dt);
            if (this._spacecrafts[i].canBeReused() || this._spacecrafts[i].isAway()) {
                index = this._hitObjects.indexOf(this._spacecrafts[i]);
                if (index >= 0) {
                    this._hitObjects[index] = null;
                    this._hitObjects.splice(index, 1);
                }
                if (this._spacecrafts[i].canBeReused()) {
                    this._spacecrafts[i].destroy(true);
                    this._spacecrafts[i] = null;
                    this._spacecrafts.splice(i, 1);
                    i--;
                }
            } else if (_showHitboxesForHitchecks) {
                this._spacecrafts[i].hideHitbox();
            }
        }
        if (_projectilePool.hasLockedObjects()) {
            octree = new Octree(this._hitObjects, 2, 1, true);
            _projectilePool.executeForLockedObjects(Mission._handleProjectile.bind(this, dt, octree));
        }
        if (_missilePool.hasLockedObjects()) {
            octree = octree || new Octree(this._hitObjects, 2, 1, true);
            _missilePool.executeForLockedObjects(Mission._handleMissile.bind(this, dt, octree));
        }
        if (_explosionPool.hasLockedObjects()) {
            _explosionPool.executeForLockedObjects(Mission._handleExplosion);
        }
        if (_particlePool.hasLockedObjects()) {
            _particlePool.executeForLockedObjects(Mission._handleParticle);
        }
        if (_trailSegmentPool.hasLockedObjects()) {
            _trailSegmentPool.executeForLockedObjects(Mission._handleTrailSegment);
        }
        // moving the scene back to the origo if the camera is too far away to avoid floating point errors becoming visible
        if (mainScene) {
            v = mainScene.moveCameraToOrigoIfNeeded(config.getSetting(config.BATTLE_SETTINGS.MOVE_TO_ORIGO_DISTANCE));
            if (v) {
                ai.handleSceneMoved(v);
            }
        }
        this._updateState();
        if (application.isDebugVersion()) {
            _debugInfo =
                    "Part: " + _particlePool.getLockedObjectCount() + " / " + _particlePool._objects.length + "<br/>" +
                    "Proj: " + _projectilePool.getLockedObjectCount() + " / " + _projectilePool._objects.length + "<br/>" +
                    "Miss: " + _missilePool.getLockedObjectCount() + " / " + _missilePool._objects.length + "<br/>" +
                    "Expl: " + _explosionPool.getLockedObjectCount() + " / " + _explosionPool._objects.length + "<br/>" +
                    "Trai: " + _trailSegmentPool.getLockedObjectCount() + " / " + _trailSegmentPool._objects.length;
        }
    };
    /**
     * Removes all references to other objects for proper cleanup of memory.
     */
    Mission.prototype.destroy = function () {
        var i;
        if (this._environment) {
            if (this._ownsEnvironment) {
                this._environment.destroy();
            } else {
                this._environment.removeFromScene();
            }
        }
        this._environment = null;
        if (this._views) {
            for (i = 0; i < this._views.length; i++) {
                if (this._views[i]) {
                    this._views[i].destroy();
                    this._views[i] = null;
                }
            }
            this._views = null;
        }
        if (this._spacecrafts) {
            for (i = 0; i < this._spacecrafts.length; i++) {
                if (this._spacecrafts[i]) {
                    this._spacecrafts[i].destroy();
                    this._spacecrafts[i] = null;
                }
            }
            this._spacecrafts = null;
        }
        this._pilotedCraft = null;
        this._hitObjects = null;
        _particlePool.clear();
        _projectilePool.clear();
        _missilePool.clear();
        _explosionPool.clear();
        _trailSegmentPool.clear();
    };
    // #########################################################################
    /**
     * @typedef {Object} MissionDescriptor~LocalData
     * @property {Number} bestScore 
     * @property {String} bestPerformance
     * @property {Number} winCount
     * @property {Number} loseCount
     */
    /**
     * @class Stores the data needed to initialize a mission. Used so that the data can be accessed (such as description, objectives) before
     * creating the Mission object itself (with all spacecrafts etc for the battle simulation) i.e. during mission briefing
     * @extends JSONResource
     * @param {Object} dataJSON The object storing the mission data or a reference to the file which stores the data
     * @param {String} folder The ID of the folder from where to load the data file in case the data passed here just stores a reference
     */
    function MissionDescriptor(dataJSON, folder) {
        resourceManager.JSONResource.call(this, dataJSON, folder, true);
        /**
         * Returns whether the mission described is a test mission (to be listed only in debug mode)
         * @type Boolean
         */
        this._test = (this._dataJSON.test === true);
        /**
         * Whether this is mission descriptor loaded from a user selected file
         * @type Boolean
         */
        this._custom = (this._dataJSON.custom === true);
        /**
         * The cached value of the spacecraft descriptor object belonging to the piloted spacecraft
         * (since it might need to be extracted from a bulk spacecraft descriptor, so that the extraction is only done the first time)
         * @type Object
         */
        this._pilotedSpacecraftDescriptor = null;
        /**
         * The data that is saved to / loaded from local storage about this mission
         * @type MissionDescriptor~LocalData
         */
        this._localData = JSON.parse(localStorage[this._getLocalStorageID()] || "{}");
        this._initLocalData();
    }
    MissionDescriptor.prototype = new resourceManager.JSONResource();
    MissionDescriptor.prototype.constructor = MissionDescriptor;
    /**
     * Initializes missing values within the object storing the local data for the mission descriptor
     * (those which are not allowed to be undefined)
     */
    MissionDescriptor.prototype._initLocalData = function () {
        var i, data, difficulties = _context.getDifficultyNames();
        for (i = 0; i < difficulties.length; i++) {
            this._localData[difficulties[i]] = this._localData[difficulties[i]] || {};
            data = this._localData[difficulties[i]];
            data.winCount = data.winCount || 0;
            data.loseCount = data.loseCount || 0;
        }
    };
    /**
     * Returns the location ID to use when saving/loading the best score value to/from local storage
     * @returns {String}
     */
    MissionDescriptor.prototype._getLocalStorageID = function () {
        return MODULE_LOCAL_STORAGE_PREFIX + this.getName();
    };
    /**
     * Updates the data saved of this mission in local storage
     */
    MissionDescriptor.prototype._saveLocalData = function () {
        localStorage[this._getLocalStorageID()] = JSON.stringify(this._localData);
    };
    /**
     * Returns whether the mission described is a test mission (to be listed only in debug mode)
     * @returns {Boolean}
     */
    MissionDescriptor.prototype.isTest = function () {
        return this._test;
    };
    /**
     * Returns whether the mission described is a test mission (to be listed only in debug mode)
     * @returns {Boolean}
     */
    MissionDescriptor.prototype.isCustom = function () {
        return this._custom;
    };
    /**
     * Returns the mission title as given in the data JSON
     * @returns {String} 
     */
    MissionDescriptor.prototype.getTitle = function () {
        return this._dataJSON.title || "";
    };
    /**
     * Returns the raw description of this mission (as given in the data JSON)
     * @returns {String} 
     */
    MissionDescriptor.prototype.getDescription = function () {
        return this._dataJSON.description || "";
    };
    /**
     * Returns the author who created this mission (for custom missions).
     * @returns {String}
     */
    MissionDescriptor.prototype.getAuthor = function () {
        return this._dataJSON.info ? this._dataJSON.info.author : null;
    };
    /**
     * Returns the user-friendly, translated and fallback protected version of the description of this mission.
     * @returns {String} 
     */
    MissionDescriptor.prototype.getDisplayDescription = function () {
        return strings.get(
                strings.MISSION.PREFIX, utils.getFilenameWithoutExtension(this.getName()) + strings.MISSION.DESCRIPTION_SUFFIX.name,
                (this.getDescription() ?
                        utils.formatString(strings.get(strings.MISSIONS.NO_TRANSLATED_DESCRIPTION), {
                            originalDescription: this.getDescription()
                        }) :
                        strings.get(strings.MISSIONS.NO_DESCRIPTION)));
    };
    /**
     * Returns the descriptor of the spacecraft the user is piloting in this mission.
     * @returns {Object}
     */
    MissionDescriptor.prototype.getPilotedSpacecraftDescriptor = function () {
        var i, result;
        if (!this._pilotedSpacecraftDescriptor) {
            for (i = 0; i < this._dataJSON.spacecrafts.length; i++) {
                if (this._dataJSON.spacecrafts[i].piloted) {
                    this._pilotedSpacecraftDescriptor = this._dataJSON.spacecrafts[i];
                    break;
                }
                if (this._dataJSON.spacecrafts[i].pilotedIndex) {
                    result = utils.deepCopy(this._dataJSON.spacecrafts[i]);
                    if (result.names) {
                        result.name = result.names[result.pilotedIndex - 1];
                        delete result.names;
                    }
                    if (result.loadouts) {
                        result.loadout = result.loadouts[result.pilotedIndex - 1];
                        delete result.loadouts;
                    }
                    delete result.count;
                    delete result.pilotedIndex;
                    delete result.positions;
                    delete result.formation;
                    this._pilotedSpacecraftDescriptor = result;
                    break;
                }
            }
        }
        return this._pilotedSpacecraftDescriptor;
    };
    /**
     * Returns the environment of the described mission.
     * Only works after the mission data has been loaded!
     * @returns {Environment}
     */
    MissionDescriptor.prototype.getEnvironment = function () {
        var mission = null;
        if (this.isReadyToUse()) {
            mission = new Mission(this.getName());
            mission.loadEnvironment(this._dataJSON);
            return mission.getEnvironment();
        }
        application.showError("Cannot get mission environment from mission descriptor that has not yet been initialized!");
        return null;
    };
    /**
     * Returns a list of translated HTML strings that can be used to display the objectives of this mission to the player.
     * Only works if the mission data file has already been loaded!
     * @returns {String[]}
     */
    MissionDescriptor.prototype.getMissionObjectives = function () {
        var mission = null;
        if (this.isReadyToUse()) {
            mission = new Mission(this.getName());
            mission.loadObjectives(this._dataJSON);
            return mission.getObjectives();
        }
        application.showError("Cannot get mission objectives from mission descriptor that has not yet been initialized!");
        return null;
    };
    /**
     * Returns the list of string IDs for gameplay tips that can be displayed for the player at the start of this mission.
     * (overrides the global list)
     * @returns {String[]}
     */
    MissionDescriptor.prototype.getTipIDs = function () {
        return this._dataJSON.tips;
    };
    /**
     * Creates and returns a Mission object based on the data stored in this descriptor. Only works if the data has been loaded - either it
     * was given when constructing this object, or it was requested and has been loaded
     * @param {String} difficulty The string ID of the difficulty level to use
     * @param {Boolean} demoMode Whether to load the created mission in demo mode
     * @returns {Mission}
     */
    MissionDescriptor.prototype.createMission = function (difficulty, demoMode) {
        var result = null;
        if (this.isReadyToUse()) {
            result = new Mission(this.getName());
            result.loadFromJSON(this._dataJSON, difficulty, demoMode);
        } else {
            application.showError("Cannot create mission from descriptor that has not yet been initialized!");
        }
        return result;
    };
    /**
     * Returns the current best score reached for the mission (also stored in local storage)
     * @param {String} [difficulty] The string ID of the difficulty level to consider (if not given, the currently set difficulty will be used)
     * @returns {Number}
     */
    MissionDescriptor.prototype.getBestScore = function (difficulty) {
        difficulty = difficulty || _context.getDifficulty();
        return this._localData[difficulty].bestScore;
    };
    /**
     * Returns the ID of the best performance level reached for the mission (also stored in local storage)
     * @param {String} [difficulty] The string ID of the difficulty level to consider (if not given, the currently set difficulty will be used)
     * @returns {String}
     */
    MissionDescriptor.prototype.getBestPerformance = function (difficulty) {
        difficulty = difficulty || _context.getDifficulty();
        return this._localData[difficulty].bestPerformance;
    };
    /**
     * Checks whether the passed score exceeds the current best score of the mission, and if so, updates the value both in this object and in
     * local storage
     * @param {Number} score
     * @param {String} performance The ID of the achieved performance level
     * @param {String} [difficulty] The string ID of the difficulty level to consider (if not given, the currently set difficulty will be used)
     * @returns {Boolean}
     */
    MissionDescriptor.prototype.updateBestScore = function (score, performance, difficulty) {
        difficulty = difficulty || _context.getDifficulty();
        var data = this._localData[difficulty];
        if ((data.bestScore === undefined) || (score > data.bestScore)) {
            data.bestScore = score;
            data.bestPerformance = performance;
            this._saveLocalData();
            return true;
        }
        return false;
    };
    /**
     * Increases the win or lose count of the mission depending on the passed parameter, and saves the new data to local storage
     * @param {Boolean} victory
     * @param {String} [difficulty] The string ID of the difficulty level to consider (if not given, the currently set difficulty will be used)
     */
    MissionDescriptor.prototype.increasePlaythroughCount = function (victory, difficulty) {
        difficulty = difficulty || _context.getDifficulty();
        if (victory) {
            this._localData[difficulty].winCount++;
        } else {
            this._localData[difficulty].loseCount++;
        }
        this._saveLocalData();
    };
    /**
     * Returns the number of times this mission has been won by the player
     * @param {String} [difficulty] The string ID of the difficulty level to consider (if not given, the currently set difficulty will be used)
     * @returns {Number}
     */
    MissionDescriptor.prototype.getWinCount = function (difficulty) {
        difficulty = difficulty || _context.getDifficulty();
        return this._localData[difficulty].winCount;
    };
    // #########################################################################
    /**
     * @class Represents a game difficulty level the player can set which is then used to adjust the values of some
     * in-game variables (e.g. armor of the player) to make the game more or less challenging. Mision performance is
     * tracked separately for each difficulty level.
     * The levels can be defined in config.json.
     * @param {Object} dataJSON Contains the data to initialize the difficulty level from
     */
    function DifficultyLevel(dataJSON) {
        /**
         * The string ID of this difficulty level
         * @type String
         */
        this._name = dataJSON.name;
        /*
         * The number of hitpoints the player's spacecraft has at the start of the mission is multiplied by this factor
         * (when playing on the corresponding difficulty level)
         * @type Number
         */
        this._playerHitpointsFactor = dataJSON.playerHitpointsFactor;
        /*
         * The number of hitpoints the friendly spacecrafts have at the start of the mission is multiplied by this factor
         * (when playing on the corresponding difficulty level)
         * @type Number
         */
        this._friendlyHitpointsFactor = dataJSON.friendlyHitpointsFactor;
        /*
         * The reaction time of hostile AI is multiplied by this factor
         * (when playing on the corresponding difficulty level)
         * @type Number
         */
        this._enemyReactionTimeFactor = dataJSON.enemyReactionTimeFactor;
        /**
         * Whether the player ship can damage itself (e.g. by flying into its own launched missile)
         * (when playing on the corresponding difficulty level)
         * @type Boolean
         */
        this._playerSelfDamage = dataJSON.playerSelfDamage;
        /**
         * Whether friendly fire can damage the player ship
         * (when playing on the corresponding difficulty level)
         * @type Boolean
         */
        this._playerFriendlyFireDamage = dataJSON.playerFriendlyFireDamage;
        /**
         * The offset (i.e. enlargement) to apply to hitboxes when the player is shooting hostiles, in meters
         * (when playing on the corresponding difficulty level)
         * @type Number
         */
        this._hitboxOffset = dataJSON.hitboxOffset;
    }
    /**
     * Returns the string ID for this difficulty level
     * @returns {String}
     */
    DifficultyLevel.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the factor by which to multiply the hitpoints of the player's spacecraft at the start of the mission.
     * @returns {Number}
     */
    DifficultyLevel.prototype.getPlayerHitpointsFactor = function () {
        return this._playerHitpointsFactor;
    };
    /**
     * Returns the factor by which to multiply the hitpoints of friendly spacecrafts at the start of the mission.
     * @returns {Number}
     */
    DifficultyLevel.prototype.getFriendlyHitpointsFactor = function () {
        return this._friendlyHitpointsFactor;
    };
    /**
     * Returns the factor by which to multiply the reaction time of enemy AIs.
     * @returns {Number}
     */
    DifficultyLevel.prototype.getEnemyReactionTimeFactor = function () {
        return this._enemyReactionTimeFactor;
    };
    /**
     * Whether the player ship can damage itself (e.g. by flying into its own launched missile)
     * @returns {Boolean}
     */
    DifficultyLevel.prototype.getPlayerSelfDamage = function () {
        return this._playerSelfDamage;
    };
    /**
     * Whether friendly fire can damage the player ship
     * @returns {Boolean}
     */
    DifficultyLevel.prototype.getPlayerFriendlyFireDamage = function () {
        return this._playerFriendlyFireDamage;
    };
    /**
     * The offset (i.e. enlargement) to apply to hitboxes when the player is shooting hostiles, in meters
     * @returns {Number}
     */
    DifficultyLevel.prototype.getHitboxOffset = function () {
        return this._hitboxOffset;
    };
    // #########################################################################
    /**
     * @class The performance of players during missions is evaluated and classified into one of several levels upon the completion of the
     * missions. A corresponding medal can be earned for each performance level. The levels can be defined in config.json.
     * @param {Object} dataJSON Contains the data to initialize the performance level from
     */
    function MissionPerformanceLevel(dataJSON) {
        /**
         * The string ID of this performance level
         * @type String
         */
        this._name = dataJSON.name;
        /*
         * To achieve this performance level, the player needs to earn a base score that is not less than the reference score for the 
         * mission multiplied by this factor (for team missions only)
         * @type Number
         */
        this._referenceBaseScoreFactor = dataJSON.referenceBaseScoreFactor;
        /*
         * To achieve this performance level, the player needs to complete the mission with a hit ratio not less than this value
         * @type Number
         */
        this._referenceHitRatio = dataJSON.referenceHitRatio;
        /*
         * To achieve this performance level, the player needs to complete the mission with a hull integrity not less than this value
         * @type Number
         */
        this._referenceHullIntegrity = dataJSON.referenceHullIntegrity;
        /*
         * To achieve this performance level, the player needs to complete the mission with a team survival rate not less than this value
         * (for team missions only)
         * @type Number
         */
        this._referenceTeamSurvival = dataJSON.referenceTeamSurvival;
    }
    /**
     * Returns the string ID for this performance level
     * @returns {String}
     */
    MissionPerformanceLevel.prototype.getName = function () {
        return this._name;
    };
    /**
     * Returns the amount of score points required in the passed mission to earn this performance level.
     * @param {Mission} mission
     * @returns {Number}
     */
    MissionPerformanceLevel.prototype.getRequiredScore = function (mission) {
        return this._referenceBaseScoreFactor ? mission.getScoreStatistics(
                mission.getReferenceScore() * (mission.isTeamMission() ? this._referenceBaseScoreFactor : 1),
                this._referenceHitRatio,
                this._referenceHullIntegrity,
                this._referenceTeamSurvival).score : 0;
    };
    // #########################################################################
    /**
     * @class A class responsible for loading and storing game logic related 
     * settings and data as well and provide an interface to access them.
     * @extends AsyncResource
     */
    function MissionContext() {
        asyncResource.AsyncResource.call(this);
        /**
         * The string ID of the currently set (default) difficulty level
         * @type String
         */
        this._difficulty = null;
        /**
         * Stores the available difficulty levels the player can choose from (defined in config.json)
         * @type DifficultyLevel[]
         */
        this._difficultyLevels = null;
        /**
         * Stores them achievable mission performance levels defined in config.json
         * @type MissionPerformanceLevel[]
         */
        this._missionPerformanceLevels = null;
        /**
         * The string IDs for gameplay tips that can be displayed for the player at the start of missions.
         * The list is defined in config.json.
         * @type String[]
         */
        this._tipIDs = null;
        /**
         * Stores (and manages the loading of) the descriptors for the missions.
         * @type ResourceManager
         */
        this._missionManager = new resourceManager.ResourceManager();
    }
    MissionContext.prototype = new asyncResource.AsyncResource();
    MissionContext.prototype.constructor = MissionContext;
    /**
     * Returns an object containing the performance level the player earned in this mission as well as (if available) the next (one level
     * higher) performance level that can be achieved and how many score points are necessary for earning it.
     * (assuming the mission has been successfully completed)
     * @param {Mission} mission The mission the player completed
     * @param {Number} score The final score the player achieved
     * @returns {Object}
     */
    MissionContext.prototype.getPerformanceInfo = function (mission, score) {
        var i, result = {}, length = this._missionPerformanceLevels.length;
        for (i = 0; i < length; i++) {
            if (score < this._missionPerformanceLevels[i].getRequiredScore(mission)) {
                break;
            }
        }
        result.performance = (i > 0) ? this._missionPerformanceLevels[i - 1].getName() : FAILED_MISSION_PERFORMACE;
        result.nextPerformance = (i < length) ? this._missionPerformanceLevels[i].getName() : null;
        result.nextPerformanceScore = result.nextPerformance ? this._missionPerformanceLevels[i].getRequiredScore(mission) : 0;
        return result;
    };
    /**
     * Returns an object containing the required scores for the passed mission for all the stored mission performance levels.
     * The keys are the IDs of the performance levels and the values are the scores.
     * @param {Mission} mission
     * @returns {Object}
     */
    MissionContext.prototype.getPerformanceLevelScores = function (mission) {
        var i, result = {};
        for (i = 0; i < this._missionPerformanceLevels.length; i++) {
            result[this._missionPerformanceLevels[i].getName()] = this._missionPerformanceLevels[i].getRequiredScore(mission);
        }
        return result;
    };
    /**
     * Loads the general game logic configuration defined in the passed JSON object (from config.json), such as available mission 
     * performance or difficulty levels.
     * @param {Object} dataJSON
     */
    MissionContext.prototype.loadConfigurationFromJSON = function (dataJSON) {
        var i;
        this._difficultyLevels = [];
        for (i = 0; i < dataJSON.difficultyLevels.length; i++) {
            this._difficultyLevels.push(new DifficultyLevel(dataJSON.difficultyLevels[i]));
        }
        this._missionPerformanceLevels = [];
        for (i = 0; i < dataJSON.missionPerformanceLevels.length; i++) {
            this._missionPerformanceLevels.push(new MissionPerformanceLevel(dataJSON.missionPerformanceLevels[i]));
        }
        this._tipIDs = dataJSON.tips;
    };
    /**
     * Loads the values of the settings which are stored in local storage, such as the chosen default difficulty level.
     */
    MissionContext.prototype.loadSettingsFromLocalStorage = function () {
        var value, params;
        // load default difficulty
        this._difficulty = _context.getDifficultyNames()[0];
        if (localStorage[DIFFICULTY_LOCAL_STORAGE_ID] !== undefined) {
            // settings might be saved in different formats in different game versions, so do not show errors for invalid type if the version
            // has changed since the last run
            params = {
                silentFallback: application.hasVersionChanged(),
                defaultValue: _context.getDifficultyNames()[0]
            };
            value = types.getValueOfTypeFromLocalStorage({baseType: "enum", values: _context.getDifficultyNames()}, DIFFICULTY_LOCAL_STORAGE_ID, params);
            // apply the setting if it is valid or if the game version has changed, in which case the fallback of the invalid setting 
            // (namely the first difficulty level) will be applied and also saved to local storage
            if (!params.error || application.hasVersionChanged()) {
                this.setDifficulty(value, !!params.error && (params.error !== types.Errors.INVALID_ENUM_OBJECT_ERROR));
            }
        }
    };
    // methods
    /**
     * Sends an asynchronous request to grab the file containing the mission
     * descriptions and sets a callback to load those descriptions 
     * and set the resource state of this context to ready when done.
     * @param {Boolean} [loadDescriptors=false] If true, the mission descriptors are also requested and loaded (used for the editor)
     */
    MissionContext.prototype.requestLoad = function (loadDescriptors) {
        var missionAssignment = {}, setToReady = function () {
            this.setToReady();
            this._missionManager.setToReady();
        }.bind(this);
        missionAssignment[MISSION_ARRAY_NAME] = MissionDescriptor;
        this._missionManager.requestConfigLoad(
                config.getConfigurationSetting(config.CONFIGURATION.MISSION_FILES).filename,
                config.getConfigurationSetting(config.CONFIGURATION.MISSION_FILES).folder,
                missionAssignment,
                (loadDescriptors ? function () {
                    this._missionManager.requestAllResources();
                    this._missionManager.executeWhenReady(setToReady);
                    this._missionManager.requestResourceLoad();
                }.bind(this) :
                        setToReady));
    };
    /**
     * Returns the string ID of the currently chosen (default) difficulty level.
     * @returns {String}
     */
    MissionContext.prototype.getDifficulty = function () {
        return this._difficulty;
    };
    /**
     * Sets a new default difficulty level.
     * @param {String} value The string ID identifying the desired option.
     * @param {Boolean} [saveToLocalStorage=true]
     */
    MissionContext.prototype.setDifficulty = function (value, saveToLocalStorage) {
        if (saveToLocalStorage === undefined) {
            saveToLocalStorage = true;
        }
        if (this._difficulty !== value) {
            this._difficulty = value;
            if (saveToLocalStorage) {
                localStorage[DIFFICULTY_LOCAL_STORAGE_ID] = value;
            }
        }
    };
    /**
     * Returns the list of the string IDs of all the available game difficulty levels.
     * @returns {String}
     */
    MissionContext.prototype.getDifficultyNames = function () {
        var i, result = [];
        for (i = 0; i < this._difficultyLevels.length; i++) {
            result.push(this._difficultyLevels[i].getName());
        }
        return result;
    };
    /**
     * Returns the difficulty level object corresponding to the difficulty level identified by the passed string
     * @param {String} name
     * @returns {DifficultyLevel} If no such level exists, null is returned.
     */
    MissionContext.prototype.getDifficultyLevel = function (name) {
        var i;
        for (i = 0; i < this._difficultyLevels.length; i++) {
            if (this._difficultyLevels[i].getName() === name) {
                return this._difficultyLevels[i];
            }
        }
        return null;
    };
    /**
     * Returns the list of string IDs for gameplay tips that can be displayed for the player at the start of missions.
     * The list is defined in config.json.
     * (can be overridden by individual missions)
     * @returns {String[]}
     */
    MissionContext.prototype.getTipIDs = function () {
        return this._tipIDs;
    };
    /**
     * Returns the (file)names of the mission( descriptor)s stored in the mission manager
     * @returns {String[]}
     */
    MissionContext.prototype.getMissionNames = function () {
        var result = [];
        this._missionManager.executeForAllResourcesOfType(MISSION_ARRAY_NAME, function (missionDescriptor) {
            if (application.isDebugVersion() || !missionDescriptor.isTest()) {
                result.push(missionDescriptor.getName());
            }
        }, false, true);
        return result;
    };
    /**
     * Returns a (new) array containing all of the mission descriptors (both loaded and not yet loaded ones)
     * @returns {MissionDescriptor[]}
     */
    MissionContext.prototype.getMissionDescriptors = function () {
        var result = [];
        this._missionManager.executeForAllResourcesOfType(MISSION_ARRAY_NAME, function (missionDescriptor) {
            if (application.isDebugVersion() || !missionDescriptor.isTest()) {
                result.push(missionDescriptor);
            }
        }, false, true);
        return result;
    };
    /**
     * Returns the mission descriptor identified by the passed name (typically the filename e.g. someMission.json)
     * @param {String} name
     * @returns {MissionDescriptor}
     */
    MissionContext.prototype.getMissionDescriptor = function (name) {
        return this._missionManager.getResource(MISSION_ARRAY_NAME, name);
    };
    /**
     * Requests the data (descriptor) for the mission with the passed name to be loaded (if it is not loaded already) and calls the passed 
     * callback with the descriptor as its argument when it is loaded
     * @param {String} name
     * @param {Function} callback
     * @param {Object} [params]
     */
    MissionContext.prototype.requestMissionDescriptor = function (name, callback, params) {
        var missionDescriptor = this._missionManager.getResource(MISSION_ARRAY_NAME, name, params);
        if (missionDescriptor) {
            this._missionManager.requestResourceLoad();
            this._missionManager.executeWhenReady(function () {
                callback(missionDescriptor);
            });
        } else {
            callback(null);
        }
    };
    /**
     * Requests the data (descriptor) for the mission with the passed name to be loaded (if it is not loaded already), creates a mission based 
     * on it and calls the passed callback with the created mission as its argument when it is loaded
     * @param {String} name
     * @param {String} difficulty The string ID of the difficulty level to use
     * @param {Boolean} demoMode Whether to load the created mission in demo mode
     * @param {Function} callback
     */
    MissionContext.prototype.requestMission = function (name, difficulty, demoMode, callback) {
        var missionDescriptor = this._missionManager.getResource(MISSION_ARRAY_NAME, name);
        if (missionDescriptor) {
            this._missionManager.requestResourceLoad();
            this._missionManager.executeWhenReady(function () {
                callback(missionDescriptor.createMission(difficulty, demoMode));
            });
        } else {
            callback(null);
        }
    };
    /**
     * @param {Object} data
     */
    MissionContext.prototype.createMissionDescriptor = function (data) {
        this._missionManager.createResource(MISSION_ARRAY_NAME, data);
    };
    // initializazion
    // obtaining pool references
    _particlePool = pools.getPool(logicConstants.PARTICLE_POOL_NAME, renderableObjects.Particle);
    _projectilePool = pools.getPool(logicConstants.PROJECTILE_POOL_NAME, equipment.Projectile);
    _missilePool = pools.getPool(logicConstants.MISSILE_POOL_NAME, equipment.Missile);
    _trailSegmentPool = pools.getPool(logicConstants.TRAIL_SEGMENT_POOL_NAME, renderableObjects.TrailSegment);
    _explosionPool = pools.getPool(logicConstants.EXPLOSION_POOL_NAME, explosion.Explosion);
    // creating the default context
    _context = new MissionContext();
    // associating condition constructors
    _conditionConstructors = {};
    _conditionConstructors[ConditionType.DESTROYED] = DestroyedCondition;
    _conditionConstructors[ConditionType.COUNT] = CountCondition;
    _conditionConstructors[ConditionType.TIME] = TimeCondition;
    // associating action constructors
    _actionConstructors = {};
    _actionConstructors[ActionType.WIN] = WinAction;
    _actionConstructors[ActionType.LOSE] = LoseAction;
    _actionConstructors[ActionType.MESSAGE] = MessageAction;
    _actionConstructors[ActionType.CLEAR_MESSAGES] = ClearMessagesAction;
    _actionConstructors[ActionType.COMMAND] = CommandAction;
    _actionConstructors[ActionType.HUD] = HUDAction;
    // caching configuration settings
    config.executeWhenReady(function () {
        _showHitboxesForHitchecks = config.getSetting(config.BATTLE_SETTINGS.SHOW_HITBOXES_FOR_HITCHECKS);
        _groupTransformsArrayName = config.getSetting(config.GENERAL_SETTINGS.UNIFORM_GROUP_TRANSFORMS_ARRAY_NAME);
    });
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        ConditionType: ConditionType,
        TriggerWhen: TriggerWhen,
        TriggerWhich: TriggerWhich,
        DestroyedConditionWhich: DestroyedConditionWhich,
        CountConditionRelation: CountConditionRelation,
        TimeConditionWhen: TimeConditionWhen,
        ActionType: ActionType,
        MissionState: MissionState,
        ObjectiveState: ObjectiveState,
        SubjectGroup: SubjectGroup,
        createCondition: createCondition,
        FAILED_MISSION_PERFORMACE: FAILED_MISSION_PERFORMACE,
        loadConfigurationFromJSON: _context.loadConfigurationFromJSON.bind(_context),
        loadSettingsFromLocalStorage: _context.loadSettingsFromLocalStorage.bind(_context),
        requestLoad: _context.requestLoad.bind(_context),
        executeWhenReady: _context.executeWhenReady.bind(_context),
        getDebugInfo: getDebugInfo,
        getDifficulty: _context.getDifficulty.bind(_context),
        setDifficulty: _context.setDifficulty.bind(_context),
        getDifficultyNames: _context.getDifficultyNames.bind(_context),
        getTipIDs: _context.getTipIDs.bind(_context),
        getMissionNames: _context.getMissionNames.bind(_context),
        getMissionDescriptor: _context.getMissionDescriptor.bind(_context),
        getMissionDescriptors: _context.getMissionDescriptors.bind(_context),
        requestMissionDescriptor: _context.requestMissionDescriptor.bind(_context),
        requestMission: _context.requestMission.bind(_context),
        createMissionDescriptor: _context.createMissionDescriptor.bind(_context)
    };
});
/**
 * Copyright 2016-2017, 2020 Krisztián Nagy
 * @file Provides some common functions to be used for the Interstellar Armada editor.
 * Interstellar Armada for the editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param utils Used for converting between float / hex colors
 * @param resources Used for obtaining resource references
 * @param classes Used for obtaining class references
 * @param environments Used for obtaining environments
 * @param missions Used for obtaining mission descriptors
 */
define('editor/common',[
    "utils/utils",
    "modules/media-resources",
    "armada/logic/classes",
    "armada/logic/environments",
    "armada/logic/missions"
], function (utils, resources, classes, environments, missions) {
    "use strict";
    /**
     * @typedef {Object} Editor~Item
     * @property {String} type (enum ItemType)
     * @property {String} name
     * @property {String} category
     * @property {GenericResource|GenericClass} reference
     * @property {Object} data
     */
    /**
     * @typedef {Object} Editor~Preview
     * @property {Function} refresh
     * @property {Function} handleDataChanged
     * @property {Function} handleStartEdit
     * @property {Function} handleStopEdit
     */
    var
            // ------------------------------------------------------------------------------
            // Enums
            /**
             * Selectable items must be one of these types
             * @enum {String}
             * @type Object
             */
            ItemType = {
                NONE: "none",
                RESOURCE: "resources",
                CLASS: "classes",
                ENVIRONMENT: "environments",
                MISSION: "missions"
            },
            // ------------------------------------------------------------------------------
            // Constants
            LABEL_CLASS = "label",
            NUMERIC_INPUT_CLASS = "numericInput",
            COLOR_COMPONENT_CLASS = "colorComponent",
            COLOR_PICKER_CLASS = "colorPicker",
            COLOR_INPUT_CLASS = "colorInput",
            COLOR_PREVIEW_CLASS = "colorPreview",
            VECTOR_COMPONENT_CLASS = "vectorComponent",
            RANGE_CHECKBOX_CLASS = "rangeCheckbox",
            RANGE_NUMERIC_INPUT_CLASS = "rangeNumericInput",
            POPUP_CLASS = "popup",
            POPUP_START_Z_INDEX = 1000,
            POPUP_RIGHT_MARGIN = 4,
            POPUP_BOTTOM_MARGIN = 4,
            EVENT_SHOW_NAME = "show",
            EVENT_HIDE_NAME = "hide",
            // ------------------------------------------------------------------------------
            // Private variables
            /**
             * A list of the root level Popups added to document.body
             * @type Popup[]
             */
            _popups = [],
            /**
             * The current highest Z index, assigned to the last popup element
             * @type Number
             */
            _maxZIndex;
    // ------------------------------------------------------------------------------
    // Public functions
    /**
     * Returns the game class (resource / class) the passed item references
     * @param {Editor~Item} item
     * @param {Boolean} [allowNullResult=false]
     * @returns {GenericResource|GenericClass}
     */
    function getItemReference(item, allowNullResult) {
        var result, params = allowNullResult ? {allowNullResult: true} : null;
        switch (item.type) {
            case ItemType.RESOURCE:
                return resources.getResource(item.category, item.name, params);
            case ItemType.CLASS:
                return classes.getClass(item.category, item.name, params);
            case ItemType.ENVIRONMENT:
                return environments.getEnvironment(item.name);
            case ItemType.MISSION:
                missions.requestMissionDescriptor(item.name, function (missionDescriptor) {
                    result = missionDescriptor;
                }, params);
                return result;
            default:
                document.crash();
        }
        return null;
    }
    /**
     * Returns the game items (resources / classes / ...) that are in the same category as the passed item
     * @param {Editor~Item} item
     * @returns {(GenericResource|GenericClass)[]}
     */
    function getItemReferencesOfSameCategory(item) {
        var names, result = [], i;
        switch (item.type) {
            case ItemType.RESOURCE:
                names = resources.getResourceNames(item.category);
                for (i = 0; i < names.length; i++) {
                    result.push(resources.getResource(item.category, names[i]));
                }
                break;
            case ItemType.CLASS:
                names = classes.getClassNames(item.category);
                for (i = 0; i < names.length; i++) {
                    result.push(classes.getClass(item.category, names[i]));
                }
                break;
            case ItemType.ENVIRONMENT:
                names = environments.getEnvironmentNames();
                for (i = 0; i < names.length; i++) {
                    result.push(environments.getEnvironment(names[i]));
                }
                break;
            case ItemType.MISSION:
                break;
            default:
                document.crash();
        }
        return result;
    }
    /**
     * Creates and returns a simple label - a span with a style and the given text content
     * @param {String} text
     * @returns {Element}
     */
    function createLabel(text) {
        var result = document.createElement("span");
        result.classList.add(LABEL_CLASS);
        result.innerHTML = text;
        return result;
    }
    /**
     * Creates and returns a button.
     * @param {String} caption The text to show on the button (innerHTML)
     * @param {Function} clickHandler The handler for the click event on the button
     * @param {String} [tooltip] The tooltip to display when hovering over the button
     * @returns {Element}
     */
    function createButton(caption, clickHandler, tooltip) {
        var result = document.createElement("button");
        result.textContent = caption;
        result.type = "button";
        result.onclick = clickHandler;
        if (tooltip) {
            result.title = tooltip;
        }
        return result;
    }
    /**
     * Creates and returns a control that can be used to edit boolean values.
     * @param {Boolean} data The starting value
     * @param {Function} [changeHandler] The function that should be run on the change event
     * @returns {Element}
     */
    function createBooleanInput(data, changeHandler) {
        var result = document.createElement("input");
        result.type = "checkbox";
        result.checked = data;
        result.onchange = changeHandler ? function () {
            changeHandler(result.checked);
        } : null;
        return result;
    }
    /**
     * @typedef {Object} NumericParams
     * @property {Boolean} integer If true, only integer values are allowed (otherwise floats as well)
     * @property {Number} [min] Minimum allowed value
     * @property {Number} [max] Maximum allowed value
     */
    /**
     * Creates and returns a control that can be used to edit numeric values.
     * @param {Number} data The starting value
     * @param {NumericParams} params
     * @param {Function} [changeHandler] The function that should be run on the change event, after checking the value to be a number
     * @returns {Element}
     */
    function createNumericInput(data, params, changeHandler) {
        var result = document.createElement("input");
        result.classList.add(NUMERIC_INPUT_CLASS);
        result.type = "text";
        result.value = data;
        result.onchange = function () {
            var number = params.integer ? parseInt(result.value, 10) : parseFloat(result.value);
            if (isNaN(number)) {
                number = 0;
            }
            if ((params.min !== undefined) && (number < params.min)) {
                number = params.min;
            }
            if ((params.max !== undefined) && (number > params.max)) {
                number = params.max;
            }
            result.value = number.toString();
            if (changeHandler) {
                changeHandler(number);
            }
        };
        return result;
    }
    /**
     * Sets the appropriate <option> tags for the passed <select> element to correspond to the list of options specified in the passed
     * string list (with text contents and value attributes both being equal to the strings)
     * @param {Element} selector
     * @param {String[]} options
     */
    function setSelectorOptions(selector, options) {
        var i, s = "";
        for (i = 0; i < options.length; i++) {
            s += '<option value="' + options[i] + '">' + options[i] + '</option>';
        }
        selector.innerHTML = s;
    }
    /**
     * Returns the list of options available in the passed HTML <select> element as an array of strings
     * @param {Element} selector
     * @returns {String[]} 
     */
    function getSelectorOptions(selector) {
        var i, result = [];
        for (i = 0; i < selector.options.length; i++) {
            result.push(selector.options[i].value);
        }
        return result;
    }
    /**
     * Creates and returns an HTML <select> element storing the given options (with the same value and text)
     * @param {String[]} options The options to include in the element
     * @param {String} selected The initial text of the element (should be one of the options)
     * @param {Boolean} includeNone If true, an additional, "none" option will be included as the first one
     * @param {Function} onchange The function to set as the element's onchange handler.
     * @returns {Element}
     */
    function createSelector(options, selected, includeNone, onchange) {
        var result = document.createElement("select");
        if (includeNone) {
            options = ["none"].concat(options);
        }
        setSelectorOptions(result, options);
        if (selected && (options.indexOf(selected) >= 0)) {
            result.value = selected;
        } else {
            result.selectedIndex = 0;
            if (selected && onchange) {
                onchange(result.value);
            }
        }
        result.onchange = onchange;
        return result;
    }
    /**
     * Creates and returns a control that can be used to edit color properties.
     * @param {Number[4]} data A reference to the color the control should affect
     * @param {Function} [changeHandler] If given, this function will be called every time the color is changed by the picker
     * @returns {Element}
     */
    function createColorPicker(data, changeHandler) {
        var component, i, components, input,
                result = document.createElement("div"),
                componentChangeHander = function (index, value) {
                    data[index] = value;
                    input.value = utils.getHexColor(data);
                    if (changeHandler) {
                        changeHandler();
                    }
                };
        result.classList.add(COLOR_PICKER_CLASS);
        input = document.createElement("input");
        input.type = "color";
        input.classList.add(COLOR_INPUT_CLASS);
        input.value = utils.getHexColor(data);
        input.onchange = function () {
            var j, color = utils.getColor3FromHex(input.value);
            for (j = 0; j < color.length; j++) {
                data[j] = color[j];
                components[j].value = color[j];
            }
            if (changeHandler) {
                changeHandler();
            }
        };
        result.appendChild(input);
        components = [];
        for (i = 0; i < data.length; i++) {
            component = createNumericInput(data[i], {min: 0, max: 1}, componentChangeHander.bind(this, i));
            component.classList.add(COLOR_COMPONENT_CLASS);
            result.appendChild(component);
            components.push(component);
        }
        return result;
    }
    /**
     * Sets a new color for a color picker created by createColorPicker(). 
     * Does NOT call the changeHandler of the color input.
     * Does NOT change the reference to the managed color, just copies the values of the components of the given color.
     * @param {Element} element The element that was returned as a result of a createColorPicker() call
     * @param {Number[4]} color The new color to be set for the picker
     */
    function setColorForPicker(element, color) {
        var
                i,
                input = element.querySelector("." + COLOR_INPUT_CLASS),
                components = element.querySelectorAll("." + COLOR_COMPONENT_CLASS);
        input.value = utils.getHexColor(color);
        for (i = 0; i < components.length; i++) {
            components[i].value = color[i];
        }
    }
    /**
     * 
     * @param {Number[3]} color
     * @returns {Element}
     */
    function createColorPreview(color) {
        var preview = document.createElement("div");
        preview.className = COLOR_PREVIEW_CLASS;
        preview.style.backgroundColor = utils.getHexColor(color);
        return preview;
    }
    /**
     * Creates and returns a control that can be used to edit numeric vectors
     * @param {Number[]} data A reference to the vector the control should affect
     * @param {Function} [changeHandler]
     * @returns {Element}
     */
    function createVectorEditor(data, changeHandler) {
        var component, i, components,
                result = document.createElement("div"),
                componentChangeHander = function (index, value) {
                    data[index] = value;
                    if (changeHandler) {
                        changeHandler();
                    }
                };
        components = [];
        for (i = 0; i < data.length; i++) {
            component = createNumericInput(data[i], {}, componentChangeHander.bind(this, i));
            component.classList.add(VECTOR_COMPONENT_CLASS);
            result.appendChild(component);
            components.push(component);
        }
        return result;
    }
    /**
     * Creates and returns a control that can be used to edit numeric ranges.
     * @param {Number[2]} data A reference to the range that can be edited.
     * @param {Object} options
     * @param {Function} [changeHandler] If given, this function will be called every time the range is changed by the control
     * @returns {Element}
     */
    function createRangeEditor(data, options, changeHandler) {
        var result = document.createElement("div"), minCheckbox, maxCheckbox, minEditor, maxEditor, dash,
                minRequired = !!options.minRequired, maxRequired = !!options.maxRequired, elementType = options.elementType || {};
        minCheckbox = createBooleanInput(data[0] !== undefined, function () {
            data[0] = minCheckbox.checked ? minEditor.value : undefined;
            minEditor.disabled = !minCheckbox.checked;
            if (changeHandler) {
                changeHandler();
            }
        });
        minCheckbox.classList.add(RANGE_CHECKBOX_CLASS);
        minEditor = createNumericInput(data[0] || ((elementType.min > 0) ? elementType.min : 0), elementType, function (value) {
            data[0] = minCheckbox.checked ? value : undefined;
            if (changeHandler) {
                changeHandler();
            }
        });
        minEditor.classList.add(RANGE_NUMERIC_INPUT_CLASS);
        if (data[0] === undefined) {
            minEditor.disabled = true;
        }
        maxCheckbox = createBooleanInput(data[1] !== undefined, function () {
            data[1] = maxCheckbox.checked ? maxEditor.value : undefined;
            maxEditor.disabled = !maxCheckbox.checked;
            if (changeHandler) {
                changeHandler();
            }
        });
        maxCheckbox.classList.add(RANGE_CHECKBOX_CLASS);
        maxEditor = createNumericInput(data[1] || ((elementType.min > 0) ? elementType.min : 0), elementType, function (value) {
            data[1] = maxCheckbox.checked ? value : undefined;
            if (changeHandler) {
                changeHandler();
            }
        });
        maxEditor.classList.add(RANGE_NUMERIC_INPUT_CLASS);
        if (data[1] === undefined) {
            maxEditor.disabled = true;
        }
        dash = createLabel((elementType.unit ? elementType.unit + " " : "") + "-");
        if (!minRequired) {
            result.appendChild(minCheckbox);
        }
        result.appendChild(minEditor);
        result.appendChild(dash);
        if (!maxRequired) {
            result.appendChild(maxCheckbox);
        }
        result.appendChild(maxEditor);
        if (elementType.unit) {
            result.appendChild(createLabel(elementType.unit));
        }
        return result;
    }
    /**
     * @class
     * Represents an (initially hidden) panel that can be shown at a position depending on another element and can have children of the 
     * same type. Showing a popup automatically hides all other popups on the same level.
     * @param {Element} invoker The element under which this popup should show up (at the same left position and directly under it)
     * @param {Popup} [parent] If given, this popup will be added as a child of the given popup
     * @param {Object} [eventHandlers] The fuctions to execute as events happen to the popup, by the names of the events.
     */
    function Popup(invoker, parent, eventHandlers) {
        /**
         * The HTML element that represents this popup.
         * @type Element
         */
        this._element = document.createElement("div");
        this._element.classList.add(POPUP_CLASS);
        this._element.hidden = true;
        /**
         * The children of this popup.
         * @type Popup[]
         */
        this._childPopups = [];
        /**
         * The element under which this popup is displayed.
         * @type Element
         */
        this._invoker = invoker;
        /**
         * The parent of this popup.
         * @type Popup
         */
        this._parent = parent;
        if (this._parent) {
            this._parent._childPopups.push(this);
        }
        /**
         * @type Object
         */
        this._eventHandlers = eventHandlers || {};
    }
    /**
     * Adds the wrapped element to the document body.
     */
    Popup.prototype.addToPage = function () {
        document.body.appendChild(this._element);
        if (!this._parent) {
            _popups.push(this);
        }
    };
    /**
     * Returns the wrapped element.
     * @returns {Element}
     */
    Popup.prototype.getElement = function () {
        return this._element;
    };
    /**
     * Returns whether the popup is currently visible.
     * @returns {Boolean}
     */
    Popup.prototype.isVisible = function () {
        return !this._element.hidden;
    };
    /**
     * If the popup does not fit on the screen, tries to reposition it.
     * @param {Boolean} [recursive=false] If true, all children of the popup are aligned recursively
     */
    Popup.prototype.alignPosition = function (recursive) {
        var rect, left, i;
        if (this.isVisible()) {
            rect = this._invoker.getBoundingClientRect();
            this._element.style.left = rect.left + "px";
            this._element.style.top = rect.bottom + "px";
            this._element.style.width = "";
            this._element.style.height = "";
            // first horizontal alignment, as it can change the height by canceling out text wrapping
            rect = this._element.getBoundingClientRect();
            if (rect.right > window.innerWidth - POPUP_RIGHT_MARGIN) {
                this._element.style.left = (window.innerWidth - (rect.right - rect.left) - POPUP_RIGHT_MARGIN) + "px";
                rect = this._element.getBoundingClientRect();
                left = rect.left;
                while ((left > 0) && (rect.right > window.innerWidth - POPUP_RIGHT_MARGIN)) {
                    left -= POPUP_RIGHT_MARGIN;
                    this._element.style.left = left + "px";
                    rect = this._element.getBoundingClientRect();
                }
            }
            if (rect.bottom > window.innerHeight - POPUP_BOTTOM_MARGIN) {
                this._element.style.height = (window.innerHeight - rect.top - 10 - POPUP_BOTTOM_MARGIN) + "px";
                rect = this._element.getBoundingClientRect();
                this._element.style.left = (rect.left - 21) + "px";
                this._element.style.width = ((rect.right - rect.left) + 16) + "px";
            }
            rect = this._element.getBoundingClientRect();
            if (recursive) {
                for (i = 0; i < this._childPopups.length; i++) {
                    this._childPopups[i].alignPosition();
                }
            }
        }
    };
    /**
     * Shows the popup and hides all other popups on the same level. Automatically positions the popup to be under the invoking element and
     * to fit on the screen horizontally (if possible)
     */
    Popup.prototype.show = function () {
        var i;
        if (!this.isVisible()) {
            // hide the other popups open at the same level
            if (!this._parent) {
                for (i = 0; i < _popups.length; i++) {
                    if (_popups[i] !== this) {
                        _popups[i].hide();
                    }
                }
            } else {
                for (i = 0; i < this._parent._childPopups.length; i++) {
                    if (this._parent._childPopups[i] !== this) {
                        this._parent._childPopups[i].hide();
                    }
                }
            }
            // show this popup at the right position
            this._element.hidden = false;
            this.alignPosition();
            this._element.style.zIndex = _maxZIndex;
            _maxZIndex++;
            if (this._eventHandlers[EVENT_SHOW_NAME]) {
                this._eventHandlers[EVENT_SHOW_NAME]();
            }
        }
    };
    /**
     * Hides all of this popup's children.
     */
    Popup.prototype.hideChildren = function () {
        var i;
        for (i = 0; i < this._childPopups.length; i++) {
            this._childPopups[i].hide();
        }
    };
    /**
     * Hides the popup and all its children.
     */
    Popup.prototype.hide = function () {
        if (this.isVisible()) {
            this.hideChildren();
            this._element.hidden = true;
            if (this._eventHandlers[EVENT_HIDE_NAME]) {
                this._eventHandlers[EVENT_HIDE_NAME]();
            }
        }
    };
    /**
     * Toggles the visibility of the popup (shows / hides it depending on the current state)
     */
    Popup.prototype.toggle = function () {
        if (this.isVisible()) {
            this.hide();
        } else {
            this.show();
        }
    };
    /**
     * Removes the popup and all its elements from the DOM
     * @param {Boolean} [leaveReference=false] When true, the reference in the module-global popups array is left
     * (used when clearing the whole array, so it is more effective)
     */
    Popup.prototype.remove = function (leaveReference) {
        var i;
        for (i = 0; i < this._childPopups.length; i++) {
            this._childPopups[i].remove();
        }
        if (this._element.parentNode) {
            this._element.parentNode.removeChild(this._element);
        }
        if (!leaveReference && !this._parent) {
            _popups.splice(_popups.indexOf(this), 1);
        }
    };
    /**
     * Removes all popups that were added to document.body
     */
    function removePopups() {
        var i;
        for (i = 0; i < _popups.length; i++) {
            _popups[i].remove(true);
        }
        _popups = [];
        _maxZIndex = POPUP_START_Z_INDEX;
    }
    /**
     * Aligns the position of all popups
     */
    function alignPopups() {
        var i;
        for (i = 0; i < _popups.length; i++) {
            _popups[i].alignPosition(true);
        }
    }
    // ------------------------------------------------------------------------------
    // The public interface of the module
    return {
        ItemType: ItemType,
        getItemReference: getItemReference,
        getItemReferencesOfSameCategory: getItemReferencesOfSameCategory,
        createLabel: createLabel,
        createButton: createButton,
        createBooleanInput: createBooleanInput,
        createNumericInput: createNumericInput,
        setSelectorOptions: setSelectorOptions,
        getSelectorOptions: getSelectorOptions,
        createSelector: createSelector,
        createColorPicker: createColorPicker,
        setColorForPicker: setColorForPicker,
        createColorPreview: createColorPreview,
        createVectorEditor: createVectorEditor,
        createRangeEditor: createRangeEditor,
        Popup: Popup,
        removePopups: removePopups,
        alignPopups: alignPopups
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file Provides wrapper classes that can be used to manage (loading, assemblin, displaying, hiding, translating...) HTML based screens for
 * an application.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, alert, window, setInterval, clearInterval, performance, parseFloat */

/**
 * @param utils Used for converting RGBA color to CSS color strings and for format strings
 * @param types Used for handling enum values
 * @param application Used for logging and file loading functionality
 * @param asyncResource Screens are subclassed from AsyncResource as they are loaded from external XML files
 * @param components Screens contain components
 * @param managedGL Screens having canvases provide the managed GL contexts for them
 * @param resources Used to clear media resource bindings to contexts of removed screens
 * @param strings Used to offer translation support
 */
define('modules/screens',[
    "utils/utils",
    "utils/types",
    "modules/application",
    "modules/async-resource",
    "modules/components",
    "modules/managed-gl",
    "modules/media-resources",
    "modules/strings"
], function (utils, types, application, asyncResource, components, managedGL, resources, strings) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // constants
            SCREEN_FOLDER = "screen",
            CSS_FOLDER = "css",
            // keys for the eventHandlers parameters passed to screen constructors
            SHOW_EVENT_NAME = components.SHOW_EVENT_NAME,
            HIDE_EVENT_NAME = components.HIDE_EVENT_NAME,
            ACTIVATE_EVENT_NANE = "activate",
            /*
             * The content of HTML elements with this class on the page will be automatically translated on every update, using
             * the key <name of the page> " <TRANSLATION_KEY_SEPARATOR> + <id of the element>
             * @type String
             */
            TRANSLATABLE_CLASS_NAME = "translatable",
            ELEMENT_ID_SEPARATOR = components.ELEMENT_ID_SEPARATOR,
            TRANSLATION_KEY_SEPARATOR = ".",
            SCREEN_BACKGROUND_ID = "screenBackground",
            DEFAULT_SCREEN_BACKGROUND_CLASS_NAME = "screenBackground",
            SCREEN_CONTAINER_ID = "screenContainer",
            DEFAULT_SCREEN_CONTAINER_CLASS_NAME = "screenContainer",
            RESIZEABLE_CLASS_NAME = "resizeable",
            LOOP_CANCELED = -1,
            LOOP_REQUESTANIMFRAME = -2,
            MENU_COMPONENT_NAME = "menu",
            ANTIALIASING_CHANGE_ERROR_STRING = {
                name: "error.antialiasingChange",
                defaultValue: "The antialiasing setting has been changed. Please restart the application to apply the new setting!"
            },
            // ------------------------------------------------------------------------------
            // private module variables
            /**
             * Stores the settings for rendering CanvasTexts for anaglyph display
             * @type Object
             */
            _anaglyphTextRendering = {
                enabled: false,
                originalColorRatio: 0.5,
                filter: [1, 1, 1, 1], // for cyan factor
                gamma: 1
            };
    // #########################################################################
    // private module functions
    /**
     * If anaglyph text rendering is enabled, returns the converted color according
     * to its settings, otherwise just returns back the color unchanged.
     * @param {Number[4]} color
     * @returns {Number[4]}
     */
    function _getColor(color) {
        var luminance;
        if (_anaglyphTextRendering.enabled) {
            luminance = utils.getLuminance(color);
            return utils.getMixedColor(
                    utils.gammaCorrect(
                            utils.filterColor([luminance, luminance, luminance, color[3]], _anaglyphTextRendering.filter),
                            _anaglyphTextRendering.gamma),
                    color,
                    _anaglyphTextRendering.originalColorRatio);
        } else {
            return color;
        }
    }
    // #########################################################################
    /**
     * @typedef {Object} HTMLScreen~Style
     * A style descriptor for an screen storing the name of the CSS file
     * associated with the component as well as class names for dynamically created
     * HTML elements.
     * @property {String} cssFilename
     * @property {String} backgroundClassName
     * @property {String} containerClassName
     */
    /**
     * @typedef {Object} HTMLScreen~ExternalComponentBinding
     * @property {ExternalComponent} component
     * @property {String} parentNodeID
     */
    /**
     * @class Holds the logical model of a screen of the game. The different screens should be defined as descendants of this class.
     * @extends AsyncResource
     * @param {String} name The name by which this screen can be identified. Needs to be unique within the same application (ScreenManager). 
     * The ID of HTML elements belonging to this screen will be prefixed by this name.
     * @param {String} htmlFilename The name of the HTML file where the structure of this screen is defined.
     * @param {HTMLScreen~Style} [style] The object storing the styling information for this screen.
     * @param {Object.<String, Function>} [eventHandlers] Event handler functions to be executed when something happens to this page, by the
     * names of the events as keys
     * @param {Object.<String, Function>} [keyCommands] Event handler functions to be executed while this screen is active, by the names of 
     * the keys (as in utils.getKeyCodeOf())
     * @param {Object.<String, Object.<String, Function>>} [elementEventHandlers] Objects storing the event handlers for HTML elements on
     * this page: the keys are the query selectors to choose the elements, the values are event handler objects just like the eventHandlers
     * parameter.
     */
    function HTMLScreen(name, htmlFilename, style, eventHandlers, keyCommands, elementEventHandlers) {
        asyncResource.AsyncResource.call(this);
        /**
         * An ID of this screen. The IDs of HTML elements on this screen are prefixed by this name.
         * @type String
         */
        this._name = name;
        /**
         * The name of the HTML file that stores the source for this page.
         * @type String
         */
        this._htmlFilename = htmlFilename;
        /**
         * An object storing the name of the CSS file that contains the styling rules and for this 
         * components and the desired classes for dynamically created elements.
         * @type HTMLScreen~Style
         */
        this._style = style || {};
        /**
         * A flag that marks whether loading the correspoding CSS stylesheet has finished.
         * @type Boolean
         */
        this._cssLoaded = false;
        /**
         * Stores the model of the screen's DOM structure after it has been loaded and is automatically
         * cleared (unless explicitly specified otherwise) when the screen is added to the page.
         * @type DocumentFragment
         */
        this._model = null;
        /**
         * An HTML element that serves as a background for this page, and is added below the main container
         * of the screen when that is loaded.
         * @type Element
         */
        this._background = null;
        /**
         * The DOM structure of the screen is added inside this container element.
         * @type Element
         */
        this._container = null;
        /**
         * Whether the screen is currently superimposed on another one
         * @type Boolean
         */
        this._superImposed = false;
        /**
         * Stores the list of simple components (wrapped HTML elements) on this screen.
         * @type SimpleComponent[]
         */
        this._simpleComponents = [];
        /**
         * Stores the list of external components (components with their own DOM structure loaded
         * from external HTML files) on this screen.
         * @type HTMLScreen~ExternalComponentBinding[]
         */
        this._externalComponentBindings = [];
        /**
         * The number of external components on this page the source files of which have already been loaded.
         * @type Number
         */
        this._externalComponentsLoaded = 0;
        /**
         * The total number of external components on this screen the source files of which have to be loaded.
         * @type Number
         */
        this._externalComponentsToLoad = 0;
        /**
         * Whether the screen is currently visible (its container and background are added to the DOM and their display style is not set to "none")
         * @type Boolean
         */
        this._visible = false;
        /**
         * Optional callback to be executed whenever this screen is shown. (show() is called)
         * @type Function
         */
        this._onShow = eventHandlers ? eventHandlers[SHOW_EVENT_NAME] : null;
        /**
         * Optional callback to be executed whenever this screen is hidden. (hide() is called)
         * @type Function
         */
        this._onHide = eventHandlers ? eventHandlers[HIDE_EVENT_NAME] : null;
        /**
         * Optional callback to be executed whenever this screen is set to active state. (setActive(true) is called)
         * @type Function
         */
        this._onActivate = eventHandlers ? eventHandlers[ACTIVATE_EVENT_NANE] : null;
        /**
         * A reference to the event listener function listening to the keydown event to handle the key commands
         * valid on this screen.
         * @type Function
         */
        this._keyDownHandler = keyCommands ? this._getKeyDownHandler(keyCommands) : null;
        /**
         * The event handlers for HTML elements on this page: the keys are the query selectors to choose the elements, the values are event 
         * handler objects storing the handler functions by the names of the events.
         * @type Object.<String, Object.<String, Function>>
         */
        this._elementEventHandlers = elementEventHandlers || null;
        // will be undefined when setting the prototypes for inheritance
        if (htmlFilename) {
            this.requestModelLoad();
        }
    }
    HTMLScreen.prototype = new asyncResource.AsyncResource();
    HTMLScreen.prototype.constructor = HTMLScreen;
    /**
     * Returns whether all external resources needed for this page have already been loaded.
     * @returns {Boolean}
     */
    HTMLScreen.prototype._isLoaded = function () {
        return this._model && this._cssLoaded && (this._externalComponentsLoaded === this._externalComponentsToLoad);
    };
    /**
     * Generates and returns an event listener function that can be added to the DOM to listen for "keydown"
     * events and perform the actions defined in the keyCommands parameter that is in the same format as for
     * the constructor.
     * @param {Object.<String, Function>} keyCommands
     * @returns {Function}
     */
    HTMLScreen.prototype._getKeyDownHandler = function (keyCommands) {
        var keyCommandsByCode = {}, keys, i;
        keys = Object.keys(keyCommands);
        for (i = 0; i < keys.length; i++) {
            keyCommandsByCode[utils.getKeyCodeOf(keys[i])] = keyCommands[keys[i]];
        }
        return function (event) {
            if (keyCommandsByCode[event.keyCode]) {
                keyCommandsByCode[event.keyCode].call(this, event);
            }
        }.bind(this);
    };
    /**
     * Adds the appropriate event listeners for this screen to the DOM.
     */
    HTMLScreen.prototype._addEventListeners = function () {
        if (this._keyDownHandler) {
            document.addEventListener("keydown", this._keyDownHandler);
        }
    };
    /**
     * Removes the previously added (if any) event listeners for this screen from the DOM.
     */
    HTMLScreen.prototype._removeEventListeners = function () {
        if (this._keyDownHandler) {
            document.removeEventListener("keydown", this._keyDownHandler);
        }
    };
    /**
     * Initiates the asynchronous loading of the screen's structure and style from the
     * external HTML and and CSS files.
     */
    HTMLScreen.prototype.requestModelLoad = function () {
        // send an asynchronous request to grab the HTML file containing the DOM of this screen
        application.requestTextFile(SCREEN_FOLDER, this._htmlFilename, function (responseText) {
            var helperDiv;
            this._model = document.createDocumentFragment();
            // the DocumentFragment node has no innerHTML property, so we create a helper
            // HTML element so we can convert the source file's text content to DOM
            helperDiv = document.createElement("div");
            helperDiv.innerHTML = responseText;
            this._model.appendChild(helperDiv.firstElementChild);
            if (this._isLoaded()) {
                this.setToReady();
            }
        }.bind(this));
        // send a request to load the stylesheet, if needed
        if (this._style.cssFilename) {
            this._cssLoaded = false;
            application.requestCSSFile(CSS_FOLDER, this._style.cssFilename, function () {
                this._cssLoaded = true;
                if (this._isLoaded()) {
                    this.setToReady();
                }
            }.bind(this));
        } else {
            this._cssLoaded = true;
        }
    };
    /**
     * Returns the name of this screen.
     * @returns {String}
     */
    HTMLScreen.prototype.getName = function () {
        return this._name;
    };
    /**
     * Specifies whether this screen is currently active. (e.g. should listen to input)
     * @param {Boolean} active
     */
    HTMLScreen.prototype.setActive = function (active) {
        if (active) {
            this._addEventListeners();
            if (this._onActivate) {
                this._onActivate();
            }
        } else {
            this._removeEventListeners();
        }
    };
    /**
     * Adds the event listeners defined in this class (in the _elementEventHandlers property) to the appropriate HTML elements on this 
     * screen
     * @param {Element} [parent] If given, only those elements will be considered, which are below this element in the DOM
     */
    HTMLScreen.prototype._addElementEventListeners = function (parent) {
        var elements, i, j, k, querySelectors, events;
        if (this._elementEventHandlers) {
            parent = parent || this._container;
            querySelectors = Object.keys(this._elementEventHandlers);
            for (i = 0; i < querySelectors.length; i++) {
                elements = parent.querySelectorAll(querySelectors[i]);
                events = Object.keys(this._elementEventHandlers[querySelectors[i]]);
                for (j = 0; j < elements.length; j++) {
                    for (k = 0; k < events.length; k++) {
                        elements[j].addEventListener(events[k], this._elementEventHandlers[querySelectors[i]][events[k]]);
                    }
                }
            }
        }
    };
    /**
     * Appends the content of the screen to the page in an invisible (display: none) div.
     * If some source files for the screen have not been loaded yet, than sets a callback to append the 
     * screen once all necessary files have been loaded.
     * @param {Function} [callback] This function will be called after the screen has been added to the page.
     * @param {Boolean} [addBackground=false] Whether to add a background <div>
     * next to the screen container <div> that can be used when the screen is
     * superimposed on other screens
     * @param {Boolean} [keepModelAfterAdding=false] Whether to keep storing the original DOM model
     * of the screen after adding it to the current document (so that it can be added again later)
     * @param {Element} [parentNode=document.body] If given, the screen and its background will be added as
     * children of this DOM node.
     */
    HTMLScreen.prototype.addScreenToPage = function (callback, addBackground, keepModelAfterAdding, parentNode) {
        parentNode = parentNode || document.body;
        this.executeWhenReady(function () {
            var elements, i;
            if (addBackground) {
                this._background = document.createElement("div");
                this._background.setAttribute("id", this._getElementID(SCREEN_BACKGROUND_ID));
                this._background.className = this._style.backgroundClassName || DEFAULT_SCREEN_BACKGROUND_CLASS_NAME;
                this._background.hidden = true;
            }
            this._container = document.createElement("div");
            this._container.setAttribute("id", this._getElementID(SCREEN_CONTAINER_ID));
            this._container.className = this._style.containerClassName || DEFAULT_SCREEN_CONTAINER_CLASS_NAME;
            this._container.hidden = true;
            if (!keepModelAfterAdding) {
                this._container.appendChild(this._model.firstElementChild);
            } else {
                this._container.appendChild(this._model.firstElementChild.cloneNode(true));
            }
            elements = this._container.querySelectorAll("[id]");
            for (i = 0; i < elements.length; i++) {
                elements[i].setAttribute("id", this._getElementID(elements[i].getAttribute("id")));
            }
            if (this._background) {
                parentNode.appendChild(this._background);
            }
            parentNode.appendChild(this._container);
            this._visible = false;
            this._initializeComponents();
            this._addElementEventListeners();
            if (callback) {
                callback();
            }
            if (!keepModelAfterAdding) {
                this._model = null;
            }
        });
    };
    /**
     * Displays the screen (makes it visible)
     * @returns {Boolean} Whether the screen was made visible (false if it was already visible, and this method didn't do anything
     */
    HTMLScreen.prototype.show = function () {
        if (!this._visible) {
            if (this._container) {
                this._container.hidden = false;
                this._visible = true;
                if (this._onShow) {
                    this._onShow();
                }
                return true;
            }
            application.showError("Attempting to show screen '" + this._name + "' before adding it to the page!");
        }
        return false;
    };
    /**
     * Superimposes the screen on the current page, by appending a full screen
     * container and the screen structure as its child inside it.
     * @param {Number[4]} [backgroundColor] The color of the page background will be overriden by this
     * color, if given.([r,g,b,a], where all color components should be 0-1)
     * @param {Element} [parentNode=document.body] If given, the screen and its background will be set as
     * children of this DOM node.
     */
    HTMLScreen.prototype.superimposeOnPage = function (backgroundColor, parentNode) {
        if (this._container) {
            parentNode = parentNode || document.body;
            if (this._background) {
                if (backgroundColor) {
                    this._background.style.backgroundColor = utils.getCSSColor(backgroundColor);
                }
                // appendChild does not clone the element if it is already part of the DOM, in that
                // case it will be simply moved to become the last child of parentNode
                this._background.hidden = false;
                parentNode.appendChild(this._background);
            }
            parentNode.appendChild(this._container);
            this._superImposed = true;
        }
        this.show();
    };
    /**
     * Hides the screen (makes it invisible and not take any screen space)
     * @returns {Boolean} Whether the screen was hidden (false if it was already hidden, and this method didn't do anything
     */
    HTMLScreen.prototype.hide = function () {
        if (this._visible) {
            if (this._container) {
                this._container.hidden = true;
                if (this._background) {
                    this._background.hidden = true;
                }
                this._visible = false;
                this._superImposed = false;
                this.setActive(false);
                if (this._onHide) {
                    this._onHide();
                }
                return true;
            }
            application.showError("Attempting to hide screen '" + this._name + "' before adding it to the page!");
        }
        return false;
    };
    /**
     * Tells whether the screen is superimposed on top of another one.
     * @returns {Boolean}
     */
    HTMLScreen.prototype.isSuperimposed = function () {
        return this._superImposed;
    };
    /**
     * Setting the properties that will be used to easier access DOM elements later.
     * In descendants, this method should be overwritten, adding the additional
     * components of the screen after calling this parent method.
     */
    HTMLScreen.prototype._initializeComponents = function () {
        var i, parentNode;
        for (i = 0; i < this._simpleComponents.length; i++) {
            this._simpleComponents[i].initComponent();
        }
        for (i = 0; i < this._externalComponentBindings.length; i++) {
            if (this._externalComponentBindings[i].parentNodeID) {
                parentNode = this.getElement(this._externalComponentBindings[i].parentNodeID);
            }
            // otherwise just leave it undefined, nothing to pass to the method below
            this.addExternalComponent(this._externalComponentBindings[i].component, parentNode);
        }
        this._updateComponents();
    };
    /**
     * Returns appropriately prefixed version of the original, passed ID that would correspond
     * to the ID of an element on this screen.
     * @param {String} originalElementID
     * @returns {String}
     */
    HTMLScreen.prototype._getElementID = function (originalElementID) {
        return this._name + ELEMENT_ID_SEPARATOR + originalElementID;
    };
    /**
     * Returns the original ID of an element of this screen, that is, the ID without prefixes referring 
     * to this screen.
     * @param {Element} element
     * @returns {String}
     */
    HTMLScreen.prototype._getOriginalElementID = function (element) {
        return element.getAttribute("id").substr(this._name.length + ELEMENT_ID_SEPARATOR.length);
    };
    /**
     * Override this and add the code update the state of components on this screen to be up-to-date with the
     * application state. This basic method automatically translated the content of all elements having the
     * TRANSLATABLE_CLASS_NAME class.
     */
    HTMLScreen.prototype._updateComponents = function () {
        var translatableElements, i;
        if (this._container) {
            application.log_DEBUG("Screen '" + this._name + "' is getting updated.", 2);
            // no data-translation-key attribute is needed to translate simple, static HTML elements - simply the ID of the element will
            // be used together with the screen name if it is omitted (generated elements however need to use data-translation-key, to avoid
            // having multiple elements with the same ID in case the same text needs to be displayed multiple times)
            translatableElements = this._container.querySelectorAll("." + TRANSLATABLE_CLASS_NAME + ", [" + components.TRANSLATION_KEY_ATTRIBUTE + "]");
            for (i = 0; i < translatableElements.length; i++) {
                translatableElements[i].innerHTML = strings.get({
                    name:
                            translatableElements[i].getAttribute(components.TRANSLATION_KEY_ATTRIBUTE) ||
                            (this._name + TRANSLATION_KEY_SEPARATOR + this._getOriginalElementID(translatableElements[i])),
                    defaultValue: translatableElements[i].innerHTML
                });
            }
            for (i = 0; i < this._externalComponentBindings.length; i++) {
                this._externalComponentBindings[i].component.updateComponents();
            }
        }
    };
    /**
     * Updates all components on this screen to be up-to-date with the application state.
     */
    HTMLScreen.prototype.updateScreen = function () {
        this._updateComponents();
    };
    /**
     * Sets up the component to be associated with an HTML element on this page having the 
     * passed original ID, which will serve as the name for the component.
     * @param {String} simpleComponentName
     * @returns {SimpleComponent}
     */
    HTMLScreen.prototype.registerSimpleComponent = function (simpleComponentName) {
        var component = new components.SimpleComponent(simpleComponentName, this._getElementID(simpleComponentName));
        this._simpleComponents.push(component);
        return component;
    };
    /**
     * A reference to the passed external component associated with the passed parent node ID will be stored, and
     * when the screen is added to the page, the external component will be added under the node with the passed
     * original ID. This also makes the screen wait for the component to load before adding it to the page.
     * The root element ID of the passed component will be prefixed with the name of the screen.
     * @param {ExternalComponent} externalComponent
     * @param {String} [parentNodeID]
     * @returns {ExternalComponent}
     */
    HTMLScreen.prototype.registerExternalComponent = function (externalComponent, parentNodeID) {
        // note that one more component needs to be loaded for the page to be ready
        this._externalComponentsToLoad++;
        // save the reference
        this._externalComponentBindings.push({
            component: externalComponent,
            parentNodeID: parentNodeID
        });
        // prefix the element ID with the name of the screen
        externalComponent.setRootElementID(this._getElementID(externalComponent.getName()));
        // set the callback to check if we are ready with the screen loading when this component is loaded
        externalComponent.executeWhenReady(function () {
            this._externalComponentsLoaded++;
            if (this._isLoaded()) {
                this.setToReady();
            }
        }.bind(this));
        return externalComponent;
    };
    /**
     * Appends the elements of an external component (a HTML document fragment
     * defined in an external xml file) to the DOM tree and returns the same 
     * component.
     * @param {ExternalComponent} externalComponent
     * @param {Node} [parentNode] The node in the document to which to append the
     * component (if omitted, it will be appended to the body)
     * @returns {ExternalComponent}
     */
    HTMLScreen.prototype.addExternalComponent = function (externalComponent, parentNode) {
        externalComponent.appendToPage(parentNode);
        return externalComponent;
    };
    /**
     * Provides visual information to the user about the current status of the application.
     * @param {String} newStatus The new status to display.
     */
    HTMLScreen.prototype.updateStatus = function (newStatus) {
        if (this._status) {
            this._status.setContent(newStatus);
        } else {
            alert(newStatus);
        }
    };
    /**
     * Returns the HTML element that is part of this screen and had the given original ID
     * @param {String} originalElementID
     * @returns {Element}
     */
    HTMLScreen.prototype.getElement = function (originalElementID) {
        return this._container.querySelector("#" + this._getElementID(originalElementID));
    };
    // #########################################################################
    /**
     * @typedef {Object} LayoutDescriptor
     * @property {Number} [left]
     * @property {Number} [centerX]
     * @property {Number} [right]
     * @property {Number} [top]
     * @property {Number} [centerY]
     * @property {Number} [bottom]
     * @property {Number} [width]
     * @property {Number} [height]
     * @property {String} scaleMode enum ScaleMode
     * @property {String} [xScaleMode] enum ScaleMode
     * @property {String} [yScaleMode] enum ScaleMode
     */
    /**
     * @class
     * Stores a set of layout settings given using clip-space coordinates and can calculate and provide coordinates of the rectangle defined
     * by these settings in different coordinate systems / scaled to a specific viewport.
     * @param {LayoutDescriptor} layoutDescriptor The descriptor object to load the settings from
     */
    function ClipSpaceLayout(layoutDescriptor) {
        /**
         * If given, the left side of the rectangle should be located at this X coordinate in clip-space.
         * @type Number
         */
        this._left = layoutDescriptor.left;
        /**
         * If given, the horizontal center of the rectangle should be located at this X coordinate in clip-space.
         * @type Number
         */
        this._centerX = layoutDescriptor.centerX;
        /**
         * If given, the right side of the rectangle should be located at this X coordinate in clip-space.
         * @type Number
         */
        this._right = layoutDescriptor.right;
        /**
         * If given, the top side of the rectangle should be located at this Y coordinate in clip-space.
         * @type Number
         */
        this._top = layoutDescriptor.top;
        /**
         * If given, the vertical center of the rectangle should be located at this Y coordinate in clip-space.
         * @type Number
         */
        this._centerY = layoutDescriptor.centerY;
        /**
         * If given, the bottom side of the rectangle should be located at this Y coordinate in clip-space.
         * @type Number
         */
        this._bottom = layoutDescriptor.bottom;
        /**
         * If given, the width of the rectangle should equal this distance in clip-space.
         * @type Number
         */
        this._width = layoutDescriptor.width;
        /**
         * If given, the height of the rectangle should equal this distance in clip-space.
         * @type Number
         */
        this._height = layoutDescriptor.height;
        /**
         * (enum ScaleMode) Determines how the actual size of the rectangle is calculated when scaled to a specific viewport.
         * @type String
         */
        this._scaleMode = types.getEnumValue(utils.ScaleMode, layoutDescriptor.scaleMode);
        /**
         * (enum ScaleMode) Determines how the X coordinate of the position of the rectangle is calculated when scaling to a specific 
         * viewport. If a left coordinate is stored in this layout, the appropriate scaling is applied from the left side of the viewport, 
         * if a center X coordinate is stored, the scaling is applied from the horizontal center of the viewport and if a right coordinate
         * is stored, from the right side of the viewport.
         * @type String
         */
        this._xScaleMode = types.getEnumValue(utils.ScaleMode, layoutDescriptor.xScaleMode || utils.ScaleMode.ASPECT);
        /**
         * (enum ScaleMode) Determines how the Y coordinate of the position of the rectangle is calculated when scaling to a specific 
         * viewport. If a top coordinate is stored in this layout, the appropriate scaling is applied from the top of the viewport, 
         * if a center Y coordinate is stored, the scaling is applied from the vertical center of the viewport and if a bottom coordinate
         * is stored, from the bottom of the viewport.
         * @type String
         */
        this._yScaleMode = types.getEnumValue(utils.ScaleMode, layoutDescriptor.yScaleMode || utils.ScaleMode.ASPECT);
        if (!this._isValid()) {
            application.showError("Invalid layout specified!");
        }
    }
    /**
     * Returns whether this object contains settings for which all coordinates can be calculated without ambiguity.
     * @returns {Boolean}
     */
    ClipSpaceLayout.prototype._isValid = function () {
        var numAnchors;
        if (this._width !== undefined) {
            numAnchors = 0;
            if (this._left !== undefined) {
                numAnchors++;
            }
            if (this._centerX !== undefined) {
                numAnchors++;
            }
            if (this._right !== undefined) {
                numAnchors++;
            }
            if (numAnchors !== 1) {
                return false;
            }
        } else {
            if ((this._left === undefined) || (this._centerX !== undefined) || (this._right === undefined)) {
                return false;
            }
            if ((this._scaleMode !== utils.ScaleMode.ASPECT) || (this._xScaleMode !== utils.ScaleMode.ASPECT)) {
                return false;
            }
        }
        if (this._height !== undefined) {
            numAnchors = 0;
            if (this._top !== undefined) {
                numAnchors++;
            }
            if (this._centerY !== undefined) {
                numAnchors++;
            }
            if (this._bottom !== undefined) {
                numAnchors++;
            }
            if (numAnchors !== 1) {
                return false;
            }
        } else {
            if ((this._top === undefined) || (this._centerY !== undefined) || (this._bottom === undefined)) {
                return false;
            }
            if ((this._scaleMode !== utils.ScaleMode.ASPECT) || (this._yScaleMode !== utils.ScaleMode.ASPECT)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns the X coordinate of the horizontal center of the rectangle specified by this layout in clip-space.
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getClipSpaceCenterX = function () {
        if (this._centerX !== undefined) {
            return this._centerX;
        }
        if (this._width !== undefined) {
            if (this._left !== undefined) {
                return this._left + this._width / 2;
            }
            return this._right - this._width / 2;
        }
        return (this._left + this._right) / 2;
    };
    /**
     * Returns the Y coordinate of the vertical center of the rectangle specified by this layout in clip-space.
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getClipSpaceCenterY = function () {
        if (this._centerY !== undefined) {
            return this._centerY;
        }
        if (this._height !== undefined) {
            if (this._bottom !== undefined) {
                return this._bottom + this._height / 2;
            }
            return this._top - this._height / 2;
        }
        return (this._bottom + this._top) / 2;
    };
    /**
     * Returns the position of the center of the rectangle specified by this layout in clip-space.
     * @returns {Number[2]}
     */
    ClipSpaceLayout.prototype.getClipSpacePosition = function () {
        return [
            this.getClipSpaceCenterX(),
            this.getClipSpaceCenterY()];
    };
    /**
     * Returns the width of the rectangle specified by this layout in clip-space.
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getClipSpaceWidth = function () {
        if (this._width !== undefined) {
            return this._width;
        }
        return this._right - this._left;
    };
    /**
     * Returns the height of the rectangle specified by this layout in clip-space.
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getClipSpaceHeight = function () {
        if (this._height !== undefined) {
            return this._height;
        }
        return this._top - this._bottom;
    };
    /**
     * Returns the width and height of the rectangle specified by this layout in clip-space.
     * @returns {Number[2]}
     */
    ClipSpaceLayout.prototype.getClipSpaceSize = function () {
        return [
            this.getClipSpaceWidth(),
            this.getClipSpaceHeight()];
    };
    /**
     * Returns the X coordinate of the left edge of the rectangle specified by this layout in clip-space.
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getClipSpaceLeft = function () {
        if (this._left !== undefined) {
            return this._left;
        }
        return this.getClipSpaceCenterX() - this.getClipSpaceWidth() / 2;
    };
    /**
     * Returns the X coordinate of the right edge of the rectangle specified by this layout in clip-space.
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getClipSpaceRight = function () {
        if (this._right !== undefined) {
            return this._right;
        }
        return this.getClipSpaceCenterX() + this.getClipSpaceWidth() / 2;
    };
    /**
     * Returns the Y coordinate of the bottom edge of the rectangle specified by this layout in clip-space.
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getClipSpaceBottom = function () {
        if (this._bottom !== undefined) {
            return this._bottom;
        }
        return this.getClipSpaceCenterY() - this.getClipSpaceHeight() / 2;
    };
    /**
     * Returns the Y coordinate of the top edge of the rectangle specified by this layout in clip-space.
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getClipSpaceTop = function () {
        if (this._top !== undefined) {
            return this._top;
        }
        return this.getClipSpaceCenterY() + this.getClipSpaceHeight() / 2;
    };
    /**
     * Returns the width of the rectangle specified by this layout in pixels when scaled to a viewport of the given size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getWidth = function (viewportWidth, viewportHeight) {
        return this.getClipSpaceWidth() / 2 * (
                utils.xScalesWithWidth(this._scaleMode, viewportWidth, viewportHeight) ?
                viewportWidth :
                viewportHeight);
    };
    /**
     * Returns the height of the rectangle specified by this layout in pixels when scaled to a viewport of the given size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getHeight = function (viewportWidth, viewportHeight) {
        return this.getClipSpaceHeight() / 2 * (
                utils.yScalesWithHeight(this._scaleMode, viewportWidth, viewportHeight) ?
                viewportHeight :
                viewportWidth);
    };
    /**
     * Returns the width and height of the rectangle specified by this layout in pixels when scaled to a viewport of the given size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number[2]}
     */
    ClipSpaceLayout.prototype.getSize = function (viewportWidth, viewportHeight) {
        return [
            this.getWidth(viewportWidth, viewportHeight),
            this.getHeight(viewportWidth, viewportHeight)];
    };
    /**
     * Returns the X coordinate of the horizontal center of the rectangle specified by this layout in pixels when scaled to a viewport of 
     * the given size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getCenterX = function (viewportWidth, viewportHeight) {
        var scale;
        if (utils.xScalesWithWidth(this._xScaleMode, viewportWidth, viewportHeight)) {
            scale = viewportWidth;
        } else {
            scale = viewportHeight;
        }
        if (this._left !== undefined) {
            return (this.getClipSpaceLeft() + 1) / 2 * scale + this.getWidth(viewportWidth, viewportHeight) / 2;
        }
        if (this._centerX !== undefined) {
            return viewportWidth / 2 + this.getClipSpaceCenterX() / 2 * scale;
        }
        return viewportWidth - (1 - this.getClipSpaceRight()) / 2 * scale - this.getWidth(viewportWidth, viewportHeight) / 2;
    };
    /**
     * Returns the Y coordinate of the vertical center of the rectangle specified by this layout in pixels when scaled to a viewport of 
     * the given size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getCenterY = function (viewportWidth, viewportHeight) {
        var scale;
        if (utils.yScalesWithHeight(this._yScaleMode, viewportWidth, viewportHeight)) {
            scale = viewportHeight;
        } else {
            scale = viewportWidth;
        }
        if (this._top !== undefined) {
            return (1 - this.getClipSpaceTop()) / 2 * scale + this.getHeight(viewportWidth, viewportHeight) / 2;
        }
        if (this._centerY !== undefined) {
            return viewportHeight / 2 - this.getClipSpaceCenterY() / 2 * scale;
        }
        return viewportHeight - (this.getClipSpaceBottom() + 1) / 2 * scale - this.getHeight(viewportWidth, viewportHeight) / 2;
    };
    /**
     * Sets a new position (center X-Y) to be used for the layout - does not do validation, call only
     * to update the center X-Y coordinates of a layout that already has them set
     * @param {Number} centerX
     * @param {Number} centerY
     */
    ClipSpaceLayout.prototype.setPosition = function (centerX, centerY) {
        this._centerX = centerX;
        this._centerY = centerY;
    };
    /**
     * Returns the position of the center of the rectangle specified by this layout in pixels when scaled to a viewport of the given size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number[2]}
     */
    ClipSpaceLayout.prototype.getPosition = function (viewportWidth, viewportHeight) {
        return [
            this.getCenterX(viewportWidth, viewportHeight),
            this.getCenterY(viewportWidth, viewportHeight)];
    };
    /**
     * Returns the X coordinate of the left edge of the rectangle specified by this layout in pixels when scaled to a viewport of the given 
     * size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getLeft = function (viewportWidth, viewportHeight) {
        var scale;
        if (utils.xScalesWithWidth(this._xScaleMode, viewportWidth, viewportHeight)) {
            scale = viewportWidth;
        } else {
            scale = viewportHeight;
        }
        if (this._left !== undefined) {
            return (this.getClipSpaceLeft() + 1) / 2 * scale;
        }
        if (this._centerX !== undefined) {
            return viewportWidth / 2 + this.getClipSpaceCenterX() / 2 * scale - this.getWidth(viewportWidth, viewportHeight) / 2;
        }
        return viewportWidth - (1 - this.getClipSpaceRight()) / 2 * scale - this.getWidth(viewportWidth, viewportHeight);
    };
    /**
     * Returns the Y coordinate of the top edge of the rectangle specified by this layout in pixels when scaled to a viewport of the given 
     * size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getTop = function (viewportWidth, viewportHeight) {
        var scale;
        if (utils.yScalesWithHeight(this._yScaleMode, viewportWidth, viewportHeight)) {
            scale = viewportHeight;
        } else {
            scale = viewportWidth;
        }
        if (this._top !== undefined) {
            return (1 - this.getClipSpaceTop()) / 2 * scale;
        }
        if (this._centerY !== undefined) {
            return viewportHeight / 2 - this.getClipSpaceCenterY() / 2 * scale - this.getHeight(viewportWidth, viewportHeight) / 2;
        }
        return viewportHeight - (this.getClipSpaceBottom() + 1) / 2 * scale - this.getHeight(viewportWidth, viewportHeight);
    };
    /**
     * Returns the Y coordinate of the bottom edge of the rectangle specified by this layout in pixels when scaled to a viewport of the 
     * given size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getBottom = function (viewportWidth, viewportHeight) {
        var scale;
        if (utils.yScalesWithHeight(this._yScaleMode, viewportWidth, viewportHeight)) {
            scale = viewportHeight;
        } else {
            scale = viewportWidth;
        }
        if (this._top !== undefined) {
            return (1 - this.getClipSpaceTop()) / 2 * scale + this.getHeight(viewportWidth, viewportHeight);
        }
        if (this._centerY !== undefined) {
            return viewportHeight / 2 - this.getClipSpaceCenterY() / 2 * scale + this.getHeight(viewportWidth, viewportHeight) / 2;
        }
        return viewportHeight - (this.getClipSpaceBottom() + 1) / 2 * scale;
    };
    /**
     * Returns the X coordinate of the left edge of the rectangle specified by this layout in positive-relative space ([0;0]: bottom-left -
     * [1;1]: top right) when scaled to a viewport of the given size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getPositiveLeft = function (viewportWidth, viewportHeight) {
        return this.getLeft(viewportWidth, viewportHeight) / viewportWidth;
    };
    /**
     * Returns the Y coordinate of the bottom edge of the rectangle specified by this layout in positive-relative space ([0;0]: bottom-left -
     * [1;1]: top right) when scaled to a viewport of the given size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getPositiveBottom = function (viewportWidth, viewportHeight) {
        return 1 - this.getBottom(viewportWidth, viewportHeight) / viewportHeight;
    };
    /**
     * Returns the width of the rectangle specified by this layout in positive-relative space (0-1) when scaled to a viewport of the given 
     * size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getPositiveWidth = function (viewportWidth, viewportHeight) {
        return this.getWidth(viewportWidth, viewportHeight) / viewportWidth;
    };
    /**
     * Returns the height of the rectangle specified by this layout in positive-relative space (0-1) when scaled to a viewport of the given 
     * size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     * @returns {Number}
     */
    ClipSpaceLayout.prototype.getPositiveHeight = function (viewportWidth, viewportHeight) {
        return this.getHeight(viewportWidth, viewportHeight) / viewportHeight;
    };
    /**
     * (enum ScaleMode) Returns the scaling mode set for the size of the rectangle specified by this layout.
     * @returns {String}
     */
    ClipSpaceLayout.prototype.getScaleMode = function () {
        return this._scaleMode;
    };
    // #########################################################################
    /**
     * @typedef {Object} Screens~TextSection Defines a renderable piece of text. Texts that span multiple lines or use different settings (such as
     * color) for different parts need to be rendered in several separate calls, because one text render call can only be one-lined and
     * us the current settings of the state machine.
     * @property {String} text The raw text to render, without any new lines or markup
     * @property {Number} xOffset The relative X position compared to the position of the CanvasText this section is part of 
     * @property {Number} yOffset The relative Y position compared to the position of the CanvasText this section is part of 
     * @property {Number[4]} [color] An optional color if a color different than the color of the CanvasText is to be used for this section
     * @property {Number} startIndex The (calculated) index of the first character of this section within the whole text this section is part of
     * @property {Number} length The (cached) length of the text of this section
     */
    /**
     * @class
     * A text with associated state (layout and style) that can be rendered on 2D canvases. Can contain multiple lines and parts that need
     * to be rendered with different settings (such as color). See text parameter for details.
     * @param {Number[2]} position The starting position of the text in the clip space of the canvas.
     * @param {String} text The starting value of the text to display. Use "\n" for explicit line breaks (the text will be word-wrapped using
     * additional lne breaks if it doesn't fit the text layer's canvas or the layour box), and brackets for modifying settings for parts
     * of the text: "[color:1,0,0,1]This part is red[], this is default color."
     * @param {String} font The name of the font to use (as in CSS font-family)
     * @param {Number} size The relative size of the font to use (relative to the width or height (depending on the scaling mode) of the canvas in pixels)
     * @param {String} scaleMode enum ScaleMode The scaling mode to use when determining the font size for rendering
     * @param {Number[4]} color The RGBA color to use when rendering
     * @param {String} [align="left"] The horizontal alignment mode for the text
     * @param {LayoutDescriptor} [boxLayoutDescriptor] When given, the text will wrap itself within the box defined by this layout (with any
     * overflowing elements clipped) and take care of clearing itself off by clearing the box, thus not triggering the clearing of the whole 
     * text layer it is part of. Both the box layout and the text position needs to be set relative to the text layer - when changing one,
     * it is needed to keep it up-to-date with the other.
     * Useful for texts that are small but are frequently repositioned within a large area to avoid clearing the large text layer every frame.
     * 
     */
    function CanvasText(position, text, font, size, scaleMode, color, align, boxLayoutDescriptor) {
        /**
         * The X coordinate of the relative position of the text in the clip space of the canvas it is rendered to.
         * @type Number
         */
        this._x = position[0];
        /**
         * The Y coordinate of the relative position of the text in the clip space of the canvas it is rendered to.
         * @type Number
         */
        this._y = position[1];
        /**
         * The current text to render.
         * @type String
         */
        this._text = null;
        /**
         * The name of the font to use (as in CSS font-family)
         * @type String
         */
        this._font = font;
        /**
         * The relative size of the font to use (relative to the width or height (depending on the scaling mode) of the canvas in pixels)
         * @type Number
         */
        this._size = size;
        /**
         * (enum ScaleMode) The scaling mode to use when determining the font size for rendering
         * @type String
         */
        this._scaleMode = types.getEnumValue(utils.ScaleMode, scaleMode);
        if (this._scaleMode === utils.ScaleMode.ASPECT) {
            application.showError("Cannot set the scaling mode to aspect for fonts!");
        }
        /**
         * The RGBA color to use when rendering
         * @type Number[4]
         */
        this._color = null;
        /**
         * The horizontal alignment mode for the text
         * @type String
         */
        this._align = align || "left";
        // fields related to the clearing box
        /**
         * The layout settings of the clearing box
         * @type ClipSpaceLayout
         */
        this._boxLayout = boxLayoutDescriptor ? new ClipSpaceLayout(boxLayoutDescriptor) : null;
        /**
         * The last calculated left edge x coordinate of the clearing box (in pixels)
         * @type Number
         */
        this._boxLeft = -1;
        /**
         * The last calculated top edge y coordinate of the clearing box (in pixels)
         * @type Number
         */
        this._boxTop = -1;
        /**
         * The last calculated width of the clearing box (in pixels)
         * @type Number
         */
        this._boxWidth = -1;
        /**
         * The last calculated height of the clearing box (in pixels)
         * @type Number
         */
        this._boxHeight = -1;
        /**
         * Whether the last calculated box coordinates and dimensions should be considered up-to-date and valid
         * @type Number
         */
        this._boxValid = false;
        /**
         * @type Boolean
         */
        this._boxCleared = false;
        /**
         * Whether the text is currently visible (should be rendered when calling render())
         * @type Boolean
         */
        this._visible = true;
        // cache variables
        /**
         * The width of the viewport when the text was last rendered, in pixels
         * @type Number
         */
        this._lastWidth = -1;
        /**
         * The height of the viewport when the text was last rendered, in pixels
         * @type Number
         */
        this._lastHeight = -1;
        /**
         * The measured width of the whole (raw) text based on the last render settings and
         * viewport. -1 marks invalid (to-be-updated) value.
         * @type Number
         */
        this._textWidth = -1;
        /**
         * The string to set as the context.font property when rendering
         * @type String
         */
        this._cssFont = null;
        /**
         * The string to set as the context.fillStyle property when rendering
         * @type String
         */
        this._cssColor = null;
        /**
         * The set text split into lines and then words for multiline support
         * @type String[][]
         */
        this._words = null;
        /**
         * Actually renderable pieces of this text, with explicit relative positions (for mutliline support) and possibly other individual
         * settings (such as color for multi-color text)
         * @type Screens~TextSection[]
         */
        this._sections = null;
        /**
         * The character count of the actually rendered text (without modifiers, line breaks)
         * @type Number
         */
        this._textLength = 0;
        /**
         * A number between 0 and 1 which governs how much of the characters of the text should be rendered, starting from the first one (0-100%).
         * Increase from 0 to 1 over time for a "typewriter" style appear animation effect.
         * @type Number
         */
        this._revealState = 1;
        /**
         * The last measured value for offsetting lines, in pixels (based on the width of the letter 'M')
         * @type Number
         */
        this._lineHeight = -1;
        this.setText(text);
        this.setColor(color);
    }
    /**
     * Updates the stored string defining the font and its settings to be used for rendering to a canvas with the passed viewport size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     */
    CanvasText.prototype._updateCSSFont = function (viewportWidth, viewportHeight) {
        if (utils.scalesWithWidth(this._scaleMode, viewportWidth, viewportHeight)) {
            this._cssFont = this._size * viewportWidth + "px";
        } else {
            this._cssFont = this._size * viewportHeight + "px";
        }
        this._cssFont = this._cssFont + " " + this._font;
    };
    /**
     * Causes the clearing box layout to be recalculated during the next render
     */
    CanvasText.prototype.invalidateLayout = function () {
        this._boxValid = false;
    };
    /**
     * Recalculates the clearing box layout if it is invalid
     */
    CanvasText.prototype._updateLayout = function () {
        if (this._boxLayout && !this._boxValid) {
            this._boxTop = this._boxLayout.getTop(this._lastWidth, this._lastHeight);
            this._boxLeft = this._boxLayout.getLeft(this._lastWidth, this._lastHeight);
            this._boxWidth = this._boxLayout.getWidth(this._lastWidth, this._lastHeight);
            this._boxHeight = this._boxLayout.getHeight(this._lastWidth, this._lastHeight);
            this._boxValid = true;
        }
    };
    /**
     * Updates the cached variables that depend on the viewport size.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     */
    CanvasText.prototype._updateSize = function (viewportWidth, viewportHeight) {
        if ((viewportWidth !== this._lastWidth) || (viewportHeight !== this._lastHeight)) {
            this._lastWidth = viewportWidth;
            this._lastHeight = viewportHeight;
            this._updateCSSFont(viewportWidth, viewportHeight);
            this._textWidth = -1;
            this._boxValid = false;
        }
    };
    /**
     * Clears the area of the clearing box (if there is one) if it is not cleared
     * @param {CanvasRenderingContext2D} context
     */
    CanvasText.prototype._clearBox = function (context) {
        if (this._boxLayout && (this._boxWidth >= 0) && !this._boxCleared) {
            context.clearRect(this._boxLeft, this._boxTop, this._boxWidth, this._boxHeight);
            this._boxCleared = true;
        }
    };
    /**
     * Parses the text and generates the renderable sections based on:
     * - deliberate line breaks in the text
     * - lines that are too long to fit in the text layer or the layout box (breaking them by word-wrapping)
     * - modifiers in the text (e.g. "[color:r,g,b,a]colored text[]")
     * @param {CanvasRenderingContext2D} context This context is used to measure rendered text sizes to calculate the position offsets for
     * the sections
     */
    CanvasText.prototype._breakIntoSections = function (context) {
        var i, j, lines, sections, align, text, lineIndex, newText, lineWidth, newLineWidth, maxLineWidth, lineHeight, first, section, word, wordLeft, noSpacing, xOffset, start, end, modifier, color, index,
                /**
                 * Goes through the sections that belong to the last line, and adjusts their offset X position according to the text alignment
                 * used for this text.
                 */
                adjustLineSections = function () {
                    var k;
                    for (k = first; k < sections.length; k++) {
                        switch (align) {
                            case "right":
                                sections[k].xOffset -= lineWidth;
                                break;
                            case "center":
                                sections[k].xOffset -= 0.5 * lineWidth;
                                break;
                        }
                    }
                },
                /**
                 * Updates the parsing state for starting a new line (with a new section)
                 * @param {String} newLineText
                 */
                breakLine = function (newLineText) {
                    // adjust the section X offsets of the finished line
                    adjustLineSections();
                    lineIndex++;
                    sections.push({text: newLineText, xOffset: 0, yOffset: lineIndex * lineHeight, color: section && section.color});
                    // calculating section properties
                    if (section) {
                        section.length = section.text.length;
                        section.startIndex = index;
                        index += section.length;
                    }
                    section = sections[sections.length - 1];
                    first = sections.length - 1;
                    xOffset = 0;
                    lineWidth = (newLineText.length > 0) ? context.measureText(newLineText).width : 0;
                    noSpacing = false;
                },
                /**
                 * Updates the parsing state for starting a new section in the same line
                 * @param {Number[4]} [sectionColor] Color to use for this section
                 */
                startNewSectionInLine = function (sectionColor) {
                    xOffset += context.measureText(section.text).width;
                    sections.push({text: "", xOffset: xOffset, yOffset: lineIndex * lineHeight, color: sectionColor});
                    // calculating section properties
                    section.length = section.text.length;
                    section.startIndex = index;
                    index += section.length;
                    section = sections[sections.length - 1];
                },
                /**
                 * Applies the effect of the last parsed modifier by starting a new section with the appropriate new settings
                 */
                applyModifier = function () {
                    // handling closing modifier - cancels all section specific settings
                    if (modifier.length < 2) {
                        if (section.text.length > 0) {
                            startNewSectionInLine();
                        } else {
                            delete section.color;
                        }
                    } else {
                        // handling opening modifiers
                        switch (modifier[0]) {
                            // handling color modifier
                            case "color":
                                color = modifier[1].split(",").map(parseFloat);
                                // if there is already text in the current section, start a new one with the new color
                                if (section.text.length > 0) {
                                    startNewSectionInLine(color);
                                } else {
                                    // otherwise just set the color for this new, empty section
                                    section.color = color;
                                }
                                break;
                            default:
                                application.showError("Unrecognized text modifier: '" + modifier[0] + "'!");
                        }
                    }
                };
        // multiline support:
        // split the text into lines, taking into account deliberate line breaks as well as wrapping the text for the canvas / layout box size
        // updating cache variables
        lines = this._text.split("\n");
        // recalculate words as they might have been altered when the sections were last generated (e.g. modifiers are stripped)
        this._words = [];
        for (i = 0; i < lines.length; i++) {
            this._words.push(lines[i].split(" "));
        }
        // lines will be wrapped based on this width limit
        maxLineWidth = this._boxLayout ? this._boxWidth : this._lastWidth;
        this._textWidth = context.measureText(this._text).width;
        this._lineHeight = context.measureText("M").width * 1.2;
        this._sections = [];
        // caching properties
        sections = this._sections;
        lineHeight = this._lineHeight;
        align = this._align;
        // starting parser state
        lineIndex = -1;
        xOffset = 0;
        lineWidth = 0;
        first = 0;
        index = 0;
        // go through explicitly (\n) broken lines
        for (i = 0; i < this._words.length; i++) {
            breakLine("");
            // go through each word within the current line
            for (j = 0; j < this._words[i].length; j++) {
                word = this._words[i][j];
                // check for modifiers
                start = word.indexOf("[");
                if (start >= 0) {
                    end = word.indexOf("]");
                    modifier = word.substring(start + 1, end).split(":");
                    // if the word starts with a modifier
                    if (start === 0) {
                        // apply the effects of the modifier
                        applyModifier();
                        // if the modifier was part of a longer word, strip it from the word and continue with parsing the stripped word
                        if (word.length > (end + 1)) {
                            this._words[i][j] = word.substr(end + 1);
                            j--;
                            continue;
                        } else {
                            // if this word just a modifier by itself, skip further processing for this round as it doesn't need to be 
                            // included in the rendered text
                            continue;
                        }
                    } else {
                        // if there is a modifier somewhere within the word, extract the word for parsing and save the part starting with
                        // the modifier for the next parsing round
                        wordLeft = (end < (word.length - 1)) ? word.substr(end + 1) : null;
                        word = word.substring(0, start);
                    }
                } else {
                    wordLeft = null;
                }
                // parse regular words, and wrap them to the next line, if needed
                text = section.text;
                newText = text + (((lineWidth > 0) && !noSpacing) ? " " : "") + word;
                newLineWidth = xOffset + context.measureText(newText).width;
                // if the new word fits, add it to the current line
                if ((j === 0) || (newLineWidth < maxLineWidth)) {
                    section.text = newText;
                    lineWidth = newLineWidth;
                } else {
                    // otherwise start a new line with this word
                    breakLine(word);
                }
                noSpacing = false;
                // if there was a modifier detected (and stripped) in the word, apply it now that we added the word
                if (start > 0) {
                    applyModifier();
                }
                // if there was a part of the word after the detected modifier, prepare it for parsing in the next round
                if (wordLeft) {
                    this._words[i][j] = wordLeft;
                    j--;
                    noSpacing = true;
                    continue;
                }
            }
        }
        // set properties of the last section
        if (section) {
            section.length = section.text.length;
            section.startIndex = index;
            index += section.length;
        }
        this._textLength = index;
        // adjust the section X offsets of the last line
        adjustLineSections();
    };
    /**
     * Set how many of the characters of the text should be rendered, as a number between 0 and 1, representing 0-100%
     * Increase from 0 to 1 over time for a "typewriter" style appear animation effect.
     * @param {Number} value
     */
    CanvasText.prototype.setRevealState = function (value) {
        this._revealState = value;
    };
    /**
     * Renders the text using the passed 2D rendering context (of a canvas) according to its current settings.
     * @param {CanvasRenderingContext2D} context
     * @returns {Boolean} Whether text that needs to be cleared before the next render has been rendered
     */
    CanvasText.prototype.render = function (context) {
        var i, color, newColor, maxRenderIndex, text;
        if (this._visible) {
            this._clearBox(context);
            context.fillStyle = this._cssColor;
            this._updateSize(context.canvas.width, context.canvas.height);
            this._updateLayout();
            context.font = this._cssFont;
            // actual alignment is taken care of when breaking the text into sections and the appropriate offsets are calculated for the
            // left alignment
            context.textAlign = "left";
            if (this._boxLayout && (this._boxWidth >= 0)) {
                context.save();
                context.rect(this._boxLeft, this._boxTop, this._boxWidth, this._boxHeight);
                context.clip();
            }
            // the below code is only executed when rendering on a canvas with a new size
            if (this._textWidth < 0) {
                this._breakIntoSections(context);
            }
            // separately render each section for multiline and multi-color support
            color = this._cssColor;
            // calculate how many characters should be visible based on _revealState
            maxRenderIndex = Math.round(this._revealState * this._textLength);
            for (i = 0; (i < this._sections.length) && (this._sections[i].startIndex <= maxRenderIndex); i++) {
                // multi-color support
                if (this._sections[i].color) {
                    newColor = utils.getCSSColor(_getColor(this._sections[i].color));
                } else {
                    newColor = this._cssColor;
                }
                if (color !== newColor) {
                    color = newColor;
                    context.fillStyle = color;
                }
                // see if this section has all or only a part of its characters visible
                if (this._sections[i].startIndex + this._sections[i].length - 1 > maxRenderIndex) {
                    text = this._sections[i].text.substring(0, maxRenderIndex - this._sections[i].startIndex + 1);
                } else {
                    text = this._sections[i].text;
                }
                // rendering the section
                context.fillText(text, (this._x + 1) / 2 * this._lastWidth + this._sections[i].xOffset, (1 - this._y) / 2 * this._lastHeight + this._sections[i].yOffset);
            }
            if (this._boxLayout) {
                context.restore();
                this._boxCleared = (this._text.length === 0);
                // return false as there is no need to clear the whole text layer
                return false;
            } else {
                return this._text.length > 0;
            }
        } else {
            this._clearBox(context);
        }
        return false;
    };
    /**
     * Clears the cache variables depending on the size of the canvas the text is rendered to.
     */
    CanvasText.prototype.invalidate = function () {
        this._lastWidth = -1;
        this._lastHeight = -1;
        this._textWidth = -1;
    };
    /**
     * Sets a new position for the text (in the clip space of the canvas it is rendered to)
     * @param {Number[2]} position
     */
    CanvasText.prototype.setPosition = function (position) {
        this._x = position[0];
        this._y = position[1];
    };
    /**
     * Sets a new value for the actual text that is displayed when rendering this object.
     * @param {String} text
     * @param {Object} [replacements] If given, the provided text is taken as a format strings, with its references replaced by the values
     * provided in this object. (e.g. "hello, {w}", {w: "world"} -> "hello, world"
     */
    CanvasText.prototype.setText = function (text, replacements) {
        text = replacements ? utils.formatString(text, replacements) : text;
        if (text !== this._text) {
            this._text = text;
            this._textWidth = -1;
        }
    };
    /**
     * Sets a new RGBA color to use when rendering this text (also considers anaglyph rendering settings)
     * @param {Number[4]} color
     */
    CanvasText.prototype.setColor = function (color) {
        this._color = color;
        this._cssColor = utils.getCSSColor(_getColor(color));
    };
    /**
     * After calling this, the text is rendered whenever calling render() (until hidden)
     */
    CanvasText.prototype.show = function () {
        if (!this._visible) {
            this._visible = true;
            this.invalidate();
        }
    };
    /**
     * After calling this, the text is not rendered anymore when calling render() (until shown)
     */
    CanvasText.prototype.hide = function () {
        if (this._visible) {
            this._visible = false;
            this.invalidate();
        }
    };
    /**
     * Returns the layout of the clearing box associated with this text (if any)
     * @returns {ClipSpaceLayout}
     */
    CanvasText.prototype.getBoxLayout = function () {
        return this._boxLayout;
    };
    // #########################################################################
    /**
     * @class
     * Represents a rectangular area to which texts can be added and rendered to, with a layout specified in the clip-space of a containing 
     * larger viewport. Implemented using a 2D canvas.
     * @param {LayoutDescriptor} layoutDescriptor The object describing the layout settings for the area
     */
    function TextLayer(layoutDescriptor) {
        /**
         * The canvas used to render this text layer.
         * @type HTMLCanvasElement
         */
        this._canvas = document.createElement("canvas");
        /**
         * The object storing the layout settings for this text layer.
         * @type ClipSpaceLayout
         */
        this._clipSpaceLayout = new ClipSpaceLayout(layoutDescriptor);
        /**
         * The 2D context used to render the texts on this layer.
         * @type CanvasRenderingContext2D
         */
        this._context = this._canvas.getContext("2d", {alpha: true});
        this._context.textBaseline = "top";
        /**
         * The list of stored texts that are rendered when this layer is rendered.
         * @type CanvasText[]
         */
        this._texts = [];
        /**
         * Whether the texts on this layer should be rendered when the layer is rendered.
         * @type Boolean
         */
        this._visible = true;
        /**
         * Whether the area of this text layer is currently cleared to transparent color.
         * @type Boolean
         */
        this._cleared = true;
        /**
         * The width of the viewport this canvas has last been laid out to
         * @type Number
         */
        this._viewportWidth = -1;
        /**
         * The height of the viewport this canvas has last been laid out to
         * @type Number
         */
        this._viewportHeight = -1;
    }
    /**
     * Clears the whole area of this text layer of all the previously rendered texts.
     * @param {String} [borderStyle] If given, a border with this style will be drawn at the edges of the area of this text layer.
     */
    TextLayer.prototype.clearContext = function (borderStyle) {
        if (!this._cleared) {
            this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
            if (borderStyle) {
                this._context.strokeStyle = borderStyle;
                this._context.strokeRect(0, 0, this._canvas.width, this._canvas.height);
            }
            this._cleared = true;
        }
    };
    /**
     * Adds a new text object to the list of texts that are rendered on this layer.
     * @param {CanvasText} value
     */
    TextLayer.prototype.addText = function (value) {
        this._texts.push(value);
    };
    /**
     * If currently visible, rendered all (visible) texts to this layer.
     */
    TextLayer.prototype.render = function () {
        var i;
        if (this._visible) {
            this.clearContext();
            for (i = 0; i < this._texts.length; i++) {
                this._cleared = !this._texts[i].render(this._context) && this._cleared;
            }
        }
    };
    /**
     * Recalculates the position and dimensions of the text layer based on its set layout (call after
     * the layout has been altered)
     */
    TextLayer.prototype.updateLayout = function () {
        this._canvas.style.top = this._clipSpaceLayout.getTop(this._viewportWidth, this._viewportHeight) + "px";
        this._canvas.style.left = this._clipSpaceLayout.getLeft(this._viewportWidth, this._viewportHeight) + "px";
        this._canvas.width = this._clipSpaceLayout.getWidth(this._viewportWidth, this._viewportHeight);
        this._canvas.height = this._clipSpaceLayout.getHeight(this._viewportWidth, this._viewportHeight);
        this._cleared = false;
    };
    /**
     * Repositions and resizes the text layer area accordingly if the size of the containing viewport has changed as given.
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     */
    TextLayer.prototype.handleResize = function (viewportWidth, viewportHeight) {
        this._viewportWidth = viewportWidth;
        this._viewportHeight = viewportHeight;
        this.updateLayout();
    };
    /**
     * Sets a new containing canvas the position and size of which will determine the position and size of this text layer.
     * @param {HTMLCanvasElement} container
     */
    TextLayer.prototype.setContainer = function (container) {
        this.handleResize(container.width, container.height);
        container.parentNode.appendChild(this._canvas);
        this._canvas.style.position = "absolute";
        this._canvas.zIndex = container.zIndex + 1;
    };
    /**
     * Returns whether the text layer is currently visible
     * @returns {Boolean}
     */
    TextLayer.prototype.isVisible = function () {
        return this._visible;
    };
    /**
     * After calling this, the (visible) texts on this layer are rendered whenever calling render()
     */
    TextLayer.prototype.show = function () {
        var i;
        if (!this._visible) {
            for (i = 0; i < this._texts.length; i++) {
                this._texts[i].invalidate();
            }
            this._visible = true;
            this._canvas.hidden = false;
        }
    };
    /**
     * Clears the text layer and after calling this, no texts on this layer are rendered when calling render()
     */
    TextLayer.prototype.hide = function () {
        var i;
        if (this._visible) {
            this.clearContext();
            for (i = 0; i < this._texts.length; i++) {
                this._texts[i].invalidate();
            }
            this._visible = false;
            this._canvas.hidden = true;
        }
    };
    /**
     * Returns the layout object specifying the positioning and sizing rules for this text layer.
     * @returns {ClipSpaceLayout}
     */
    TextLayer.prototype.getLayout = function () {
        return this._clipSpaceLayout;
    };
    // #########################################################################
    /**
     * @class An enhanced canvas element (a wrapper around a regular HTML canvas), 
     * that can create and hold a reference to a managed WebGL context for the canvas.
     * @param {HTMLCanvasElement} canvas The canvas around which this object should be created.
     * @param {Boolean} antialiasing Whether antialiasing should be turned on for the GL context of this canvas
     * @param {Boolean} alpha Whether alpha channel support (blending with the HTML element behind the canvas) 
     * should be turned on for this canvas.
     * @param {String} filtering (enum managedGL.TextureFiltering) What texture filtering mode to use when rendering to this canvas
     */
    function ScreenCanvas(canvas, antialiasing, alpha, filtering) {
        /**
         * A reference to the wrapped HTML5 canvas.
         * @type HTMLCanvasElement
         */
        this._canvas = canvas;
        /**
         * Whether the size of this canvas can change when resizing the screen
         * @type Boolean
         */
        this._resizeable = canvas.classList.contains(RESIZEABLE_CLASS_NAME);
        /**
         * Whether antialiasing should be turned on for the GL context of this canvas
         * @type Boolean
         */
        this._antialiasing = antialiasing;
        /**
         * Whether alpha channel support (blending with the HTML element behind the canvas) 
         * is turned on for (the GL context of) this canvas.
         * @type Boolean
         */
        this._alpha = alpha;
        /**
         * (enum managedGL.TextureFiltering) What texture filtering mode to use when rendering to this canvas
         * @type String
         */
        this._filtering = types.getEnumValue(managedGL.TextureFiltering, filtering, {name: "ScreenCanvas.filtering"});
        /**
         * A reference to the managed GL context associated with this canvas.
         * @type ManagedGLContext
         */
        this._context = null;
        /**
         * The list of stored text layers that can be used to render 2D text, using smaller canvases with 2D rendering contexts superimposed
         * on the main canvas. (this way not the whole area of the canvas needs to be cleared for each frame, only the parts that contain
         * text)
         * @type TextLayer[]
         */
        this._textLayers = [];
    }
    /**
     * Returns the stored HTML canvas element.
     * @returns {HTMLCanvasElement}
     */
    ScreenCanvas.prototype.getCanvasElement = function () {
        return this._canvas;
    };
    /**
     * Tells if the canvas is resizeable = if it has a dynamic size that changes when the window is resized.
     * @returns {Boolean}
     */
    ScreenCanvas.prototype.isResizeable = function () {
        return this._resizeable;
    };
    /**
     * Returns a managed WebGL context created for the canvas. It creates the 
     * context if it does not exist yet.
     * @returns {ManagedGLContext}
     */
    ScreenCanvas.prototype.getManagedContext = function () {
        if (!this._context) {
            this._context = new managedGL.ManagedGLContext(this._canvas.getAttribute("id"), this._canvas, this._antialiasing, this._alpha, this._filtering);
        }
        return this._context;
    };
    /**
     * If a managed context has already been created for this canvas, clears it so that it can be safely set up again with e.g. new 
     * framebuffers or vertexbuffers. Does not remove the added resources from the context.
     */
    ScreenCanvas.prototype.clearManagedContext = function () {
        if (this._context) {
            this._context.clear();
        }
    };
    /**
     * Sets a new antialiasing setting for the managed context to be created for this canvas, or if it was already created, notifies a user
     * that a restart is required.
     * @param {Boolean} value
     * @returns {Boolean} Whether the antialiasing value is now the same as the passed one.
     */
    ScreenCanvas.prototype.setAntialiasing = function (value) {
        if (value !== this._antialiasing) {
            if (this._context) {
                application.showError(strings.get(ANTIALIASING_CHANGE_ERROR_STRING));
                return false;
            }
            this._antialiasing = value;
        }
        return true;
    };
    /**
     * Sets a new filtering option for the textures rendered to the managed context of this canvas.
     * @param {String} value (enum ManagedGL.TextureFiltering)
     */
    ScreenCanvas.prototype.setFiltering = function (value) {
        if (value !== this._filtering) {
            this._filtering = value;
            if (this._context) {
                this._context.setFiltering(this._filtering);
            }
        }
    };
    /**
     * Resizes the viewport of the wrapped canvas and any text layer canvases. To be called in case the window size changes.
     */
    ScreenCanvas.prototype.handleResize = function () {
        var
                width = this._canvas.clientWidth,
                height = this._canvas.clientHeight,
                i;
        if (this._canvas.width !== width ||
                this._canvas.height !== height) {
            // Change the size of the canvas to match the size it's being displayed
            this._canvas.width = width;
            this._canvas.height = height;
            for (i = 0; i < this._textLayers.length; i++) {
                this._textLayers[i].handleResize(width, height);
            }
        }
    };
    /**
     * Adds the passed text layer to the list of text layers rendered on top of this canvas.
     * @param {TextLayer} value
     */
    ScreenCanvas.prototype.addTextLayer = function (value) {
        this._textLayers.push(value);
        value.setContainer(this._canvas);
    };
    /**
     * Renders all the text layers that were added on top of this canvas.
     */
    ScreenCanvas.prototype.renderTextLayers = function () {
        var i;
        for (i = 0; i < this._textLayers.length; i++) {
            this._textLayers[i].render();
        }
    };
    // #########################################################################
    /**
     * @class Represents a game screen that has one or more canvases where WebGL scenes can be rendered.
     * @extends HTMLScreen
     * @param {String} name The name by which this screen can be identified.
     * @param {String} htmlFilename See HTMLScreen.
     * @param {HTMLScreen~Style} [style] See HTMLScreen.
     * @param {Boolean} antialiasing Whether antialiasing should be turned on for the GL contexts of the canvases of this screen
     * @param {Boolean|Object.<String, Boolean>} alpha Whether alpha channel support should be turned on for the GL contexts of the 
     * canvases of this screen. It can be specified altogether (Boolean) or on a per-canvas basis (Object storing Booleans for the
     * IDs of the canvases)
     * @param {String} filtering (enum managedGL.TextureFiltering) What texture filtering mode to use when rendering to a canvases of this screen
     * @param {Boolean} [useRequestAnimFrame=false] Whether to use the requestAnimationFrame API for the render loop
     * (as opposed to setInterval)
     * @param {Object.<String, Function>} [eventHandlers] Event handler functions to be executed when something happens to this page, by the
     * names of the events as keys
     * @param {Object.<String, Function>} [keyCommands] Event handler functions to be executed
     * while this screen is active, by the names of the keys (as in utils.getKeyCodeOf())
     * @param {Object.<String, Object.<String, Function>>} [elementEventHandlers] See HTMLScreen
     */
    function HTMLScreenWithCanvases(name, htmlFilename, style, antialiasing, alpha, filtering, useRequestAnimFrame, eventHandlers, keyCommands, elementEventHandlers) {
        HTMLScreen.call(this, name, htmlFilename, style, eventHandlers, keyCommands, elementEventHandlers);
        /**
         * Whether antialiasing should be turned on for the GL contexts of the canvases of this screen
         * @type Boolean
         */
        this._antialiasing = antialiasing;
        /**
         * Whether alpha channel support should be turned on for the GL contexts of the 
         * canvases of this screen. It can be specified altogether (Boolean) or on a per-canvas basis (Object storing Booleans for the
         * IDs of the canvases)
         * @type Boolean|Object.<String, Boolean>
         */
        this._alpha = alpha;
        /**
         * (enum managedGL.TextureFiltering) What texture filtering mode to use when rendering to a canvases of this screen
         * @type String
         */
        this._filtering = htmlFilename ? types.getEnumValue(managedGL.TextureFiltering, filtering, {name: "HTMLScreenWithCanvases.filtering"}) : null;
        /**
         * Stores the canvases of the screen by their names (IDs)
         * @type Object.<String, ScreenCanvas>
         */
        this._canvases = {};
        /**
         * @typedef {Object} HTMLScreenWithCanvases~ScreenCanvasBinding
         * @property {Scene} scene
         * @property {ScreenCanvas} canvas
         */
        /**
         * Stores all the active bindings that exist between the canvases of this screen and WebGL (SceneGraph)
         * Scenes. When calling render or starting the render loop, all the scenes present in these bindings
         * will be automatically rendered on their corresponding canvases.
         * @type HTMLScreenWithCanvases~ScreenCanvasBinding[]
         */
        this._sceneCanvasBindings = [];
        /**
         * An ID for the render loop so that it can be cleared (when using setInterval)
         * @type Number
         */
        this._renderLoop = LOOP_CANCELED;
        /**
         * Stores the timestamps of the last renders so that the FPS can be calculated.
         * @type DOMHighResTimeStamp[]
         */
        this._renderTimes = [];
        /**
         * @type Number
         */
        this._minFPS = 0;
        /**
         * @type Number
         */
        this._maxFPS = 0;
        /**
         * Sum of measured FPS values for averaging
         * @type Number
         */
        this._fpsSum = 0;
        /**
         * Count of frame for which FPS was measured, for averaging
         * @type Number
         */
        this._fpsFrameCount = 0;
        /**
         * A reference to the function that is set to handle the resize event for this screen so
         * that it can be removed if the screen is no longer active.
         * @type Function
         */
        this._resizeEventListener = null;
        /**
         * Whether to use the requestAnimationFrame API for the render loop (as opposed to setInterval)
         * @type Boolean
         */
        this._useRequestAnimFrame = useRequestAnimFrame;
    }
    HTMLScreenWithCanvases.prototype = new HTMLScreen();
    HTMLScreenWithCanvases.prototype.constructor = HTMLScreenWithCanvases;
    /**
     * A handler for the resize event of the window so that e.g. the projection matrices used to render
     * the scene can be adjusted for the new aspect ratio.
     */
    HTMLScreenWithCanvases.prototype.handleResize = function () {
        this.resizeCanvases();
        if (this._renderLoop === LOOP_CANCELED) {
            this.render();
        }
    };
    /**
     * Removes all stored binding between scenes and canvases. 
     * This removes all references to the related scenes existing in this object.
     */
    HTMLScreenWithCanvases.prototype.clearSceneCanvasBindings = function () {
        var i;
        for (i = 0; i < this._sceneCanvasBindings.length; i++) {
            this._sceneCanvasBindings[i].canvas.clearManagedContext();
        }
        this._sceneCanvasBindings = [];
    };
    /**
     * @override
     * Stops the render loops next to hiding the page.
     * @returns {Boolean}
     */
    HTMLScreenWithCanvases.prototype.hide = function () {
        if (HTMLScreen.prototype.hide.call(this)) {
            this.stopRenderLoop();
            return true;
        }
        return false;
    };
    /**
     * Returns whether the alpha channel should be turned on for the canvas with the given name on this screen.
     * @param {String} canvasName The name of the canvas (the id of the canvas element without the page specific
     * prefixes)
     * @returns {Boolean}
     */
    HTMLScreenWithCanvases.prototype._getAlphaForCanvas = function (canvasName) {
        if (typeof this._alpha === "boolean") {
            return this._alpha;
        }
        if (typeof this._alpha[canvasName] === "boolean") {
            return this._alpha[canvasName];
        }
        application.showError("No alpha channel support is defined for canvas '" + canvasName + "' of screen '" + this._name + "'!");
        return false;
    };
    /**
     * @override
     * Initializes the components of the parent class, then the additional ones for
     * this class (the canvases).
     */
    HTMLScreenWithCanvases.prototype._initializeComponents = function () {
        var canvasElements, i;
        HTMLScreen.prototype._initializeComponents.call(this);
        canvasElements = this._container.getElementsByTagName("canvas");
        for (i = 0; i < canvasElements.length; i++) {
            this._canvases[canvasElements[i].getAttribute("id")] = new ScreenCanvas(
                    canvasElements[i],
                    this._antialiasing,
                    this._getAlphaForCanvas(this._getOriginalElementID(canvasElements[i])),
                    this._filtering);
        }
        // save a specific reference so we can remove it later
        this._resizeEventListener = this.handleResize.bind(this);
        window.addEventListener("resize", this._resizeEventListener);
    };
    /**
     * Returns the stored canvas component that corresponds to the HTML5 canvas element with the passed
     * original ID.
     * @param {String} name
     * @returns {ScreenCanvas}
     */
    HTMLScreenWithCanvases.prototype.getScreenCanvas = function (name) {
        return this._canvases[this._getElementID(name)];
    };
    /**
     * Creates a binding between the passed scene and canvas, causing the scene to
     * be rendered on the canvas automatically in the render loop of this screen.
     * @param {Scene} scene
     * @param {ScreenCanvas} canvas
     */
    HTMLScreenWithCanvases.prototype.bindSceneToCanvas = function (scene, canvas) {
        var alreadyBound = false, i;
        for (i = 0; i < this._sceneCanvasBindings.length; i++) {
            if (
                    (this._sceneCanvasBindings[i].scene === scene) &&
                    (this._sceneCanvasBindings[i].canvas === canvas)) {
                alreadyBound = true;
            }
        }
        if (alreadyBound === false) {
            this._sceneCanvasBindings.push({
                scene: scene,
                canvas: canvas
            });
        }
        scene.addToContext(canvas.getManagedContext());
        if (this._renderLoop !== LOOP_CANCELED) {
            canvas.getManagedContext().setup();
        }
    };
    /**
     * Sets a new antialiasing setting for the managed contexts to be created for the canvases of this screen, or if some were already 
     * created with a different antialiasing setting, notifies a user that a restart is required.
     * @param {Boolean} value
     */
    HTMLScreenWithCanvases.prototype.setAntialiasing = function (value) {
        var canvasName;
        if (value !== this._antialiasing) {
            this._antialiasing = value;
            for (canvasName in this._canvases) {
                if (this._canvases.hasOwnProperty(canvasName)) {
                    if (!this._canvases[canvasName].setAntialiasing(this._antialiasing)) {
                        return;
                    }
                }
            }
        }
    };
    /**
     * Sets a new filtering option for the textures rendered to the managed contexts of the canvases of this screen.
     * @param {String} value (enum ManagedGL.TextureFiltering)
     */
    HTMLScreenWithCanvases.prototype.setFiltering = function (value) {
        var canvasName;
        value = types.getEnumValue(managedGL.TextureFiltering, value, {name: "HTMLScreenWithCanvases.filtering", defaultValue: this._filtering});
        if (value !== this._filtering) {
            this._filtering = value;
            for (canvasName in this._canvases) {
                if (this._canvases.hasOwnProperty(canvasName)) {
                    this._canvases[canvasName].setFiltering(this._filtering);
                }
            }
        }
    };
    /**
     * The core render function that needs to be overridden adding any additional rendering next to
     * rendering the bound scenes to their canvases.
     * @param {Number} dt The time passed since the last render in milliseconds.
     */
    HTMLScreenWithCanvases.prototype._render = function (dt) {
        var i, canvasNames;
        canvasNames = Object.keys(this._canvases);
        for (i = 0; i < this._sceneCanvasBindings.length; i++) {
            this._sceneCanvasBindings[i].scene.render(this._sceneCanvasBindings[i].canvas.getManagedContext(), dt);
        }
        for (i = 0; i < canvasNames.length; i++) {
            this._canvases[canvasNames[i]].renderTextLayers();
        }
    };
    /**
     * Calls the core render method and manages the timestamps for FPS calculation as a simple 
     * standalone method that can be used with setInterval or on its own for a single render.
     */
    HTMLScreenWithCanvases.prototype.render = function () {
        var d, dt, shifted, fps;
        d = performance.now();
        dt = (this._renderTimes && (this._renderTimes.length > 0)) ? (d - this._renderTimes[this._renderTimes.length - 1]) : 0;
        this._render(dt);
        if (this._renderLoop !== LOOP_CANCELED) {
            this._renderTimes.push(d);
            shifted = false;
            while ((this._renderTimes.length > 1) && ((d - this._renderTimes[0]) > 1000)) {
                this._renderTimes.shift();
                shifted = true;
            }
            if (shifted) {
                fps = this._renderTimes.length;
                if ((this._minFPS === 0) || (this._minFPS > fps)) {
                    this._minFPS = fps;
                }
                if ((this._maxFPS === 0) || (this._maxFPS < fps)) {
                    this._maxFPS = fps;
                }
                this._fpsSum += fps;
                this._fpsFrameCount++;
            }
        }
    };
    /**
     * Calls the core render method and manages the timestamps for FPS calculation, and if needed, maintains
     * the render loop using the RequestAnimationFrame API.
     * @param {DOMHighResTimeStamp} timestamp
     */
    HTMLScreenWithCanvases.prototype._renderRequestAnimFrame = function (timestamp) {
        var dt, shifted, fps;
        if (this._renderLoop !== LOOP_CANCELED) {
            dt = (this._renderTimes && (this._renderTimes.length > 0)) ? (timestamp - this._renderTimes[this._renderTimes.length - 1]) : 0;
            this._render(dt);
            this._renderTimes.push(timestamp);
            shifted = false;
            while ((this._renderTimes.length > 1) && ((timestamp - this._renderTimes[0]) > 1000)) {
                this._renderTimes.shift();
                shifted = true;
            }
            if (shifted) {
                fps = this._renderTimes.length;
                if ((this._minFPS === 0) || (this._minFPS > fps)) {
                    this._minFPS = fps;
                }
                if ((this._maxFPS === 0) || (this._maxFPS < fps)) {
                    this._maxFPS = fps;
                }
                this._fpsSum += fps;
                this._fpsFrameCount++;
            }
            window.requestAnimationFrame(this._renderRequestAnimFrame.bind(this));
        }
    };
    /**
     * Starts the render loop, by beginning to execute the render function every interval milliseconds or
     * using the requestAnimationFrame API.
     * @param {Number} interval This will only be considered if setInterval, and not the RequestAnimationFrame
     * API is used
     */
    HTMLScreenWithCanvases.prototype.startRenderLoop = function (interval) {
        var i;
        if (this._renderLoop === LOOP_CANCELED) {
            for (i = 0; i < this._sceneCanvasBindings.length; i++) {
                this._sceneCanvasBindings[i].canvas.getManagedContext().setup();
            }
            this._renderTimes = [performance.now()];
            this._minFPS = 0;
            this._maxFPS = 0;
            this._fpsSum = 0;
            this._fpsFrameCount = 0;
            if (this._useRequestAnimFrame) {
                this._renderLoop = LOOP_REQUESTANIMFRAME;
                window.requestAnimationFrame(this._renderRequestAnimFrame.bind(this));
            } else {
                this._renderLoop = setInterval(function () {
                    this.render();
                }.bind(this), interval);
            }
        }
    };
    /**
     * Stops the render loop.
     */
    HTMLScreenWithCanvases.prototype.stopRenderLoop = function () {
        if (this._renderLoop !== LOOP_CANCELED) {
            if (!this._useRequestAnimFrame) {
                clearInterval(this._renderLoop);
            }
            this._renderLoop = LOOP_CANCELED;
            this._renderTimes = [];
        }
    };
    /**
     * Returns the Frames Per Second count for this screen's render loop.
     * @returns {Number}
     */
    HTMLScreenWithCanvases.prototype.getFPS = function () {
        return this._renderTimes.length;
    };
    /**
     * Returns the the current, minimum and maximum FPS values (as a string) for this screen's render loop.
     * @returns {String}
     */
    HTMLScreenWithCanvases.prototype.getFPSStats = function () {
        return this._renderTimes.length + " (" + ((this._fpsFrameCount > 0) ? Math.round(this._fpsSum / this._fpsFrameCount) : "0") + ", " + this._minFPS + "-" + this._maxFPS + ")";
    };
    /**
     * Updates all needed variables when the screen is resized.
     */
    HTMLScreenWithCanvases.prototype.resizeCanvases = function () {
        var canvasName;
        // first, update the canvas width and height properties if the client width/
        // height has changed
        for (canvasName in this._canvases) {
            if (this._canvases.hasOwnProperty(canvasName)) {
                if (this._canvases[canvasName].isResizeable() === true) {
                    this._canvases[canvasName].handleResize();
                }
            }
        }
    };
    // #########################################################################
    /**
     * @class A game screen with a menu component and related convenience constructor.
     * @extends HTMLScreen
     * @param {String} name See HTMLScreen.
     * @param {String} htmlFilename See HTMLScreen.
     * @param {HTMLScreen~Style} [style] See HTMLScreen.
     * @param {String} menuHTMLFilename The filename of the HTML source file of the menu component.
     * @param {MenuComponent~Style} [menuStyle] The style information for the menu component.
     * @param {MenuComponent~MenuOption[]} menuOptions The menuOptions for creating the menu component.
     * @param {String} [menuContainerID] The ID of the HTML element inside of which
     * the menu should be added (if omitted, it will be appended to body)
     * @param {Object.<String, Function>} [eventHandlers] Event handler functions for BOTH the screen AND THE MenuComponent ON THE SCREEN!
     * @param {Object.<String, Function>} [keyCommands] Event handler functions to be executed
     * while this screen is active, by the names of the keys (as in utils.getKeyCodeOf())
     * @param {Object.<String, Object.<String, Function>>} [elementEventHandlers] See HTMLScreen
     */
    function MenuScreen(name, htmlFilename, style, menuHTMLFilename, menuStyle, menuOptions, menuContainerID, eventHandlers, keyCommands, elementEventHandlers) {
        HTMLScreen.call(this, name, htmlFilename, style, eventHandlers, this._getKeyCommands(keyCommands), elementEventHandlers);
        /**
         * The menuOptions for creating the menu component.
         * @type MenuComponent~MenuOption[]
         */
        this._menuOptions = menuOptions;
        /**
         * The ID of the HTML element inside of which the menu will be added. If
         * undefined, it will be appended to the document body.
         * @type String
         */
        this._menuContainerID = menuContainerID;
        /**
         * The component generating the HTML menu.
         * @type MenuComponent
         */
        this._menuComponent = this.registerExternalComponent(
                new components.MenuComponent(
                        MENU_COMPONENT_NAME,
                        menuHTMLFilename,
                        menuStyle,
                        this._menuOptions,
                        eventHandlers),
                this._menuContainerID);
    }
    MenuScreen.prototype = new HTMLScreen();
    MenuScreen.prototype.constructor = MenuScreen;
    /**
     * Adds the default menu key commands (up-down-enter) to the given key commands object and returns the
     * result.
     * @param {Object.<String, Function>} [keyCommands] If not given, an object with just the default commands
     * will be returned.
     */
    MenuScreen.prototype._getKeyCommands = function (keyCommands) {
        keyCommands = keyCommands || {};
        keyCommands.up = keyCommands.up || function () {
            this._menuComponent.selectPrevious();
        }.bind(this);
        keyCommands.down = keyCommands.down || function () {
            this._menuComponent.selectNext();
        }.bind(this);
        keyCommands.enter = keyCommands.enter || function () {
            this._menuComponent.activateSelected();
        }.bind(this);
        return keyCommands;
    };
    /**
     * @override
     * @param {Boolean} active
     */
    MenuScreen.prototype.setActive = function (active) {
        HTMLScreen.prototype.setActive.call(this, active);
        this._menuComponent.unselect();
    };
    // -------------------------------------------------------------------------
    // Public functions
    /**
     * Sets up the anaglyph rendering settings. After anaglyph text rendering is enabled,
     * setting a CanvasText color will consider the settings appropriately (existing colors
     * will not be changed)
     * @param {Boolean} enabled
     * @param {Number} originalColorRatio
     * @param {Number} cyanFactor
     * @param {Number} gamma
     */
    function setAnaglyphTextRendering(enabled, originalColorRatio, cyanFactor, gamma) {
        _anaglyphTextRendering.enabled = enabled;
        _anaglyphTextRendering.originalColorRatio = originalColorRatio;
        _anaglyphTextRendering.filter[1] = cyanFactor;
        _anaglyphTextRendering.filter[2] = cyanFactor;
        _anaglyphTextRendering.gamma = gamma;
    }
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        ELEMENT_ID_SEPARATOR: ELEMENT_ID_SEPARATOR,
        HTMLScreen: HTMLScreen,
        CanvasText: CanvasText,
        ClipSpaceLayout: ClipSpaceLayout,
        TextLayer: TextLayer,
        HTMLScreenWithCanvases: HTMLScreenWithCanvases,
        MenuScreen: MenuScreen,
        setAnaglyphTextRendering: setAnaglyphTextRendering
    };
});
/**
 * Copyright 2017-2018, 2020 Krisztián Nagy
 * @file This is a simple analytics module that sends requests to an analytics backend
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, location, document, JSON */

/**
 * @param application Used for logging
 */
define('modules/analytics',[
    "modules/application"
], function (application) {
    "use strict";
    // private variables
    var
            /**
             * The base of the URL of the analytics backend to send the requests to
             * @type String
             */
            _baseUrl = null,
            /**
             * Unique component of the ID identifying the user within the analytics context
             * @type String
             */
            _id,
            /**
             * Random component of the ID identifying the user within the analytics context
             * @type String
             */
            _userID,
            /**
             * Whether analytics reporting is currently enabled
             * @type Boolean
             */
            _enabled = false,
            /**
             * Whether the login request has already been sent to the analytics backend
             * @type Boolean
             */
            _loginSent = false,
            // -------------------------------------------------------------------------
            // Private methods
            /**
             * Send a POST request to the analytics backend with the specified path
             * @param {String} path
             * @param {Function} onfinish Function to execute when the request finishes. Gets the request back if it succeeded, otherwise gets no arguments.
             */
            _sendRequest = function (path, onfinish) {
                var request = new XMLHttpRequest();
                if (!_enabled) {
                    return;
                }
                request.onload = function () {
                    application.log_DEBUG("Analytics request: '" + path + "' successfully completed.", 2);
                    onfinish(request);
                }.bind(this);
                request.onerror = function () {
                    application.log_DEBUG("ERROR: An error occured during analytics request: '" + path + "'. The status of the request was: '" + request.statusText + "' when the error happened.", 1);
                    onfinish();
                }.bind(this);
                request.ontimeout = function () {
                    application.log_DEBUG("Analytics request : '" + path + "' timed out.", 1);
                    onfinish();
                }.bind(this);
                request.overrideMimeType("text/plain; charset=utf-8");
                request.open("POST", _baseUrl + path, true);
                request.send(null);
            };
    // -------------------------------------------------------------------------
    // Public methods
    /**
     * Initializes analytics settings from LocalStorage
     * @param {String} baseUrl The base URL of the analytics backend
     */
    function init(baseUrl) {
        _baseUrl = baseUrl;
        _id = localStorage.analytics_id;
        _userID = localStorage.analytics_user_id;
        _enabled = localStorage.analytics_enabled ? (localStorage.analytics_enabled === true.toString()) : true;
    }
    /**
     * Notifies the backend of the login, requesting and saving a new analytics ID if there is none (or an invalid one)
     * The request is only executed once (nothing happens on subsequent calls)
     */
    function login() {
        var newUser = !(_id && _userID);
        if (_loginSent) {
            return;
        }
        _loginSent = true;
        _sendRequest("start" + (newUser ? "" : ("/" + _id + "/" + _userID)) + "?version=" + application.getVersion().split(" ")[0], function (request) {
            if (request) {
                var data = JSON.parse(request.responseText);
                if (data.newlyCreated && data.id && data.userID) {
                    _id = data.id;
                    _userID = data.userID;
                    localStorage.analytics_id = _id;
                    localStorage.analytics_user_id = _userID;
                    application.log_DEBUG("Successfully created new user '" + _id + "/" + _userID + "' for analytics.", 2);
                } else {
                    application.log_DEBUG("Successfully logged user '" + _id + "/" + _userID + "' for analytics.", 2);
                }
            }
        });
    }
    /**
     * Sends an event to the analytics backend
     * @param {String} eventName
     * @param {String[]} [urlParams]
     * @param {Object} [queryParams]
     */
    function sendEvent(eventName, urlParams, queryParams) {
        var url, i, p;
        if (!_enabled) {
            return;
        }
        if (!(_id && _userID)) {
            application.log_DEBUG("Warning! Cannot send analytics event, because user is not identified!", 2);
            return;
        }
        url = eventName + "/" + _id + "/" + _userID;
        if (urlParams) {
            for (i = 0; i < urlParams.length; i++) {
                url += "/" + urlParams[i];
            }
        }
        if (queryParams) {
            url += "?";
            p = Object.keys(queryParams);
            for (i = 0; i < p.length; i++) {
                url += p[i] + "=" + queryParams[p[i]] + "&";
            }
        }
        _sendRequest(url, function (request) {
            if (request) {
                application.log_DEBUG("Successfully sent analytics event '" + eventName + "'!", 2);
            }
        });
    }
    /**
     * Returns whether analytics reporting is currently enabled
     * @returns {Boolean}
     */
    function isEnabled() {
        return _enabled;
    }
    /**
     * Enables analytics reporting, and notifies the backend
     */
    function enable() {
        if (!_enabled) {
            _enabled = true;
            localStorage.analytics_enabled = true.toString();
            sendEvent("enable");
        }
    }
    /**
     * Disables analytics reporting, and notifies the backend
     */
    function disable() {
        if (_enabled) {
            sendEvent("disable");
            _enabled = false;
            localStorage.analytics_enabled = false.toString();
        }
    }
    /**
     * Enables/disables analytics reporting depending on the passed value, and notifies the backend
     * @param {Boolean} value 
     */
    function setEnabled(value) {
        if (value) {
            enable();
        } else {
            disable();
        }
    }
    // -------------------------------------------------------------------------
    // The public interface of the module
    return {
        init: init,
        login: login,
        sendEvent: sendEvent,
        isEnabled: isEnabled,
        enable: enable,
        disable: disable,
        setEnabled: setEnabled
    };
});
/**
 * Copyright 2014-2020 Krisztián Nagy
 * @file This module manages and provides the Battle screen of the Interstellar Armada game.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 2.0
 */

/*global define, document, setInterval, clearInterval, window, performance */

/**
 * @param utils Used for string formatting, async calls.
 * @param vec Used for vector operation for the HUD elements.
 * @param mat Used for matrix operation for the HUD elements and displaying matrix stats.
 * @param application Used for displaying errors and logging.
 * @param game Used for navigation
 * @param components Used for the components of the screen (e.g. loading box)
 * @param screens The battle screen is a HTMLScreenWithCanvases.
 * @param renderableObjects Used for creating the HUD elements
 * @param sceneGraph Used for creating the battle scene and the nodes for the HUD elements.
 * @param analytics Used for reporting mission start/win/lose/score events.
 * @param resources Used for accessing the resources for the HUD and for requesting the loading of reasourcing and setting callback for when they are ready.
 * @param egomModel Used for creating the models for the HUD elements
 * @param strings Used for translation support.
 * @param armadaScreens Used for common screen constants.
 * @param graphics Used for accessing graphics settings.
 * @param audio Used for controlling volume (muting when opening the menu)
 * @param classes Used for HUD elements for convenient acquiry of their resources.
 * @param config Used to access game setting / configuration.
 * @param control Used for global game control functions.
 * @param SpacecraftEvents used for setting spacecraft event handlers
 * @param missions Used for creating the Mission object, accessing enums.
 * @param equipment Used to access flight mode constants
 * @param ai Used for performing the AI control operations in the battle simulation loop.
 */
define('armada/screens/battle',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/application",
    "modules/game",
    "modules/components",
    "modules/screens",
    "modules/media-resources",
    "modules/egom-model",
    "modules/scene/renderable-objects",
    "modules/scene/scene-graph",
    "modules/analytics",
    "armada/strings",
    "armada/screens/shared",
    "armada/graphics",
    "armada/audio",
    "armada/logic/classes",
    "armada/configuration",
    "armada/control",
    "armada/logic/SpacecraftEvents",
    "armada/logic/missions",
    "armada/logic/equipment",
    "armada/logic/ai",
    "utils/polyfill"
], function (
        utils, vec, mat,
        application, game, components, screens, resources, egomModel,
        renderableObjects, sceneGraph,
        analytics,
        strings, armadaScreens, graphics, audio, classes, config, control,
        SpacecraftEvents, missions, equipment, ai) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // enums
            HUDSection = {
                TARGET_INFO: 0,
                TARGET_INDICATOR: 1,
                SHIP_INDICATORS: 2,
                AIM_ASSIST_INDICATOR: 3,
                WEAPON_IMPACT_INDICATORS: 4,
                HULL_BAR: 5,
                SHIELD_BAR: 6,
                SPEED_BAR: 7,
                DRIFT_ARROW: 8,
                FLIGHT_MODE: 9,
                WINGMEN_INFO: 10,
                MISSILE_INFO: 11,
                MISSILE_INDICATOR: 12,
                OBJECTIVES: 13,
                ESCORTS: 14,
                SCORE: 15
            },
            HUDSectionState = {
                VISIBLE: 0,
                HIDDEN: 1,
                HIGHLIGHTED: 2
            },
            // ------------------------------------------------------------------------------
            // constants
            /** @type String */
            STATS_PARAGRAPH_ID = "stats",
            LOADING_BOX_ID = "loadingBox",
            INFO_BOX_ID = "infoBox",
            BATTLE_CANVAS_ID = "battleCanvas",
            /** @type Number */
            LOOP_CANCELED = -1,
            LOOP_REQUESTANIMFRAME = -2,
            LOADING_BUILDING_SCENE_PROGRESS = 10,
            LOADING_RESOURCES_START_PROGRESS = 20,
            LOADING_RESOURCE_PROGRESS = 60,
            LOADING_INIT_WEBGL_PROGRESS = LOADING_RESOURCES_START_PROGRESS + LOADING_RESOURCE_PROGRESS,
            /**
             * When creating the battle scene, the camera will be created with this FOV, but it will be immediately overwritten by the 
             * FOV set for the first scene view of the loaded mission, therefore no point in making this settable.
             * @type Number
             */
            INITIAL_CAMERA_FOV = 40,
            INITIAL_CAMERA_SPAN = 0.2,
            /**
             * If the scene (environment) contains particle system effects, the scene will be rendered this many times in preparation before
             * starting the battle, to achieve a stable particle system state
             * @type Number
             */
            PREPARE_SCENE_COUNT = 20,
            /**
             * When the scene is rendered in preparation (see PREPARE_SCENE_COUNT), this will be the dt value passed for each render
             * @type Number
             */
            PREPARE_SCENE_DT = 100,
            /** @type String */
            HUD_ELEMENT_CLASS_NAME = "hudElementClass",
            HUD_ELEMENT_MODEL_NAME_PREFIX = "squareModel",
            MODEL_NAME_INFIX = "-",
            UI_2D_SHADER_NAME = "ui2d",
            UI_3D_SHADER_NAME = "ui3d",
            UI_2D_MIX_VIEWPORT_SHADER_NAME = "ui2d-mix-viewport",
            UI_2D_CLIP_VIEWPORT_SHADER_NAME = "ui2d-clip-viewport",
            // identifiers for music tracks
            AMBIENT_THEME = "ambient",
            ANTICIPATION_THEME_PREFIX = "anticipation",
            COMBAT_THEME_PREFIX = "combat",
            VICTORY_THEME = "victory",
            DEFEAT_THEME = "defeat",
            // HUD messages
            /** @type Number */
            HUD_MESSAGE_DURATION_PER_CHAR = 70, // based on average ~900 char per minute human reading speed
            HUD_MESSAGE_BASE_DURATION = 400, // fix extra time added to the duration of all HUD messages without explicit duration
            HUD_MESSAGE_APPEAR_DURATION_PER_CHAR = 7,
            HUD_MESSAGE_APPEAR_SOUND_STOP_RAMP_DURATION = 0.01, // in seconds!
            /** ID for the HUD message queue for the hostile alert that is shown in parallel to highlighting the newly arrived hostiles, if no other message is visible @type String */
            HOSTILE_ALERT_QUEUE = "hostileAlert",
            /** ID for the HUD message queue for general messages - messages without a specified queue go here @type String */
            INFO_QUEUE = "info",
            /** ID for the HUD message queue for mission state updates @type String */
            MISSION_QUEUE = "mission",
            /** ID for the HUD message queue for messages from the jump engine of the ship @type String */
            JUMP_QUEUE = "system",
            /** In descending priority order @type Array */
            MESSAGE_QUEUES = [JUMP_QUEUE, MISSION_QUEUE, INFO_QUEUE, HOSTILE_ALERT_QUEUE],
            // target info section names
            /** @type String */
            TARGET_INFO_NAME = "name",
            TARGET_INFO_CLASS = "class",
            TARGET_INFO_TEAM = "team",
            TARGET_INFO_FIREPOWER = "firepower",
            TARGET_INFO_DISTANCE = "distance",
            TARGET_INFO_VELOCITY = "velocity",
            /** From top to bottom in the info panel
             * @type Array */
            TARGET_INFO_SECTIONS = [TARGET_INFO_NAME, TARGET_INFO_CLASS, TARGET_INFO_TEAM, TARGET_INFO_FIREPOWER, TARGET_INFO_DISTANCE, TARGET_INFO_VELOCITY],
            /** This governs what suppements are target view items added with @type Object */
            TARGET_VIEW_SUPPLEMENTS = {weapons: true},
            // ------------------------------------------------------------------------------
            // private variables
            /**
             * The mission object storing and simulating the game-logic model of the battle
             * @type Mission
             */
            _mission,
            /**
             * The scene that is used to render the battle
             * @type Scene
             */
            _battleScene,
            /**
             * The ID of the loop function that is set to run the game simulation
             * @type Number
             */
            _simulationLoop = LOOP_CANCELED,
            /**
             * This stores the value of the cursor as it was used in the battle, while some menu is active
             * @type String
             */
            _battleCursor,
            /**
             * Stores the timestamp of the last simulation step
             * @type DOMHighResTimeStamp
             */
            _prevDate,
            /**
             * Whether the time is stopped in the simulated battle currently
             * @type Boolean
             */
            _isTimeStopped,
            /**
             * A function handling the resizing of the window from the battle screen's perspective is stored in this variable
             * @type Function
             */
            _handleResize,
            /**
             * Stores the parameters of the last sent analytics event
             * @type Object
             */
            _analyticsState,
            /**
             * A reference to the created battle screen instance
             * @type BattleScreen
             */
            _battleScreen,
            /**
             * The object that will be returned as this module
             * @type Battle
             */
            _battle = {},
            /**
             * The name (including the path within the mission folder) of the loaded mission file.
             * @type String
             */
            _missionSourceFilename,
            /**
             * The string ID of the difficulty level on which the battle is currently played.
             * @type String
             */
            _difficulty,
            /**
             * Whether the game is in demo mode, in which all spacecrafts are controlled by AI and automatic camera switching is performed.
             * @type Boolean
             */
            _demoMode,
            /**
             * The translated gameplay tip text displayed in the loading box.
             * @type String
             */
            _tipText,
            /**
             * The theme identifier of the anticipation theme of the current mission (might be a combination of the ANTICIPATION_THEME_PREFIX and an
             * index for songs listed as the general anticipation themes (in settings.json) or the resource name of the track itself if a custom
             * track is chosen for the mission)
             * @type String
             */
            _anticipationTheme,
            /**
             * The theme identifier of the combat theme of the current mission (might be a combination of the COMBAT_THEME_PREFIX and an
             * index for songs listed as the general combat themes (in settings.json) or the resource name of the track itself if a custom
             * track is chosen for the mission)
             * @type String
             */
            _combatTheme,
            /**
             * The total time elapsed in simulation since the battle began, in milliseconds
             * @type Number
             */
            _elapsedTime,
            /**
             * The time elapsed since last switching view in demo mode, in milliseconds.
             * @type Number
             */
            _timeInSameView,
            /**
             * (enum missions.MissionState) The last mission state that the player has been made aware of.
             * @type String
             */
            _displayedMissionState,
            /**
             * The elapsed simulation time since the game's end state changed to victory or defeat. In milliseconds
             * @type Number
             */
            _timeSinceGameStateChanged,
            /**
             * The elapsed simulation time since the the player's spacecraft jump out of the battle scene. In milliseconds
             * @type Number
             */
            _timeSincePlayerLeft,
            /**
             * A reference to the followed spacecraft (if any, as last displayed on the HUD)
             * @type Spacecraft
             */
            _spacecraft,
            /**
             * A cached reference to the squads in the team of the currently followed spacecraft, for quicker update of the wingmen status
             * indicator on the HUD
             * @type Array
             */
            _squads,
            /**
             * A cached reference to the missile classes equipped on the followed spacecraft, for quicker update of missile info indicator on the HUD
             * @type Array
             */
            _missileClasses,
            /**
             * A cached reference to the spacecrafts that need to be escorted (protected) by the player
             * @type Array
             */
            _escorts,
            /**
             * A cached reference to the spacecrafts that need to be destroyed by the player to complete the mission
             * @type Array
             */
            _targets,
            /**
             * The hull integrity of the followed spacecraft (if any, as last displayed on the HUD)
             * @type Number
             */
            _spacecraftHullIntegrity,
            /**
             * The shield integrity of the followed spacecraft (if any, as last displayed on the HUD)
             * @type Number
             */
            _spacecraftShieldIntegrity,
            /**
             * A reference to the target of the followed spacecraft (if any, as last displayed on the HUD)
             * @type Spacecraft
             */
            _target,
            /**
             * The hull integrity of the target of the followed spacecraft (if any, as last displayed on the HUD)
             * @type Number
             */
            _targetHullIntegrity,
            /**
             * The shield integrity of the target of the followed spacecraft (if any, as last displayed on the HUD)
             * @type Number
             */
            _targetShieldIntegrity,
            /**
             * An array storing the reference to all persistent HUD elements (so that when the graphics settings are changed, they can be
             * notified to update the shaders etc)
             * @type HUDElement[]
             */
            _hudElements = [],
            // HUD animation timing
            /**
             * The time left from the hull integrity decrease HUD animation, in milliseconds
             * @type Number
             */
            _hullIntegrityDecreaseTime,
            /**
             * The time left from the shield integrity decrease HUD animation, in milliseconds
             * @type Number
             */
            _shieldDecreaseTime,
            /**
             * The time left from the target hull integrity decrease HUD animation, in milliseconds
             * @type Number
             */
            _targetHullIntegrityDecreaseTime,
            /**
             * The time left from the target shield integrity decrease HUD animation, in milliseconds
             * @type Number
             */
            _targetShieldDecreaseTime,
            /**
             * The time left from the target switch HUD animation, in milliseconds
             * @type Number
             */
            _targetSwitchTime,
            /**
             * The time left from the aim assist appear HUD animation, in milliseconds
             * @type Number
             */
            _aimAssistAppearTime,
            /**
             * The time left / elapsed from the ship indicator highlight animation, in milliseconds
             * @type Number
             */
            _shipIndicatorHighlightTime,
            /**
             * A reference to the camera configuration that was active at the time an automatic configuration was set instead (i.e. during
             * jump sequences, to allow going back to the original configuration)
             * @type CameraConfiguration
             */
            _originalCameraConfig,
            // HUD messages
            /**
             * @typedef {Object} Battle~HUDMessage The properties of a message that can be displayed for the player on the HUD
             * @property {String} [text] The text of the message (formatted, translated, can contain '\n'-s)
             * @property {Number} [duration] The duration to display the message for, in milliseconds. If not given, an automatic
             * duration will be set based on the length of the text
             * @property {Number} timeLeft How much time is still left from displaying this message, in milliseconds
             * @property {String} [queue] The ID of the message queue this messag should go in
             * @property {Boolean} [permanent] If true, the message keeps being displayed until a new urgent
             * message is added or the queue is cleared
             * @property {Number[4]} [color] When given, the text is displayed using this text color
             * @property {Number} [blinkInterval] When given, the text will blink with this interval, in milliseconds
             * @property {Boolean} [silent=false] When true, the message sound effect will not be played for this message
             * @property {Boolean} [new=false] When a new message is put at the front of the queue, this flag is set to true
             * @property {Boolean} [appearAnimation=false] If true, the message will have a "typewriter" style appearing animation
             * @property {Number} appearDuration If appearAnimation is true, this holds the calculated value for the duration of the appear animation, in milliseconds
             * @property {Number} appearDurationLeft If appearAnimation is true, this holds the time left from the appear animation, in milliseconds
             * @property {Spacecraft} [source] If the message is a transmission from another spacecraft, this field holds a reference to that spacecraft
             */
            /**
             * Contains the HUD message queues by their IDs. Each queue is the list of messages to be displayed on the HUD for that queue. 
             * The messages are displayed in the order they are in the queue.
             * @type Object.<String, Battle~HUDMessage[]>
             */
            _messageQueues,
            /**
             * If the message currently displayed on the HUD is a transmission from another spacecraft, this holds the reference to that spacecraft
             * @type Spacecraft
             */
            _messageSource,
            /**
             * The sound played when a new HUD message is displayed.
             * @type SoundClip
             */
            _messageSound,
            /**
             * The sound played while the "typewriter" appear animation for a new HUD message is in progress.
             * @type SoundClip
             */
            _messageTypeSound,
            /**
             * The sound played when the current missile finishes loading while being already locked
             * @type SoundClip
             */
            _missileLoadedSound,
            /**
             * Whether the selected missile is loaded and ready for launch during the current frame (independently from being locked on target)
             * @type Boolean
             */
            _missileLoaded,
            /**
             * The sound played as the missile is being locked (several time during the locking process)
             * @type SoundClip
             */
            _missileLockingSound,
            /**
             * How many times should the locking sound play while locking before full missile lock is achieved (e.g. 3 means the sound plays at 0%, 33% and 67% lock)
             * @type Number
             */
            _missileLockingSoundCount,
            /**
             * The number of times the missile locking sound has been already played during the locking process
             * @type Number
             */
            _missileLockingSoundsPlayed,
            /**
             * The sound played when the selected missile gets locked on target.
             * @type SoundClip
             */
            _missileLockedSound,
            /**
             * Whether the selected missile is locked on target during the current frame
             * @type Boolean
             */
            _missileLocked,
            /**
             * The message that is displayed informing the player about engaged jump engines.
             * @type Battle~HUDMessage
             */
            _jumpMessage,
            /**
             * The message that is displayed informing the player about new hostiles that arrived.
             * @type Battle~HUDMessage
             */
            _newHostilesMessage,
            /**
             * The sound played when the new hostiles arrive
             * @type SoundClip
             */
            _newHostilesAlertSound,
            /**
             * The time left from the new hostiles alert (both the message and enemy highlights) - we need to decrease this
             * even when the message is not shown, because a higher priority message (e.g. winning or jump) pushed it. In milliseconds.
             * @type Number
             */
            _newHostilesAlertTimeLeft,
            /**
             * An array holding references to the hostile spacecrafts that should be highlighted as newly arrived
             * @type Spacecraft[]
             */
            _newHostiles,
            /**
             * Used to determine the visibility of currently highlighted (blinking) HUD elements
             * @type Number
             */
            _hudHighlightTime,
            /**
             * Whether currently highlighted (blinking) HUD elements are visible at the moment
             * @type Number
             */
            _hudHighlightVisible,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // music related
            /**
             * The elapsed simulation time since a spacecraft last fired at a hostile target. (for deciding whether there is combat going
             * on to choose the right music track) In milliseconds
             * @type Number
             */
            _timeSinceLastFire,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // cached configuration settings
            /**
             * Cached setting of the duration while the combat theme is kept playing during battle after a spacecraft fires at a hostile 
             * target, in milliseconds
             * @type Number
             */
            _combatThemeDurationAfterFire,
            /**
             * Cached setting of the interval of blinking for highlighted HUD elements
             * @type Number
             */
            _hudHighlightInterval,
            // ................................................................................................
            // elements of the HUD and their stored state
            /**
             * Whether the HUD should be currently displayed.
             * @type Boolean
             */
            _isHUDVisible,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // central elements
            /**
             * A crosshair that is always shown at the center of the screen when the camera is set to an aiming view of a spacecraft.
             * @type HUDElement
             */
            _centerCrosshair,
            /**
             * Crosshairs that are shown in the line of fire of the weapons of the followed ship, at the same distance as the estimated
             * hit position.
             * @type HUDElement[]
             */
            _weaponImpactIndicators,
            /**
             * A bar showing the hull integrity of the current target near the center of the HUD / over the target (depending on settings)
             * @type HUDElement
             */
            _targetHullIntegrityQuickViewBar,
            /**
             * A bar showing the shield integrity of the current target near the center of the HUD / over the target (depending on settings)
             * @type HUDElement
             */
            _targetShieldQuickViewBar,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // cursor
            /**
             * When a spacecraft is controlled by the mouse, this HUD element is shown at the position of the cursor if it is within the 
             * deadzone (is not triggering a turn of the controlled spacecraft).
             * @type HUDElement
             */
            _hudStillCursor,
            /**
             * When a spacecraft is controlled by the mouse, this HUD element is shown at the position of the cursor if it is outside the 
             * deadzone (is triggering a turn of the controlled spacecraft), pointing towards the direction of the triggered turn.
             * @type HUDElement
             */
            _hudTurnCursor,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // 3D position based target info
            /**
             * Reticles that are shown at the location of the indicated ships 
             * @type HUDElement[]
             */
            _shipIndicators,
            /**
             * Arrows that points in the direction of indicated ships, when they are not visible on the screen.
             * @type HUDElement[]
             */
            _shipArrows,
            /**
             * Indicators shown around the current target that indicate the state of missile lock state
             * @type HUDElement[]
             */
            _missileLockIndicators,
            /**
             * The angle of the first missile lock indicator (to track them rotating around the target while locking), in radians
             * @type Number
             */
            _missileLockIndicatorAngle,
            /**
             * For tracking the time for the blinking of missile lock indicators while locked
             * @type Number
             */
            _missileLockIndicatorBlinkTime,
            /**
             * Houses the texts displaying the distance from the target at its indicator reticle
             * @type TextLayer
             */
            _distanceTextLayer,
            /**
             * Displays the current calculated distance from the target at its indicator reticle
             * @type CanvasText
             */
            _distanceText,
            /**
             * Little icons that are displayed next to ship reticles and arrows which relay information about the spacecrafts
             * (e.g. if it is an objective target or is transmitting the message that is displayed on the HUD)
             * @type HUDElement[]
             */
            _shipStatusIndicators,
            /**
             * A reticle that is shown at the estimated location towards which the followed spacecraft has to fire in order to hit the
             * current target, given the current velocity of both and the speed of the first fired projectile of the first equipped weapon.
             * @type HUDElement
             */
            _aimAssistIndicator,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // target info panel
            /**
             * The scene to which a view of the currently selected target ship is rendered.
             * @type Scene
             */
            _targetScene,
            /**
             * A reference to the currently displayed spacecraft in the target view scene.
             * @type Spacecraft
             */
            _targetViewItem,
            /**
             * A reference to the visual model that was added to the target view scene to display the current target
             * @type ParameterizedMesh
             */
            _targetViewModel,
            /**
             * The reusable matrix to store the orientation of the target view item
             * @type Float32Array
             */
            _targetViewOrientationMatrix = mat.identity4(),
            /**
             * Stores the parameters for adding the target view item to the target view scene
             * @type Object
             */
            _targetViewParams,
            /**
             * The RGBA color of the currently displayed spacecraft in the target view screen. (based on its hull integrity)
             * @type Number[4]
             */
            _targetViewItemColor,
            /**
             * A rectangle displayed as the background of the panel showing the information about the current target (including the target
             * view scene, hull integrity bar, textual information...), if there is one selected.
             * @type HUDElement
             */
            _targetInfoBackground,
            /**
             * A bar showing the current hull integrity of the selected target within the target info panel.
             * @type HUDElement
             */
            _targetHullIntegrityBar,
            /**
             * A bar showing the current shield integrity of the selected target within the target info panel.
             * @type HUDElement
             */
            _targetShieldBar,
            /**
             * Houses all the texts that display information about the current target within the target info panel.
             * @type TextLayer
             */
            _targetInfoTextLayer,
            /**
             * Stores the texts that Display the various information about the currently targeted spacecraft within the target info panel.
             * The keys are IDs (defined among the constants)
             * @type Object.<String, CanvasText>
             */
            _targetInfoTexts,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // wingmen status panel
            /**
             * A rectangle displayed as the background of the panel showing the information about the wingmen
             * @type HUDElement
             */
            _wingmenStatusBackground,
            /**
             * Houses the texts of the wingmen status indicator panel.
             * @type TextLayer
             */
            _wingmenStatusTextLayer,
            /**
             * Displays the header text (i.e. "Wingmen:") on the wingmen status indicator panel.
             * @type CanvasText
             */
            _wingmenStatusHeaderText,
            /**
             * The indicator laid over the spacecraft indicator that represents the player's spacecraft (if it is within a squad) on the
             * wingmen status indicator
             * @type HUDElement
             */
            _wingmenStatusPlayerIndicator,
            /**
             * The indicators for the individual spacecrafts within the squads for the wingmen status panel
             * @type {body: HUDElement, shield: HUDElement}[]
             */
            _wingmenStatusCraftIndicators,
            /**
             * Stored layouts for each of the individual spacecraft indicators of the wingmen status panel. This array is cleared whenever
             * a new spacecraft is followed so that new layouts are automatically generated for the (potentially) different squads
             * @type ClipSpaceLayout
             */
            _wingmenStatusCraftLayouts,
            /**
             * Displays the names of the squads on the wingmen status panel
             * @type CanvasText[]
             */
            _wingmenStatusSquadTexts,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // speed and drift indicators
            /**
             * Displays the current forward or reverse speed compared to a calculated maximum in the form of a partially filled bar.
             * @type HUDElement
             */
            _speedBar,
            /**
             * Highlights the current target (intended) forward or reverse speed within the speed bar.
             * @type HUDElement
             */
            _speedTargetIndicator,
            /**
             * Indicates the current missile firing mode (single / salvo) and status (loading / out of range / locking / ready to fire) with icon and color
             * @type HUDElement
             */
            _missileIndicator,
            /**
             * Houses the missile indicator text
             * @type TextLayer
             */
            _missileIndicatorTextLayer,
            /**
             * Displays the count for the currently selected missile class
             * @type CanvasText
             */
            _missileIndicatorText,
            /**
             * Houses the texts displaying the current and reference speed values.
             * @type TextLayer
             */
            _speedTextLayer,
            /**
             * Displays the current calculated reference (forward or reverse) speed (relative to which the speed bar is filled) next to (the 
             * top or bottom of) the speed bar.
             * @type CanvasText
             */
            _maxSpeedText,
            /**
             * Displays the current (forward or reverse) speed of the followed spacecraft next to the speed bar.
             * @type CanvasText
             */
            _currentSpeedText,
            /**
             * An arrow pointing towards the direction the followed spacecraft is drifting towards with a color based on the intensity of
             * the drift.
             * @type HUDElement
             */
            _driftArrow,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // hull integrity bar
            /**
             * Displays the hull integrity of the followed spacecraft.
             * @type HUDElement
             */
            _hullIntegrityBar,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // shield integrity bar
            /**
             * Displays the shield integrity of the followed spacecraft.
             * @type HUDElement
             */
            _shieldBar,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // flight mode indicator
            /**
             * A rectangle displayed as the background for the flight mode indicator panel.
             * @type HUDElement
             */
            _flightModeIndicatorBackground,
            /**
             * Houses the texts of the flight mode indicator panel.
             * @type TextLayer
             */
            _flightModeIndicatorTextLayer,
            /**
             * Displays the header text (i.e. "Flight mode:") on the flight mode indicator panel.
             * @type CanvasText
             */
            _flightModeHeaderText,
            /**
             * Displays the current flight mode on the flight mode indicator panel.
             * @type CanvasText
             */
            _flightModeText,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // missile info indicator
            /**
             * A rectangle displayed as the background for the missile info indicator panel.
             * @type HUDElement
             */
            _missileInfoBackground,
            /**
             * Houses the texts of the missile info indicator panel.
             * @type TextLayer
             */
            _missileInfoTextLayer,
            /**
             * Displays the header text (i.e. "Missiles:") on the missile info indicator panel.
             * @type CanvasText
             */
            _missileInfoHeaderText,
            /**
             * Displays the class name and count about missiles on the missile info indicator panel.
             * @type CanvasText[]
             */
            _missileInfoNameTexts,
            _missileInfoCountTexts,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // headers
            /**
             * Houses the header texts.
             * @type TextLayer
             */
            _headerTextLayer,
            /**
             * Displays a smaller header text at the top center of the screen, shown/hidden independently from the HUD, used for displaying
             * version info.
             * @type CanvasText
             */
            _smallHeaderText,
            /**
             * Displays a larger header text below the small one, shown/hidden with the rest of the HUD.
             * @type CanvasText
             */
            _bigHeaderText,
            /**
             * Displays a smaller header text below the big one, shown/hidden with the rest of the HUD.
             * @type CanvasText
             */
            _subheaderText,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // message
            /**
             * A rectangle displayed as the background for the HUD message.
             * @type HUDElement
             */
            _messageBackground,
            /**
             * Houses the message text.
             * @type TextLayer
             */
            _messageTextLayer,
            /**
             * A message that can be displayed to the user (status of the mission, tutorial, radio chatter...)
             * @type CanvasText
             */
            _messageText,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // top left
            /**
             * Houses the score text
             * @type TextLayer
             */
            _topLeftTextLayer,
            /**
             * Displays the score of the player
             * @type CanvasText
             */
            _scoreText,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // objectives indicator
            /**
             * A rectangle displayed as the background for the mission objective indicator panel.
             * @type HUDElement
             */
            _objectivesBackground,
            /**
             * Houses the texts of the mission objective indicator panel.
             * @type TextLayer
             */
            _objectivesTextLayer,
            /**
             * Displays the header text (i.e. "Objectives:") on the mission objective indicator panel.
             * @type CanvasText
             */
            _objectivesHeaderText,
            /**
             * Displays the objectives on the mission objective indicator panel.
             * @type CanvasText[]
             */
            _objectivesTexts,
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // escorted ships indicator
            /**
             * A rectangle displayed as the background for the escorted ships indicator panel.
             * @type HUDElement
             */
            _escortsBackground,
            /**
             * Houses the texts of the escorted ships indicator panel.
             * @type TextLayer
             */
            _escortsTextLayer,
            /**
             * Displays the header text (i.e. "Protect:") on the escorted ships indicator panel.
             * @type CanvasText
             */
            _escortsHeaderText,
            /**
             * Displays the names of the escorted ships on the indicator panel.
             * @type CanvasText[]
             */
            _escortsTexts,
            /**
             * The HUD elements and layouts for displaying the hull and shield integrity bars for each escorted ship
             * @type {hull: HUDElement, shield: HUDElement, hullLayout: ClipSpaceLayout, shieldLayout: ClipSpaceLayout}[]
             */
            _escortBars,
            // ................................................................................................
            // cached references of setting values used for the layout of the HUD
            /**
             * Whether the crosshairs should be offset for aim assist instead of showing a separate indicator.
             * @type Boolean
             */
            _aimAssistCrosshairs,
            /**
             * (enum ScaleMode) Stores the scaling mode to use for the center crosshair for quicker access.
             * @type String
             */
            _centerCrosshairScaleMode,
            /**
             * Stores a reference to the layout used for distance text's clearing box
             * @type LayoutDescriptor
             */
            _distanceTextBoxLayoutDescriptor,
            /**
             * Stores a reference to the layout used for the target view scene for quicker access.
             * @type ClipSpaceLayout
             */
            _targetViewLayout,
            /**
             * Stores a reference to the layout used for the target info background HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _targetInfoBackgroundLayout,
            /**
             * Stores a reference to the layout used for the wingmen status background HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _wingmenStatusBackgroundLayout,
            /**
             * Stores a reference to the layout used for the target hull integrity bar HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _targetHullIntegrityBarLayout,
            /**
             * Stores a reference to the layout used for the target shield integrity bar HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _targetShieldBarLayout,
            /**
             * Stores a reference to the layout used for the speed bar HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _speedBarLayout,
            /**
             * Stores a reference to the size used for the speed target indicator HUD element for quicker access.
             * @type Number[2]
             */
            _speedTargetIndicatorSize,
            /**
             * Stores a reference to the layout used for the missile indicator HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _missileIndicatorLayout,
            /**
             * Stores a reference to the layout used for the hull integrity bar HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _hullIntegrityBarLayout,
            /**
             * Stores a reference to the layout used for the shield integrity bar HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _shieldBarLayout,
            /**
             * Stores a reference to the layout used for the flight mode indicator background HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _flightModeIndicatorBackgroundLayout,
            /**
             * Stores a reference to the layout used for the missile info indicator background HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _missileInfoBackgroundLayout,
            /**
             * Stores a reference to the layout used for the target hull integrity quick view bar HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _targetHullIntegrityQuickViewBarLayout,
            /**
             * Stores a reference to the layout used for the target shield integrity quick view bar HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _targetShieldQuickViewBarLayout,
            /**
             * Stores a reference to the layout used for the mission objective indicator background HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _objectivesBackgroundLayout,
            /**
             * Stores a reference to the layout used for the escorted ships indicator background HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _escortsBackgroundLayout,
            /**
             * Stores a reference to the layout used for the message background HUD element for quicker access.
             * @type ClipSpaceLayout
             */
            _messageBackgroundLayout,
            // ................................................................................................
            // other cached setting values used for the HUD
            /**
             * The duration of the target switch animation (scaling applied to target indicator reticle / arrow and weapon impact indicators),
             * in milliseconds
             * @type Number
             */
            _hudTargetSwitchAnimationDuration,
            /**
             * The duration of the aim assist appear animation, in milliseconds
             * @type Number
             */
            _hudAimAssistAppearAnimationDuration,
            /**
             * The duration of the hull integrity decrease animation (highlighting hull integrity bar), in milliseconds
             * @type Number
             */
            _hudHullIntegrityDecreaseAnimationDuration,
            /**
             * The duration of the shield integrity decrease animation (highlighting shield integrity bar), in milliseconds
             * @type Number
             */
            _hudShieldDecreaseAnimationDuration,
            /**
             * The duration of the target hull integrity decrease animation (highlighting target hull integrity quick view bar), in milliseconds
             * @type Number
             */
            _hudTargetHullIntegrityDecreaseAnimationDuration,
            /**
             * The duration of the target shield integrity decrease animation (highlighting target shield integrity quick view bar), in milliseconds
             * @type Number
             */
            _hudTargetShieldDecreaseAnimationDuration,
            /**
             * The interval of the ship indicator (reticle/arrow) highlight animation, in milliseconds
             * @type Number
             */
            _shipIndicatorHighlightAnimationInterval,
            /**
             * The horizontal and vertical min/max sizes of the target indicator reticle
             * @type Object.<String, Number[2]>
             */
            _shipIndicatorSizes,
            /**
             * The factor by which to multiply the visible size of spacecrafts to get the size of their indicator
             * @type type
             */
            _shipIndicatorSizeFactor,
            /**
             * The scaling to apply to the target indicator reticle at the start of the target switch HUD animation
             * @type Number
             */
            _targetIndicatorSwitchScale,
            /**
             * The horizontal and vertical base size of the target indicator arrow
             * @type Number[2]
             */
            _shipArrowSizes,
            /**
             * The scaling to apply to the target indicator arrow at the start of the target switch HUD animation
             * @type Number
             */
            _targetArrowSwitchScale,
            /**
             * The horizontal and vertical base size of the weapon impact indicators
             * @type Number[2]
             */
            _weaponImpactIndicatorSize,
            /**
             * The scaling to apply to the weapon impact indicators at the start of the target switch HUD animation
             * @type Number
             */
            _weaponImpactIndicatorSwitchScale,
            /**
             * The horizontal and vertical base size of the aim assist indicator
             * @type Number[2]
             */
            _aimAssistIndicatorSize,
            /**
             * The scaling to apply to the aim assist indicator at the start of the appear / target switch HUD animation
             * @type Number
             */
            _aimAssistIndicatorAppearScale,
            /**
             * The minimum drift speed at which the drift arrow HUD element is displayed.
             * @type Number
             */
            _driftArrowMinSpeed,
            /**
             * The factor by which to multiply the acceleration of the followed spacecraft to get the drift speed at which the drift arrow is
             * displayed with the max speed color.
             * @type Number
             */
            _driftArrowMaxSpeedFactor,
            /**
             * The settings object for escorted ship hull and shield integrity bars is used at various points, so we store a cached reference to it
             * @type Object
             */
            _escortsIntegrityBarsSettings,
            /**
             * The settings object for wingmen status craft indicators is used at various points, so we store a cached reference to it
             * @type Object
             */
            _wingmenStatusCraftIndicatorSettings,
            /**
             * Stores that based on the configuration, what is the biggest size a squad can be so that there are positions defined for all
             * individual spacecraft indicators within it, in case it needs to be displayed on the wingmen status indicator panel
             * @type Number
             */
            _wingmenStatusMaxSquadMemberCount,
            /**
             * The settings object for message text is used frequently for setting message colors, so we store a cached reference to it
             * @type Object
             */
            _messageTextSettings,
            /**
             * An array storing the current state of each of the HUD sections
             * @type Number[]
             */
            _hudSectionStates;
    // -------------------------------------------------------------------------
    // Freezing enums
    Object.freeze(HUDSection);
    Object.freeze(HUDSectionState);
    // ------------------------------------------------------------------------------
    // private functions
    /**
     * Executes one simulation (and control) step for the battle.
     */
    function _simulationLoopFunction() {
        var followedCraft, curDate, dt;
        if (_simulationLoop !== LOOP_CANCELED) {
            curDate = performance.now();
            dt = curDate - _prevDate;
            control.control(dt);
            ai.control(dt);
            followedCraft = _mission.getFollowedSpacecraftForScene(_battleScene);
            if (!_isTimeStopped) {
                _mission.tick(dt, _battleScene);
                _elapsedTime += dt;
                if (!_mission.isFinished() && !_mission.noHostilesPresent()) {
                    _timeSinceLastFire += dt;
                    if (_timeSinceLastFire > _combatThemeDurationAfterFire) {
                        audio.playMusic(_anticipationTheme);
                    }
                }
            }
            if (followedCraft) {
                // handling the loss of the spacecraft that is followed by the camera
                if (followedCraft.canBeReused() || followedCraft.isAway()) {
                    if (control.isInPilotMode()) {
                        control.switchToSpectatorMode(true);
                    } else if (_demoMode) {
                        // first, try to switch to a new spacecraft, if there are none, switch to free camera
                        if (!_battleScene.getCamera().followNextNode()) {
                            control.switchToSpectatorMode(true, true);
                        }
                        _timeInSameView = 0;
                    }
                } else if (_demoMode) {
                    if (config.getBattleSetting(config.BATTLE_SETTINGS.DEMO_VIEW_SWITCHING)) {
                        // automatic view switching in demo mode
                        _timeInSameView += dt;
                        if (_timeInSameView > config.getSetting(config.BATTLE_SETTINGS.DEMO_VIEW_SWITCH_INTERVAL)) {
                            _timeInSameView = 0;
                            _battleScene.getCamera().changeToNextView();
                            if (Math.random() < config.getSetting(config.BATTLE_SETTINGS.DEMO_DOUBLE_VIEW_SWITCH_CHANCE)) {
                                _battleScene.getCamera().changeToNextView();
                            }
                        }
                    }
                }
            }
            _prevDate = curDate;
        }
    }
    /**
     * Removes the stored renferences to the logic and graphical models of the battle.
     */
    function _clearData() {
        if (_mission) {
            _mission.destroy();
        }
        _mission = null;
        if (_battleScene) {
            _battleScene.clear(true);
        }
        _battleScene = null;
        if (_targetScene) {
            _targetScene.clear(true);
        }
        _targetScene = null;
        _messageQueues = null;
        _newHostilesMessage = null;
        _newHostilesAlertTimeLeft = 0;
        _newHostiles = null;
        audio.playMusic(null);
        // HUD
        _hullIntegrityDecreaseTime = 0;
        _shieldDecreaseTime = 0;
        _targetHullIntegrityDecreaseTime = 0;
        _targetShieldDecreaseTime = 0;
        _targetSwitchTime = 0;
        _aimAssistAppearTime = 0;
        _shipIndicatorHighlightTime = 0;
        // other
        _tipText = "";
        _hudSectionStates = null;
    }
    /**
     * Sets the tip text by choosing one randomly from the available options.
     */
    function _chooseTipText() {
        var
                tipIDs = missions.getMissionDescriptor(_missionSourceFilename).getTipIDs() || missions.getTipIDs(),
                i = Math.min(Math.floor(Math.random() * tipIDs.length), tipIDs.length - 1);
        _tipText = strings.get(strings.TIP.PREFIX, tipIDs[i]);
    }
    // ------------------------------------------------------------------------------
    // public functions
    /**
     * Stops the time in the battle simulation.
     */
    function stopTime() {
        _isTimeStopped = true;
        if (_battleScene) {
            _battleScene.setShouldAnimate(false);
        }
    }
    /**
     * Resumes the time in the battle simulation
     */
    function resumeTime() {
        if (_battleScene) {
            _battleScene.setShouldAnimate(true);
        }
        _isTimeStopped = false;
    }
    /**
     * Changes whether the time is stopped in the simulation to the opposite of the current value
     */
    function toggleTime() {
        if (_isTimeStopped) {
            resumeTime();
        } else {
            stopTime();
        }
    }
    /**
     * Hides all elements of the HUD. (rendering the battle screen after this will not show the HUD)
     */
    function hideHUD() {
        _isHUDVisible = false;
    }
    /**
     * Shows all elements of the HUD. (rendering the battle screen after this will show the HUD)
     */
    function showHUD() {
        _isHUDVisible = true;
    }
    /**
     * Switches the current state of visibility of the HUD to its opposite.
     */
    function toggleHUDVisibility() {
        _isHUDVisible = !_isHUDVisible;
    }
    /**
     * Updates all HUD elements for the case when the graphics settings have been changed (i.e. clears cached values depending on graphics 
     * settings)
     */
    function handleGraphicsSettingsChanged() {
        var i;
        for (i = 0; i < _hudElements.length; i++) {
            _hudElements[i].handleGraphicsSettingsChanged();
        }
    }
    // ------------------------------------------------------------------------------
    // Spacecraft event handlers
    /**
     * Updates the state / mood based music theme for the case a spacecraft just fired.
     */
    function _handleSpacecraftFired() {
        var target = this.getTarget();
        if (target && target.isHostile(this) && !_mission.isFinished()) {
            _timeSinceLastFire = 0;
            if (_combatTheme) {
                audio.playMusic(_combatTheme);
            }
        }
    }
    /**
     * Handles camera configuration / HUD message features related to the jump engine engaged event
     * @returns {Boolean} Always true (signals the spacecraft's jump engine that the HUD actions happened so it can play the related sound
     * effect)
     */
    function _handlePilotedSpacecraftJumpEngaged() {
        _jumpMessage = {
            text: strings.get(strings.BATTLE.MESSAGE_JUMP_ENGAGED),
            color: _messageTextSettings.colors.jump,
            queue: JUMP_QUEUE,
            permanent: true,
            silent: true
        };
        _battleScreen.queueHUDMessage(_jumpMessage, true);
        _originalCameraConfig = _battleScene.getCamera().getConfiguration();
        return true;
    }
    /**
     * Handles camera configuration / HUD message features related to the jump engine cancelled event
     * @returns {Boolean} Always true (signals the spacecraft's jump engine that the HUD actions happened so it can play the related sound
     * effect)
     */
    function _handlePilotedSpacecraftJumpCancelled() {
        _battleScreen.clearHUDMessages(JUMP_QUEUE);
        _battleScene.getCamera().startTransitionToConfiguration(_originalCameraConfig);
        return true;
    }
    /**
     * If the given spacecraft has a view with the given name, initiates a transition for the battle scene camera to the corresponding 
     * camera configuration
     * @param {Spacecraft} craft
     * @param {String} viewName
     * @param {Number} duration The duration of the transition, in milliseconds
     * @returns {Boolean} Whether there was a view found (and transition initiated)
     */
    function _switchToCameraConfig(craft, viewName, duration) {
        var camConfigs = craft.getVisualModel().getNode().getCameraConfigurationsWithName(viewName);
        if (camConfigs.length > 0) {
            _battleScene.getCamera().startTransitionToConfiguration(camConfigs[0], duration);
            return true;
        }
        return false;
    }
    /**
     * Handles camera configuration / HUD message features related to the jump engine prepare event
     * @param {SpacecraftEvents~PreparingJumpData} data
     */
    function _handlePilotedSpacecraftPreparingJump(data) {
        // when starting the preparation...
        if (data.duration === data.timeLeft) {
            _switchToCameraConfig(this, config.getSetting(config.BATTLE_SETTINGS.JUMP_PREPARE_VIEW_NAME), data.duration);
        }
        // when finishing the preparation
        if (data.timeLeft <= 0) {
            hideHUD();
            if (!_switchToCameraConfig(this, config.getSetting(config.BATTLE_SETTINGS.JUMP_OUT_VIEW_NAME), 0)) {
                _battleScene.getCamera().setToFreeCamera();
            }
        } else {
            // during preparation
            _battleScreen.queueHUDMessage({
                text: utils.formatString(strings.get(strings.BATTLE.MESSAGE_JUMP_PREPARING), {
                    timeLeft: utils.formatTimeToSeconds(data.timeLeft)
                }),
                color: _messageTextSettings.colors.jump,
                duration: 1,
                queue: JUMP_QUEUE,
                silent: true
            }, true);
        }
    }
    /**
     * Handles camera configuration features related to the jump out event for non-piloted spacecrafts
     */
    function _handleSpacecraftJumpOutStarted() {
        if (this === _mission.getFollowedSpacecraftForScene(_battleScene)) {
            if (_demoMode) {
                _switchToCameraConfig(this, config.getSetting(config.BATTLE_SETTINGS.JUMP_OUT_VIEW_NAME), 0);
            } else {
                _battleScene.getCamera().setToFreeCamera();
            }
        }
    }
    /**
     * Issues / updates the HUD message notifying of new hostiles if necessary
     */
    function _handleSpacecraftArrived() {
        /**@type Spacecraft */
        var craft = _mission.getPilotedSpacecraft();
        if (craft && craft.isAlive() && !craft.isAway() && craft.isHostile(this)) {
            if (!_newHostilesMessage || (_newHostilesAlertTimeLeft <= 0)) {
                if (_newHostilesMessage) {
                    _newHostilesMessage.timeLeft = 0;
                }
                _newHostilesMessage = {
                    text: "\n\n" + strings.get(strings.BATTLE.MESSAGE_NEW_HOSTILES),
                    color: _messageTextSettings.colors.alert,
                    blinkInterval: config.getHUDSetting(config.BATTLE_SETTINGS.HUD.NEW_HOSTILES_ALERT_BLINK_INTERVAL),
                    duration: config.getHUDSetting(config.BATTLE_SETTINGS.HUD.NEW_HOSTILES_ALERT_DURATION),
                    silent: true,
                    queue: HOSTILE_ALERT_QUEUE
                };
                _battleScreen.queueHUDMessage(_newHostilesMessage, true);
                _newHostiles = [this];
                _newHostilesAlertSound.play();
            } else {
                _newHostiles.push(this);
            }
            _newHostilesAlertTimeLeft = _newHostilesMessage.duration;
        }
    }
    /**
     * Updates the HUD state according to the passed HUD event data
     * @param {SpacecraftEvents~HUDData} data
     */
    function _handleHUDEvent(data) {
        var i, state;
        state = HUDSectionState[utils.constantName(data.state)];
        if (data.section) {
            _hudSectionStates[HUDSection[utils.constantName(data.section)]] = state;
        } else {
            for (i = 0; i < _hudSectionStates.length; i++) {
                _hudSectionStates[i] = state;
            }
        }
    }
    // ##############################################################################
    /**
     * @class Can be used to represent an element of the HUD, for which it can create an appropriate UIElement and add it to the battle scene.
     * @param {String} shaderName The name of the shader to use for rendering this element.
     * @param {String} textureName The name of the common texture resource to use for this element.
     * @param {Number[2]|Number[3]} position The 2D or 3D (starting) position of the element (depending on the shader used)
     * @param {Number[2]} size The 2D size factor of the element to scale it.
     * @param {String} scaleMode (enum ScaleMode) The scaling mode to be used to size this element.
     * @param {Number[4]} color An RGBA color for the element it can be modulated with. (inside the clip zone)
     * @param {Number[4]} [clipColor] An RGBA color to be used for modulation outside the clip zone set for the element.
     * @param {Number[2][2]} [textureCoordinates] The coordinates for the top-left and bottom-right corners of the section of the texture
     * image to use for texture mapping (or other corners if flipped horizontally or vertically) If not given, the whole image is used.
     * (0;0) is top-left and (1;1) is bottom-right of the image
     */
    function HUDElement(shaderName, textureName, position, size, scaleMode, color, clipColor, textureCoordinates) {
        /**
         * Manages the acquiry of appropriate resources.
         * @type TexturedModelClass
         */
        this._class = new classes.TexturedModelClass({
            name: HUD_ELEMENT_CLASS_NAME,
            shader: shaderName,
            texture: textureName
        });
        /**
         * The 2D or 3D (starting) position of the element (depending on the shader used)
         * @type Number[2]|Number[3]
         */
        this._position = position;
        /**
         * The 2D factor of the element to scale it.
         * @type Number[2]
         */
        this._scale = [0.5 * size[0], 0.5 * size[1]]; // square model coordinates are -1 to 1, resulting in a scale of 1 corresponding to a size of 2
        /**
         * (enum ScaleMode) The scaling mode to be used to size this element.
         * @type String
         */
        this._scaleMode = scaleMode;
        /**
         * An RGBA color for the element it can be modulated with. (inside the clip zone)
         * @type Number[4]
         */
        this._color = color;
        /**
         * The current angle for the element to be rotated by in 2D, in radians.
         * @type Number
         */
        this._angle = 0;
        /**
         * The coordinates specifying the clip zone for this element, in the form of [minX, maxX, minY, maxY], where the area outside the
         * min-max range on either the X or Y is considered to be outside the clip zone, and all coordinates go from -1 (left / bottom) to
         * 1 (right / top), corresponding to a relative position within the element.
         * @type Number[4]
         */
        this._clipCoordinates = renderableObjects.CLIP_COORDINATES_NO_CLIP.slice();
        /**
         * An RGBA color to be used for modulation outside the clip zone set for the element.
         * @type Number[4]
         */
        this._clipColor = clipColor || [0, 0, 0, 0];
        /**
         * The coordinates for the top-left and bottom-right corners of the section of the texture image to use for texture mapping (or 
         * other corners if flipped horizontally or vertically) When not set, the whole image is used.
         * (0;0) is top-left and (1;1) is bottom-right of the image
         * @type Number[2][2]
         */
        this._textureCoordinates = textureCoordinates;
        /**
         * A reference to the visual model that is used to add a representation of this element to the scene.
         * @type UIElement
         */
        this._visualModel = null;
        /**
         * A reference to the node at which the visual model of this element is stored in the scene.
         * @type RenderableNode
         */
        this._node = null;
    }
    /**
     * Returns the name of the model to be used / created for this HUD element, based on its texture coordinates
     * @returns {String}
     */
    HUDElement.prototype._getModelName = function () {
        return HUD_ELEMENT_MODEL_NAME_PREFIX + (this._textureCoordinates ?
                MODEL_NAME_INFIX + (this._textureCoordinates[0].join(MODEL_NAME_INFIX) + MODEL_NAME_INFIX + this._textureCoordinates[1].join(MODEL_NAME_INFIX)) :
                "");
    };
    /**
     * Grabs the references to all needed resource objects and marks them for loading. Automatically called when the element is added to a scene.
     */
    HUDElement.prototype._acquireResources = function () {
        var modelName, model;
        modelName = this._getModelName();
        model = resources.getModel(modelName, {allowNullResult: true});
        this._class.acquireResources({model: model || egomModel.squareModel(modelName, this._textureCoordinates)});
    };
    /**
     * Sets up the visual model to represent this HUD element, creating it if necessary. Automatically called when the element is added to a 
     * scene.
     */
    HUDElement.prototype._initVisualModel = function () {
        if (!this._visualModel) {
            this._visualModel = new renderableObjects.UIElement(
                    this._class.getModel(),
                    this._class.getShader(),
                    this._class.getTexturesOfTypes(this._class.getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                    this._position,
                    this._scale,
                    this._scaleMode,
                    this._color,
                    Math.degrees(this._angle),
                    this._clipCoordinates,
                    this._clipColor);
        } else {
            this._visualModel.init(
                    this._class.getModel(),
                    this._class.getShader(),
                    this._class.getTexturesOfTypes(this._class.getShader().getTextureTypes(), graphics.getTextureQualityPreferenceList()),
                    this._position,
                    this._scale,
                    this._scaleMode,
                    this._color,
                    Math.degrees(this._angle),
                    this._clipCoordinates,
                    this._clipColor);
        }
    };
    /**
     * Returns the current scale factor used (on the X and Y axes) for the element.
     * @returns {Number[2]}
     */
    HUDElement.prototype.getScale = function () {
        return this._scale;
    };
    /**
     * Returns the scale mode (enum: utils.ScaleMode) set for this HUD element
     * @returns {String}
     */
    HUDElement.prototype.getScaleMode = function () {
        return this._scaleMode;
    };
    /**
     * Returns the current RGBA color set for this element. (direct reference)
     * @returns {Number[4]}
     */
    HUDElement.prototype.getColor = function () {
        return this._color;
    };
    /**
     * Marks all needed resources for loading and sets a callback to add the visual model of this element to the passed scene if when all
     * resources are loaded (or adds it right away, if the resources are already loaded at the time of call)
     * @param {Scene} scene
     */
    HUDElement.prototype.addToScene = function (scene) {
        this._acquireResources();
        resources.executeWhenReady(function () {
            this._initVisualModel();
            this._node = scene.addUIObject(this._visualModel);
        }.bind(this));
    };
    /**
     * Marks all needed resources for loading and sets a callback to add the resources to the passed scene if when all
     * resources are loaded (or adds it right away, if the resources are already loaded at the time of call)
     * @param {Scene} scene
     */
    HUDElement.prototype.addResourcesToScene = function (scene) {
        this._acquireResources();
        resources.executeWhenReady(function () {
            this._initVisualModel();
            scene.addResourcesOfObject(this._visualModel);
        }.bind(this));
    };
    /**
     * Hides the visual representation of this element in the scene it was added to.
     */
    HUDElement.prototype.hide = function () {
        this._node.hide();
    };
    /**
     * Shows (makes visible) the visual representation of this element in the scene it was added to.
     */
    HUDElement.prototype.show = function () {
        this._node.show();
    };
    /**
     * Returns whether the visual representation of this element is set to be visible in the scene it was added to.
     * @returns {Boolean}
     */
    HUDElement.prototype.isVisible = function () {
        return this._node.isVisible();
    };
    /**
     * Sets a new position for this HUD element and its visual representation, if that exists.
     * @param {Number[2]|Number[3]} value
     */
    HUDElement.prototype.setPosition = function (value) {
        this._position = value;
        if (this._visualModel) {
            this._visualModel.setPosition(value);
        }
    };
    /**
     * Sets a new size for the element to be used for scaling it when rendering.
     * @param {Number[2]} value
     */
    HUDElement.prototype.setSize = function (value) {
        // square model coordinates are -1 to 1, resulting in a scale of 1 corresponding to a size of 2
        this._scale[0] = 0.5 * value[0];
        this._scale[1] = 0.5 * value[1];
        if (this._visualModel) {
            this._visualModel.setSize(this._scale);
        }
    };
    /**
     * Sets a new angle for this HUD element and its visual representation, if that exists.
     * @param {Number} value The new angle, in radians
     */
    HUDElement.prototype.setAngle = function (value) {
        this._angle = value;
        if (this._visualModel) {
            this._visualModel.setAngle(value);
        }
    };
    /**
     * Sets a new color for this HUD elements and its visual representation, if that exists.
     * @param {Number[4]} value RGBA color
     */
    HUDElement.prototype.setColor = function (value) {
        this._color = value;
        if (this._visualModel) {
            this._visualModel.setColor(value);
        }
    };
    /**
     * Sets new minimum and maximum X coordinates for the clip zone of the element.
     * @param {Number} minimum
     * @param {Number} maximum
     */
    HUDElement.prototype.clipX = function (minimum, maximum) {
        if (this._textureCoordinates) {
            minimum = utils.getLinearMix(this._textureCoordinates[0][0], this._textureCoordinates[1][0], minimum);
            maximum = utils.getLinearMix(this._textureCoordinates[0][0], this._textureCoordinates[1][0], maximum);
        }
        this._clipCoordinates[0] = minimum;
        this._clipCoordinates[1] = maximum;
        if (this._visualModel) {
            this._visualModel.clipX(minimum, maximum);
        }
    };
    /**
     * Sets new minimum and maximum Y coordinates for the clip zone of the element.
     * @param {Number} minimum
     * @param {Number} maximum
     */
    HUDElement.prototype.clipY = function (minimum, maximum) {
        if (this._textureCoordinates) {
            minimum = 1 - utils.getLinearMix(this._textureCoordinates[1][1], this._textureCoordinates[0][1], minimum);
            maximum = 1 - utils.getLinearMix(this._textureCoordinates[1][1], this._textureCoordinates[0][1], maximum);
        }
        this._clipCoordinates[2] = 1 - maximum;
        this._clipCoordinates[3] = 1 - minimum;
        if (this._visualModel) {
            this._visualModel.clipY(minimum, maximum);
        }
    };
    /**
     * Sets a new RGBA color for the element to be used for coloring it outsite its clip zone.
     * @param {Number[4]} value
     */
    HUDElement.prototype.setClipColor = function (value) {
        this._clipColor = value;
        if (this._visualModel) {
            this._visualModel.setClipColor(value);
        }
    };
    /**
     * Sets new texture coordinates for the HUD element. If it already has a visual model, also changes its model, so in case the element
     * is already used in a scene, the appropriate model needs to already be loaded! (e.g. with addResourcesToScene() for a HUD element 
     * with the same texture coordinates, before the loading)
     * @param {Number[2][2]} value
     */
    HUDElement.prototype.setTextureCoordinates = function (value) {
        this._textureCoordinates = value;
        if (this._visualModel) {
            this._visualModel.setModel(graphics.getModel(this._getModelName()).getEgomModel());
        }
    };
    /**
     * Set a new scaling mode to be used for the visual representation of this element
     * @param {String} value (enum ScaleMode)
     */
    HUDElement.prototype.setScaleMode = function (value) {
        this._scaleMode = value;
        if (this._visualModel) {
            this._visualModel.setScaleMode(value);
        }
    };
    /**
     * Sets new absolute (viewport) coordinates for the position and size of the element applying the rules
     * of the passed clip space layout to a viewport of the given size.
     * @param {ClipSpaceLayout} layout
     * @param {Number} viewportWidth
     * @param {Number} viewportHeight
     */
    HUDElement.prototype.applyLayout = function (layout, viewportWidth, viewportHeight) {
        this.setPosition(layout.getPosition(viewportWidth, viewportHeight));
        this.setSize(layout.getSize(viewportWidth, viewportHeight));
    };
    /**
     * Updates the properties of the class of this element for the case when the graphics settings have been changed. (e.g. clearing the
     * cached shader value, since a new shader might have become active)
     */
    HUDElement.prototype.handleGraphicsSettingsChanged = function () {
        this._class.handleGraphicsSettingsChanged();
    };
    // ------------------------------------------------------------------------------
    // private functions
    /**
     * Adds the passed HUD element to the stores persistent HUD element list and also returns it for convenience.
     * @param {HUDElement} hudElement
     * @returns {HUDElement}
     */
    function _addHUDElement(hudElement) {
        _hudElements.push(hudElement);
        return hudElement;
    }
    /**
     * Creates and returns a new HUD element that can be used as a ship indicator.
     * @returns {HUDElement}
     */
    function _createShipIndicator() {
        return _addHUDElement(new HUDElement(
                UI_3D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).texture,
                [0, 0, 0],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).sizes.maximum,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).scaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).colors.hostile,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).mapping));
    }
    /**
     * Creates and returns a new HUD element that can be used as a ship status indicator.
     * @param {String} mapping The string ID of the area of the texture to be used
     * @returns {HUDElement}
     */
    function _createShipStatusIndicator(mapping) {
        return _addHUDElement(new HUDElement(
                UI_2D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).texture,
                [0, 0],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).sizes.reticle,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).scaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).colors.friendly,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).mappings[mapping]));
    }
    /**
     * Creates and returns a new HUD element that can be used as a ship arrow.
     * @returns {HUDElement}
     */
    function _createShipArrow() {
        return _addHUDElement(new HUDElement(
                UI_2D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).texture,
                [0, 0],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).sizes.default,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).scaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).colors.hostile,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).mapping));
    }
    /**
     * Creates and returns a new HUD element that can be used as a missile lock indicator.
     * @returns {HUDElement}
     */
    function _createMissileLockIndicator() {
        return _addHUDElement(new HUDElement(
                UI_2D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR).texture,
                [0, 0],
                [1, 1],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR).scaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).colors.hostile,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR).mapping));
    }
    /**
     * Creates and returns a new HUD element that can be used as a weapon impact indicator.
     * @returns {HUDElement}
     */
    function _createWeaponImpactIndicator() {
        return _addHUDElement(new HUDElement(
                UI_3D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WEAPON_IMPACT_INDICATOR).texture,
                [0, 0, 0],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WEAPON_IMPACT_INDICATOR).size,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WEAPON_IMPACT_INDICATOR).scaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WEAPON_IMPACT_INDICATOR).colors.normal,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WEAPON_IMPACT_INDICATOR).mapping));
    }
    /**
     * Creates and returns a layout suitable for an individual spacecraft within the wingmen status indicator,
     * based on the layout defined for squads and the positions defined for spacecrafts
     * @param {Number} squadIndex
     * @param {Number} squadSize
     * @param {Number} craftIndex
     * @returns {HUDElement}
     */
    function _createWingmanCraftIndicatorLayout(squadIndex, squadSize, craftIndex) {
        var layoutDescriptor, craftPosition, craftSize;
        // start with a generic (1st) squad layout
        layoutDescriptor = utils.deepCopy(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_SQUAD_LAYOUT));
        // shift it to the right based on the index of the squad
        layoutDescriptor.right += layoutDescriptor.width * squadIndex;
        // position and resize according to the settings referring to individual spacecraft indicators
        craftPosition = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_CRAFT_POSITIONS)[squadSize - 1][craftIndex];
        craftSize = _wingmenStatusCraftIndicatorSettings.size;
        layoutDescriptor.right -= layoutDescriptor.width * (0.5 - 0.5 * (craftPosition[0] + craftSize[0]));
        layoutDescriptor.top -= layoutDescriptor.height * (0.5 - 0.5 * (craftPosition[1] + craftSize[1]));
        layoutDescriptor.width *= craftSize[0];
        layoutDescriptor.height *= craftSize[1];
        return new screens.ClipSpaceLayout(layoutDescriptor);
    }
    /**
     * Creates a HUD element suitable as an individual spacecraft indicator within the wingmen status panel
     * @param {ClipSpaceLayout} layout The layout to be used (create it beforehand using _createWingmanCraftIndicatorLayout())
     * @param {String} [craftType=general] The string ID of the craft / indicator type (which determines the icon to be used)
     * Special values are: player, general.
     * @param {Boolean} [forResourcesOnly=false] If true, the created indicator is not added to the list of persistently stored HUD elements
     * @returns {HUDElement}
     */
    function _createWingmanCraftIndicator(layout, craftType, forResourcesOnly) {
        var mappings, result;
        mappings = _wingmenStatusCraftIndicatorSettings.mappings;
        result = new HUDElement(
                UI_2D_MIX_VIEWPORT_SHADER_NAME,
                _wingmenStatusCraftIndicatorSettings.texture,
                layout.getClipSpacePosition(),
                layout.getClipSpaceSize(),
                layout.getScaleMode(),
                _wingmenStatusCraftIndicatorSettings.colors.fullIntegrity,
                undefined,
                (craftType && mappings[craftType]) || mappings.general);
        if (!forResourcesOnly) {
            _addHUDElement(result);
        }
        return result;
    }
    /**
     * 
     * @param {Number} squadIndex
     * @returns {CanvasText}
     */
    function _createWingmenStatusSquadText(squadIndex) {
        var position = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_SQUAD_TEXT).position;
        position = [position[0] + squadIndex * 2 *
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_SQUAD_LAYOUT).width /
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_BACKGROUND).layout.width,
            position[1]];
        return new screens.CanvasText(
                position,
                "",
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_SQUAD_TEXT).fontName,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_SQUAD_TEXT).fontSize,
                _wingmenStatusBackgroundLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_SQUAD_TEXT).color,
                "center");
    }
    /**
     * Creates all HUD elements, marks their resources for loading if they are not loaded yet, and adds their visual models to the scene if
     * they are. If they are not loaded, sets callbacks to add them after the loading has finished.
     */
    function _addHUDToScene() {
        var i, n, layout, mappings, indicator, layoutDescriptor, element;
        // keep the ons with the same shader together for faster rendering
        // ---------------------------------------------------------
        // UI 2D SHADER
        _centerCrosshair = _centerCrosshair || _addHUDElement(new HUDElement(
                UI_2D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CENTER_CROSSHAIR).texture,
                [0, 0],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CENTER_CROSSHAIR).size,
                _centerCrosshairScaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CENTER_CROSSHAIR).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CENTER_CROSSHAIR).mapping));
        _centerCrosshair.addToScene(_battleScene);
        _driftArrow = _driftArrow || _addHUDElement(new HUDElement(
                UI_2D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW).texture,
                [0, 0],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW).size,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW).scaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW).colors.maxSpeed,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW).mapping));
        _driftArrow.addToScene(_battleScene);
        if (!_shipArrows) {
            _shipArrows = [_createShipArrow()];
        }
        for (i = 0; i < _shipArrows.length; i++) {
            _shipArrows[i].addToScene(_battleScene);
        }
        if (!_shipStatusIndicators) {
            _shipStatusIndicators = [];
            mappings = Object.keys(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).mappings);
            for (i = 0; i < mappings.length; i++) {
                _shipStatusIndicators.push(_createShipStatusIndicator(mappings[i]));
            }
        }
        for (i = 0; i < _shipStatusIndicators.length; i++) {
            _shipStatusIndicators[i].addToScene(_battleScene);
        }
        if (!_missileLockIndicators) {
            _missileLockIndicators = [];
            for (i = 0; i < config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR_COUNT); i++) {
                _missileLockIndicators.push(_createMissileLockIndicator());
            }
        }
        for (i = 0; i < config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR_COUNT); i++) {
            _missileLockIndicators[i].addToScene(_battleScene);
        }
        // ---------------------------------------------------------
        // UI 3D SHADER
        if (!_shipIndicators) {
            _shipIndicators = [_createShipIndicator()];
        }
        for (i = 0; i < _shipIndicators.length; i++) {
            _shipIndicators[i].addToScene(_battleScene);
        }
        _aimAssistIndicator = _aimAssistIndicator || _addHUDElement(new HUDElement(
                UI_3D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR).texture,
                [0, 0, 0],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR).size,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR).scaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR).colors.hostile,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR).mapping));
        _aimAssistIndicator.addToScene(_battleScene);
        if (!_weaponImpactIndicators) {
            _weaponImpactIndicators = [_createWeaponImpactIndicator()];
        }
        for (i = 0; i < _weaponImpactIndicators.length; i++) {
            _weaponImpactIndicators[i].addToScene(_battleScene);
        }
        // ---------------------------------------------------------
        // UI 2D MIX VIEWPORT SHADER
        _targetInfoBackground = _targetInfoBackground || _addHUDElement(new HUDElement(
                UI_2D_MIX_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_BACKGROUND).texture,
                _targetInfoBackgroundLayout.getClipSpacePosition(),
                _targetInfoBackgroundLayout.getClipSpaceSize(),
                _targetInfoBackgroundLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_BACKGROUND).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_BACKGROUND).mapping));
        _targetInfoBackground.addToScene(_battleScene);
        _wingmenStatusBackground = _wingmenStatusBackground || _addHUDElement(new HUDElement(
                UI_2D_MIX_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_BACKGROUND).texture,
                _wingmenStatusBackgroundLayout.getClipSpacePosition(),
                _wingmenStatusBackgroundLayout.getClipSpaceSize(),
                _wingmenStatusBackgroundLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_BACKGROUND).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_BACKGROUND).mapping));
        _wingmenStatusBackground.addToScene(_battleScene);
        _flightModeIndicatorBackground = _flightModeIndicatorBackground || _addHUDElement(new HUDElement(
                UI_2D_MIX_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_INDICATOR_BACKGROUND).texture,
                _flightModeIndicatorBackgroundLayout.getClipSpacePosition(),
                _flightModeIndicatorBackgroundLayout.getClipSpaceSize(),
                _flightModeIndicatorBackgroundLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_INDICATOR_BACKGROUND).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_INDICATOR_BACKGROUND).mapping));
        _flightModeIndicatorBackground.addToScene(_battleScene);
        _missileInfoBackground = _missileInfoBackground || _addHUDElement(new HUDElement(
                UI_2D_MIX_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_BACKGROUND).texture,
                _missileInfoBackgroundLayout.getClipSpacePosition(),
                _missileInfoBackgroundLayout.getClipSpaceSize(),
                _missileInfoBackgroundLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_BACKGROUND).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_BACKGROUND).mapping));
        _missileInfoBackground.addToScene(_battleScene);
        _objectivesBackground = _objectivesBackground || _addHUDElement(new HUDElement(
                UI_2D_MIX_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_BACKGROUND).texture,
                _objectivesBackgroundLayout.getClipSpacePosition(),
                _objectivesBackgroundLayout.getClipSpaceSize(),
                _objectivesBackgroundLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_BACKGROUND).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_BACKGROUND).mapping));
        _objectivesBackground.addToScene(_battleScene);
        _escortsBackground = _escortsBackground || _addHUDElement(new HUDElement(
                UI_2D_MIX_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_BACKGROUND).texture,
                _escortsBackgroundLayout.getClipSpacePosition(),
                _escortsBackgroundLayout.getClipSpaceSize(),
                _escortsBackgroundLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_BACKGROUND).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_BACKGROUND).mapping));
        _escortsBackground.addToScene(_battleScene);
        _messageBackground = _messageBackground || _addHUDElement(new HUDElement(
                UI_2D_MIX_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_BACKGROUND).texture,
                _messageBackgroundLayout.getClipSpacePosition(),
                _messageBackgroundLayout.getClipSpaceSize(),
                _messageBackgroundLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_BACKGROUND).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_BACKGROUND).mapping));
        _messageBackground.addToScene(_battleScene);
        // these are created dynamically so initialize the arrays 
        if (!_wingmenStatusCraftIndicators) {
            _wingmenStatusCraftLayouts = [];
            _wingmenStatusCraftIndicators = [];
        }
        // but if they were already created for a previous battle, we need to add them to the current, new scene
        for (i = 0; i < _wingmenStatusCraftIndicators.length; i++) {
            _wingmenStatusCraftIndicators[i].body.addToScene(_battleScene);
            _wingmenStatusCraftIndicators[i].shield.addToScene(_battleScene);
        }
        if (_wingmenStatusPlayerIndicator) {
            _wingmenStatusPlayerIndicator.addToScene(_battleScene);
        }
        // ---------------------------------------------------------
        // UI 2D CLIP VIEWPORT SHADER
        _targetHullIntegrityBar = _targetHullIntegrityBar || _addHUDElement(new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_BAR).texture,
                _targetHullIntegrityBarLayout.getClipSpacePosition(),
                _targetHullIntegrityBarLayout.getClipSpaceSize(),
                _targetHullIntegrityBarLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_BAR).colors.filled,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_BAR).colors.empty,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_BAR).mapping));
        _targetHullIntegrityBar.addToScene(_battleScene);
        _targetShieldBar = _targetShieldBar || _addHUDElement(new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_BAR).texture,
                _targetShieldBarLayout.getClipSpacePosition(),
                _targetShieldBarLayout.getClipSpaceSize(),
                _targetShieldBarLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_BAR).colors.filled,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_BAR).colors.empty,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_BAR).mapping));
        _targetShieldBar.addToScene(_battleScene);
        _speedBar = _speedBar || _addHUDElement(new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR).texture,
                _speedBarLayout.getClipSpacePosition(),
                _speedBarLayout.getClipSpaceSize(),
                _speedBarLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR).colors.combatFilled,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR).colors.combatEmpty,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR).mapping));
        _speedBar.addToScene(_battleScene);
        _speedTargetIndicator = _speedTargetIndicator || _addHUDElement(new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TARGET_INDICATOR).texture,
                _speedBarLayout.getClipSpacePosition(),
                _speedBarLayout.getClipSpaceSize(),
                _speedBarLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TARGET_INDICATOR).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TARGET_INDICATOR).mapping));
        _speedTargetIndicator.addToScene(_battleScene);
        _missileIndicator = _missileIndicator || _addHUDElement(new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).texture,
                _missileIndicatorLayout.getClipSpacePosition(),
                _missileIndicatorLayout.getClipSpaceSize(),
                _missileIndicatorLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).colors.loading,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).colors.loading,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).mappings.single));
        _missileIndicator.addToScene(_battleScene);
        // just to make sure model with salvo texture coordinates is added to context:
        element = new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).texture,
                _missileIndicatorLayout.getClipSpacePosition(),
                _missileIndicatorLayout.getClipSpaceSize(),
                _missileIndicatorLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).colors.loading,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).colors.loading,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).mappings.salvo);
        element.addResourcesToScene(_battleScene);
        _hullIntegrityBar = _hullIntegrityBar || _addHUDElement(new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.HULL_INTEGRITY_BAR).texture,
                _hullIntegrityBarLayout.getClipSpacePosition(),
                _hullIntegrityBarLayout.getClipSpaceSize(),
                _hullIntegrityBarLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.HULL_INTEGRITY_BAR).colors.filled,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.HULL_INTEGRITY_BAR).colors.empty,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.HULL_INTEGRITY_BAR).mapping));
        _hullIntegrityBar.addToScene(_battleScene);
        _shieldBar = _shieldBar || _addHUDElement(new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIELD_BAR).texture,
                _shieldBarLayout.getClipSpacePosition(),
                _shieldBarLayout.getClipSpaceSize(),
                _shieldBarLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIELD_BAR).colors.filled,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIELD_BAR).colors.empty,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIELD_BAR).mapping));
        _shieldBar.addToScene(_battleScene);
        _targetHullIntegrityQuickViewBar = _targetHullIntegrityQuickViewBar || _addHUDElement(new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_QUICK_VIEW_BAR).texture,
                _targetHullIntegrityQuickViewBarLayout.getClipSpacePosition(),
                _targetHullIntegrityQuickViewBarLayout.getClipSpaceSize(),
                _targetHullIntegrityQuickViewBarLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_QUICK_VIEW_BAR).colors.hostileFilled,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_QUICK_VIEW_BAR).mapping));
        _targetHullIntegrityQuickViewBar.addToScene(_battleScene);
        _targetShieldQuickViewBar = _targetShieldQuickViewBar || _addHUDElement(new HUDElement(
                UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_QUICK_VIEW_BAR).texture,
                _targetShieldQuickViewBarLayout.getClipSpacePosition(),
                _targetShieldQuickViewBarLayout.getClipSpaceSize(),
                _targetShieldQuickViewBarLayout.getScaleMode(),
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_QUICK_VIEW_BAR).colors.filled,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_QUICK_VIEW_BAR).mapping));
        _targetShieldQuickViewBar.addToScene(_battleScene);
        n = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MAX_ESCORTS_DISPLAYED);
        if (!_escortBars) {
            _escortBars = [];
            for (i = 0; i < n; i++) {
                _escortBars.push({});
                layoutDescriptor = utils.deepCopy(_escortsIntegrityBarsSettings.layouts.hull);
                layoutDescriptor.top += i * config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_TEXT_OFFSET) * _escortsBackgroundLayout.getClipSpaceHeight() * 0.5;
                _escortBars[i].hullLayout = new screens.ClipSpaceLayout(layoutDescriptor);
                _escortBars[i].hull = _addHUDElement(new HUDElement(
                        UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                        _escortsIntegrityBarsSettings.texture,
                        _escortBars[i].hullLayout.getClipSpacePosition(),
                        _escortBars[i].hullLayout.getClipSpaceSize(),
                        _escortBars[i].hullLayout.getScaleMode(),
                        _escortsIntegrityBarsSettings.colors.fullHull,
                        _escortsIntegrityBarsSettings.colors.destroyed,
                        _escortsIntegrityBarsSettings.mapping));
                layoutDescriptor = utils.deepCopy(_escortsIntegrityBarsSettings.layouts.shield);
                layoutDescriptor.top += i * config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_TEXT_OFFSET) * _escortsBackgroundLayout.getClipSpaceHeight() * 0.5;
                _escortBars[i].shieldLayout = new screens.ClipSpaceLayout(layoutDescriptor);
                _escortBars[i].shield = _addHUDElement(new HUDElement(
                        UI_2D_CLIP_VIEWPORT_SHADER_NAME,
                        _escortsIntegrityBarsSettings.texture,
                        _escortBars[i].shieldLayout.getClipSpacePosition(),
                        _escortBars[i].shieldLayout.getClipSpaceSize(),
                        _escortBars[i].shieldLayout.getScaleMode(),
                        _escortsIntegrityBarsSettings.colors.shield,
                        _escortsIntegrityBarsSettings.colors.lostShield,
                        _escortsIntegrityBarsSettings.mapping));
            }
        }
        for (i = 0; i < n; i++) {
            _escortBars[i].hull.addToScene(_battleScene);
            _escortBars[i].shield.addToScene(_battleScene);
        }
        // ---------------------------------------------------------
        // UI 2D SHADER
        // these need to render on top of the backgrounds
        _hudStillCursor = _hudStillCursor || _addHUDElement(new HUDElement(
                UI_2D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).texture,
                [0, 0],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).size,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).scaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).mappings.still));
        _hudStillCursor.addToScene(_battleScene);
        _hudTurnCursor = _hudTurnCursor || _addHUDElement(new HUDElement(
                UI_2D_SHADER_NAME,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).texture,
                [0, 0],
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).size,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).scaleMode,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).color,
                undefined,
                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CURSOR).mappings.turn));
        _hudTurnCursor.addToScene(_battleScene);
        // mark wingman craft indicator resources for loading
        layout = _createWingmanCraftIndicatorLayout(0, 1, 0);
        mappings = Object.keys(_wingmenStatusCraftIndicatorSettings.mappings);
        for (i = 0; i < mappings.length; i++) {
            indicator = _createWingmanCraftIndicator(layout, mappings[i], true);
            indicator.addResourcesToScene(_battleScene);
        }
        // mark HUD sound effects for loading
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SWITCH_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SWITCH_DENIED_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_SWITCH_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_CHANGE_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_CHANGE_DENIED_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_SALVO_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOADED_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCKING_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCKED_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_TYPE_SOUND).name);
        resources.getSoundEffect(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.NEW_HOSTILES_ALERT_SOUND).name);
    }
    /**
     * Returns the HTML string to insert to messages that contains the key to open the menu in a highlighted style.
     * @returns {String}
     */
    function _getMenuKeyHTMLString() {
        return "<span class='highlightedText'>" + control.getInputInterpreter(control.KEYBOARD_NAME).getControlStringForAction("quit") + "</span>";
    }
    /**
     * @param {Spacecraft} craft
     * @returns {Boolean}
     */
    function _spacecraftShouldBeIndicated(craft) {
        return  craft.isAlive() && !craft.isAway() && (craft !== _spacecraft);
    }
    /**
     * @param {Spacecraft} craft
     * @returns {Boolean}
     */
    function _escortShouldBeIndicated(craft) {
        return  (craft !== _spacecraft);
    }
    /**
     * 
     * @param {Number} distance
     * @returns {String}
     */
    function _getDistanceString(distance) {
        return (distance > 1000) ? (distance / 1000).toPrecision(3) + "k" : Math.round(distance).toString();
    }
    /**
     * Returns an interpolated color to be used to represent hull integrities
     * @param {Number} hullIntegrity The hull integrity to represent (0.0-1.0)
     * @param {Number[4]} fullColor Color to use when the hull integrity is 1.0
     * @param {Number[4]} halfColor Color to use when the hull integrity is 0.5
     * @param {Number[4]} zeroColor Color to use when the hull integrity is 0.0
     * @returns {Number[4]}
     */
    function _getHullIntegrityColor(hullIntegrity, fullColor, halfColor, zeroColor) {
        return (hullIntegrity > 0.5) ?
                utils.getMixedColor(
                        halfColor,
                        fullColor,
                        (hullIntegrity - 0.5) * 2) :
                utils.getMixedColor(
                        zeroColor,
                        halfColor,
                        hullIntegrity * 2);
    }
    /**
     * The callback to execute when adding the target view model to its scene
     * @param {Model} model
     */
    function _targetViewAddCallback(model) {
        model.setUniformValueFunction(renderableObjects.UNIFORM_COLOR_NAME, function () {
            return _targetViewItemColor;
        });
        model.setScale(1 / model.getSize());
        _targetViewModel = model;
    }
    /**
     * Whether the passed HUD section should be currently visible according to its state
     * @param {Number} hudSection (enum HUDSection)
     * @returns {Boolean}
     */
    function _hudSectionIsVisible(hudSection) {
        return (_hudSectionStates[hudSection] === HUDSectionState.VISIBLE) ||
                ((_hudSectionStates[hudSection] === HUDSectionState.HIGHLIGHTED) && _hudHighlightVisible);
    }
    // ##############################################################################
    /**
     * @class Represents the battle screen.
     * @extends HTMLScreenWithCanvases
     */
    function BattleScreen() {
        screens.HTMLScreenWithCanvases.call(this,
                armadaScreens.BATTLE_SCREEN_NAME,
                armadaScreens.BATTLE_SCREEN_SOURCE,
                {
                    cssFilename: armadaScreens.BATTLE_SCREEN_CSS,
                    backgroundClassName: armadaScreens.SCREEN_BACKGROUND_CLASS_NAME,
                    containerClassName: armadaScreens.SCREEN_CONTAINER_CLASS_NAME
                },
                graphics.getAntialiasing(),
                true,
                graphics.getFiltering(),
                config.getSetting(config.GENERAL_SETTINGS.USE_REQUEST_ANIM_FRAME),
                {
                    activate: function () {
                        _aimAssistCrosshairs = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_CROSSHAIRS);
                    }
                });
        /**
         * @type SimpleComponent
         */
        this._stats = this.registerSimpleComponent(STATS_PARAGRAPH_ID);
        /**
         * @type LoadingBox
         */
        this._loadingBox = this.registerExternalComponent(new components.LoadingBox(
                LOADING_BOX_ID,
                armadaScreens.LOADING_BOX_SOURCE,
                {cssFilename: armadaScreens.LOADING_BOX_CSS},
                strings.LOADING.HEADER.name));
        /**
         * @type InfoBox
         */
        this._infoBox = this.registerExternalComponent(new components.InfoBox(
                INFO_BOX_ID,
                armadaScreens.INFO_BOX_SOURCE,
                {cssFilename: armadaScreens.INFO_BOX_CSS},
                strings.INFO_BOX.HEADER.name,
                strings.INFO_BOX.OK_BUTTON.name,
                {
                    show: function () {
                        this.pauseBattle();
                    }.bind(this),
                    hide: function () {
                        this.resumeBattle();
                        resumeTime();
                        if (!_demoMode) {
                            control.switchToPilotMode(_mission.getPilotedSpacecraft(), true);
                        } else {
                            control.switchToSpectatorMode(false, true);
                            _battleScene.getCamera().followNextNode();
                            _timeInSameView = 0;
                        }
                    }.bind(this),
                    buttonselect: armadaScreens.playButtonSelectSound,
                    buttonclick: armadaScreens.playButtonClickSound
                }));
    }
    BattleScreen.prototype = new screens.HTMLScreenWithCanvases();
    BattleScreen.prototype.constructor = BattleScreen;
    /**
     * @override
     * @returns {Boolean}
     */
    BattleScreen.prototype.hide = function () {
        if (screens.HTMLScreenWithCanvases.prototype.hide.call(this)) {
            this.pauseBattle();
            _clearData();
            return true;
        }
        return false;
    };
    /**
     * @override
     */
    BattleScreen.prototype._initializeComponents = function () {
        var canvas;
        screens.HTMLScreenWithCanvases.prototype._initializeComponents.call(this);
        canvas = this.getScreenCanvas(BATTLE_CANVAS_ID).getCanvasElement();
        if (_handleResize) {
            window.removeEventListener("resize", _handleResize);
        }
        _handleResize = _handleResize || function () {
            control.setScreenCenter(canvas.width / 2, canvas.height / 2);
        };
        window.addEventListener("resize", _handleResize);
        _handleResize();
    };
    /**
     * @override
     */
    BattleScreen.prototype._updateComponents = function () {
        screens.HTMLScreenWithCanvases.prototype._updateComponents.call(this);
    };
    /**
     * Pauses the battle by canceling all control, simulation and the render loop (e.g. for when a menu is 
     * displayed)
     * @param {Boolean} [dimMusic=true] 
     * @param {Boolean} [dimSFX=true] 
     */
    BattleScreen.prototype.pauseBattle = function (dimMusic, dimSFX) {
        control.stopListening();
        _battleCursor = document.body.style.cursor;
        document.body.style.cursor = game.getDefaultCursor();
        if (_simulationLoop !== LOOP_REQUESTANIMFRAME) {
            clearInterval(_simulationLoop);
        }
        _simulationLoop = LOOP_CANCELED;
        if (_battleScene) {
            _battleScene.setShouldAnimate(false);
        }
        this.stopRenderLoop();
        if (dimMusic !== false) {
            audio.resetMusicVolume();
            audio.setMusicVolume(config.getSetting(config.BATTLE_SETTINGS.MUSIC_VOLUME_IN_MENUS) * audio.getMusicVolume(), false);
        }
        if (dimSFX !== false) {
            audio.resetSFXVolume();
            audio.setSFXVolume(config.getSetting(config.BATTLE_SETTINGS.SFX_VOLUME_IN_MENUS) * audio.getSFXVolume(), false);
        }
        if (_messageTypeSound) {
            _messageTypeSound.stopPlaying(HUD_MESSAGE_APPEAR_SOUND_STOP_RAMP_DURATION);
        }
        if (application.isDebugVersion()) {
            _battleScene.logNodes();
        }
    };
    /**
     * Resumes the simulation and control of the battle and the render loop
     */
    BattleScreen.prototype.resumeBattle = function () {
        document.body.style.cursor = _battleCursor || game.getDefaultCursor();
        if (_simulationLoop === LOOP_CANCELED) {
            _prevDate = performance.now();
            if (_battleScene) {
                if (!_isTimeStopped) {
                    _battleScene.setShouldAnimate(true);
                }
            }
            if (config.getSetting(config.GENERAL_SETTINGS.USE_REQUEST_ANIM_FRAME)) {
                _simulationLoop = LOOP_REQUESTANIMFRAME;
            } else {
                _simulationLoop = setInterval(_simulationLoopFunction, 1000 / (config.getSetting(config.BATTLE_SETTINGS.SIMULATION_STEPS_PER_SECOND)));
            }
            control.startListening();
            this.startRenderLoop(1000 / config.getSetting(config.BATTLE_SETTINGS.RENDER_FPS));
        } else {
            application.showError(
                    "Trying to resume simulation while it is already going on!",
                    application.ErrorSeverity.MINOR,
                    "No action was taken, to avoid double-running the simulation.");
        }
        audio.resetMusicVolume();
        audio.resetSFXVolume();
    };
    /**
     * Uses the loading box to show the status to the user.
     * @param {String} newStatus The status to show on the loading box. If
     * undefined, the status won't be updated.
     * @param {Number} newProgress The new value of the progress bar on the loading
     * box. If undefined, the value won't be updated.
     */
    BattleScreen.prototype._updateLoadingStatus = function (newStatus, newProgress) {
        if (newStatus !== undefined) {
            this._loadingBox.updateStatus(_tipText + armadaScreens.getSubParagraph(newStatus));
        }
        if (newProgress !== undefined) {
            this._loadingBox.updateProgress(newProgress);
        }
    };
    /**
     * Updates the loading box message and progress value to reflect the state given in the parameters.
     * @param {String} resourceName The name of the resource that have just finished loading
     * @param {String} resourceType The name of the resource that have just finished loading
     * @param {Number} totalResources The number of total resources to be loaded
     * @param {Number} loadedResources The number of resources that have already been loaded
     */
    BattleScreen.prototype._updateLoadingBoxForResourceLoad = function (resourceName, resourceType, totalResources, loadedResources) {
        this._updateLoadingStatus(
                utils.formatString(strings.get(strings.LOADING.RESOURCE_READY), {
                    resource: resourceName,
                    resourceType: resourceType,
                    loaded: loadedResources,
                    total: totalResources
                }),
                LOADING_RESOURCES_START_PROGRESS + (loadedResources / totalResources) * LOADING_RESOURCE_PROGRESS);
    };
    /**
     * Adds the text layers and texts of the HUD to the screen if needed.
     */
    BattleScreen.prototype._addUITexts = function () {
        var i, n, layoutDescriptor,
                screenCanvas = this.getScreenCanvas(BATTLE_CANVAS_ID),
                // general HUD text
                initText = function (descriptor, layout, layer, alignment) {
                    var setting, result;
                    setting = config.getHUDSetting(descriptor);
                    result = new screens.CanvasText(
                            setting.position,
                            "",
                            setting.fontName,
                            setting.fontSize,
                            layout.getScaleMode(),
                            setting.color || setting.colors[Object.keys(setting.colors)[0]],
                            alignment);
                    layer.addText(result);
                    return result;
                },
                getTargetInfoText = function (sectionName) {
                    return new screens.CanvasText(
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_TEXT).positions[sectionName],
                            "",
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_TEXT).fontName,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_TEXT).fontSizes[(sectionName === "name") ? "name" : "others"],
                            _targetInfoBackgroundLayout.getScaleMode(),
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_TEXT).colors.friendly);
                },
                getSpeedText = function (textPosition) {
                    return new screens.CanvasText(
                            textPosition,
                            "",
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).fontName,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).fontSize,
                            _speedBarLayout.getScaleMode(),
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).colors.combatForward);
                },
                getMissileInfoNameText = function (index) {
                    var position = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT).positions.name;
                    position = [position[0], position[1] + index * config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT_OFFSET)];
                    return new screens.CanvasText(
                            position,
                            "",
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT).fontName,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT).fontSize,
                            _missileInfoBackgroundLayout.getScaleMode(),
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT).colors.notSelected);
                },
                getMissileInfoCountText = function (index) {
                    var position = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT).positions.count;
                    position = [position[0], position[1] + index * config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT_OFFSET)];
                    return new screens.CanvasText(
                            position,
                            "",
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT).fontName,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT).fontSize,
                            _missileInfoBackgroundLayout.getScaleMode(),
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT).colors.notSelected,
                            "right");
                },
                getObjectiveText = function (index) {
                    var position = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_TEXT).position;
                    position = [position[0], position[1] + index * config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_TEXT_OFFSET)];
                    return new screens.CanvasText(
                            position,
                            "",
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_TEXT).fontName,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_TEXT).fontSize,
                            _objectivesBackgroundLayout.getScaleMode(),
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_TEXT).colors.inProgress);
                },
                getEscortText = function (index) {
                    var position = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_TEXT).position;
                    position = [position[0], position[1] + index * config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_TEXT_OFFSET)];
                    return new screens.CanvasText(
                            position,
                            "",
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_TEXT).fontName,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_TEXT).fontSize,
                            _escortsBackgroundLayout.getScaleMode(),
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_TEXT).colors.alive);
                };
        // ..............................................................................
        // target distance
        if (!_distanceTextLayer) {
            _distanceTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DISTANCE_TEXT_LAYER_LAYOUT));
            screenCanvas.addTextLayer(_distanceTextLayer);
        }
        if (!_distanceText) {
            _distanceText = new screens.CanvasText(
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DISTANCE_TEXT).position,
                    "",
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DISTANCE_TEXT).fontName,
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DISTANCE_TEXT).fontSize,
                    new screens.ClipSpaceLayout(_distanceTextBoxLayoutDescriptor).getScaleMode(),
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DISTANCE_TEXT).colors.hostile,
                    "left",
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DISTANCE_TEXT).layout);
            _distanceTextLayer.addText(_distanceText);
        }
        // ..............................................................................
        // target info
        if (!_targetInfoTextLayer) {
            _targetInfoTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_TEXT_LAYER_LAYOUT));
            screenCanvas.addTextLayer(_targetInfoTextLayer);
        }
        if (!_targetInfoTexts) {
            _targetInfoTexts = {};
            for (i = 0; i < TARGET_INFO_SECTIONS.length; i++) {
                _targetInfoTexts[TARGET_INFO_SECTIONS[i]] = getTargetInfoText(TARGET_INFO_SECTIONS[i]);
                _targetInfoTextLayer.addText(_targetInfoTexts[TARGET_INFO_SECTIONS[i]]);
            }
        }
        // ..............................................................................
        // wingmen status
        if (!_wingmenStatusTextLayer) {
            _wingmenStatusTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_BACKGROUND).layout);
            screenCanvas.addTextLayer(_wingmenStatusTextLayer);
        }
        _wingmenStatusHeaderText = _wingmenStatusHeaderText || initText(
                config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_HEADER_TEXT,
                _wingmenStatusBackgroundLayout,
                _wingmenStatusTextLayer);
        _wingmenStatusHeaderText.setText(strings.get(strings.BATTLE.HUD_WINGMEN_HEADER));
        if (!_wingmenStatusSquadTexts) {
            _wingmenStatusSquadTexts = [];
        }
        // ..............................................................................
        // speed bar
        if (!_speedTextLayer) {
            _speedTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT_LAYER_LAYOUT));
            screenCanvas.addTextLayer(_speedTextLayer);
        }
        if (!_maxSpeedText) {
            _maxSpeedText = getSpeedText(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).positions.maxForward);
            _speedTextLayer.addText(_maxSpeedText);
        }
        if (!_currentSpeedText) {
            _currentSpeedText = getSpeedText(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).positions.maxReverse);
            _speedTextLayer.addText(_currentSpeedText);
        }
        // ..............................................................................
        // missile indicator text
        if (!_missileIndicatorTextLayer) {
            _missileIndicatorTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR_TEXT_LAYOUT));
            screenCanvas.addTextLayer(_missileIndicatorTextLayer);
        }
        if (!_missileIndicatorText) {
            _missileIndicatorText = new screens.CanvasText(
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR_TEXT).position,
                    "",
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR_TEXT).fontName,
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR_TEXT).fontSize,
                    _missileIndicatorLayout.getScaleMode(),
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR_TEXT).colors.ready,
                    "right");
            _missileIndicatorTextLayer.addText(_missileIndicatorText);
        }
        // ..............................................................................
        // flight mode
        if (!_flightModeIndicatorTextLayer) {
            _flightModeIndicatorTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_INDICATOR_BACKGROUND).layout);
            screenCanvas.addTextLayer(_flightModeIndicatorTextLayer);
        }
        _flightModeHeaderText = _flightModeHeaderText || initText(
                config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_HEADER_TEXT,
                _flightModeIndicatorBackgroundLayout,
                _flightModeIndicatorTextLayer);
        _flightModeHeaderText.setText(strings.get(strings.BATTLE.HUD_FLIGHT_MODE));
        if (!_flightModeText) {
            _flightModeText = new screens.CanvasText(
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_TEXT).position,
                    "",
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_TEXT).fontName,
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_TEXT).fontSize,
                    _flightModeIndicatorBackgroundLayout.getScaleMode(),
                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_TEXT).colors.combat);
            _flightModeIndicatorTextLayer.addText(_flightModeText);
        }
        // ..............................................................................
        // missile info
        if (!_missileInfoTextLayer) {
            _missileInfoTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_BACKGROUND).layout);
            screenCanvas.addTextLayer(_missileInfoTextLayer);
        }
        _missileInfoHeaderText = _missileInfoHeaderText || initText(
                config.BATTLE_SETTINGS.HUD.MISSILE_INFO_HEADER_TEXT,
                _missileInfoBackgroundLayout,
                _missileInfoTextLayer);
        _missileInfoHeaderText.setText(strings.get(strings.BATTLE.HUD_MISSILES));
        if (!_missileInfoNameTexts) {
            _missileInfoNameTexts = [];
            _missileInfoCountTexts = [];
            n = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MAX_MISSILE_INFO_DISPLAYED);
            for (i = 0; i < n; i++) {
                _missileInfoNameTexts.push(getMissileInfoNameText(i));
                _missileInfoTextLayer.addText(_missileInfoNameTexts[i]);
                _missileInfoCountTexts.push(getMissileInfoCountText(i));
                _missileInfoTextLayer.addText(_missileInfoCountTexts[i]);
            }
        }
        // ..............................................................................
        // headers
        if (!_headerTextLayer) {
            _headerTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.HEADER_TEXT_LAYER_LAYOUT));
            screenCanvas.addTextLayer(_headerTextLayer);
        }
        _smallHeaderText = _smallHeaderText || initText(
                config.BATTLE_SETTINGS.HUD.SMALL_HEADER_TEXT,
                _headerTextLayer.getLayout(),
                _headerTextLayer,
                "center");
        _bigHeaderText = _bigHeaderText || initText(
                config.BATTLE_SETTINGS.HUD.BIG_HEADER_TEXT,
                _headerTextLayer.getLayout(),
                _headerTextLayer,
                "center");
        _subheaderText = _subheaderText || initText(
                config.BATTLE_SETTINGS.HUD.SUBHEADER_TEXT,
                _headerTextLayer.getLayout(),
                _headerTextLayer,
                "center");
        // ..............................................................................
        // message
        if (!_messageTextLayer) {
            layoutDescriptor = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_BACKGROUND).layout;
            layoutDescriptor.width -= config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_TEXT_MARGIN);
            _messageTextLayer = new screens.TextLayer(layoutDescriptor);
            screenCanvas.addTextLayer(_messageTextLayer);
        }
        _messageText = _messageText || initText(
                config.BATTLE_SETTINGS.HUD.MESSAGE_TEXT,
                _messageTextLayer.getLayout(),
                _messageTextLayer,
                "center");
        // ..............................................................................
        // top left
        if (!_topLeftTextLayer) {
            _topLeftTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TOP_LEFT_TEXT_LAYER_LAYOUT));
            screenCanvas.addTextLayer(_topLeftTextLayer);
        }
        _scoreText = _scoreText || initText(
                config.BATTLE_SETTINGS.HUD.SCORE_TEXT,
                _topLeftTextLayer.getLayout(),
                _topLeftTextLayer,
                "left");
        // ..............................................................................
        // objectives
        if (!_objectivesTextLayer) {
            _objectivesTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_BACKGROUND).layout);
            screenCanvas.addTextLayer(_objectivesTextLayer);
        }
        _objectivesHeaderText = _objectivesHeaderText || initText(
                config.BATTLE_SETTINGS.HUD.OBJECTIVES_HEADER_TEXT,
                _objectivesBackgroundLayout,
                _objectivesTextLayer);
        _objectivesHeaderText.setText(strings.get(strings.BATTLE.HUD_OBJECTIVES));
        if (!_objectivesTexts) {
            _objectivesTexts = [];
            n = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MAX_OBJECTIVES_DISPLAYED);
            for (i = 0; i < n; i++) {
                _objectivesTexts.push(getObjectiveText(i));
                _objectivesTextLayer.addText(_objectivesTexts[i]);
            }
        }
        // ..............................................................................
        // escorted ships
        if (!_escortsTextLayer) {
            _escortsTextLayer = new screens.TextLayer(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_BACKGROUND).layout);
            screenCanvas.addTextLayer(_escortsTextLayer);
        }
        _escortsHeaderText = _escortsHeaderText || initText(
                config.BATTLE_SETTINGS.HUD.ESCORTS_HEADER_TEXT,
                _escortsBackgroundLayout,
                _escortsTextLayer);
        _escortsHeaderText.setText(strings.get(strings.BATTLE.HUD_ESCORTED_SHIPS_HEADER));
        if (!_escortsTexts) {
            _escortsTexts = [];
            n = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MAX_ESCORTS_DISPLAYED);
            for (i = 0; i < n; i++) {
                _escortsTexts.push(getEscortText(i));
                _escortsTextLayer.addText(_escortsTexts[i]);
            }
        }
    };
    /**
     * Shows the stats (FPS, draw stats) component.
     */
    BattleScreen.prototype.showDevelopmentInfo = function () {
        this._stats.show();
        _smallHeaderText.show();
    };
    /**
     * Hides the stats (FPS, draw stats) component.
     */
    BattleScreen.prototype.hideDevelopmentInfo = function () {
        this._stats.hide();
        _smallHeaderText.hide();
    };
    /**
     * Toggles the visibility of the development related information (e.g. version info header and FPS count) on the screen.
     */
    BattleScreen.prototype.toggleDevInfoVisibility = function () {
        if (this._stats.isVisible()) {
            this.hideDevelopmentInfo();
        } else {
            this.showDevelopmentInfo();
        }
    };
    /**
     * Shows the given message to the user in an information box.
     * @param {String} message
     */
    BattleScreen.prototype.showMessage = function (message) {
        this._infoBox.updateMessage(message);
        this._infoBox.show();
    };
    /**
     * Updates the big header's content on the screen.
     * @param {String} content
     * @param {Object} [replacements]
     */
    BattleScreen.prototype.setHeaderContent = function (content, replacements) {
        if (_bigHeaderText) {
            _bigHeaderText.setText(content, replacements);
        }
    };
    /**
     * Updates the subheader's content on the screen.
     * @param {String} content
     * @param {Object} [replacements]
     */
    BattleScreen.prototype.setSubheaderContent = function (content, replacements) {
        if (_subheaderText) {
            _subheaderText.setText(content, replacements);
        }
    };
    /**
     * Adds a new HUD message to the queue.
     * @param {Battle~HUDMessage} message The properties of the message to add
     * @param {Boolean} urgent If true, the message will be appended to the front of the queue, otherwise to the
     * back of the queue.
     */
    BattleScreen.prototype.queueHUDMessage = function (message, urgent) {
        var text, start, end, i, length, replacementID, replacementText, modifier, /**@type Spacecraft*/ craft;
        text = message.text;
        // replacing references in the text
        for (start = text.indexOf("{"); start >= 0; start = text.indexOf("{")) {
            end = text.indexOf("}");
            if (end >= 0) {
                replacementID = text.substring(start + 1, end).split("/");
                switch (replacementID[0]) {
                    case "controlStrings":
                        // control strings have a specific color assigned to them, so add the modifier to the string
                        replacementText =
                                "[color:" + _messageTextSettings.colors.controlString.join(",") + "]" +
                                control.getInputInterpreter(replacementID[1]).getControlStringForAction(replacementID[2]) +
                                "[]";
                        break;
                    case "spacecrafts":
                        craft = _mission.getSpacecraft(replacementID[1]);
                        replacementText =
                                "[color:" + (_spacecraft.isHostile(craft) ? _messageTextSettings.colors.hostileSpacecraft : _messageTextSettings.colors.friendlySpacecraft).join(",") + "]" +
                                craft.getDisplayName() +
                                "[]";
                        break;
                    default:
                        application.showError("Unknown reference type specified in HUD message: '" + replacementID[0] + "'!");
                        replacementText = "";
                }
                text = text.substring(0, start) + replacementText + text.substr(end + 1);
            } else {
                application.showError("Unclosed reference in HUD message: '" + message.text + "'!");
            }
        }
        // calculate the real, visible length of the text, excluding modifiers and line breaks
        // because appear animation and text visibility duration needs to take that as a base
        length = 0;
        modifier = false;
        for (i = 0; i < text.length; i++) {
            if (text[i] === "[") {
                modifier = true;
            } else if (text[i] === "]") {
                modifier = false;
            } else if ((modifier === false) && (text[i] !== "\n")) {
                length++;
            }
        }
        message.text = text;
        message.new = true;
        // calculating duration based on message length if needed
        message.timeLeft = message.duration || Math.round(length * HUD_MESSAGE_DURATION_PER_CHAR + HUD_MESSAGE_BASE_DURATION);
        // setting up appear animation
        message.appearDuration = message.appearAnimation ? Math.round(length * HUD_MESSAGE_APPEAR_DURATION_PER_CHAR) : 0;
        message.appearTimeLeft = message.appearDuration || 0;
        message.queue = message.queue || INFO_QUEUE;
        if (urgent) {
            _messageQueues[message.queue].unshift(message);
        } else {
            _messageQueues[message.queue].push(message);
        }
    };
    /**
     * Clears all HUD messages from the given queue.
     * @param {String} [queue=INFO_QUEUE] 
     */
    BattleScreen.prototype.clearHUDMessages = function (queue) {
        _messageQueues[queue || INFO_QUEUE] = [];
    };
    /**
     * Clears all HUD messages from the all queues.
     */
    BattleScreen.prototype.clearHUDMessageQueues = function () {
        var i;
        for (i = 0; i < MESSAGE_QUEUES.length; i++) {
            _messageQueues[MESSAGE_QUEUES[i]] = [];
        }
    };
    /**
     * Updates the contents of the HUDF with information about the currently followed spacecraft
     * @param {Number} dt The time elapsed since the last HUD update (in milliseconds)
     */
    BattleScreen.prototype._updateHUD = function (dt) {
        var
                /** @type Spacecraft */
                craft = _mission ? _mission.getFollowedSpacecraftForScene(_battleScene) : null,
                target, wingman,
                /** @type MissileLauncher */
                missileLauncher,
                /** @type Number */
                distance, aspect, i, j, count, scale, futureDistance, animationProgress, animation2Progress, aimAssistAppearAnimationProgress, targetSwitchAnimationProgress, shipWidth,
                hullIntegrity, shieldIntegrity,
                acceleration, speed, absSpeed, maxSpeed, stepFactor, stepBuffer, speedRatio, speedTarget, driftSpeed, driftArrowMaxSpeed, arrowPositionRadius,
                armor, craftCount, height, statusCount, angle, lockRatio,
                /** @type Weapon[] */
                weapons,
                /** @type Number[2] */
                position2D, direction2D, maxSpeedTextPosition, maxReverseSpeedTextPosition, shipIndicatorSize, shipIndicatorMinSize, size2D,
                /** @type Number[3] */
                position, targetPosition, vectorToTarget, futureTargetPosition, slotPosition, basePointPosition, relativeVelocity, indicatorPosition,
                /** @type Number[4] */
                direction, color, targetInfoTextColor, filledColor, emptyColor, hostileColor, friendlyColor, hostileArrowColor, friendlyArrowColor,
                newHostileColor, newHostileArrowColor,
                /** @type Object.<String, Number[4]> */
                colors,
                /** @type Float32Array */
                m, scaledOriMatrix,
                /** @type HTMLCanvasElement */
                canvas = this.getScreenCanvas(BATTLE_CANVAS_ID).getCanvasElement(),
                /** @type Boolean */
                isInAimingView, behind, targetInRange, targetIsHostile, targetSwitched, scalesWithWidth, playerFound, newHostilesPresent, skip, away, transmissionSource, missileLockIndicatorsUpdated, missileLoaded,
                visible1, visible2, visible3, visible4,
                /** @type MouseInputIntepreter */
                mouseInputInterpreter,
                /** @type String */
                text,
                /** @type String[] */
                objectivesState, statusIndicators,
                /** @type HUDElement */
                indicator,
                /** @type Spacecraft[] */
                ships, highlightedShips,
                /** @type Battle~HUDMessage[] */
                messageQueue;
        missileLockIndicatorsUpdated = false;
        if (craft && _isHUDVisible) {
            _hudHighlightTime = (_hudHighlightTime + dt) % _hudHighlightInterval;
            _hudHighlightVisible = _hudHighlightTime < 0.5 * _hudHighlightInterval;
            isInAimingView = craft.getView(_battleScene.getCamera().getConfiguration().getName()).isAimingView();
            // .....................................................................................................
            // header and score
            _bigHeaderText.show();
            if (control.isInPilotMode()) {
                _subheaderText.hide();
                if (_hudSectionIsVisible(HUDSection.SCORE)) {
                    _scoreText.setText(utils.formatString(strings.get(strings.BATTLE.SCORE), {
                        score: Math.round(craft.getScore())
                    }));
                    _scoreText.show();
                } else {
                    _scoreText.hide();
                }
            } else {
                _subheaderText.setText(craft.getDisplayName() || craft.getClass().getDisplayName());
                _subheaderText.show();
                _scoreText.hide();
            }
            // .....................................................................................................
            // center crosshair
            if (isInAimingView) {
                _centerCrosshair.show();
            } else {
                _centerCrosshair.hide();
            }
            // .....................................................................................................
            // cursor
            mouseInputInterpreter = control.getInputInterpreter(control.MOUSE_NAME);
            if (control.isListening() &&
                    mouseInputInterpreter.isEnabled() &&
                    control.isInPilotMode() &&
                    !control.isControllerPriority(control.CAMERA_CONTROLLER_NAME) &&
                    !control.isMouseTurningDisabled() &&
                    !craft.isManeuveringLocked()) {
                position2D = mouseInputInterpreter.getMousePosition();
                position2D = [
                    (position2D[0] / canvas.width - 0.5) * 2,
                    (0.5 - position2D[1] / canvas.height) * 2
                ];
                if (mouseInputInterpreter.isMouseDisplaced()) {
                    _hudStillCursor.hide();
                    _hudTurnCursor.show();
                    _hudTurnCursor.setPosition(position2D);
                    angle = vec.angle2y(position2D[0] * canvas.width / canvas.height, position2D[1]);
                    _hudTurnCursor.setAngle(angle * ((position2D[0] < 0) ? -1 : 1));
                } else {
                    _hudStillCursor.show();
                    _hudTurnCursor.hide();
                    _hudStillCursor.setPosition(position2D);
                }
            } else {
                _hudStillCursor.hide();
                _hudTurnCursor.hide();
            }
            // .....................................................................................................
            // speed bar
            relativeVelocity = craft.getRelativeVelocityMatrix();
            if (_hudSectionIsVisible(HUDSection.SPEED_BAR)) {
                speed = relativeVelocity[13];
                absSpeed = Math.abs(speed);
                acceleration = craft.getMaxAcceleration();
                maxSpeed = craft.getMaxSpeed();
                if (!maxSpeed) {
                    maxSpeed = (config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR_BASE_MAX_SPEED_FACTOR) * acceleration) ||
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR_DEFAULT_BASE_MAX_SPEED);
                    stepFactor = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR_MAX_SPEED_STEP_FACTOR);
                    stepBuffer = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR_MAX_SPEED_STEP_BUFFER);
                    while ((maxSpeed + stepBuffer) < absSpeed) {
                        maxSpeed *= stepFactor;
                    }
                }
                if (craft.hasSpeedTarget()) {
                    speedTarget = craft.getSpeedTarget();
                    if (speed * speedTarget >= 0) {
                        speedTarget = Math.abs(speedTarget);
                    } else {
                        speedTarget = 0;
                    }
                }
                speedRatio = Math.min(absSpeed / maxSpeed, 1.0);
                maxSpeedTextPosition = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).positions.maxForward;
                maxReverseSpeedTextPosition = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).positions.maxReverse;
                colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR).colors;
                text = craft.getFlightMode();
                if (speed >= 0) {
                    _speedBar.setColor(colors[text + "Filled"]);
                    _speedBar.setClipColor(colors[text + "Empty"]);
                    _speedBar.clipY(0, speedRatio);
                    _maxSpeedText.setPosition(maxSpeedTextPosition);
                    _maxSpeedText.setColor(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).colors[text + "Forward"]);
                    _maxSpeedText.setText(Math.max(maxSpeed, speed).toFixed());
                    _currentSpeedText.setPosition([maxSpeedTextPosition[0], maxReverseSpeedTextPosition[1] + (maxSpeedTextPosition[1] - maxReverseSpeedTextPosition[1]) * speedRatio]);
                    _currentSpeedText.setColor(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).colors[text + "Forward"]);
                    _currentSpeedText.setText(absSpeed.toFixed());
                    _speedTargetIndicator.clipX(0.5 - _speedTargetIndicatorSize[0] / 2, 0.5 + _speedTargetIndicatorSize[0] / 2);
                    if (craft.hasSpeedTarget()) {
                        _speedTargetIndicator.clipY(speedTarget / maxSpeed - _speedTargetIndicatorSize[1] / 2, speedTarget / maxSpeed + _speedTargetIndicatorSize[1] / 2);
                        _speedTargetIndicator.show();
                    } else {
                        _speedTargetIndicator.hide();
                    }
                } else {
                    _speedBar.setColor(colors[text + "ReverseFilled"]);
                    _speedBar.setClipColor(colors[text + "ReverseEmpty"]);
                    _speedBar.clipY(1 - speedRatio, 1);
                    _maxSpeedText.setPosition(maxReverseSpeedTextPosition);
                    _maxSpeedText.setColor(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).colors[text + "Reverse"]);
                    _maxSpeedText.setText(Math.min(-maxSpeed, speed).toFixed());
                    _currentSpeedText.setPosition([maxSpeedTextPosition[0], maxSpeedTextPosition[1] - (maxSpeedTextPosition[1] - maxReverseSpeedTextPosition[1]) * speedRatio]);
                    _currentSpeedText.setColor(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TEXT).colors[text + "Reverse"]);
                    _currentSpeedText.setText("-" + absSpeed.toFixed());
                    _speedTargetIndicator.clipX(0.5 - _speedTargetIndicatorSize[0] / 2, 0.5 + _speedTargetIndicatorSize[0] / 2);
                    if (craft.hasSpeedTarget()) {
                        _speedTargetIndicator.clipY(1 - (speedTarget / maxSpeed + _speedTargetIndicatorSize[1] / 2), 1 - (speedTarget / maxSpeed - _speedTargetIndicatorSize[1] / 2));
                        _speedTargetIndicator.show();
                    } else {
                        _speedTargetIndicator.hide();
                    }
                }
                _speedBar.applyLayout(_speedBarLayout, canvas.width, canvas.height);
                _speedBar.show();
                _speedTargetIndicator.applyLayout(_speedBarLayout, canvas.width, canvas.height);
                _speedTextLayer.show();
            } else {
                _speedBar.hide();
                _speedTargetIndicator.hide();
                _speedTextLayer.hide();
            }
            // .....................................................................................................
            // drift arrow
            if (isInAimingView && _hudSectionIsVisible(HUDSection.DRIFT_ARROW)) {
                direction2D = [relativeVelocity[12], relativeVelocity[14]];
                driftSpeed = vec.extractLength2(direction2D);
                if (driftSpeed > _driftArrowMinSpeed) {
                    _driftArrow.show();
                    aspect = _battleScene.getCamera().getAspect();
                    arrowPositionRadius = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW_POSITION_RADIUS) * (utils.yScalesWithHeight(_centerCrosshairScaleMode, canvas.width, canvas.height) ? 1 : aspect);
                    _driftArrow.setPosition(vec.scaled2([direction2D[0] / aspect, direction2D[1]], arrowPositionRadius));
                    _driftArrow.setAngle(Math.acos(direction2D[1]) * ((direction2D[0] < 0) ? -1 : 1));
                    driftArrowMaxSpeed = _driftArrowMaxSpeedFactor * acceleration;
                    if (driftArrowMaxSpeed === 0) {
                        driftArrowMaxSpeed = maxSpeed;
                    }
                    _driftArrow.setColor(utils.getMixedColor(
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW).colors.minSpeed,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW).colors.maxSpeed,
                            Math.min((driftSpeed - _driftArrowMinSpeed) / (driftArrowMaxSpeed - _driftArrowMinSpeed), 1.0)));
                } else {
                    _driftArrow.hide();
                }
            } else {
                _driftArrow.hide();
            }
            // .....................................................................................................
            // hull and shield integrity bar
            hullIntegrity = craft.getHullIntegrity();
            shieldIntegrity = craft.getShieldIntegrity();
            // color change animation when the integrity decreases
            if (craft !== _spacecraft) {
                _spacecraft = craft;
                _squads = craft.getTeam() ? craft.getTeam().getSquads() : [];
                _wingmenStatusCraftLayouts = []; // drop the previous array so new layouts are generated for potentially new squads
                _missileClasses = craft.getMissileClasses();
                _spacecraftHullIntegrity = hullIntegrity;
                _spacecraftShieldIntegrity = shieldIntegrity;
                animationProgress = 0;
                animation2Progress = 0;
                _hullIntegrityDecreaseTime = 0;
                _shieldDecreaseTime = 0;
            } else {
                if (hullIntegrity < _spacecraftHullIntegrity) {
                    _hullIntegrityDecreaseTime = _hudHullIntegrityDecreaseAnimationDuration;
                    animationProgress = 1;
                } else if (_hullIntegrityDecreaseTime > 0) {
                    _hullIntegrityDecreaseTime -= dt;
                    animationProgress = _hullIntegrityDecreaseTime / _hudHullIntegrityDecreaseAnimationDuration;
                }
                _spacecraftHullIntegrity = hullIntegrity;
                if (shieldIntegrity < _spacecraftShieldIntegrity) {
                    _shieldDecreaseTime = _hudShieldDecreaseAnimationDuration;
                    animation2Progress = 1;
                } else if (_shieldDecreaseTime > 0) {
                    _shieldDecreaseTime -= dt;
                    animation2Progress = _shieldDecreaseTime / _hudShieldDecreaseAnimationDuration;
                }
                _spacecraftShieldIntegrity = shieldIntegrity;
            }
            colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.HULL_INTEGRITY_BAR).colors;
            if (_hudSectionIsVisible(HUDSection.HULL_BAR)) {
                if (_hullIntegrityDecreaseTime > 0) {
                    _hullIntegrityBar.setColor(utils.getMixedColor(colors.filled, colors.filledWhenDecreasing, animationProgress));
                    _hullIntegrityBar.setClipColor(utils.getMixedColor(colors.empty, colors.emptyWhenDecreasing, animationProgress));
                } else {
                    _hullIntegrityBar.setColor(colors.filled);
                    _hullIntegrityBar.setClipColor(colors.empty);
                }
                _hullIntegrityBar.clipY(0, hullIntegrity);
                _hullIntegrityBar.applyLayout(_hullIntegrityBarLayout, canvas.width, canvas.height);
                _hullIntegrityBar.show();
            } else {
                _hullIntegrityBar.hide();
            }
            if (craft.hasShield() && _hudSectionIsVisible(HUDSection.SHIELD_BAR)) {
                colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIELD_BAR).colors;
                if (_shieldDecreaseTime > 0) {
                    _shieldBar.setColor(utils.getMixedColor(colors.filled, colors.filledWhenDecreasing, animation2Progress));
                    _shieldBar.setClipColor(utils.getMixedColor(colors.empty, colors.emptyWhenDecreasing, animation2Progress));
                } else {
                    _shieldBar.setColor(colors.filled);
                    _shieldBar.setClipColor(colors.empty);
                }
                _shieldBar.clipY(0, shieldIntegrity);
                _shieldBar.applyLayout(_shieldBarLayout, canvas.width, canvas.height);
                _shieldBar.show();
            } else {
                _shieldBar.hide();
            }
            // .....................................................................................................
            // flight mode indicator
            if (_hudSectionIsVisible(HUDSection.FLIGHT_MODE)) {
                _flightModeIndicatorBackground.applyLayout(_flightModeIndicatorBackgroundLayout, canvas.width, canvas.height);
                _flightModeIndicatorBackground.show();
                _flightModeText.setText(strings.get(strings.FLIGHT_MODE.PREFIX, craft.getFlightMode(), craft.getFlightMode()));
                colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_TEXT).colors;
                switch (craft.getFlightMode()) {
                    case equipment.FlightMode.FREE:
                        _flightModeText.setColor(colors.free);
                        break;
                    case equipment.FlightMode.COMBAT:
                        _flightModeText.setColor(colors.combat);
                        break;
                    case equipment.FlightMode.CRUISE:
                        _flightModeText.setColor(colors.cruise);
                        break;
                    default:
                        application.showError("Unknown flight mode: " + craft.getFlightMode() + "!");
                }
                _flightModeIndicatorTextLayer.show();
            } else {
                _flightModeIndicatorBackground.hide();
                _flightModeIndicatorTextLayer.hide();
            }
            // .....................................................................................................
            // missile info indicator
            lockRatio = 0;
            if (_missileClasses.length > 0) {
                colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_TEXT).colors;
                missileLauncher = craft.getActiveMissileLauncher();
                craftCount = 0; // used for saving count of equipped missiles
                for (i = 0; i < _missileInfoNameTexts.length; i++) {
                    if (i < _missileClasses.length) {
                        text = _missileClasses[i].getShortName();
                        count = craft.getMissileCount(_missileClasses[i]);
                        _missileInfoCountTexts[i].setText(count.toString());
                        if (count <= 0) {
                            color = colors.empty;
                        } else if (missileLauncher && (missileLauncher.getMissileClass() === _missileClasses[i])) {
                            if (craft.getTarget()) {
                                lockRatio = craft.getMissileLockRatio();
                            }
                            targetInRange = lockRatio >= 1;
                            missileLoaded = missileLauncher.isReady();
                            color = missileLoaded ? (targetInRange ? colors.readySelected : colors.lockingSelected) : colors.loadingSelected;
                            if (missileLauncher.isInSalvoMode()) {
                                text += " (×" + Math.min(missileLauncher.getSalvo(), missileLauncher.getMissileCount()) + ")";
                            }
                            craftCount = count;
                            if (targetInRange) {
                                if (!_missileLocked) {
                                    _missileLockedSound.play();
                                } else if (missileLoaded && !_missileLoaded) {
                                    _missileLoadedSound.play();
                                }
                                _missileLocked = true;
                            } else {
                                speedRatio = lockRatio * _missileLockingSoundCount;
                                if (speedRatio <= 0) {
                                    _missileLockingSoundsPlayed = 0;
                                } else {
                                    speedRatio = Math.floor(speedRatio) + 1;
                                    if (speedRatio > _missileLockingSoundsPlayed) {
                                        _missileLockingSoundsPlayed++;
                                        _missileLockingSound.play();
                                    } else if (speedRatio < _missileLockingSoundsPlayed) {
                                        _missileLockingSoundsPlayed = 0;
                                    }
                                }
                                _missileLocked = false;
                            }
                            _missileLoaded = missileLoaded;
                        } else {
                            color = colors.notSelected;
                        }
                        _missileInfoNameTexts[i].setText(text);
                        _missileInfoNameTexts[i].setColor(color);
                        _missileInfoCountTexts[i].setColor(color);
                        _missileInfoNameTexts[i].show();
                        _missileInfoCountTexts[i].show();
                    } else {
                        _missileInfoNameTexts[i].hide();
                        _missileInfoCountTexts[i].hide();
                    }
                }
                if (_hudSectionIsVisible(HUDSection.MISSILE_INFO)) {
                    _missileInfoBackground.applyLayout(_missileInfoBackgroundLayout, canvas.width, canvas.height);
                    _missileInfoBackground.show();
                    _missileInfoTextLayer.show();
                } else {
                    _missileInfoBackground.hide();
                    _missileInfoTextLayer.hide();
                }
                // .....................................................................................................
                // missile indicator
                if ((craftCount > 0) && _hudSectionIsVisible(HUDSection.MISSILE_INDICATOR)) {
                    _missileIndicator.setTextureCoordinates(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).mappings[missileLauncher.isInSalvoMode() ? "salvo" : "single"]);
                    colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).colors;
                    speedRatio = missileLauncher.getLoadRatio();
                    if (speedRatio < 1) {
                        _missileIndicator.setColor(colors.locking);
                        _missileIndicator.setClipColor(colors.loading);
                        _missileIndicator.clipY(0, speedRatio);
                    } else {
                        _missileIndicator.setColor(colors.ready);
                        _missileIndicator.setClipColor(colors.locking);
                        _missileIndicator.clipY(0, lockRatio);
                    }
                    _missileIndicator.applyLayout(_missileIndicatorLayout, canvas.width, canvas.height);
                    _missileIndicator.show();
                    _missileIndicatorText.setText(craftCount.toString());
                    colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR_TEXT).colors;
                    _missileIndicatorText.setColor((speedRatio >= 1) ? (targetInRange ? colors.ready : colors.locking) : colors.loading);
                    _missileIndicatorTextLayer.show();
                } else {
                    _missileIndicator.hide();
                    _missileIndicatorTextLayer.hide();
                }
            } else {
                _missileInfoBackground.hide();
                _missileInfoTextLayer.hide();
                _missileIndicator.hide();
                _missileIndicatorTextLayer.hide();
            }
            if (!_demoMode && control.isInPilotMode()) {
                // .....................................................................................................
                // objectives
                if (_hudSectionIsVisible(HUDSection.OBJECTIVES)) {
                    _objectivesBackground.applyLayout(_objectivesBackgroundLayout, canvas.width, canvas.height);
                    _objectivesBackground.show();
                    objectivesState = _mission.getObjectivesState();
                    colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_TEXT).colors;
                    for (i = 0; i < _objectivesTexts.length; i++) {
                        if (i < objectivesState.length) {
                            _objectivesTexts[i].setText(objectivesState[i].text);
                            switch (objectivesState[i].state) {
                                case missions.ObjectiveState.IN_PROGRESS:
                                    _objectivesTexts[i].setColor(colors.inProgress);
                                    break;
                                case missions.ObjectiveState.COMPLETED:
                                    _objectivesTexts[i].setColor(colors.completed);
                                    break;
                                case missions.ObjectiveState.FAILED:
                                    _objectivesTexts[i].setColor(colors.failed);
                                    break;
                            }
                            _objectivesTexts[i].show();
                        } else {
                            _objectivesTexts[i].hide();
                        }
                    }
                    _objectivesTextLayer.show();
                } else {
                    _objectivesBackground.hide();
                    _objectivesTextLayer.hide();
                }
                // .....................................................................................................
                // escorts
                ships = _escorts.filter(_escortShouldBeIndicated);
                if ((ships.length > 0) && _hudSectionIsVisible(HUDSection.ESCORTS)) {
                    _escortsBackground.applyLayout(_escortsBackgroundLayout, canvas.width, canvas.height);
                    _escortsBackground.show();
                    for (i = 0; i < _escortsTexts.length; i++) {
                        if (i < ships.length) {
                            _escortsTexts[i].setText(ships[i].getDisplayName() || strings.get(strings.BATTLE.HUD_SPACECRAFT_NAME_UNKNOWN));
                            away = ships[i].isAway();
                            colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_TEXT).colors;
                            _escortsTexts[i].setColor(ships[i].isAlive() ? (away ? colors.away : colors.alive) : colors.destroyed);
                            _escortBars[i].hull.setColor(away ? _escortsIntegrityBarsSettings.colors.awayHull :
                                    _getHullIntegrityColor(ships[i].getHullIntegrity(),
                                            _escortsIntegrityBarsSettings.colors.fullHull,
                                            _escortsIntegrityBarsSettings.colors.halfHull,
                                            _escortsIntegrityBarsSettings.colors.zeroHull));
                            _escortBars[i].hull.clipX(0, ships[i].getHullIntegrity());
                            _escortBars[i].hull.applyLayout(_escortBars[i].hullLayout, canvas.width, canvas.height);
                            _escortsTexts[i].show();
                            _escortBars[i].hull.show();
                            if (ships[i].hasShield() && !away) {
                                _escortBars[i].shield.clipX(0, ships[i].getShieldIntegrity());
                                _escortBars[i].shield.applyLayout(_escortBars[i].shieldLayout, canvas.width, canvas.height);
                                _escortBars[i].shield.show();
                            } else {
                                _escortBars[i].shield.hide();
                            }
                        } else {
                            _escortsTexts[i].hide();
                            _escortBars[i].hull.hide();
                            _escortBars[i].shield.hide();
                        }
                    }
                    _escortsTextLayer.show();
                } else {
                    _escortsBackground.hide();
                    _escortsTextLayer.hide();
                    for (i = 0; i < _escortBars.length; i++) {
                        _escortBars[i].hull.hide();
                        _escortBars[i].shield.hide();
                    }
                }
            } else {
                _objectivesBackground.hide();
                _objectivesTextLayer.hide();
                _escortsBackground.hide();
                _escortsTextLayer.hide();
                for (i = 0; i < _escortBars.length; i++) {
                    _escortBars[i].hull.hide();
                    _escortBars[i].shield.hide();
                }
            }
            // .....................................................................................................
            // HUD messages
            i = 0;
            // finding the highest priority non empty queue
            while ((i < MESSAGE_QUEUES.length) && (_messageQueues[MESSAGE_QUEUES[i]].length === 0)) {
                i++;
            }
            // if such a queue has been found, display the first message in the queue
            if ((control.isInPilotMode()) && (i < MESSAGE_QUEUES.length)) {
                messageQueue = _messageQueues[MESSAGE_QUEUES[i]];
                // playing sound for messages which appear instantly (without animation)
                if (messageQueue[0].new) {
                    if (!messageQueue[0].silent && !messageQueue[0].appearTimeLeft) {
                        _messageSound.play();
                    }
                    messageQueue[0].new = false;
                }
                // setting text
                _messageText.setText(messageQueue[0].text);
                // setting reveal state based on appear animation for "typewriter" effect
                if (messageQueue[0].appearTimeLeft > 0) {
                    _messageText.setRevealState(1 - messageQueue[0].appearTimeLeft / messageQueue[0].appearDuration);
                    messageQueue[0].appearTimeLeft -= dt;
                    // playing appear animation sound
                    if (!messageQueue[0].silent) {
                        _messageTypeSound.setVolume(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_TYPE_SOUND).volume);
                        _messageTypeSound.play();
                    }
                } else {
                    _messageText.setRevealState(1);
                    _messageTypeSound.stopLoop();
                }
                // setting color
                if (messageQueue[0].color) {
                    color = messageQueue[0].color;
                } else {
                    color = _messageTextSettings.colors.default;
                }
                if (messageQueue[0].blinkInterval > 0) {
                    color = color.slice();
                    color[3] = color[3] * Math.abs(((messageQueue[0].duration - messageQueue[0].timeLeft) % messageQueue[0].blinkInterval) / messageQueue[0].blinkInterval - 0.5) * 2;
                }
                _messageText.setColor(color);
                // transmission source
                _messageSource = messageQueue[0].source;
                // managing timing
                skip = false;
                if (!messageQueue[0].permanent) {
                    if ((messageQueue[0] === _newHostilesMessage)) {
                        messageQueue[0].timeLeft = _newHostilesAlertTimeLeft;
                        if (_newHostilesAlertTimeLeft <= 0) {
                            skip = true;
                        }
                    } else {
                        messageQueue[0].timeLeft -= dt;
                    }
                    if (messageQueue[0].timeLeft <= 0) {
                        messageQueue.shift();
                        if (messageQueue.length > 0) {
                            messageQueue[0].new = true;
                        }
                    }
                }
                if (!skip) {
                    _messageBackground.applyLayout(_messageBackgroundLayout, canvas.width, canvas.height);
                    _messageBackground.show();
                    _messageTextLayer.show();
                } else {
                    _messageTextLayer.hide();
                    _messageBackground.hide();
                }
            } else {
                _messageTextLayer.hide();
                _messageBackground.hide();
                _messageTypeSound.stopPlaying(HUD_MESSAGE_APPEAR_SOUND_STOP_RAMP_DURATION);
                _messageSource = null;
            }
            if (_newHostilesAlertTimeLeft > 0) {
                _newHostilesAlertTimeLeft -= dt;
            }
            // .....................................................................................................
            // target related information
            target = craft.getTarget();
            if (_target !== target) {
                _target = target;
                targetSwitched = true;
                _targetSwitchTime = _hudTargetSwitchAnimationDuration;
                targetSwitchAnimationProgress = 1;
            } else if (_targetSwitchTime > 0) {
                _targetSwitchTime -= dt;
                targetSwitchAnimationProgress = _targetSwitchTime / _hudTargetSwitchAnimationDuration;
            } else {
                targetSwitchAnimationProgress = 0;
            }
            if (_aimAssistAppearTime > 0) {
                aimAssistAppearAnimationProgress = _aimAssistAppearTime / _hudAimAssistAppearAnimationDuration;
            } else {
                aimAssistAppearAnimationProgress = 0;
            }
            visible1 = false;
            visible2 = false;
            visible3 = false;
            visible4 = false;
            if (target) {
                targetPosition = target.getPhysicalPositionVector();
                position = craft.getPhysicalPositionVector();
                vectorToTarget = vec.diff3(targetPosition, position);
                distance = vec.length3(vectorToTarget);
                weapons = craft.getWeapons();
                targetIsHostile = target.isHostile(craft);
                if (weapons.length > 0) {
                    futureTargetPosition = craft.getTargetHitPosition();
                    // aim assist indicator at the expected future position of the target (if turned on)
                    if (!_aimAssistCrosshairs && _hudSectionIsVisible(HUDSection.AIM_ASSIST_INDICATOR)) {
                        _aimAssistIndicator.setPosition(futureTargetPosition);
                        color = targetIsHostile ?
                                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR).colors.hostile :
                                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR).colors.friendly;
                        // scaling / coloring according to the appear / target switch animation
                        if ((_targetSwitchTime > 0) || (_aimAssistAppearTime > 0)) {
                            animationProgress = Math.max(targetSwitchAnimationProgress, aimAssistAppearAnimationProgress);
                            _aimAssistIndicator.setColor(utils.getMixedColor(
                                    color,
                                    config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR).colors.appear,
                                    animationProgress));
                            _aimAssistIndicator.setSize(vec.scaled2(
                                    _aimAssistIndicatorSize,
                                    1 + (_aimAssistIndicatorAppearScale - 1) * animationProgress));
                        } else {
                            _aimAssistIndicator.setColor(color);
                            _aimAssistIndicator.setSize(_aimAssistIndicatorSize);
                        }
                        _aimAssistIndicator.show();
                        visible1 = true;
                    }
                    // weapon crosshairs in the lines of fire
                    futureDistance = vec.length3(vec.diff3(futureTargetPosition, position));
                    m = craft.getPhysicalModel().getOrientationMatrix();
                    scale = craft.getVisualModel().getScalingMatrix()[0];
                    scaledOriMatrix = craft.getScaledOriMatrix();
                    targetInRange = false;
                    for (i = 0; i < weapons.length; i++) {
                        if (_weaponImpactIndicators.length <= i) {
                            _weaponImpactIndicators.push(_createWeaponImpactIndicator());
                            _weaponImpactIndicators[i].addToScene(_battleScene);
                        }
                        if (weapons[i].isFixed()) {
                            slotPosition = weapons[i].getOrigoPositionMatrix();
                            indicatorPosition = vec.sumArray3([
                                position,
                                vec.scaled3(mat.getRowB43(m), futureDistance),
                                vec.scaled3(mat.getRowA43(m), slotPosition[12] * scale),
                                vec.scaled3(mat.getRowC43(m), slotPosition[14] * scale)]);
                        } else {
                            basePointPosition = weapons[i].getBasePointPosVector(scaledOriMatrix);
                            indicatorPosition = vec.sum3(
                                    basePointPosition,
                                    vec.scaled3(mat.getRowB43(weapons[i].getProjectileOrientationMatrix()), vec.length3(
                                            vec.diff3(futureTargetPosition, basePointPosition))));
                        }
                        if (_aimAssistCrosshairs) {
                            vec.sub3(indicatorPosition, vec.diff3Aux(futureTargetPosition, targetPosition));
                        }
                        _weaponImpactIndicators[i].setPosition(indicatorPosition);
                        if (futureDistance <= weapons[i].getRange(speed)) {
                            _weaponImpactIndicators[i].setColor(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WEAPON_IMPACT_INDICATOR).colors.normal);
                            targetInRange = true;
                        } else {
                            _weaponImpactIndicators[i].setColor(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WEAPON_IMPACT_INDICATOR).colors.outOfRange);
                        }
                        // scaling according to the target switch animation
                        if (_targetSwitchTime > 0) {
                            _weaponImpactIndicators[i].setSize(vec.scaled2(_weaponImpactIndicatorSize, 1 + (_weaponImpactIndicatorSwitchScale - 1) * targetSwitchAnimationProgress));
                        } else {
                            _weaponImpactIndicators[i].setSize(_weaponImpactIndicatorSize);
                        }
                        _weaponImpactIndicators[i].show();
                    }
                    if (_hudSectionIsVisible(HUDSection.WEAPON_IMPACT_INDICATORS)) {
                        while (i < _weaponImpactIndicators.length) {
                            _weaponImpactIndicators[i].hide();
                            i++;
                        }
                        visible2 = true;
                    }
                    if (!targetInRange || (craft.isFighter() && (vec.dot3(mat.getRowB43(m), vectorToTarget) < 0))) {
                        visible1 = false;
                        _aimAssistAppearTime = _hudAimAssistAppearAnimationDuration;
                    } else {
                        _aimAssistAppearTime -= dt;
                    }
                }
                // target info panel
                hullIntegrity = target.getHullIntegrity();
                shieldIntegrity = target.getShieldIntegrity();
                if (_hudSectionIsVisible(HUDSection.TARGET_INFO)) {
                    _targetInfoBackground.applyLayout(_targetInfoBackgroundLayout, canvas.width, canvas.height);
                    _targetInfoBackground.show();
                    // target view
                    _targetViewItemColor = _getHullIntegrityColor(hullIntegrity,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_VIEW_TARGET_ITEM_FULL_INTEGRITY_COLOR),
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_VIEW_TARGET_ITEM_HALF_INTEGRITY_COLOR),
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_VIEW_TARGET_ITEM_ZERO_INTEGRITY_COLOR));
                    if (_targetViewItem !== target) {
                        _targetScene.clearNodes(true);
                        _targetViewModel = null;
                        _targetViewItem = target;
                        _targetViewItem.addToScene(_targetScene, graphics.getMaxLoadedLOD(), true, TARGET_VIEW_SUPPLEMENTS, _targetViewParams, _targetViewAddCallback);
                    }
                    // setting orientation of the target view model
                    if (_targetViewModel) {
                        _targetViewModel.setOrientationM4(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.RELATIVE_TARGET_ORIENTATION) ? mat.prod4Aux(
                                target.getPhysicalOrientationMatrix(),
                                mat.inverseOfRotation4Aux(mat.lookTowards4Aux(
                                        vec.normalize3(vec.diffTranslation3Aux(craft.getPhysicalPositionMatrix(), target.getPhysicalPositionMatrix())),
                                        mat.getRowC43(craft.getPhysicalOrientationMatrix())))) :
                                mat.IDENTITY4);
                    }
                    _targetScene.setRelativeViewport(
                            _targetViewLayout.getPositiveLeft(canvas.width, canvas.height),
                            _targetViewLayout.getPositiveBottom(canvas.width, canvas.height),
                            _targetViewLayout.getPositiveWidth(canvas.width, canvas.height),
                            _targetViewLayout.getPositiveHeight(canvas.width, canvas.height));
                    // target hull and shield integrity bars
                    _targetHullIntegrityBar.clipX(0, hullIntegrity);
                    _targetHullIntegrityBar.applyLayout(_targetHullIntegrityBarLayout, canvas.width, canvas.height);
                    _targetHullIntegrityBar.show();
                    if (target.hasShield()) {
                        _targetShieldBar.clipX(0, shieldIntegrity);
                        _targetShieldBar.applyLayout(_targetShieldBarLayout, canvas.width, canvas.height);
                        _targetShieldBar.show();
                    } else {
                        _targetShieldBar.hide();
                    }
                    // target info texts
                    targetInfoTextColor = targetIsHostile ?
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_TEXT).colors.hostile :
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_TEXT).colors.friendly;
                    _targetInfoTexts[TARGET_INFO_NAME].setColor(targetInfoTextColor);
                    _targetInfoTexts[TARGET_INFO_NAME].setText(target.getDisplayName() || strings.get(strings.BATTLE.HUD_SPACECRAFT_NAME_UNKNOWN));
                    _targetInfoTexts[TARGET_INFO_TEAM].setColor(targetInfoTextColor);
                    _targetInfoTexts[TARGET_INFO_TEAM].setText(target.getTeam() ? target.getTeam().getDisplayName() : strings.get(strings.BATTLE.HUD_TEAM_UNKNOWN));
                    _targetInfoTexts[TARGET_INFO_CLASS].setColor(targetInfoTextColor);
                    _targetInfoTexts[TARGET_INFO_CLASS].setText(target.getClass().getDisplayName());
                    _targetInfoTexts[TARGET_INFO_FIREPOWER].setColor(targetInfoTextColor);
                    armor = target.getTarget() && target.getTarget().getClass().getArmor();
                    _targetInfoTexts[TARGET_INFO_FIREPOWER].setText(strings.get(strings.BATTLE.HUD_FIREPOWER) + ": " + (armor ? (target.getFirepower(armor).toFixed(1) + " / ") : "") + target.getFirepower().toFixed(1));
                    _targetInfoTexts[TARGET_INFO_DISTANCE].setColor(targetInfoTextColor);
                    _targetInfoTexts[TARGET_INFO_DISTANCE].setText(strings.get(strings.BATTLE.HUD_DISTANCE) + ": " + utils.getLengthString(distance));
                    _targetInfoTexts[TARGET_INFO_VELOCITY].setColor(targetInfoTextColor);
                    _targetInfoTexts[TARGET_INFO_VELOCITY].setText(strings.get(strings.BATTLE.HUD_VELOCITY) + ": " + vec.length3(mat.translationVector3(target.getVelocityMatrix())).toFixed() + " m/s");
                    _targetInfoTextLayer.show();
                    visible3 = true;
                }
                // .....................................................................................................
                // target integrity quick view bar
                if (isInAimingView) {
                    _targetHullIntegrityQuickViewBar.clipX(0.5 - hullIntegrity / 2, 0.5 + hullIntegrity / 2);
                    _targetHullIntegrityQuickViewBar.applyLayout(_targetHullIntegrityQuickViewBarLayout, canvas.width, canvas.height);
                    if (target.hasShield()) {
                        _targetShieldQuickViewBar.clipX(0.5 - shieldIntegrity / 2, 0.5 + shieldIntegrity / 2);
                        _targetShieldQuickViewBar.applyLayout(_targetShieldQuickViewBarLayout, canvas.width, canvas.height);
                        _targetShieldQuickViewBar.show();
                    } else {
                        _targetShieldQuickViewBar.hide();
                    }
                    // target hull integrity decrease animation (color change of the filled portion)
                    if (targetSwitched) {
                        _targetHullIntegrity = hullIntegrity;
                        _targetShieldIntegrity = shieldIntegrity;
                        _targetHullIntegrityDecreaseTime = 0;
                        _targetShieldDecreaseTime = 0;
                        animationProgress = 0;
                        animation2Progress = 0;
                    } else {
                        if (hullIntegrity < _targetHullIntegrity) {
                            _targetHullIntegrityDecreaseTime = _hudTargetHullIntegrityDecreaseAnimationDuration;
                            animationProgress = 1;
                        } else if (_targetHullIntegrityDecreaseTime > 0) {
                            _targetHullIntegrityDecreaseTime -= dt;
                            animationProgress = _targetHullIntegrityDecreaseTime / _hudTargetHullIntegrityDecreaseAnimationDuration;
                        }
                        _targetHullIntegrity = hullIntegrity;
                        if (shieldIntegrity < _targetShieldIntegrity) {
                            _targetShieldDecreaseTime = _hudTargetShieldDecreaseAnimationDuration;
                            animation2Progress = 1;
                        } else if (_targetShieldDecreaseTime > 0) {
                            _targetShieldDecreaseTime -= dt;
                            animation2Progress = _targetShieldDecreaseTime / _hudTargetShieldDecreaseAnimationDuration;
                        }
                        _targetShieldIntegrity = shieldIntegrity;
                    }
                    colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_QUICK_VIEW_BAR).colors;
                    filledColor = targetIsHostile ? colors.hostileFilled : colors.friendlyFilled;
                    emptyColor = targetIsHostile ? colors.hostileEmpty : colors.friendlyEmpty;
                    if (_targetHullIntegrityDecreaseTime > 0) {
                        _targetHullIntegrityQuickViewBar.setColor(utils.getMixedColor(filledColor, colors.filledWhenDecreasing, animationProgress));
                    } else {
                        _targetHullIntegrityQuickViewBar.setColor(filledColor);
                    }
                    _targetHullIntegrityQuickViewBar.setClipColor(emptyColor);
                    _targetHullIntegrityQuickViewBar.show();
                    if (target.hasShield()) {
                        colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_QUICK_VIEW_BAR).colors;
                        if (_targetShieldDecreaseTime > 0) {
                            _targetShieldQuickViewBar.setColor(utils.getMixedColor(colors.filled, colors.filledWhenDecreasing, animation2Progress));
                        } else {
                            _targetShieldQuickViewBar.setColor(colors.filled);
                        }
                        _targetShieldQuickViewBar.setClipColor(colors.empty);
                        _targetShieldQuickViewBar.show();
                    } else {
                        _targetShieldQuickViewBar.hide();
                    }
                    visible4 = _hudSectionIsVisible(HUDSection.TARGET_INDICATOR);
                }
            }
            if (!visible1) {
                _aimAssistIndicator.hide();
            }
            if (!visible2) {
                for (i = 0; i < _weaponImpactIndicators.length; i++) {
                    _weaponImpactIndicators[i].hide();
                }
            }
            if (!visible3) {
                _targetInfoBackground.hide();
                if (_targetViewItem) {
                    _targetScene.clearNodes(true);
                    _targetViewItem = null;
                    _targetViewModel = null;
                }
                _targetHullIntegrityBar.hide();
                _targetShieldBar.hide();
                _targetInfoTextLayer.hide();
            }
            if (!visible4) {
                _targetHullIntegrityQuickViewBar.hide();
                _targetShieldQuickViewBar.hide();
                _distanceTextLayer.hide();
            }
            // .....................................................................................................
            // wingmen status
            if ((_squads.length > 0) && _hudSectionIsVisible(HUDSection.WINGMEN_INFO)) {
                _wingmenStatusBackground.applyLayout(_wingmenStatusBackgroundLayout, canvas.width, canvas.height);
                _wingmenStatusBackground.show();
                _wingmenStatusTextLayer.show();
                // create / update squad labels and individual spacecraft indicators
                count = 0;
                playerFound = false;
                for (i = 0; i < _squads.length; i++) {
                    // create / update the text label for the squad
                    if (_wingmenStatusSquadTexts.length <= i) {
                        _wingmenStatusSquadTexts.push(_createWingmenStatusSquadText(i));
                        _wingmenStatusTextLayer.addText(_wingmenStatusSquadTexts[i]);
                    }
                    _wingmenStatusSquadTexts[i].setText(strings.get(strings.SQUAD.PREFIX, _squads[i].name, _squads[i].name));
                    _wingmenStatusSquadTexts[i].show();
                    // only check as many spacecrafts as there are positions defined for, as we cannot display more
                    craftCount = Math.min(_squads[i].crafts.length, _wingmenStatusMaxSquadMemberCount);
                    for (j = 0; j < craftCount; j++) {
                        // create / update individual indicators
                        wingman = _squads[i].crafts[j];
                        // generate a new layout if necessary
                        if (_wingmenStatusCraftLayouts.length <= count) {
                            _wingmenStatusCraftLayouts.push(_createWingmanCraftIndicatorLayout(i, craftCount, j));
                            // if the layout changed, it is possible, that the spacecraft type changed too, so update texture coordinates
                            if (_wingmenStatusCraftIndicators.length > count) {
                                _wingmenStatusCraftIndicators[count].body.setTextureCoordinates(
                                        _wingmenStatusCraftIndicatorSettings.mappings[wingman.getTypeName()] ||
                                        _wingmenStatusCraftIndicatorSettings.mappings.general);
                            }
                        }
                        // create a new HUD element if necessary
                        if (_wingmenStatusCraftIndicators.length <= count) {
                            _wingmenStatusCraftIndicators.push({
                                body: _createWingmanCraftIndicator(_wingmenStatusCraftLayouts[count], wingman.getTypeName()),
                                shield: _createWingmanCraftIndicator(_wingmenStatusCraftLayouts[count], "shield")
                            });
                            _wingmenStatusCraftIndicators[count].body.addToScene(_battleScene);
                            _wingmenStatusCraftIndicators[count].shield.addToScene(_battleScene);
                        }
                        // apply the created / stored layout
                        _wingmenStatusCraftIndicators[count].body.applyLayout(_wingmenStatusCraftLayouts[count], canvas.width, canvas.height);
                        _wingmenStatusCraftIndicators[count].shield.applyLayout(_wingmenStatusCraftLayouts[count], canvas.width, canvas.height);
                        // color based on hull integrity
                        _wingmenStatusCraftIndicators[count].body.setColor(wingman.isAlive() ?
                                (wingman.isAway() ?
                                        _wingmenStatusCraftIndicatorSettings.colors.away :
                                        _getHullIntegrityColor(wingman.getHullIntegrity(),
                                                _wingmenStatusCraftIndicatorSettings.colors.fullIntegrity,
                                                _wingmenStatusCraftIndicatorSettings.colors.halfIntegrity,
                                                _wingmenStatusCraftIndicatorSettings.colors.zeroIntegrity)) :
                                _wingmenStatusCraftIndicatorSettings.colors.destroyed);
                        _wingmenStatusCraftIndicators[count].body.show();
                        if (wingman.isAlive() && !wingman.isAway() && wingman.hasShield()) {
                            _wingmenStatusCraftIndicators[count].shield.setColor(
                                    _getHullIntegrityColor(wingman.getShieldIntegrity(),
                                            _wingmenStatusCraftIndicatorSettings.colors.fullShieldIntegrity,
                                            _wingmenStatusCraftIndicatorSettings.colors.halfShieldIntegrity,
                                            _wingmenStatusCraftIndicatorSettings.colors.zeroShieldIntegrity));
                            _wingmenStatusCraftIndicators[count].shield.show();
                        } else {
                            _wingmenStatusCraftIndicators[count].shield.hide();
                        }
                        // add player indicator for the followed spacecraft
                        if (wingman === craft) {
                            if (!_wingmenStatusPlayerIndicator) {
                                _wingmenStatusPlayerIndicator = _createWingmanCraftIndicator(_wingmenStatusCraftLayouts[count], "player");
                                _wingmenStatusPlayerIndicator.addToScene(_battleScene);
                            }
                            _wingmenStatusPlayerIndicator.applyLayout(_wingmenStatusCraftLayouts[count], canvas.width, canvas.height);
                            _wingmenStatusPlayerIndicator.setColor(_wingmenStatusCraftIndicators[count].body.getColor());
                            _wingmenStatusPlayerIndicator.show();
                            playerFound = true;
                        }
                        count++;
                    }
                }
                // hide any elements that were created before but are not needed currently
                while (i < _wingmenStatusSquadTexts.length) {
                    _wingmenStatusSquadTexts[i].hide();
                    i++;
                }
                for (i = count; i < _wingmenStatusCraftIndicators.length; i++) {
                    _wingmenStatusCraftIndicators[i].body.hide();
                    _wingmenStatusCraftIndicators[i].shield.hide();
                }
                if (!playerFound && _wingmenStatusPlayerIndicator) {
                    _wingmenStatusPlayerIndicator.hide();
                }
            } else {
                // if there are no squads in the team of the followed spacecraft, just hide the whole panel
                _wingmenStatusBackground.hide();
                _wingmenStatusTextLayer.hide();
                for (i = 0; i < _wingmenStatusCraftIndicators.length; i++) {
                    _wingmenStatusCraftIndicators[i].body.hide();
                    _wingmenStatusCraftIndicators[i].shield.hide();
                }
                if (_wingmenStatusPlayerIndicator) {
                    _wingmenStatusPlayerIndicator.hide();
                }
            }
            // .....................................................................................................
            // ship indicators and arrows
            ships = _mission.getSpacecrafts().filter(_spacecraftShouldBeIndicated);
            highlightedShips = craft.getTargetingSpacecrafts().filter(_spacecraftShouldBeIndicated);
            aspect = _battleScene.getCamera().getAspect();
            // caching (animated) colors for indicators and arrows
            animationProgress = Math.abs((2 * _shipIndicatorHighlightTime / _shipIndicatorHighlightAnimationInterval) - 1);
            colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).colors;
            hostileColor = utils.getMixedColor(colors.hostile, colors.hostileHighlight, animationProgress);
            friendlyColor = utils.getMixedColor(colors.friendly, colors.friendlyHighlight, animationProgress);
            colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).colors;
            hostileArrowColor = utils.getMixedColor(colors.hostile, colors.hostileHighlight, animationProgress);
            friendlyArrowColor = utils.getMixedColor(colors.friendly, colors.friendlyHighlight, animationProgress);
            if (control.isInPilotMode() && _newHostilesMessage && (_newHostilesAlertTimeLeft > 0)) {
                newHostilesPresent = true;
                animationProgress = Math.abs(((_newHostilesMessage.duration - _newHostilesAlertTimeLeft) % _newHostilesMessage.blinkInterval) / _newHostilesMessage.blinkInterval - 0.5) * 2;
                newHostileColor = utils.getMixedColor(
                        config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).colors.hostile,
                        config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).colors.newHostile,
                        animationProgress);
                newHostileArrowColor = utils.getMixedColor(
                        config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).colors.hostile,
                        config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).colors.newHostile,
                        animationProgress);
            } else {
                newHostilesPresent = false;
            }
            statusCount = 0; // counter for the status indicators that we are using
            for (i = 0; i < ships.length; i++) {
                visible1 = ((ships[i] === target) && _hudSectionIsVisible(HUDSection.TARGET_INDICATOR)) ||
                        ((ships[i] !== target) && _hudSectionIsVisible(HUDSection.SHIP_INDICATORS));
                transmissionSource = (ships[i] === _messageSource);
                // targeting reticle at the ship position
                if (_shipIndicators.length <= i) {
                    _shipIndicators.push(_createShipIndicator());
                    _shipIndicators[i].addToScene(_battleScene);
                }
                targetPosition = ships[i].getPhysicalPositionVector();
                indicator = _shipIndicators[i];
                indicator.setPosition(targetPosition);
                targetIsHostile = ships[i].isHostile(craft);
                shipWidth = ships[i].getVisualModel().updateVisibleSize({camera: _battleScene.getCamera()}, true).width * _shipIndicatorSizeFactor;
                shipIndicatorMinSize = (ships[i] === target) ? _shipIndicatorSizes.targetMinimum : _shipIndicatorSizes.minimum;
                shipIndicatorSize = [
                    Math.min(Math.max(shipIndicatorMinSize[0], shipWidth), _shipIndicatorSizes.maximum[0]),
                    Math.min(Math.max(shipIndicatorMinSize[1], shipWidth), _shipIndicatorSizes.maximum[1])
                ];
                colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).colors;
                if (transmissionSource) {
                    indicator.setColor(colors.transmission);
                }
                // current target
                if (ships[i] === target) {
                    if (!transmissionSource) {
                        indicator.setColor(
                                (targetIsHostile ?
                                        ((newHostilesPresent && (_newHostiles.indexOf(ships[i]) >= 0)) ?
                                                utils.getMixedColor(colors.hostileTarget, colors.newHostile, animationProgress) :
                                                colors.hostileTarget) :
                                        colors.friendlyTarget));
                    }
                    // scaling according to the target switch animation
                    if (_targetSwitchTime > 0) {
                        indicator.setSize(vec.scaled2(shipIndicatorSize, 1 + (_targetIndicatorSwitchScale - 1) * targetSwitchAnimationProgress));
                    } else {
                        indicator.setSize(shipIndicatorSize);
                    }
                } else {
                    // ships other than the target
                    if (!transmissionSource) {
                        indicator.setColor((newHostilesPresent && (_newHostiles.indexOf(ships[i]) >= 0)) ?
                                newHostileColor :
                                ((highlightedShips.indexOf(ships[i]) >= 0) ?
                                        (targetIsHostile ? hostileColor : friendlyColor) :
                                        (targetIsHostile ? colors.hostile : colors.friendly)));
                    }
                    indicator.setSize(shipIndicatorSize);
                }
                if (visible1) {
                    indicator.show();
                } else {
                    indicator.hide();
                }
                // ship indicating arrow, if ship target is not visible on the screen
                if (_shipArrows.length <= i) {
                    _shipArrows.push(_createShipArrow());
                    _shipArrows[i].addToScene(_battleScene);
                }
                direction = mat.getRowD4(mat.prod34Aux(ships[i].getPhysicalPositionMatrix(), _battleScene.getCamera().getViewMatrix(), _battleScene.getCamera().getProjectionMatrix()));
                behind = direction[3] < 0;
                vec.normalize4D(direction);
                indicator = _shipArrows[i];
                if (behind || (direction[0] < -1) || (direction[0] > 1) || (direction[1] < -1) || (direction[1] > 1)) {
                    if (visible1) {
                        indicator.show();
                    } else {
                        indicator.hide();
                    }
                    direction[0] *= aspect;
                    vec.normalize2(direction);
                    if (behind) {
                        vec.negate2(direction);
                    }
                    arrowPositionRadius = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW_POSITION_RADIUS) * (utils.yScalesWithHeight(_centerCrosshairScaleMode, canvas.width, canvas.height) ? (1 / aspect) : 1);
                    indicator.setPosition(vec.scaled2([direction[0], direction[1] * aspect], arrowPositionRadius));
                    indicator.setAngle(Math.acos(direction[1]) * ((direction[0] < 0) ? -1 : 1));
                    colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).colors;
                    if (transmissionSource) {
                        indicator.setColor(colors.transmission);
                    }
                    // current target
                    if (ships[i] === target) {
                        if (!transmissionSource) {
                            indicator.setColor(
                                    (targetIsHostile ?
                                            ((newHostilesPresent && (_newHostiles.indexOf(ships[i]) >= 0)) ?
                                                    utils.getMixedColor(colors.hostileTarget, colors.newHostile, animationProgress) :
                                                    colors.hostileTarget) :
                                            colors.friendlyTarget));
                        }
                        // scaling according to the target switch animation
                        if (_targetSwitchTime > 0) {
                            indicator.setSize(vec.scaled2(_shipArrowSizes.target, 1 + (_targetArrowSwitchScale - 1) * targetSwitchAnimationProgress));
                        } else {
                            indicator.setSize(_shipArrowSizes.target);
                        }
                        _distanceTextLayer.hide();
                    } else {
                        // ships other than the target
                        if (!transmissionSource) {
                            indicator.setColor((newHostilesPresent && (_newHostiles.indexOf(ships[i]) >= 0)) ?
                                    newHostileArrowColor :
                                    ((highlightedShips.indexOf(ships[i]) >= 0) ?
                                            (targetIsHostile ? hostileArrowColor : friendlyArrowColor) :
                                            (targetIsHostile ? colors.hostile : colors.friendly)));
                        }
                        indicator.setSize(_shipArrowSizes.default);
                    }
                } else {
                    indicator.hide();
                    // if no arrow is displayed for the target, display the distance text next to its reticle
                    if ((ships[i] === target) && visible1) {
                        _distanceText.setText(_getDistanceString(distance));
                        _distanceText.setColor(targetIsHostile ?
                                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DISTANCE_TEXT).colors.hostile :
                                config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DISTANCE_TEXT).colors.friendly);
                        // calculate and set the current position for the text box and the text itself
                        height = 0.5 * shipIndicatorSize[1] * (utils.scalesWithWidth(_shipIndicators[i].getScaleMode(), aspect, 1) ? aspect : 1);
                        position2D = [direction[0], direction[1] - height];
                        scalesWithWidth = utils.scalesWithWidth(_distanceText.getBoxLayout().getScaleMode(), aspect, 1);
                        size2D = [_distanceTextBoxLayoutDescriptor.width / (scalesWithWidth ? 1 : aspect), _distanceTextBoxLayoutDescriptor.height * (scalesWithWidth ? aspect : 1)];
                        _distanceText.getBoxLayout().setPosition(
                                position2D[0] + size2D[0] * 0.5,
                                position2D[1] - size2D[1] * 0.5);
                        _distanceText.invalidateLayout();
                        _distanceText.setPosition([
                            position2D[0] + size2D[0] * 0.05,
                            position2D[1] - size2D[1] * 0.95
                        ]);
                        _distanceTextLayer.show();
                        // calculate and set the current position for target hull integrity quick view bar
                        if (!config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ALWAYS_SHOW_TARGET_HULL_BAR_AT_CENTER)) {
                            position2D[1] = direction[1] + height;
                            _targetHullIntegrityQuickViewBar.setPosition([
                                (0.5 + 0.5 * position2D[0]) * canvas.width,
                                (0.5 - 0.5 * (position2D[1] + _targetHullIntegrityQuickViewBarLayout.getClipSpaceHeight() * 1.5)) * canvas.height
                            ]);
                            _targetShieldQuickViewBar.setPosition([
                                (0.5 + 0.5 * position2D[0]) * canvas.width,
                                (0.5 - 0.5 * (position2D[1] + _targetHullIntegrityQuickViewBarLayout.getClipSpaceHeight() * 1.75 + _targetShieldQuickViewBarLayout.getClipSpaceHeight())) * canvas.height
                            ]);
                        }
                        // display missile lock indicators
                        if (lockRatio > 0) {
                            arrowPositionRadius = 0.5 * shipIndicatorSize[1] * config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR_RADIUS) * (utils.yScalesWithHeight(_shipIndicators[i].getScaleMode(), canvas.width, canvas.height) ? (1 / aspect) : 1);
                            if (lockRatio < 1) {
                                // indicators rotate and stay visible while locking
                                _missileLockIndicatorAngle += dt * config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR_ROTATION_SPEED);
                                _missileLockIndicatorBlinkTime = 0;
                            } else {
                                // indicators stay in place and blink while locked
                                _missileLockIndicatorAngle = Math.radians(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR_ANGLE));
                                _missileLockIndicatorBlinkTime = (_missileLockIndicatorBlinkTime + dt / config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR_BLINK_INTERVAL)) % 1;
                            }
                            angle = _missileLockIndicatorAngle;
                            colors = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR).colors;
                            color = (targetIsHostile ? colors.hostileTarget : colors.friendlyTarget);
                            size2D = vec.scaled2(shipIndicatorSize, config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR_SIZE));
                            for (j = 0; j < _missileLockIndicators.length; j++) {
                                indicator = _missileLockIndicators[j];
                                if ((lockRatio < 1) || ((_missileLockIndicatorBlinkTime > 0.25) && (_missileLockIndicatorBlinkTime < 0.75))) {
                                    indicator.setPosition([direction[0] + Math.cos(angle) * arrowPositionRadius, direction[1] + Math.sin(angle) * aspect * arrowPositionRadius]);
                                    indicator.setSize(size2D);
                                    indicator.setAngle(-0.5 * Math.PI - angle);
                                    indicator.setColor(color);
                                    indicator.show();
                                    angle += 2 * Math.PI / config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR_COUNT);
                                } else {
                                    indicator.hide();
                                }
                            }
                            missileLockIndicatorsUpdated = true;
                        }
                    }
                }
                // .....................................................................................................
                // ship status indicators
                // if all (visible) hostile ships are targets, we do not add "destroy" indicators to any of them (instead of adding to all of them)
                // so we count the target ships with "j":
                j = 0;
                while ((j < ships.length) && (!ships[j].isHostile(craft) || (_targets.indexOf(ships[j]) >= 0))) {
                    j++;
                }
                // collect the IDs of all indicators that are valid in this array
                statusIndicators = [];
                if (transmissionSource) {
                    statusIndicators.push("transmission");
                }
                if (_escorts.indexOf(ships[i]) >= 0) {
                    statusIndicators.push("protect");
                }
                if ((j < ships.length) && (_targets.indexOf(ships[i]) >= 0)) {
                    statusIndicators.push("destroy");
                }
                // setting up the indicator(s)
                if ((statusIndicators.length > 0) && visible1) {
                    if (!_shipArrows[i].isVisible()) {
                        // if the ship is on screen, all status indicators are displayed below its indicator reticle
                        scalesWithWidth = utils.scalesWithWidth(_shipIndicators[i].getScaleMode(), aspect, 1);
                        height = 0.5 * shipIndicatorSize[1] * (scalesWithWidth ? aspect : 1);
                        position2D = [direction[0], direction[1] - height];
                        size2D = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).sizes.reticle;
                        size2D = [size2D[0] * 0.5 / (scalesWithWidth ? 1 : aspect), size2D[1] * 0.5 * (scalesWithWidth ? aspect : 1)];
                        for (j = 0; j < statusIndicators.length; j++) {
                            if (_shipStatusIndicators.length <= statusCount) {
                                _shipStatusIndicators.push(_createShipStatusIndicator(statusIndicators[j]));
                                _shipStatusIndicators[statusCount].addToScene(_battleScene);
                            }
                            indicator = _shipStatusIndicators[statusCount];
                            statusCount++;
                            indicator.setColor(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).colors[statusIndicators[j]] || _shipIndicators[i].getColor());
                            indicator.setScaleMode(_shipIndicators[i].getScaleMode());
                            indicator.setSize(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).sizes.reticle);
                            indicator.setPosition([
                                position2D[0] - size2D[0] * (1.2 + 2.1 * (statusIndicators.length - 1 - j)),
                                position2D[1] - size2D[1] * 1.2
                            ]);
                            indicator.setTextureCoordinates(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).mappings[statusIndicators[j]]);
                            indicator.show();
                        }
                    } else {
                        // if the ship is not on screen, the first status indicator is displayed next to its indicator arrow
                        if (_shipStatusIndicators.length <= statusCount) {
                            _shipStatusIndicators.push(_createShipStatusIndicator(statusIndicators[0]));
                            _shipStatusIndicators[statusCount].addToScene(_battleScene);
                        }
                        indicator = _shipStatusIndicators[statusCount];
                        statusCount++;
                        indicator.setColor(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).colors[statusIndicators[0]] || _shipArrows[i].getColor());
                        indicator.setScaleMode(_shipArrows[i].getScaleMode());
                        indicator.setSize(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).sizes.arrow);
                        indicator.setPosition(vec.scaled2([direction[0], direction[1] * aspect], (config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW_POSITION_RADIUS) + _shipArrows[i].getScale()[0] * 1.5) * (utils.yScalesWithHeight(_centerCrosshairScaleMode, canvas.width, canvas.height) ? (1 / aspect) : 1)));
                        indicator.setTextureCoordinates(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_STATUS_INDICATOR).mappings[statusIndicators[0]]);
                        indicator.show();
                    }
                }
            }
            while (i < _shipIndicators.length) {
                _shipIndicators[i].hide();
                _shipArrows[i].hide();
                i++;
            }
            while (statusCount < _shipStatusIndicators.length) {
                _shipStatusIndicators[statusCount].hide();
                statusCount++;
            }
            _battleScene.showUI();
        } else {
            // if there is no followed spacecraft
            if (_isHUDVisible) {
                _bigHeaderText.show();
            } else {
                _bigHeaderText.hide();
            }
            _subheaderText.hide();
            _scoreText.hide();
            _battleScene.hideUI();
            _targetScene.clearNodes(true);
            _targetViewItem = null;
            _targetViewModel = null;
            _targetInfoTextLayer.hide();
            _speedTextLayer.hide();
            _flightModeIndicatorTextLayer.hide();
            _missileInfoTextLayer.hide();
            _missileIndicatorTextLayer.hide();
            _objectivesTextLayer.hide();
            _escortsTextLayer.hide();
            _messageTextLayer.hide();
            _messageTypeSound.stopPlaying(HUD_MESSAGE_APPEAR_SOUND_STOP_RAMP_DURATION);
            _distanceTextLayer.hide();
            _wingmenStatusTextLayer.hide();
        }
        _shipIndicatorHighlightTime = (_shipIndicatorHighlightTime + dt) % _shipIndicatorHighlightAnimationInterval;
        if (!missileLockIndicatorsUpdated) {
            _missileLockIndicatorAngle = Math.radians(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCK_INDICATOR_ANGLE));
            _missileLockIndicatorBlinkTime = 0;
            for (i = 0; i < _missileLockIndicators.length; i++) {
                _missileLockIndicators[i].hide();
            }
        }
    };
    /**
     * @param {ObjectiveWithState} object Information about a mission objective
     * @returns {Boolean} Whether the objective is completed
     */
    function _mapObjectiveState(object) {
        return object.state === missions.ObjectiveState.COMPLETED;
    }
    /**
     * Sets up and navigates to the debriefing screen according to the current state of the mission.
     */
    function _goToDebriefing() {
        var
                /**@type Boolean*/ victory, isRecord = false,
                /**@type Spacecraft*/ craft,
                /**@type Number*/ hitRatio,
                /**@type Object*/ perfStats,
                /**@type MissionDescriptor */ missionDescriptor;
        craft = _mission.getPilotedSpacecraft();
        victory = _mission.getState() === missions.MissionState.COMPLETED;
        missionDescriptor = missions.getMissionDescriptor(_mission.getName());
        // NONE state mission playthrough count is increased right when the mission starts
        if (_mission.getState() !== missions.MissionState.NONE) {
            missionDescriptor.increasePlaythroughCount(victory);
        }
        hitRatio = craft ? craft.getHitRatio() : 0;
        // calculating score from base score and bonuses
        perfStats = craft ? _mission.getPerformanceStatistics() : {};
        if (victory && !missionDescriptor.isCustom()) {
            // updating the record if needed
            isRecord = missionDescriptor.updateBestScore(perfStats.score, perfStats.performance);
            analytics.sendEvent("score", [utils.getFilenameWithoutExtension(_missionSourceFilename)], {difficulty: _difficulty, score: perfStats.score});
        }
        game.getScreen(armadaScreens.DEBRIEFING_SCREEN_NAME).setData({
            missionState: _mission.getState(),
            objectives: _mission.getObjectives(),
            objectivesCompleted: _mission.getObjectivesState(true).map(_mapObjectiveState),
            performance: victory ? perfStats.performance : missions.FAILED_MISSION_PERFORMACE,
            nextPerformance: victory ? perfStats.nextPerformance : null,
            nextPerformanceScore: victory ? perfStats.nextPerformanceScore : 0,
            score: victory ? perfStats.score : 0,
            isRecord: isRecord,
            elapsedTime: _elapsedTime,
            kills: craft ? craft.getKills() : 0,
            damageDealt: craft ? Math.round(craft.getDamageDealt()) : 0,
            baseScore: perfStats.baseScore || 0,
            hitRatio: hitRatio,
            hitRatioBonus: perfStats.hitRatioBonus,
            missileDamageDealt: craft ? Math.round(craft.getMissileDamageDealt()) : 0,
            missilesLaunched: craft ? Math.round(craft.getMissilesLaunched()) : 0,
            missilesHit: craft ? Math.round(craft.getMissileHitsOnEnemies()) : 0,
            hullIntegrity: craft ? craft.getHullIntegrity() : 0,
            hullIntegrityBonus: perfStats.hullIntegrityBonus,
            teamSurvival: perfStats.teamSurvival,
            teamSurvivalBonus: perfStats.teamSurvivalBonus,
            nextMissionName: victory ? _mission.getNextMissionName() : null
        });
        game.setScreen(armadaScreens.DEBRIEFING_SCREEN_NAME);
    }
    /**
     * @override
     * @param {Number} dt
     */
    BattleScreen.prototype._render = function (dt) {
        var
                /**@type Boolean*/ victory,
                /**@type Spacecraft*/ craft,
                /**@type Number */ time,
                /**@type Object */ analyticsParams,
                /**@type ModelDebugStats*/ mainStats, shadowStats;
        // if we are using the RequestAnimationFrame API for the rendering loop, then the simulation
        // is performed right before each render and not in a separate loop for best performance
        if (_simulationLoop === LOOP_REQUESTANIMFRAME) {
            _simulationLoopFunction();
        }
        if (_battleScene) {
            // manually updating the camera so the HUD update has up-to-date information
            _battleScene.getCamera().update((_simulationLoop !== LOOP_CANCELED) ? dt : 0);
            this._updateHUD(dt);
        }
        screens.HTMLScreenWithCanvases.prototype._render.call(this, dt);
        if (_battleScene) {
            if (application.isDebugVersion()) {
                mainStats = _battleScene.getMainDebugStats();
                shadowStats = _battleScene.getShadowMapDebugStats();
                if (this._stats.isVisible()) {
                    this._stats.setContent(
                            missions.getDebugInfo() + "<br/>" +
                            sceneGraph.getDebugInfo() + "<br/>" +
                            mat.getMatrixCount() + " <br/>" +
                            this.getFPSStats() + "<br/>" +
                            (mainStats ? (mainStats.triangleDrawCalls + ": " + mainStats.triangles + " + i: " + mainStats.instancedTriangleDrawCalls + ": " + mainStats.instancedTriangles) : "") + "<br/>" +
                            (shadowStats ? (shadowStats.triangleDrawCalls + ": " + shadowStats.triangles) : ""));
                }
                mat.clearMatrixCount();
            } else {
                if (this._stats.isVisible()) {
                    this._stats.setTextContent(this.getFPSStats());
                }
            }
        }
        // displaying the victory or defeat message
        if ((_simulationLoop !== LOOP_CANCELED)) {
            if (!_demoMode) {
                craft = _mission.getPilotedSpacecraft();
                if (craft && craft.isAlive() && craft.isAway()) {
                    if (_timeSincePlayerLeft > config.getSetting(config.BATTLE_SETTINGS.QUIT_DELAY_AFTER_JUMP_OUT)) {
                        _goToDebriefing();
                    } else {
                        _timeSincePlayerLeft += dt;
                    }
                    return;
                }
                // we wait a little after the state changes to victory or defeat so that incoming projectiles destroying the player's ship
                // right after it destroyed the last enemy can change the state from victory to defeat
                if (_mission && (_displayedMissionState !== _mission.getState())) {
                    _displayedMissionState = _mission.getState();
                    _timeSinceGameStateChanged = 0;
                } else if (_timeSinceGameStateChanged < config.getSetting(config.BATTLE_SETTINGS.GAME_STATE_DISPLAY_DELAY)) {
                    _timeSinceGameStateChanged += dt;
                    if (_timeSinceGameStateChanged >= config.getSetting(config.BATTLE_SETTINGS.GAME_STATE_DISPLAY_DELAY)) {
                        victory = _mission.getState() === missions.MissionState.COMPLETED;
                        time = Math.round(_elapsedTime / 1000);
                        if (!missions.getMissionDescriptor(_mission.getName()).isCustom()) {
                            analyticsParams = {difficulty: _difficulty, time: time};
                            if (_analyticsState) {
                                if (_analyticsState.win) {
                                    analyticsParams.prevwin = true;
                                } else {
                                    analyticsParams.prevlose = true;
                                }
                                analyticsParams.prevdifficulty = _analyticsState.difficulty;
                                analyticsParams.prevtime = _analyticsState.time;
                            }
                            analytics.sendEvent(victory ? "win" : "lose", [utils.getFilenameWithoutExtension(_missionSourceFilename)], analyticsParams);
                            _analyticsState = {
                                win: victory,
                                difficulty: _difficulty,
                                time: time
                            };
                        }
                        if (craft && craft.isAlive()) {
                            this.queueHUDMessage({
                                text: strings.get(victory ? strings.BATTLE.MESSAGE_VICTORY : strings.BATTLE.MESSAGE_FAIL),
                                queue: MISSION_QUEUE,
                                permanent: true
                            }, true);
                        } else {
                            this.pauseBattle(false, true);
                            armadaScreens.openDialog({
                                header: strings.get(strings.BATTLE.MESSAGE_DEFEAT_HEADER),
                                message: strings.get(strings.BATTLE.MESSAGE_DEFEAT_MESSAGE),
                                buttons: [{
                                        caption: strings.get(strings.BATTLE.MESSAGE_DEFEAT_DEBRIEFING),
                                        action: _goToDebriefing
                                    }, {
                                        caption: strings.get(strings.BATTLE.MESSAGE_DEFEAT_RESTART),
                                        action: function () {
                                            game.closeSuperimposedScreen();
                                            this.startNewBattle({
                                                restart: true
                                            });
                                        }.bind(this)
                                    }, {
                                        caption: strings.get(strings.BATTLE.MESSAGE_DEFEAT_SPECTATE),
                                        action: function () {
                                            game.closeSuperimposedScreen();
                                            this.resumeBattle();
                                        }.bind(this)
                                    }],
                                onClose: function () {
                                    this.resumeBattle();
                                }.bind(this)
                            });
                        }
                        audio.playMusic(
                                (victory ? VICTORY_THEME : DEFEAT_THEME),
                                (victory ? AMBIENT_THEME : null),
                                config.getSetting(config.BATTLE_SETTINGS.END_THEME_CROSSFADE_DURATION));
                    }
                }
            } else {
                if (_mission && (_displayedMissionState !== _mission.getState())) {
                    _displayedMissionState = _mission.getState();
                    if (_displayedMissionState === missions.MissionState.ENDED) {
                        audio.playMusic(AMBIENT_THEME);
                    }
                }
            }
        }
    };
    /**
     * @typedef {Object} BattleScreen~BattleParams
     * @property {String} [missionSourceFilename]
     * @property {String} [difficulty]  The string ID of the difficulty level to use
     * @property {Boolean} [demoMode] If true, AIs are added to all spacecrafts and the piloted spacecraft is not set, when loading the mission.
     * @property {Boolean} [restart]
     */
    /**
     * Loads the specified mission description file and sets a callback to create a new game-logic model and scene for the simulated battle
     * based on the mission description and current settings
     * @param {BattleScreen~BattleParams} [params]
     */
    BattleScreen.prototype.startNewBattle = function (params) {
        var
                loadingStartTime = performance.now(),
                canvas = this.getScreenCanvas(BATTLE_CANVAS_ID).getCanvasElement();
        params = params || {};
        if (params.restart) {
            this.pauseBattle();
        }
        if (params.missionSourceFilename !== undefined) {
            _missionSourceFilename = params.missionSourceFilename;
        }
        if (params.difficulty !== undefined) {
            _difficulty = params.difficulty;
        }
        if (params.demoMode !== undefined) {
            _demoMode = params.demoMode;
        }
        _clearData();
        _chooseTipText();
        document.body.classList.add("wait");
        this._loadingBox.show();
        this.resizeCanvases();
        control.setScreenCenter(
                canvas.width / 2,
                canvas.height / 2);
        this._updateLoadingStatus(strings.get(strings.BATTLE.LOADING_BOX_LOADING_MISSION), 0);
        missions.requestMission(_missionSourceFilename, _difficulty, _demoMode, function (createdMission) {
            var missionDescriptor, custom, anticipationMusicNames, anticipationMusic, anticipationMusicIndex, combatMusicNames, combatMusic, combatMusicIndex, i;
            _mission = createdMission;
            _targets = _mission.getTargetSpacecrafts();
            _escorts = _mission.getEscortedSpacecrafts();
            missionDescriptor = missions.getMissionDescriptor(_mission.getName());
            custom = missionDescriptor.isCustom();
            // for missions that are already won or lost at the very beginning (no enemies / controlled craft), we do not display the
            // victory / defeat message
            if (!_demoMode) {
                if ((!_mission.getPilotedSpacecraft() || (_mission.getState() === missions.MissionState.NONE))) {
                    missionDescriptor.increasePlaythroughCount(true);
                }
                if (!custom) {
                    _analyticsState = null;
                    analytics.sendEvent("start", [utils.getFilenameWithoutExtension(_missionSourceFilename)], {difficulty: _difficulty});
                } else {
                    analytics.sendEvent("customstart");
                }
            }
            _displayedMissionState = _mission.getState();
            _timeSinceGameStateChanged = config.getSetting(config.BATTLE_SETTINGS.GAME_STATE_DISPLAY_DELAY);
            _timeSincePlayerLeft = 0;
            this._updateLoadingStatus(strings.get(strings.BATTLE.LOADING_BOX_BUILDING_SCENE), LOADING_BUILDING_SCENE_PROGRESS);
            if (graphics.shouldUseShadowMapping()) {
                graphics.getShadowMappingShader();
            }
            if (graphics.isAnaglyphRenderingEnabled()) {
                graphics.getAnaglyphRedShader();
                graphics.getAnaglyphCyanShader();
            }
            if (graphics.isSideBySideRenderingEnabled()) {
                graphics.getSideBySideLeftShader();
                graphics.getSideBySideRightShader();
            }
            if (graphics.isShadowMapDebuggingEnabled()) {
                graphics.getShadowMapDebugShader();
            }
            _battleScene = new sceneGraph.Scene(
                    0, 0, 1, 1,
                    true, [true, true, true, true],
                    [0, 0, 0, 1], true,
                    graphics.getLODContext(),
                    graphics.getMaxDirLights(),
                    graphics.getMaxPointLights(),
                    graphics.getMaxSpotLights(),
                    {
                        useVerticalValues: config.getSetting(config.GENERAL_SETTINGS.USE_VERTICAL_CAMERA_VALUES),
                        viewDistance: config.getSetting(config.BATTLE_SETTINGS.VIEW_DISTANCE),
                        fov: INITIAL_CAMERA_FOV,
                        span: INITIAL_CAMERA_SPAN,
                        transitionDuration: config.getSetting(config.BATTLE_SETTINGS.CAMERA_DEFAULT_TRANSITION_DURATION),
                        transitionStyle: config.getSetting(config.BATTLE_SETTINGS.CAMERA_DEFAULT_TRANSITION_STYLE)
                    });
            // we manually update the camera separately before the HUD rendering to make sure it is up-to-date
            _battleScene.setShouldUpdateCamera(false);
            _targetScene = new sceneGraph.Scene(
                    _targetViewLayout.getPositiveLeft(canvas.width, canvas.height),
                    _targetViewLayout.getPositiveBottom(canvas.width, canvas.height),
                    _targetViewLayout.getPositiveWidth(canvas.width, canvas.height),
                    _targetViewLayout.getPositiveHeight(canvas.width, canvas.height),
                    false, [true, true, true, true],
                    [0, 0, 0, 0], true,
                    graphics.getLODContext(),
                    0,
                    0,
                    0,
                    {
                        useVerticalValues: config.getSetting(config.GENERAL_SETTINGS.USE_VERTICAL_CAMERA_VALUES),
                        viewDistance: config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_VIEW_VIEW_DISTANCE),
                        fov: config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_VIEW_FOV),
                        span: config.getSetting(config.CAMERA_SETTINGS.DEFAULT_SPAN),
                        transitionDuration: config.getSetting(config.BATTLE_SETTINGS.CAMERA_DEFAULT_TRANSITION_DURATION),
                        transitionStyle: config.getSetting(config.BATTLE_SETTINGS.CAMERA_DEFAULT_TRANSITION_STYLE)
                    },
                    false);
            _targetScene.getCamera().moveToPosition([0, 0, config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_VIEW_CAMERA_DISTANCE)], 0);
            _mission.addToScene(_battleScene, _targetScene);
            _addHUDToScene();
            _hudSectionStates = new Array(Object.keys(HUDSection).length);
            for (i = 0; i < _hudSectionStates.length; i++) {
                _hudSectionStates[i] = HUDSectionState.VISIBLE;
            }
            _hudHighlightTime = 0;
            _shipIndicatorHighlightTime = 0;
            this._addUITexts();
            _messageQueues = _messageQueues || {};
            this.clearHUDMessageQueues();
            // initializing music
            audio.initMusic(config.getSetting(config.BATTLE_SETTINGS.AMBIENT_MUSIC), AMBIENT_THEME, true);
            // choose the anticipation music track
            anticipationMusicNames = config.getSetting(config.BATTLE_SETTINGS.ANTICIPATION_MUSIC);
            // check if there is a specific track given for the mission
            anticipationMusic = _mission.getAnticipationTheme();
            if (anticipationMusic) {
                // check if the specific track is also listed among the general anticipation tracks (if so, it might already be loaded)
                anticipationMusicIndex = anticipationMusicNames.indexOf(anticipationMusicNames);
            } else {
                // choose a track randomly, if no specific one was given
                anticipationMusicIndex = Math.min(Math.floor(Math.random() * anticipationMusicNames.length), anticipationMusicNames.length - 1);
                anticipationMusic = anticipationMusicNames[anticipationMusicIndex];
            }
            // set the theme ID based on whether it is a listed or custom combat theme
            _anticipationTheme = (anticipationMusicIndex >= 0) ? ANTICIPATION_THEME_PREFIX + anticipationMusicIndex : anticipationMusic;
            // choose the combat music track
            combatMusicNames = config.getSetting(config.BATTLE_SETTINGS.COMBAT_MUSIC);
            // check if there is a specific track given for the mission
            combatMusic = _mission.getCombatTheme();
            if (combatMusic) {
                // check if the specific track is also listed among the general combat tracks (if so, it might already be loaded)
                combatMusicIndex = combatMusicNames.indexOf(combatMusic);
            } else {
                // choose a track randomly, if no specific one was given
                combatMusicIndex = Math.min(Math.floor(Math.random() * combatMusicNames.length), combatMusicNames.length - 1);
                combatMusic = combatMusicNames[combatMusicIndex];
            }
            // set the theme ID based on whether it is a listed or custom combat theme
            _combatTheme = (combatMusicIndex >= 0) ? COMBAT_THEME_PREFIX + combatMusicIndex : combatMusic;
            // load the selected music, associating it with the selected theme ID
            audio.initMusic(anticipationMusic, _anticipationTheme, true);
            audio.initMusic(combatMusic, _combatTheme, true);
            audio.initMusic(config.getSetting(config.BATTLE_SETTINGS.VICTORY_MUSIC), VICTORY_THEME, false);
            audio.initMusic(config.getSetting(config.BATTLE_SETTINGS.DEFEAT_MUSIC), DEFEAT_THEME, false);
            audio.initMusic(config.getSetting(config.BATTLE_SETTINGS.DEBRIEFING_VICTORY_MUSIC), armadaScreens.DEBRIEFING_VICTORY_THEME, true);
            audio.initMusic(config.getSetting(config.BATTLE_SETTINGS.DEBRIEFING_DEFEAT_MUSIC), armadaScreens.DEBRIEFING_DEFEAT_THEME, true);
            control.getController(control.GENERAL_CONTROLLER_NAME).setMission(_mission);
            control.getController(control.GENERAL_CONTROLLER_NAME).setBattle(_battle);
            control.getController(control.CAMERA_CONTROLLER_NAME).setControlledCamera(_battleScene.getCamera());
            this._updateLoadingStatus(strings.get(strings.LOADING.RESOURCES_START), LOADING_RESOURCES_START_PROGRESS);
            resources.executeOnResourceLoad(this._updateLoadingBoxForResourceLoad.bind(this));
            resources.executeWhenReady(function () {
                _battleScene.setShadowMapping(_mission.hasShadows() ? graphics.getShadowMappingSettings() : null);
                if (graphics.isAnaglyphRenderingEnabled()) {
                    _battleScene.setAnaglyphRendering(graphics.getAnaglyphRenderingSettings());
                }
                if (graphics.isSideBySideRenderingEnabled()) {
                    _battleScene.setSideBySideRendering(graphics.getSideBySideRenderingSettings());
                }
                if (graphics.isShadowMapDebuggingEnabled()) {
                    _battleScene.setupShadowMapDebugging(graphics.getShadowMapDebuggingSettings());
                }
                this._updateLoadingStatus(strings.get(strings.LOADING.INIT_WEBGL), LOADING_INIT_WEBGL_PROGRESS);
                utils.executeAsync(function () {
                    this.setAntialiasing(graphics.getAntialiasing());
                    this.setFiltering(graphics.getFiltering());
                    this.clearSceneCanvasBindings();
                    this.bindSceneToCanvas(_battleScene, this.getScreenCanvas(BATTLE_CANVAS_ID));
                    this.bindSceneToCanvas(_targetScene, this.getScreenCanvas(BATTLE_CANVAS_ID));
                    _targetScene.clearNodes(true);
                    this._updateLoadingStatus(strings.get(strings.LOADING.READY), 100);
                    application.log("Game data loaded in " + ((performance.now() - loadingStartTime) / 1000).toFixed(3) + " seconds!", 1);
                    _smallHeaderText.setText(strings.get(strings.BATTLE.DEVELOPMENT_VERSION_NOTICE), {version: application.getVersion()});
                    document.body.classList.remove("wait");
                    control.switchToSpectatorMode(false, true);
                    this.setHeaderContent(custom ?
                            missionDescriptor.getTitle() || utils.getFilenameWithoutExtension(_missionSourceFilename) :
                            strings.get(strings.MISSION.PREFIX, utils.getFilenameWithoutExtension(_missionSourceFilename) + strings.MISSION.NAME_SUFFIX.name));
                    _battleCursor = document.body.style.cursor;
                    this.showMessage(utils.formatString(strings.get(strings.BATTLE.MESSAGE_READY), {
                        menuKey: _getMenuKeyHTMLString()
                    }));
                    _mission.applyToSpacecrafts(function (spacecraft) {
                        spacecraft.addEventHandler(SpacecraftEvents.FIRED, _handleSpacecraftFired.bind(spacecraft));
                        if (spacecraft === _mission.getPilotedSpacecraft()) {
                            spacecraft.addEventHandler(SpacecraftEvents.JUMP_ENGAGED, _handlePilotedSpacecraftJumpEngaged.bind(spacecraft));
                            spacecraft.addEventHandler(SpacecraftEvents.JUMP_CANCELLED, _handlePilotedSpacecraftJumpCancelled.bind(spacecraft));
                            spacecraft.addEventHandler(SpacecraftEvents.PREPARING_JUMP, _handlePilotedSpacecraftPreparingJump.bind(spacecraft));
                            spacecraft.addEventHandler(SpacecraftEvents.HUD, _handleHUDEvent.bind(spacecraft));
                        } else {
                            spacecraft.addEventHandler(SpacecraftEvents.JUMP_OUT_STARTED, _handleSpacecraftJumpOutStarted.bind(spacecraft));
                            spacecraft.addEventHandler(SpacecraftEvents.ARRIVED, _handleSpacecraftArrived.bind(spacecraft));
                        }
                    });
                    _missileLoadedSound = resources.getSoundEffect(
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOADED_SOUND).name).createSoundClip(
                            resources.SoundCategory.SOUND_EFFECT,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOADED_SOUND).volume);
                    _missileLockingSoundsPlayed = 0;
                    _missileLockingSound = resources.getSoundEffect(
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCKING_SOUND).name).createSoundClip(
                            resources.SoundCategory.SOUND_EFFECT,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCKING_SOUND).volume);
                    _missileLockedSound = resources.getSoundEffect(
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCKED_SOUND).name).createSoundClip(
                            resources.SoundCategory.SOUND_EFFECT,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCKED_SOUND).volume);
                    _messageSound = resources.getSoundEffect(
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_SOUND).name).createSoundClip(
                            resources.SoundCategory.SOUND_EFFECT,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_SOUND).volume);
                    _messageTypeSound = resources.getSoundEffect(
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_TYPE_SOUND).name).createSoundClip(
                            resources.SoundCategory.SOUND_EFFECT,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_TYPE_SOUND).volume,
                            true);
                    _newHostilesAlertSound = resources.getSoundEffect(
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.NEW_HOSTILES_ALERT_SOUND).name).createSoundClip(
                            resources.SoundCategory.SOUND_EFFECT,
                            config.getHUDSetting(config.BATTLE_SETTINGS.HUD.NEW_HOSTILES_ALERT_SOUND).volume);
                    this._loadingBox.hide();
                    showHUD();
                    this.startRenderLoop(1000 / config.getSetting(config.BATTLE_SETTINGS.RENDER_FPS));
                    _elapsedTime = 0;
                    _timeSinceLastFire = 0;
                    _missileLocked = false;
                    audio.playMusic(_mission.noHostilesPresent() ? AMBIENT_THEME : _anticipationTheme);
                    if (_mission.prepareScene(_battleScene)) {
                        _battleScene.setShouldAnimate(true);
                        for (i = 0; i < PREPARE_SCENE_COUNT; i++) {
                            this._render(PREPARE_SCENE_DT);
                        }
                        _battleScene.setShouldAnimate(false);
                    }
                }.bind(this));
            }.bind(this));
            resources.requestResourceLoad();
        }.bind(this));
    };
    // -------------------------------------------------------------------------
    // Caching frequently needed setting values
    config.executeWhenReady(function () {
        // hud
        // see also the activate event handler at the BattleScreen constructor
        _centerCrosshairScaleMode = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.CENTER_CROSSHAIR).scaleMode;
        _speedTargetIndicatorSize = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_TARGET_INDICATOR).size;
        _distanceTextBoxLayoutDescriptor = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DISTANCE_TEXT).layout;
        _targetViewLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_VIEW_LAYOUT));
        _targetInfoBackgroundLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INFO_BACKGROUND).layout);
        _wingmenStatusBackgroundLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_BACKGROUND).layout);
        _targetHullIntegrityBarLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_BAR).layout);
        _targetShieldBarLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_BAR).layout);
        _speedBarLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SPEED_BAR).layout);
        _missileIndicatorLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INDICATOR).layout);
        _hullIntegrityBarLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.HULL_INTEGRITY_BAR).layout);
        _shieldBarLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIELD_BAR).layout);
        _flightModeIndicatorBackgroundLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.FLIGHT_MODE_INDICATOR_BACKGROUND).layout);
        _missileInfoBackgroundLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_INFO_BACKGROUND).layout);
        _objectivesBackgroundLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.OBJECTIVES_BACKGROUND).layout);
        _escortsBackgroundLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_BACKGROUND).layout);
        _messageBackgroundLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_BACKGROUND).layout);
        _hudTargetSwitchAnimationDuration = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SWITCH_ANIMATION_DURATION);
        _hudAimAssistAppearAnimationDuration = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_APPEAR_ANIMATION_DURATION);
        _hudHullIntegrityDecreaseAnimationDuration = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.HULL_INTEGRITY_DECREASE_ANIMATION_DURATION);
        _hudShieldDecreaseAnimationDuration = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIELD_DECREASE_ANIMATION_DURATION);
        _hudTargetHullIntegrityDecreaseAnimationDuration = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_DECREASE_ANIMATION_DURATION);
        _hudTargetShieldDecreaseAnimationDuration = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_DECREASE_ANIMATION_DURATION);
        _shipIndicatorHighlightAnimationInterval = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR_HIGHLIGHT_ANIMATION_INTERVAL);
        _shipIndicatorSizes = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR).sizes;
        _shipIndicatorSizeFactor = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_INDICATOR_SIZE_FACTOR);
        _targetIndicatorSwitchScale = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_INDICATOR_SWITCH_SCALE);
        _aimAssistIndicatorSize = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR).size;
        _aimAssistIndicatorAppearScale = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.AIM_ASSIST_INDICATOR_APPEAR_SCALE);
        _shipArrowSizes = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.SHIP_ARROW).sizes;
        _targetArrowSwitchScale = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_ARROW_SWITCH_SCALE);
        _weaponImpactIndicatorSize = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WEAPON_IMPACT_INDICATOR).size;
        _weaponImpactIndicatorSwitchScale = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WEAPON_IMPACT_INDICATOR_SWITCH_SCALE);
        _driftArrowMinSpeed = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW_MIN_SPEED);
        _driftArrowMaxSpeedFactor = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.DRIFT_ARROW_MAX_SPEED_FACTOR);
        _targetHullIntegrityQuickViewBarLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_HULL_INTEGRITY_QUICK_VIEW_BAR).layout);
        _targetShieldQuickViewBarLayout = new screens.ClipSpaceLayout(config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_SHIELD_QUICK_VIEW_BAR).layout);
        _escortsIntegrityBarsSettings = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.ESCORTS_INTEGRITY_BARS);
        _wingmenStatusCraftIndicatorSettings = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_CRAFT_INDICATOR);
        _wingmenStatusMaxSquadMemberCount = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.WINGMEN_STATUS_CRAFT_POSITIONS).length;
        _messageTextSettings = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MESSAGE_TEXT);
        _missileLockingSoundCount = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.MISSILE_LOCKING_SOUND_COUNT);
        _targetViewParams = {
            shaderName: config.getHUDSetting(config.BATTLE_SETTINGS.HUD.TARGET_VIEW_TARGET_ITEM_SHADER),
            positionMatrix: mat.IDENTITY4,
            orientationMatrix: _targetViewOrientationMatrix,
            skipResources: true
        };
        _hudHighlightInterval = config.getHUDSetting(config.BATTLE_SETTINGS.HUD.HIGHLIGHT_INTERVAL);
        // music
        _combatThemeDurationAfterFire = config.getSetting(config.BATTLE_SETTINGS.COMBAT_THEME_DURATION_AFTER_FIRE) * 1000;
    });
    // initializing anaglyph text rendering if needed
    graphics.executeWhenReady(function () {
        if (graphics.isAnaglyphRenderingEnabled()) {
            screens.setAnaglyphTextRendering(true, graphics.getAnaglyphOriginalColorRatio(), graphics.getAnaglyphCyanFactor(), graphics.getAnaglyphGamma());
        }
    });
    graphics.onSettingsChange(handleGraphicsSettingsChanged);
    // -------------------------------------------------------------------------
    // The public interface of the module
    _battle.getBattleScreen = function () {
        if (!_battleScreen) {
            _battleScreen = new BattleScreen();
            _battle.pauseBattle = _battleScreen.pauseBattle.bind(_battleScreen);
            _battle.resumeBattle = _battleScreen.resumeBattle.bind(_battleScreen);
        }
        return _battleScreen;
    };
    _battle.stopTime = stopTime;
    _battle.resumeTime = resumeTime;
    _battle.toggleTime = toggleTime;
    _battle.showHUD = showHUD;
    _battle.hideHUD = hideHUD;
    _battle.toggleHUDVisibility = toggleHUDVisibility;
    _battle.HUDSection = HUDSection;
    _battle.HUDSectionState = HUDSectionState;
    return _battle;
});
/**
 * Copyright 2016-2017, 2019-2020 Krisztián Nagy
 * @file Provides the descriptor objects that outline the structure of properties for the various resource / class categories of 
 * Interstellar Armada for the editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document */

/**
 * @param utils Used to handle enums
 * @param managedGL Used to access enums
 * @param egomModel Used to access enums
 * @param camera Used to access enums
 * @param resources Used to retrieve resource name lists
 * @param config Used for configuration (setting) key strings
 * @param graphics Used to access contants
 * @param strings Used to access string key lists
 * @param classes Used to access enums and retrieve class name lists
 * @param environments Used to retrieve environment name lists
 * @param missions Used to access enums
 * @param equipment Used to access enums 
 * @param spacecraft Used to access enums 
 * @param ai Used to access the list of valid AI types
 * @param battle Used to access HUD enums
 * @param common Used to access enums (ItemType)
 */
define('editor/descriptors',[
    "utils/utils",
    "modules/managed-gl",
    "modules/egom-model",
    "modules/scene/camera",
    "modules/media-resources",
    "armada/configuration",
    "armada/graphics",
    "armada/strings",
    "armada/logic/classes",
    "armada/logic/environments",
    "armada/logic/missions",
    "armada/logic/equipment",
    "armada/logic/spacecraft",
    "armada/logic/ai",
    "armada/screens/battle",
    "editor/common"
], function (utils, managedGL, egomModel, camera, resources, config, graphics, strings, classes, environments, missions, equipment, spacecraft, ai, battle, common) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // Enums
            BaseType = {
                BOOLEAN: "boolean",
                NUMBER: "number",
                STRING: "string",
                ARRAY: "array",
                OBJECT: "object",
                ENUM: "enum", // string or number that must have a value from a fixed set (defined in an object such as {FIRST: 1, SECOND: 2} -> value must be 1 or 2)
                ASSOCIATIVE_ARRAY: "associativeArray", // object with custom properties
                COLOR3: "color3", // [r, g, b]
                COLOR4: "color4", // [r, g, b, a]
                VECTOR3: "vector3", // [x, y, z]
                RANGE: "range", // [min, max]
                PAIRS: "pairs", // [[a, b], [a, b], ...]
                ROTATIONS: "rotations", // [{axis: "X"/"Y"/"Z", degrees: x}, ...]
                SET: "set", // array where all elements must be members of an enum
                CONFINES: "confines" // [[minX, maxX], [minY, maxY], [minZ, maxZ]]
            },
            Unit = {
                TIMES: "×",
                METERS: "m",
                METERS_PER_SECOND: "m/s",
                METERS_PER_SECOND_SQUARED: "m/s²",
                SECONDS: "s",
                MILLISECONDS: "ms",
                PER_SECOND: "/s",
                DEGREES: "°",
                DEGREES_PER_SECOND: "°/s",
                DEGREES_PER_SECOND_SQUARED: "°/s²",
                KILOGRAMS: "kg",
                PERCENT: "%"
            },
            /**
             * The possible axes for rotations
             * @enum {String}
             * @type Object
             */
            Axis = {
                X: "X",
                Y: "Y",
                Z: "Z"
            },
            ThrusterUse = equipment.ThrusterUse,
            /**
             * @typedef {Object} Editor~TypeDescriptor
             * @property {String} baseType (enum BaseType)
             * @property {String} [unit] For BaseType.NUMBER
             * @property {Boolean} [long=false] For BaseType.STRING
             * @property {String} [resourceReference] For BaseType.ENUM and BaseType.SET
             * @property {String} [classReference] For BaseType.ENUM and BaseType.SET
             * @property {String} [environmentReference] For BaseType.ENUM and BaseType.SET
             * @property {String} [missionReference] For BaseType.ENUM and BaseType.SET
             * @property {String} [name] For BaseType.OBJECT and BaseType.SET
             * @property {Editor~ItemDescriptor} [properties] For BaseType.OBJECT
             * @property {Object} [values] For BaseType.ENUM and BaseType.SET
             * @property {Editor~PropertyDescriptor} [first] For BaseType.PAIRS
             * @property {Editor~PropertyDescriptor} [second] For BaseType.PAIRS
             * @property {String|Editor~TypeDescriptor} [elementType] For BaseType.ARRAY and BaseType.ASSOCIATIVE_ARRAY
             * @property {String[]} [validKeys] For BaseType.ASSOCIATIVE_ARRAY (if not given, all keys valid)
             */
            /**
             * @typedef {Object} Editor~PropertyDescriptor
             * @property {String} name
             * @property {String|Editor~TypeDescriptor} type (if string: enum BaseType)
             * @property {Boolean} [optional=false] Whether undefined / null (= unset) is actually a valid value for this property
             * @property {} [defaultValue] If the value is undefined, it means the property will be taken as having this value. 
             * Use this for properties for which the game logic actually replaces undefined values with a proper value upon loading.
             * When a new object is created having this property, this default value will be set for it. (unless an explicit newValue is 
             * specified)
             * @property {Boolean} [globalDefault] If the value is undefined, the value of the property will be set from a global (configuration) variable
             * @property {String} [settingName] If globalDefault is true, the name of the setting from where the default value is retrieved from can be given here
             * @property {} [newValue] When a new object is created having this property, this value will be set as its value.
             * @property {String} [defaultText] The text to show in the editor when the property is unset and has no default value or it is better to show
             * some explanation instead of the default value
             */
            /**
             * @typedef {Object.<String, PropertyDescriptor>} Editor~ItemDescriptor
             */
            // ------------------------------------------------------------------------------
            // private functions used for constants
            /**
             * Returns a type descriptor describing an array type that has elements of the passed type
             * @param {Editor~TypeDescriptor} elementType
             * @param {Object} [length]
             * @returns {Editor~TypeDescriptor}
             */
            _createTypedArrayType = function (elementType, length) {
                return {
                    baseType: BaseType.ARRAY,
                    elementType: elementType,
                    fixedLength: length && length.fixed,
                    minLength: length && length.min,
                    maxLength: length && length.max
                };
            },
            /**
             * Returns a type descriptor describing an associative array type that has elements of the passed type
             * @param {Editor~TypeDescriptor} elementType
             * @returns {Editor~TypeDescriptor}
             */
            _createTypedAssociativeArrayType = function (elementType) {
                return {
                    baseType: BaseType.ASSOCIATIVE_ARRAY,
                    elementType: elementType
                };
            },
            /**
             * Returns a type descriptor describing an range type
             * @param {Boolean} minRequired
             * @param {Boolean} maxRequired
             * @param {Editor~TypeDescriptor} [elementType] from enum Unit
             * @returns {Editor~TypeDescriptor}
             */
            _createRangeType = function (minRequired, maxRequired, elementType) {
                return {
                    baseType: BaseType.RANGE,
                    minRequired: minRequired,
                    maxRequired: maxRequired,
                    elementType: elementType
                };
            },
            // ------------------------------------------------------------------------------
            // Constants
            NAME_PROPERTY_NAME = "name",
            BASED_ON_PROPERTY_NAME = "basedOn",
            LONG_TEXT_PREVIEW_LENGTH = 12,
            /**
             * @type Editor~TypeDescriptor
             */
            STRING_ARRAY = _createTypedArrayType(BaseType.STRING),
            /**
             * @type Editor~TypeDescriptor
             */
            STRING_ASSOCIATIVE_ARRAY = _createTypedAssociativeArrayType(BaseType.STRING),
            /**
             * @type Editor~TypeDescriptor
             */
            LONG_STRING = {
                baseType: BaseType.STRING,
                long: true
            },
            SCALE = {
                baseType: BaseType.NUMBER,
                unit: Unit.TIMES
            },
            NON_NEGATIVE_SCALE = {
                baseType: BaseType.NUMBER,
                unit: Unit.TIMES,
                min: 0
            },
            GROWTH_RATE = {
                baseType: BaseType.NUMBER,
                unit: Unit.TIMES,
                min: 1
            },
            POSITIVE_SCALE = {
                baseType: BaseType.NUMBER,
                unit: Unit.TIMES,
                min: 0.001
            },
            DISTANCE = {
                baseType: BaseType.NUMBER,
                unit: Unit.METERS,
                min: 0
            },
            POSITIVE_DISTANCE = {
                baseType: BaseType.NUMBER,
                unit: Unit.METERS,
                min: 1
            },
            POSITIVE_LENGTH = {
                baseType: BaseType.NUMBER,
                unit: Unit.METERS,
                min: 0.001
            },
            METERS_PER_SECOND = {
                baseType: BaseType.NUMBER,
                unit: Unit.METERS_PER_SECOND
            },
            NON_NEGATIVE_METERS_PER_SECOND = {
                baseType: BaseType.NUMBER,
                unit: Unit.METERS_PER_SECOND,
                min: 0
            },
            POSITIVE_METERS_PER_SECOND = {
                baseType: BaseType.NUMBER,
                unit: Unit.METERS_PER_SECOND,
                min: 0.001
            },
            METERS_PER_SECOND_SQUARED = {
                baseType: BaseType.NUMBER,
                unit: Unit.METERS_PER_SECOND_SQUARED
            },
            POSITIVE_METERS_PER_SECOND_SQUARED = {
                baseType: BaseType.NUMBER,
                unit: Unit.METERS_PER_SECOND_SQUARED,
                min: 0.001
            },
            MILLISECONDS = {
                baseType: BaseType.NUMBER,
                unit: Unit.MILLISECONDS,
                integer: true
            },
            NON_NEGATIVE_MILLISECONDS = {
                baseType: BaseType.NUMBER,
                unit: Unit.MILLISECONDS,
                integer: true,
                min: 0
            },
            POSITIVE_MILLISECONDS = {
                baseType: BaseType.NUMBER,
                unit: Unit.MILLISECONDS,
                integer: true,
                min: 1
            },
            SPAWN_INTERVAL = {
                baseType: BaseType.NUMBER,
                unit: Unit.MILLISECONDS,
                integer: true,
                min: 10
            },
            POSITIVE_PER_SECOND = {
                baseType: BaseType.NUMBER,
                unit: Unit.PER_SECOND,
                min: 0.001
            },
            DEGREES = {
                baseType: BaseType.NUMBER,
                unit: Unit.DEGREES,
                min: -360,
                max: 360
            },
            NON_NEGATIVE_DEGREES = {
                baseType: BaseType.NUMBER,
                unit: Unit.DEGREES,
                min: 0,
                max: 360
            },
            NON_NEGATIVE_DEGREES_180 = {
                baseType: BaseType.NUMBER,
                unit: Unit.DEGREES,
                min: 0,
                max: 180
            },
            POSITIVE_DEGREES_180 = {
                baseType: BaseType.NUMBER,
                unit: Unit.DEGREES,
                min: 0.1,
                max: 180
            },
            DEGREES_BETA = {
                baseType: BaseType.NUMBER,
                unit: Unit.DEGREES,
                min: -90,
                max: 90
            },
            POSITIVE_DEGREES_PER_SECOND = {
                baseType: BaseType.NUMBER,
                unit: Unit.DEGREES_PER_SECOND,
                min: 0.001
            },
            POSITIVE_DEGREES_PER_SECOND_SQUARED = {
                baseType: BaseType.NUMBER,
                unit: Unit.DEGREES_PER_SECOND_SQUARED,
                min: 0.001
            },
            KILOGRAMS = {
                baseType: BaseType.NUMBER,
                unit: Unit.KILOGRAMS,
                min: 0.001
            },
            POSITIVE_INT_PERCENT = {
                baseType: BaseType.NUMBER,
                unit: Unit.PERCENT,
                integer: true,
                min: 1,
                max: 100
            },
            NON_NEGATIVE_INTEGER = {
                baseType: BaseType.NUMBER,
                integer: true,
                min: 0
            },
            POSITIVE_INTEGER = {
                baseType: BaseType.NUMBER,
                integer: true,
                min: 1
            },
            RATIO = {
                baseType: BaseType.NUMBER,
                min: 0,
                max: 1
            },
            POSITIVE_RATIO = {
                baseType: BaseType.NUMBER,
                min: 0.001,
                max: 1
            },
            NON_NEGATIVE_NUMBER = {
                baseType: BaseType.NUMBER,
                min: 0
            },
            POSITIVE_NUMBER = {
                baseType: BaseType.NUMBER,
                min: 0.001
            },
            /**
             * @type Editor~TypeDescriptor
             */
            NON_NEGATIVE_MILLISECONDS_ARRAY = _createTypedArrayType(NON_NEGATIVE_MILLISECONDS, {min: 1}),
            /**
             * @type Editor~TypeDescriptor
             */
            MODEL_REFERENCE = {
                baseType: BaseType.ENUM,
                resourceReference: "models"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SHADER_REFERENCE = {
                baseType: BaseType.ENUM,
                resourceReference: "shaders"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TEXTURE_REFERENCE = {
                baseType: BaseType.ENUM,
                resourceReference: "textures"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            CUBEMAP_REFERENCE = {
                baseType: BaseType.ENUM,
                resourceReference: "cubemaps"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SOUND_REFERENCE = {
                baseType: BaseType.ENUM,
                resourceReference: "soundEffects"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MUSIC_REFERENCE = {
                baseType: BaseType.ENUM,
                resourceReference: "music"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SKYBOX_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "skyboxClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            BACKGROUND_OBJECT_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "backgroundObjectClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            DUST_CLOUD_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "dustCloudClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT_TYPE_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "spacecraftTypes"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "spacecraftClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            EXPLOSION_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "explosionClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            PROJECTILE_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "projectileClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MISSILE_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "missileClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            WEAPON_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "weaponClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            PROPULSION_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "propulsionClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            JUMP_ENGINE_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "jumpEngineClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SHIELD_CLASS_REFERENCE = {
                baseType: BaseType.ENUM,
                classReference: "shieldClasses"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            ENVIRONMENT_REFERENCE = {
                baseType: BaseType.ENUM,
                environmentReference: "environments"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MISSION_REFERENCE = {
                baseType: BaseType.ENUM,
                missionReference: "missions"
            },
            /**
             * @type Editor~TypeDescriptor
             */
            LUMINOSITY_FACTOR_PAIRS = {
                baseType: BaseType.PAIRS,
                first: {
                    name: "group",
                    type: NON_NEGATIVE_INTEGER
                },
                second: {
                    name: "luminosity",
                    type: RATIO
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            AXIS = {
                baseType: BaseType.ENUM,
                values: Axis
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TEXTURE_IMAGE_FORMAT = {
                baseType: BaseType.ENUM,
                values: {
                    PNG: "png",
                    JPG: "jpg",
                    JPEG: "jpeg",
                    WEBP: "webp"
                }
            },
            /**
             * The descriptor object for texture resources, describing their properties
             * @type Editor~ItemDescriptor
             */
            TEXTURE = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                BASEPATH: {
                    name: "basepath",
                    type: BaseType.STRING
                },
                FORMAT: {
                    name: "format",
                    type: TEXTURE_IMAGE_FORMAT
                },
                USE_MIPMAP: {
                    name: "useMipmap",
                    type: BaseType.BOOLEAN
                },
                TYPE_SUFFIXES: {
                    name: "typeSuffixes",
                    type: STRING_ASSOCIATIVE_ARRAY
                },
                QUALITY_SUFFIXES: {
                    name: "qualitySuffixes",
                    type: STRING_ASSOCIATIVE_ARRAY
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            CUBEMAP_IMAGE_NAMES = {
                baseType: BaseType.OBJECT,
                name: "CubemapImageNames",
                properties: {
                    POS_X: {
                        name: "posX",
                        type: BaseType.STRING
                    },
                    NEG_X: {
                        name: "negX",
                        type: BaseType.STRING
                    },
                    POS_Y: {
                        name: "posY",
                        type: BaseType.STRING
                    },
                    NEG_Y: {
                        name: "negY",
                        type: BaseType.STRING
                    },
                    POS_Z: {
                        name: "posZ",
                        type: BaseType.STRING
                    },
                    NEG_Z: {
                        name: "negZ",
                        type: BaseType.STRING
                    }
                }
            },
            /**
             * The descriptor object for cubemap resources, describing their properties
             * @type Editor~ItemDescriptor
             */
            CUBEMAP = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                BASEPATH: {
                    name: "basepath",
                    type: BaseType.STRING
                },
                FORMAT: {
                    name: "format",
                    type: TEXTURE_IMAGE_FORMAT
                },
                IMAGE_NAMES: {
                    name: "imageNames",
                    type: CUBEMAP_IMAGE_NAMES
                },
                QUALITY_SUFFIXES: {
                    name: "qualitySuffixes",
                    type: STRING_ASSOCIATIVE_ARRAY
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SHADER_VARIANTS = {
                baseType: BaseType.ASSOCIATIVE_ARRAY,
                validKeys: [
                    graphics.SHADER_VARIANT_WITHOUT_SHADOWS_NAME,
                    graphics.SHADER_VARIANT_WITHOUT_DYNAMIC_LIGHTS_NAME,
                    classes.SHADER_VARIANT_INSTANCED_NAME
                ],
                elementType: SHADER_REFERENCE
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SHADER_BLEND_MODE = {
                baseType: BaseType.ENUM,
                values: managedGL.ShaderBlendMode
            },
            /**
             * @type Editor~TypeDescriptor
             */
            VERTEX_ATTRIBUTE_ROLE = {
                baseType: BaseType.ENUM,
                name: "VertexAttributeRole",
                values: egomModel.VertexAttributeRole
            },
            /**
             * The descriptor object for shader resources, describing their properties
             * @type Editor~ItemDescriptor
             */
            SHADER = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                VARIANTS: {
                    name: "variants",
                    type: SHADER_VARIANTS,
                    optional: true
                },
                VERTEX_SHADER_SOURCE: {
                    name: "vertexShaderSource",
                    type: BaseType.STRING
                },
                FRAGMENT_SHADER_SOURCE: {
                    name: "fragmentShaderSource",
                    type: BaseType.STRING
                },
                BLEND_MODE: {
                    name: "blendMode",
                    type: SHADER_BLEND_MODE
                },
                VERTEX_ATTRIBUTE_ROLES: {
                    name: "vertexAttributeRoles",
                    type: _createTypedAssociativeArrayType(VERTEX_ATTRIBUTE_ROLE)
                },
                INSTANCE_ATTRIBUTE_ROLES: {
                    name: "instanceAttributeRoles",
                    type: STRING_ASSOCIATIVE_ARRAY,
                    optional: true
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MODEL_FILE_DESCRIPTOR = {
                baseType: BaseType.OBJECT,
                name: "ModelFileDescriptor",
                properties: {
                    SUFFIX: {
                        name: "suffix",
                        type: BaseType.STRING
                    },
                    MAX_LOD: {
                        name: "maxLOD",
                        type: NON_NEGATIVE_INTEGER
                    }
                }
            },
            /**
             * Supported model file formats
             * @type Editor~TypeDescriptor
             */
            MODEL_FORMAT = {
                baseType: BaseType.ENUM,
                values: {
                    EGM: "egm"
                }
            },
            /**
             * The descriptor object for model resources, describing their properties
             * @type Editor~ItemDescriptor
             */
            MODEL = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                BASEPATH: {
                    name: "basepath",
                    type: BaseType.STRING
                },
                FORMAT: {
                    name: "format",
                    type: MODEL_FORMAT
                },
                FILES: {
                    name: "files",
                    type: _createTypedArrayType(MODEL_FILE_DESCRIPTOR)
                }
            },
            /**
             * The descriptor object for sound effect resources, describing their properties
             * @type Editor~ItemDescriptor
             */
            SOUND_EFFECT = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                SAMPLES: {
                    name: "samples",
                    type: STRING_ARRAY
                }
            },
            /**
             * The descriptor object for music resources, describing their properties
             * @type Editor~ItemDescriptor
             */
            MUSIC = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                SAMPLES: {
                    name: "sample",
                    type: BaseType.STRING
                }
            },
            /**
             * The descriptor object for skybox classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            SKYBOX_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                SHADER: {
                    name: "shader",
                    type: SHADER_REFERENCE,
                    newValue: "skybox"
                },
                CUBEMAP: {
                    name: "cubemap",
                    type: CUBEMAP_REFERENCE
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            BACKGROUND_OBJECT_LAYER = {
                baseType: BaseType.OBJECT,
                name: "Layer",
                properties: {
                    SIZE: {
                        name: "size",
                        type: POSITIVE_SCALE,
                        defaultValue: 1
                    },
                    SHADER: {
                        name: "shader",
                        type: SHADER_REFERENCE,
                        newValue: "backgroundBillboard"
                    },
                    TEXTURE: {
                        name: "texture",
                        type: TEXTURE_REFERENCE
                    },
                    COLOR: {
                        name: "color",
                        type: BaseType.COLOR4,
                        defaultValue: [1, 1, 1, 1]
                    }
                }
            },
            /**
             * The descriptor object for background object classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            BACKGROUND_OBJECT_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                LIGHT_COLOR: {
                    name: "lightColor",
                    type: BaseType.COLOR3,
                    optional: true,
                    defaultText: "no light emitted"
                },
                LAYERS: {
                    name: "layers",
                    type: _createTypedArrayType(BACKGROUND_OBJECT_LAYER, {min: 1})
                }
            },
            /**
             * The descriptor object for dust cloud classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            DUST_CLOUD_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                SHADER: {
                    name: "shader",
                    type: SHADER_REFERENCE,
                    newValue: "dust"
                },
                NUMBER_OF_PARTICLES: {
                    name: "numberOfParticles",
                    type: POSITIVE_INTEGER
                },
                RANGE: {
                    name: "range",
                    type: POSITIVE_DISTANCE
                },
                COLOR: {
                    name: "color",
                    type: BaseType.COLOR3,
                    defaultValue: [1, 1, 1]
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            PARTICLE_EMITTER_TYPE = {
                baseType: BaseType.ENUM,
                values: classes.ParticleEmitterType
            },
            _particleStateIsNotFirst = function (data, parent) {
                return data !== parent.particleStates[0];
            },
            /**
             * @type Editor~TypeDescriptor
             */
            PARTICLE_STATE = {
                baseType: BaseType.OBJECT,
                name: "ParticleState",
                properties: {
                    COLOR: {
                        name: "color",
                        type: BaseType.COLOR4,
                        defaultValue: [1, 1, 1, 1]
                    },
                    SIZE: {
                        name: "size",
                        type: NON_NEGATIVE_NUMBER,
                        defaultValue: 1
                    },
                    TIME_TO_REACH: {
                        name: "timeToReach",
                        type: NON_NEGATIVE_MILLISECONDS,
                        defaultValue: 0,
                        isValid: _particleStateIsNotFirst
                    }
                }
            },
            _emitterHasProjectileModel = function (data) {
                return data.hasProjectileModel;
            },
            _emitterHasDirection = function (data) {
                return data.type && (data.type !== classes.ParticleEmitterType.OMNIDIRECTIONAL);
            },
            _emitterIsSpawning = function (data) {
                return data.spawnNumber > 0;
            },
            /**
             * @type Editor~TypeDescriptor
             */
            PARTICLE_EMITTER = {
                baseType: BaseType.OBJECT,
                name: "ParticleEmitter",
                properties: {
                    TYPE: {
                        name: "type",
                        type: PARTICLE_EMITTER_TYPE,
                        defaultValue: classes.ParticleEmitterType.OMNIDIRECTIONAL
                    },
                    HAS_PROJECTILE_MODEL: {
                        name: "hasProjectileModel",
                        type: BaseType.BOOLEAN,
                        defaultValue: false
                    },
                    PROJECTILE_MODEL_WIDTH: {
                        name: "projectileModelWidth",
                        type: RATIO,
                        optional: true,
                        defaultValue: 1,
                        isValid: _emitterHasProjectileModel
                    },
                    PROJECTILE_MODEL_INTERSECTION: {
                        name: "projectileModelIntersection",
                        type: BaseType.NUMBER,
                        optional: true,
                        defaultValue: 0,
                        isValid: _emitterHasProjectileModel
                    },
                    DIMENSIONS: {
                        name: "dimensions",
                        type: BaseType.VECTOR3,
                        defaultValue: [0, 0, 0]
                    },
                    DIRECTION_SPREAD: {
                        name: "directionSpread",
                        type: NON_NEGATIVE_DEGREES,
                        defaultValue: 0,
                        isValid: _emitterHasDirection
                    },
                    VELOCITY: {
                        name: "velocity",
                        type: METERS_PER_SECOND,
                        defaultValue: 0
                    },
                    VELOCITY_SPREAD: {
                        name: "velocitySpread",
                        type: NON_NEGATIVE_METERS_PER_SECOND,
                        defaultValue: 0
                    },
                    INITIAL_NUMBER: {
                        name: "initialNumber",
                        type: NON_NEGATIVE_INTEGER,
                        defaultValue: 0
                    },
                    SPAWN_NUMBER: {
                        name: "spawnNumber",
                        type: NON_NEGATIVE_INTEGER,
                        defaultValue: 0
                    },
                    SPAWN_TIME: {
                        name: "spawnTime",
                        type: SPAWN_INTERVAL,
                        newValue: 1000,
                        isRequired: _emitterIsSpawning,
                        isValid: _emitterIsSpawning
                    },
                    DURATION: {
                        name: "duration",
                        type: POSITIVE_MILLISECONDS,
                        optional: true,
                        isValid: _emitterIsSpawning,
                        defaultText: "infinite"
                    },
                    DELAY: {
                        name: "delay",
                        type: NON_NEGATIVE_MILLISECONDS,
                        defaultValue: 0
                    },
                    SHADER: {
                        name: "shader",
                        type: SHADER_REFERENCE,
                        newValue: "particle"
                    },
                    TEXTURE: {
                        name: "texture",
                        type: TEXTURE_REFERENCE
                    },
                    PARTICLE_STATES: {
                        name: "particleStates",
                        type: _createTypedArrayType(PARTICLE_STATE, {min: 2})
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            LIGHT_STATE = {
                baseType: BaseType.OBJECT,
                name: "LightState",
                properties: {
                    COLOR: {
                        name: "color",
                        type: BaseType.COLOR3,
                        newValue: [1, 1, 1]
                    },
                    INTENSITY: {
                        name: "intensity",
                        type: NON_NEGATIVE_NUMBER
                    },
                    TIME_TO_REACH: {
                        name: "timeToReach",
                        type: NON_NEGATIVE_MILLISECONDS
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SOUND_DESCRIPTOR = {
                baseType: BaseType.OBJECT,
                name: "SoundDescriptor",
                getPreviewText: function (data) {
                    return "((" + ((data.name.length > 18) ? data.name.substring(0, 15) + "..." : data.name) + " | " + ((data.volume !== undefined) ? data.volume : 1) + "))";
                },
                properties: {
                    NAME: {
                        name: "name",
                        type: SOUND_REFERENCE
                    },
                    VOLUME: {
                        name: "volume",
                        type: NON_NEGATIVE_NUMBER,
                        defaultValue: 1
                    }
                }
            },
            /**
             * The descriptor object for propulsion classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            EXPLOSION_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                PARTICLE_EMITTERS: {
                    name: "particleEmitters",
                    type: _createTypedArrayType(PARTICLE_EMITTER, {min: 1})
                },
                LIGHT_STATES: {
                    name: "lightStates",
                    type: _createTypedArrayType(LIGHT_STATE, {min: 1}),
                    optional: true,
                    defaultText: "no light emitted"
                },
                SOUND_EFFECT: {
                    name: "soundEffect",
                    type: SOUND_DESCRIPTOR,
                    optional: true,
                    defaultText: "no sound"
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            PARTICLE_DESCRIPTOR = {
                baseType: BaseType.OBJECT,
                name: "ParticleDescriptor",
                properties: {
                    SHADER: {
                        name: "shader",
                        type: SHADER_REFERENCE,
                        newValue: "particle"
                    },
                    TEXTURE: {
                        name: "texture",
                        type: TEXTURE_REFERENCE
                    },
                    COLOR: {
                        name: "color",
                        type: BaseType.COLOR4,
                        defaultValue: [1, 1, 1, 1]
                    },
                    SIZE: {
                        name: "size",
                        type: POSITIVE_SCALE,
                        defaultValue: 1
                    },
                    DURATION: {
                        name: "duration",
                        type: POSITIVE_MILLISECONDS
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TRAIL_DESCRIPTOR = {
                baseType: BaseType.OBJECT,
                name: "TrailDescriptor",
                properties: {
                    SHADER: {
                        name: "shader",
                        type: SHADER_REFERENCE,
                        newValue: "trail"
                    },
                    TEXTURE: {
                        name: "texture",
                        type: TEXTURE_REFERENCE
                    },
                    COLOR: {
                        name: "color",
                        type: BaseType.COLOR4,
                        defaultValue: [1, 1, 1, 1]
                    },
                    SIZE: {
                        name: "size",
                        type: POSITIVE_SCALE,
                        defaultValue: 1
                    },
                    DURATION: {
                        name: "duration",
                        type: POSITIVE_MILLISECONDS,
                        newValue: 500
                    },
                    GROWTH_RATE: {
                        name: "growthRate",
                        type: GROWTH_RATE,
                        newValue: 2
                    }
                }
            },
            _hasLight = function (data) {
                return !!data.lightColor;
            },
            /**
             * The descriptor object for projectile classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            PROJECTILE_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                DAMAGE: {
                    name: "damage",
                    type: BaseType.NUMBER,
                    defaultValue: 0
                },
                SHADER: {
                    name: "shader",
                    type: SHADER_REFERENCE,
                    newValue: "billboard"
                },
                TEXTURE: {
                    name: "texture",
                    type: TEXTURE_REFERENCE
                },
                SIZE: {
                    name: "size",
                    type: POSITIVE_SCALE,
                    defaultValue: 1
                },
                MASS: {
                    name: "mass",
                    type: KILOGRAMS
                },
                DRAG_FACTOR: {
                    name: "dragFactor",
                    type: NON_NEGATIVE_SCALE,
                    defaultValue: 0
                },
                DURATION: {
                    name: "duration",
                    type: POSITIVE_MILLISECONDS
                },
                DISSIPATION_DURATION: {
                    name: "dissipationDuration",
                    type: POSITIVE_MILLISECONDS
                },
                INTERSECTION_POSITIONS: {
                    name: "intersectionPositions",
                    type: _createTypedArrayType(BaseType.NUMBER, {min: 1}),
                    optional: true,
                    defaultText: "no intersections"
                },
                WIDTH: {
                    name: "width",
                    type: POSITIVE_RATIO,
                    defaultValue: 1
                },
                MUZZLE_FLASH: {
                    name: "muzzleFlash",
                    type: PARTICLE_DESCRIPTOR
                },
                LIGHT_COLOR: {
                    name: "lightColor",
                    type: BaseType.COLOR3,
                    optional: true,
                    newValue: [1, 1, 1],
                    defaultText: "no light emitted"
                },
                LIGHT_INTENSITY: {
                    name: "lightIntensity",
                    type: POSITIVE_NUMBER,
                    isValid: _hasLight
                },
                EXPLOSION: {
                    name: "explosion",
                    type: EXPLOSION_CLASS_REFERENCE
                },
                SHIELD_EXPLOSION: {
                    name: "shieldExplosion",
                    type: EXPLOSION_CLASS_REFERENCE
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            THRUSTER = {
                baseType: BaseType.OBJECT,
                name: "Thruster",
                properties: {
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3
                    },
                    SIZE: {
                        name: "size",
                        type: POSITIVE_SCALE,
                        newValue: 1
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            THRUSTER_USES = {
                baseType: BaseType.SET,
                name: "ThrusterUses",
                values: ThrusterUse
            },
            _hasNoCount = function (data) {
                return !data.count;
            },
            _hasCount = function (data) {
                return data.count > 0;
            },
            /**
             * @type Editor~TypeDescriptor
             */
            THRUSTER_SLOT = {
                baseType: BaseType.OBJECT,
                name: "ThrusterSlot",
                properties: {
                    GROUP: {
                        name: "group",
                        type: NON_NEGATIVE_INTEGER
                    },
                    USES: {
                        name: "uses",
                        type: THRUSTER_USES
                    },
                    THRUSTERS: {
                        name: "thrusters",
                        type: _createTypedArrayType(THRUSTER, {min: 1}),
                        isValid: _hasNoCount
                    },
                    COUNT: {
                        name: "count",
                        type: POSITIVE_INTEGER,
                        optional: true,
                        defaultText: "not an array"
                    },
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3,
                        isValid: _hasCount
                    },
                    VECTOR: {
                        name: "vector",
                        type: BaseType.VECTOR3,
                        isValid: _hasCount
                    },
                    SIZE: {
                        name: "size",
                        type: POSITIVE_SCALE,
                        newValue: 1,
                        isValid: _hasCount
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MISSILE_SIZE = {
                baseType: BaseType.ENUM,
                values: utils.getEnumObject(utils.getEnumKeys(classes.MissileSize))
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MISSILE_HOMING_MODE = {
                baseType: BaseType.ENUM,
                values: utils.getEnumObject(utils.getEnumKeys(classes.MissileHomingMode))
            },
            _getName = function (data) {
                return data.name;
            },
            _getShortName = function (data) {
                var name = data.fullName || data.name;
                return name.split(" ")[0].substring(0, 5);
            },
            _missileIsHoming = function (data) {
                return !!data.homingMode && (classes.MissileHomingMode[utils.constantName(data.homingMode)] !== classes.MissileHomingMode.NONE);
            },
            _missileNeedsLocking = function (data) {
                return !!data.lockingTime;
            },
            /**
             * The descriptor object for missile classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            MISSILE_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                FULL_NAME: {
                    name: "fullName",
                    type: BaseType.STRING,
                    optional: true,
                    getDerivedDefault: _getName,
                    updateOnValidate: true
                },
                SHORT_NAME: {
                    name: "shortName",
                    type: BaseType.STRING,
                    optional: true,
                    getDerivedDefault: _getShortName,
                    updateOnValidate: true
                },
                MODEL: {
                    name: "model",
                    type: MODEL_REFERENCE,
                    newValue: "mediumMissile"
                },
                MODEL_SCALE: {
                    name: "modelScale",
                    type: POSITIVE_SCALE,
                    optional: true,
                    defaultValue: 1
                },
                SHADER: {
                    name: "shader",
                    type: SHADER_REFERENCE,
                    newValue: "ship"
                },
                TEXTURE: {
                    name: "texture",
                    type: TEXTURE_REFERENCE
                },
                ANTI_SHIP: {
                    name: "antiShip",
                    type: BaseType.BOOLEAN,
                    defaultValue: false
                },
                DAMAGE: {
                    name: "damage",
                    type: BaseType.NUMBER,
                    defaultValue: 0
                },
                SIZE: {
                    name: "size",
                    type: MISSILE_SIZE
                },
                CAPACITY: {
                    name: "capacity",
                    type: POSITIVE_INTEGER,
                    defaultValue: 1
                },
                LENGTH: {
                    name: "length",
                    type: POSITIVE_LENGTH,
                    newValue: 1
                },
                HOMING_MODE: {
                    name: "homingMode",
                    type: MISSILE_HOMING_MODE,
                    optional: true,
                    defaultText: "not homing"
                },
                MASS: {
                    name: "mass",
                    type: KILOGRAMS,
                    newValue: 1
                },
                DRAG_FACTOR: {
                    name: "dragFactor",
                    type: NON_NEGATIVE_SCALE,
                    defaultValue: 1
                },
                LAUNCH_VELOCITY: {
                    name: "launchVelocity",
                    type: NON_NEGATIVE_METERS_PER_SECOND,
                    defaultValue: 0
                },
                IGNITION_TIME: {
                    name: "ignitionTime",
                    type: NON_NEGATIVE_MILLISECONDS,
                    defaultValue: 0
                },
                ACCELERATION: {
                    name: "acceleration",
                    type: POSITIVE_METERS_PER_SECOND_SQUARED,
                    newValue: 100
                },
                ANGULAR_ACCELERATION: {
                    name: "angularAcceleration",
                    type: POSITIVE_DEGREES_PER_SECOND_SQUARED,
                    newValue: 90,
                    isRequired: _missileIsHoming,
                    isValid: _missileIsHoming
                },
                MAIN_BURN_ANGLE_THRESHOLD: {
                    name: "mainBurnAngleThreshold",
                    type: POSITIVE_DEGREES_180,
                    newValue: 1,
                    isRequired: _missileIsHoming,
                    isValid: _missileIsHoming
                },
                DURATION: {
                    name: "duration",
                    type: POSITIVE_MILLISECONDS,
                    newValue: 1000
                },
                LOCKING_TIME: {
                    name: "lockingTime",
                    type: NON_NEGATIVE_MILLISECONDS,
                    defaultValue: 0,
                    isValid: _missileIsHoming
                },
                LOCKING_ANGLE: {
                    name: "lockingAngle",
                    type: POSITIVE_DEGREES_180,
                    optional: true,
                    defaultText: "unlimited",
                    isValid: _missileNeedsLocking
                },
                COOLDOWN: {
                    name: "cooldown",
                    type: POSITIVE_MILLISECONDS,
                    newValue: 1000
                },
                SALVO_COOLDOWN: {
                    name: "salvoCooldown",
                    type: POSITIVE_MILLISECONDS,
                    optional: true,
                    defaultText: "same as cooldown"
                },
                PROXIMITY_RANGE: {
                    name: "proximityRange",
                    type: DISTANCE,
                    defaultValue: 0
                },
                KINETIC_FACTOR: {
                    name: "kineticFactor",
                    type: POSITIVE_SCALE,
                    defaultValue: 1
                },
                LIGHT_COLOR: {
                    name: "lightColor",
                    type: BaseType.COLOR3,
                    optional: true,
                    newValue: [1, 1, 1],
                    defaultText: "no light emitted"
                },
                LIGHT_INTENSITY: {
                    name: "lightIntensity",
                    type: POSITIVE_NUMBER,
                    isValid: _hasLight
                },
                TRAIL: {
                    name: "trail",
                    type: TRAIL_DESCRIPTOR
                },
                EXPLOSION: {
                    name: "explosion",
                    type: EXPLOSION_CLASS_REFERENCE
                },
                SHIELD_EXPLOSION: {
                    name: "shieldExplosion",
                    type: EXPLOSION_CLASS_REFERENCE
                },
                LAUNCH_SOUND: {
                    name: "launchSound",
                    type: SOUND_DESCRIPTOR
                },
                START_SOUND: {
                    name: "startSound",
                    type: SOUND_DESCRIPTOR
                },
                PROPULSION: {
                    name: "propulsion",
                    type: PROPULSION_CLASS_REFERENCE
                },
                THRUSTER_SLOTS: {
                    name: "thrusterSlots",
                    type: _createTypedArrayType(THRUSTER_SLOT)
                },
                SCORE_VALUE: {
                    name: "scoreValue",
                    type: NON_NEGATIVE_INTEGER,
                    defaultValue: 0
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            BARREL = {
                baseType: BaseType.OBJECT,
                name: "Barrel",
                properties: {
                    PROJECTILE: {
                        name: "projectile",
                        type: PROJECTILE_CLASS_REFERENCE
                    },
                    PROJECTILE_VELOCITY: {
                        name: "projectileVelocity",
                        type: POSITIVE_METERS_PER_SECOND,
                        newValue: 1
                    },
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            WEAPON_ROTATION_STYLE = {
                baseType: BaseType.ENUM,
                values: classes.WeaponRotationStyle
            },
            /**
             * @type Editor~TypeDescriptor
             */
            WEAPON_ROTATOR = {
                baseType: BaseType.OBJECT,
                name: "WeaponRotator",
                properties: {
                    AXIS: {
                        name: "axis",
                        type: BaseType.VECTOR3,
                        newValue: [0, 0, 1]
                    },
                    CENTER: {
                        name: "center",
                        type: BaseType.VECTOR3
                    },
                    RANGE: {
                        name: "range",
                        type: _createRangeType(true, true, DEGREES),
                        optional: true,
                        defaultText: "360°"
                    },
                    DEFAULT_ANGLE: {
                        name: "defaultAngle",
                        type: DEGREES,
                        defaultValue: 0
                    },
                    ROTATION_RATE: {
                        name: "rotationRate",
                        type: POSITIVE_DEGREES_PER_SECOND,
                        newValue: 1
                    },
                    TRANSFORM_GROUP_INDEX: {
                        name: "transformGroupIndex",
                        type: NON_NEGATIVE_INTEGER
                    }
                }
            },
            _weaponCanRotate = function (data) {
                return data.rotationStyle && (data.rotationStyle !== classes.WeaponRotationStyle.NONE);
            },
            /**
             * The descriptor object for weapon classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            WEAPON_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                FULL_NAME: {
                    name: "fullName",
                    type: BaseType.STRING,
                    optional: true,
                    getDerivedDefault: _getName,
                    updateOnValidate: true
                },
                SHADER: {
                    name: "shader",
                    type: SHADER_REFERENCE,
                    newValue: "ship"
                },
                MODEL: {
                    name: "model",
                    type: MODEL_REFERENCE
                },
                TEXTURE: {
                    name: "texture",
                    type: TEXTURE_REFERENCE
                },
                DEFAULT_LUMINOSITY_FACTORS: {
                    name: "defaultLuminosityFactors",
                    type: LUMINOSITY_FACTOR_PAIRS,
                    optional: true,
                    defaultText: "all zeros"
                },
                COOLDOWN: {
                    name: "cooldown",
                    type: POSITIVE_MILLISECONDS
                },
                BARRELS: {
                    name: "barrels",
                    type: _createTypedArrayType(BARREL, {min: 1})
                },
                ATTACHMENT_POINT: {
                    name: "attachmentPoint",
                    type: BaseType.VECTOR3,
                    defaultValue: [0, 0, 0]
                },
                ROTATION_STYLE: {
                    name: "rotationStyle",
                    type: WEAPON_ROTATION_STYLE,
                    defaultValue: classes.WeaponRotationStyle.NONE
                },
                BASE_POINT: {
                    name: "basePoint",
                    type: BaseType.VECTOR3,
                    defaultValue: [0, 0, 0],
                    isValid: _weaponCanRotate
                },
                ROTATORS: {
                    name: "rotators",
                    type: _createTypedArrayType(WEAPON_ROTATOR, {fixed: 2}),
                    isRequired: _weaponCanRotate,
                    isValid: _weaponCanRotate
                },
                FIRE_SOUND: {
                    name: "fireSound",
                    type: SOUND_DESCRIPTOR
                },
                SCORE_VALUE: {
                    name: "scoreValue",
                    type: NON_NEGATIVE_INTEGER,
                    defaultValue: 0
                }
            },
            /**
             * The descriptor object for propulsion classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            PROPULSION_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                FULL_NAME: {
                    name: "fullName",
                    type: BaseType.STRING,
                    optional: true,
                    getDerivedDefault: _getName,
                    updateOnValidate: true
                },
                SHADER: {
                    name: "shader",
                    type: SHADER_REFERENCE,
                    newValue: "particle"
                },
                TEXTURE: {
                    name: "texture",
                    type: TEXTURE_REFERENCE
                },
                COLOR: {
                    name: "color",
                    type: BaseType.COLOR4,
                    newValue: [1, 1, 1, 1]
                },
                REFERENCE_MASS: {
                    name: "referenceMass",
                    type: KILOGRAMS,
                    newValue: 1
                },
                THRUST: {
                    name: "thrust",
                    type: POSITIVE_METERS_PER_SECOND_SQUARED,
                    newValue: 1
                },
                ANGULAR_THRUST: {
                    name: "angularThrust",
                    type: POSITIVE_DEGREES_PER_SECOND_SQUARED,
                    newValue: 1
                },
                MAX_MOVE_BURN_LEVEL: {
                    name: "maxMoveBurnLevel",
                    type: POSITIVE_RATIO,
                    newValue: 0.5
                },
                MAX_TURN_BURN_LEVEL: {
                    name: "maxTurnBurnLevel",
                    type: POSITIVE_RATIO,
                    newValue: 0.5
                },
                THRUSTER_SOUND: {
                    name: "thrusterSound",
                    type: SOUND_DESCRIPTOR
                },
                SCORE_VALUE: {
                    name: "scoreValue",
                    type: NON_NEGATIVE_INTEGER,
                    defaultValue: 0
                }
            },
            _getDefaultJumpInDeceleration = function (data) {
                return data.jumpOutAcceleration + " " + METERS_PER_SECOND_SQUARED.unit;
            },
            _getDefaultJumpInDuration = function (data) {
                return data.jumpOutDuration + " " + MILLISECONDS.unit;
            },
            _getDefaultJumpInVelocity = function (data) {
                return data.prepareVelocity + " " + METERS_PER_SECOND.unit;
            },
            _getDefaultJumpInScaling = function (data) {
                return (data.jumpOutScaling || 1) + " " + SCALE.unit;
            },
            _getDefaultJumpInSound = function (data) {
                return SOUND_DESCRIPTOR.getPreviewText(data.jumpOutSound);
            },
            _getDefaultJumpInExplosion = function (data) {
                return data.jumpOutExplosion;
            },
            /**
             * The descriptor object for jump engine classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            JUMP_ENGINE_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                ENGAGE_SOUND: {
                    name: "engageSound",
                    type: SOUND_DESCRIPTOR
                },
                DISENGAGE_SOUND: {
                    name: "disengageSound",
                    type: SOUND_DESCRIPTOR
                },
                PREPARE_VELOCITY: {
                    name: "prepareVelocity",
                    type: NON_NEGATIVE_METERS_PER_SECOND
                },
                PREPARE_DURATION: {
                    name: "prepareDuration",
                    type: NON_NEGATIVE_MILLISECONDS
                },
                PREPARE_SOUND: {
                    name: "prepareSound",
                    type: SOUND_DESCRIPTOR
                },
                CANCEL_SOUND: {
                    name: "cancelSound",
                    type: SOUND_DESCRIPTOR
                },
                JUMP_OUT_ACCELERATION: {
                    name: "jumpOutAcceleration",
                    type: POSITIVE_METERS_PER_SECOND_SQUARED
                },
                JUMP_OUT_DURATION: {
                    name: "jumpOutDuration",
                    type: POSITIVE_MILLISECONDS
                },
                JUMP_OUT_SCALING: {
                    name: "jumpOutScaling",
                    type: POSITIVE_SCALE,
                    defaultValue: 1
                },
                JUMP_OUT_SOUND: {
                    name: "jumpOutSound",
                    type: SOUND_DESCRIPTOR
                },
                JUMP_OUT_EXPLOSION: {
                    name: "jumpOutExplosion",
                    type: EXPLOSION_CLASS_REFERENCE
                },
                JUMP_IN_DECELERATION: {
                    name: "jumpInDeceleration",
                    type: POSITIVE_METERS_PER_SECOND_SQUARED,
                    optional: true,
                    getDerivedDefault: _getDefaultJumpInDeceleration,
                    updateOnValidate: true
                },
                JUMP_IN_DURATION: {
                    name: "jumpInDuration",
                    type: POSITIVE_MILLISECONDS,
                    optional: true,
                    getDerivedDefault: _getDefaultJumpInDuration,
                    updateOnValidate: true
                },
                JUMP_IN_VELOCITY: {
                    name: "jumpInVelocity",
                    type: METERS_PER_SECOND,
                    optional: true,
                    getDerivedDefault: _getDefaultJumpInVelocity,
                    updateOnValidate: true
                },
                JUMP_IN_SCALING: {
                    name: "jumpInScaling",
                    type: POSITIVE_SCALE,
                    optional: true,
                    getDerivedDefault: _getDefaultJumpInScaling,
                    updateOnValidate: true
                },
                JUMP_IN_SOUND: {
                    name: "jumpInSound",
                    type: SOUND_DESCRIPTOR,
                    optional: true,
                    getDerivedDefault: _getDefaultJumpInSound,
                    updateOnValidate: true
                },
                JUMP_IN_EXPLOSION: {
                    name: "jumpInExplosion",
                    type: EXPLOSION_CLASS_REFERENCE,
                    optional: true,
                    getDerivedDefault: _getDefaultJumpInExplosion,
                    updateOnValidate: true
                }
            },
            /**
             * The descriptor object for shield classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            SHIELD_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                FULL_NAME: {
                    name: "fullName",
                    type: BaseType.STRING,
                    optional: true,
                    getDerivedDefault: _getName,
                    updateOnValidate: true
                },
                CAPACITY: {
                    name: "capacity",
                    type: POSITIVE_INTEGER
                },
                RECHARGE_DELAY: {
                    name: "rechargeDelay",
                    type: NON_NEGATIVE_MILLISECONDS
                },
                RECHARGE_RATE: {
                    name: "rechargeRate",
                    type: POSITIVE_PER_SECOND
                },
                RECHARGE_COLOR: {
                    name: "rechargeColor",
                    type: BaseType.COLOR3,
                    defaultValue: [1, 1, 1]
                },
                RECHARGE_ANIMATION_DURATION: {
                    name: "rechargeAnimationDuration",
                    type: POSITIVE_MILLISECONDS
                },
                RECHARGE_START_SOUND: {
                    name: "rechargeStartSound",
                    type: SOUND_DESCRIPTOR
                },
                SCORE_VALUE: {
                    name: "scoreValue",
                    type: NON_NEGATIVE_INTEGER,
                    defaultValue: 0
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT_TYPES = {
                baseType: BaseType.SET,
                name: "SpacecraftTypes",
                classReference: "spacecraftTypes"
            },
            /**
             * The descriptor object for spacecraft types, describing their properties
             * @type Editor~ItemDescriptor
             */
            SPACECRAFT_TYPE = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                IS_FIGHTER_TYPE: {
                    name: "isFighterType",
                    type: BaseType.BOOLEAN,
                    defaultValue: false
                },
                FULL_NAME: {
                    name: "fullName",
                    type: BaseType.STRING,
                    optional: true,
                    getDerivedDefault: _getName,
                    updateOnValidate: true
                },
                DESCRIPTION: {
                    name: "description",
                    type: LONG_STRING
                },
                GOOD_AGAINST: {
                    name: "goodAgainst",
                    type: SPACECRAFT_TYPES,
                    optional: true,
                    defaultText: "none"
                },
                BAD_AGAINST: {
                    name: "badAgainst",
                    type: SPACECRAFT_TYPES,
                    optional: true,
                    defaultText: "none"
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT_TURN_STYLE = {
                baseType: BaseType.ENUM,
                values: classes.SpacecraftTurnStyle
            },
            /**
             * @type Editor~TypeDescriptor
             */
            BODY = {
                baseType: BaseType.OBJECT,
                name: "Body",
                properties: {
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3
                    },
                    ROTATIONS: {
                        name: "rotations",
                        type: BaseType.ROTATIONS,
                        optional: true
                    },
                    SIZE: {
                        name: "size",
                        type: BaseType.VECTOR3
                    }
                }
            },
            _isArray = function (data) {
                return data.count > 1;
            },
            /**
             * @type Editor~TypeDescriptor
             */
            WEAPON_SLOT = {
                baseType: BaseType.OBJECT,
                name: "WeaponSlot",
                properties: {
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3
                    },
                    COUNT: {
                        name: "count",
                        type: POSITIVE_INTEGER,
                        defaultValue: 1
                    },
                    VECTOR: {
                        name: "vector",
                        type: BaseType.VECTOR3,
                        isValid: _isArray,
                        isRequired: _isArray
                    },
                    ROTATIONS: {
                        name: "rotations",
                        type: BaseType.ROTATIONS,
                        optional: true
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MISSILE_TUBE = {
                baseType: BaseType.OBJECT,
                name: "MissileTube",
                properties: {
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3
                    },
                    VECTOR: {
                        name: "vector",
                        type: BaseType.VECTOR3,
                        isValid: _isArray,
                        isRequired: _isArray
                    },
                    COUNT: {
                        name: "count",
                        type: POSITIVE_INTEGER,
                        defaultValue: 1
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MISSILE_LAUNCHER = {
                baseType: BaseType.OBJECT,
                name: "MissileLauncher",
                properties: {
                    TUBES: {
                        name: "tubes",
                        type: _createTypedArrayType(MISSILE_TUBE, {min: 1})
                    },
                    SIZE: {
                        name: "size",
                        type: MISSILE_SIZE
                    },
                    CAPACITY: {
                        name: "capacity",
                        type: POSITIVE_INTEGER
                    },
                    SALVO: {
                        name: "salvo",
                        type: POSITIVE_INTEGER,
                        defaultValue: 1
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            BASE_ORIENTATION = {
                baseType: BaseType.ENUM,
                values: camera.CameraOrientationConfiguration.BaseOrientation
            },
            /**
             * @type Editor~TypeDescriptor
             */
            POINT_TO_FALLBACK = {
                baseType: BaseType.ENUM,
                values: camera.CameraOrientationConfiguration.PointToFallback
            },
            /**
             * @type Editor~TypeDescriptor
             */
            OBJECT_VIEW_LOOK_AT_MODE = {
                baseType: BaseType.ENUM,
                values: classes.ObjectViewLookAtMode
            },
            _isFPS = function (data) {
                return !!data.fps;
            },
            _noLookAtSelf = function (data) {
                return data.lookAt !== classes.ObjectViewLookAtMode.SELF;
            },
            _followsPosition = function (data) {
                return (data.followsPosition !== undefined) ? data.followsPosition : _noLookAtSelf(data);
            },
            _pointsTowardObjects = function (data) {
                return !!data.lookAt && (data.lookAt !== classes.ObjectViewLookAtMode.NONE);
            },
            _canMove = function (data) {
                return !_followsPosition(data) || data.movable;
            },
            _canTurn = function (data) {
                return !_pointsTowardObjects(data);
            },
            _followsOrientation = function (data) {
                return (data.followsOrientation !== undefined) ? data.followsOrientation : _canTurn(data);
            },
            _canRotateAroundObject = function (data) {
                return _noLookAtSelf(data) && _followsPosition(data) && (!_followsOrientation(data) || data.turnable || data.rotations);
            },
            _turnableFPS = function (data) {
                return _isFPS(data) && !!data.turnable;
            },
            _canLookAt = function (data) {
                return !_followsOrientation(data) && !data.turnable;
            },
            _canStartRelative = function (data) {
                return !_followsPosition(data) && !data.rotationCenterIsObject;
            },
            _relativePosition = function (data) {
                return _followsPosition(data) || data.startsWithRelativePosition;
            },
            _canResetWhenLeavingConfines = function (data) {
                return (data.distanceRange || data.confines) && _relativePosition(data);
            },
            _requiresDistanceRange = function (data) {
                return (data.rotationCenterIsObject || _pointsTowardObjects(data)) && data.movable;
            },
            _canMoveRelative = function (data) {
                return _followsPosition(data) && _followsOrientation(data) && !data.rotationCenterIsObject && data.movable;
            },
            _canHaveDistanceRange = function (data) {
                return _canMove(data) && (_relativePosition(data) || _canTurn(data) || !data.confines);
            },
            _canHaveConfines = function (data) {
                return _canMove(data) && (_relativePosition(data) || _canTurn(data) || !data.distanceRange);
            },
            _canResetOnFocusChange = function (data) {
                return (_canMove(data) || data.turnable) && !(_pointsTowardObjects(data) && data.startsWithRelativePosition);
            },
            /**
             * @type Editor~TypeDescriptor
             */
            VIEW = {
                baseType: BaseType.OBJECT,
                name: "View",
                properties: {
                    NAME: {
                        name: "name",
                        type: BaseType.STRING
                    },
                    AIMING_VIEW: {
                        name: "aimingView",
                        type: BaseType.BOOLEAN,
                        defaultValue: false
                    },
                    FOV: {
                        name: "fov",
                        type: POSITIVE_DEGREES_180,
                        globalDefault: true,
                        settingName: config.CAMERA_SETTINGS.DEFAULT_FOV
                    },
                    FOV_RANGE: {
                        name: "fovRange",
                        type: _createRangeType(true, true, POSITIVE_DEGREES_180),
                        optional: true,
                        defaultText: "fixed"
                    },
                    SPAN: {
                        name: "span",
                        type: POSITIVE_LENGTH,
                        globalDefault: true,
                        settingName: config.CAMERA_SETTINGS.DEFAULT_SPAN
                    },
                    FPS: {
                        name: "fps",
                        type: BaseType.BOOLEAN,
                        defaultValue: false
                    },
                    FOLLOWS_POSITION: {
                        name: "followsPosition",
                        type: BaseType.BOOLEAN,
                        defaultValue: true,
                        isValid: _noLookAtSelf
                    },
                    FOLLOWS_ORIENTATION: {
                        name: "followsOrientation",
                        type: BaseType.BOOLEAN,
                        defaultValue: true,
                        isValid: _canTurn
                    },
                    BASE_ORIENTATION: {
                        name: "baseOrientation",
                        type: BASE_ORIENTATION,
                        globalDefault: true,
                        settingName: config.CAMERA_SETTINGS.DEFAULT_BASE_ORIENTATION,
                        isValid: _isFPS
                    },
                    POINT_TO_FALLBACK: {
                        name: "pointToFallback",
                        type: POINT_TO_FALLBACK,
                        globalDefault: true,
                        settingName: config.CAMERA_SETTINGS.DEFAULT_POINT_TO_FALLBACK,
                        isValid: _pointsTowardObjects
                    },
                    STARTS_WITH_RELATIVE_POSITION: {
                        name: "startsWithRelativePosition",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _canStartRelative
                    },
                    LOOK_AT: {
                        name: "lookAt",
                        type: OBJECT_VIEW_LOOK_AT_MODE,
                        defaultValue: classes.ObjectViewLookAtMode.NONE,
                        isValid: _canLookAt
                    },
                    MOVABLE: {
                        name: "movable",
                        type: BaseType.BOOLEAN,
                        defaultValue: false
                    },
                    TURNABLE: {
                        name: "turnable",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _canTurn
                    },
                    ALPHA_RANGE: {
                        name: "alphaRange",
                        type: _createRangeType(true, true, DEGREES),
                        optional: true,
                        defaultText: "unlimited",
                        isValid: _turnableFPS
                    },
                    BETA_RANGE: {
                        name: "betaRange",
                        type: _createRangeType(true, true, DEGREES_BETA),
                        defaultValue: [-90, 90],
                        isValid: _turnableFPS
                    },
                    ROTATION_CENTER_IS_OBJECT: {
                        name: "rotationCenterIsObject",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _canRotateAroundObject
                    },
                    DISTANCE_RANGE: {
                        name: "distanceRange",
                        type: _createRangeType(false, false, DISTANCE),
                        isRequired: _requiresDistanceRange,
                        updateOnValidate: true,
                        defaultText: "unlimited",
                        isValid: _canHaveDistanceRange
                    },
                    CONFINES: {
                        name: "confines",
                        type: BaseType.CONFINES,
                        optional: true,
                        defaultText: "no confines",
                        isValid: _canHaveConfines
                    },
                    RESETS_WHEN_LEAVING_CONFINES: {
                        name: "resetsWhenLeavingConfines",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _canResetWhenLeavingConfines
                    },
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3
                    },
                    ROTATIONS: {
                        name: "rotations",
                        type: BaseType.ROTATIONS,
                        optional: true
                    },
                    MOVES_RELATIVE_TO_OBJECT: {
                        name: "movesRelativeToObject",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _canMoveRelative
                    },
                    RESETS_ON_FOCUS_CHANGE: {
                        name: "resetsOnFocusChange",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _canResetOnFocusChange
                    },
                    EXCLUDE_FROM_CYCLE: {
                        name: "excludeFromCycle",
                        type: BaseType.BOOLEAN,
                        defaultValue: false
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            WEAPON = {
                baseType: BaseType.OBJECT,
                name: "Weapon",
                getName: function (data) {
                    return data.class;
                },
                properties: {
                    CLASS: {
                        name: "class",
                        type: WEAPON_CLASS_REFERENCE
                    },
                    SLOT_INDEX: {
                        name: "slotIndex",
                        type: NON_NEGATIVE_INTEGER,
                        optional: true,
                        defaultText: "auto"
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MISSILE = {
                baseType: BaseType.OBJECT,
                name: "Missile",
                getName: function (data) {
                    return data.class + " (" + data.amount + ")";
                },
                properties: {
                    CLASS: {
                        name: "class",
                        type: MISSILE_CLASS_REFERENCE
                    },
                    AMOUNT: {
                        name: "amount",
                        type: POSITIVE_INTEGER
                    },
                    LAUNCHER_INDEX: {
                        name: "launcherIndex",
                        type: NON_NEGATIVE_INTEGER,
                        optional: true,
                        defaultText: "auto"
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            PROPULSION = {
                baseType: BaseType.OBJECT,
                name: "Propulsion",
                getPreviewText: function (instance) {
                    return instance.class;
                },
                properties: {
                    CLASS: {
                        name: "class",
                        type: PROPULSION_CLASS_REFERENCE
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            JUMP_ENGINE = {
                baseType: BaseType.OBJECT,
                name: "JumpEngine",
                getPreviewText: function (instance) {
                    return instance.class;
                },
                properties: {
                    CLASS: {
                        name: "class",
                        type: JUMP_ENGINE_CLASS_REFERENCE
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SHIELD = {
                baseType: BaseType.OBJECT,
                name: "Shield",
                getPreviewText: function (instance) {
                    return instance.class;
                },
                properties: {
                    CLASS: {
                        name: "class",
                        type: SHIELD_CLASS_REFERENCE
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            LOADOUT = {
                baseType: BaseType.OBJECT,
                name: "Loadout",
                properties: {
                    NAME: {
                        name: "name",
                        type: BaseType.STRING
                    },
                    WEAPONS: {
                        name: "weapons",
                        type: _createTypedArrayType(WEAPON),
                        optional: true,
                        defaultText: "none"
                    },
                    MISSILES: {
                        name: "missiles",
                        type: _createTypedArrayType(MISSILE),
                        optional: true,
                        defaultText: "none"
                    },
                    PROPULSION: {
                        name: "propulsion",
                        type: PROPULSION,
                        optional: true,
                        defaultText: "none"
                    },
                    JUMP_ENGINE: {
                        name: "jumpEngine",
                        type: JUMP_ENGINE,
                        optional: true,
                        defaultText: "none"
                    },
                    SHIELD: {
                        name: "shield",
                        type: SHIELD,
                        optional: true,
                        defaultText: "none"
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            DAMAGE_INDICATOR = {
                baseType: BaseType.OBJECT,
                name: "DamageIndicator",
                getName: function (data) {
                    return data.hullIntegrity + "% - " + data.class;
                },
                properties: {
                    HULL_INTEGRITY: {
                        name: "hullIntegrity",
                        type: POSITIVE_INT_PERCENT,
                        newValue: 50
                    },
                    CLASS: {
                        name: "class",
                        type: EXPLOSION_CLASS_REFERENCE
                    }
                }
            },
            _isSpotLight = function (data) {
                return !!data.spotDirection;
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT_LIGHT = {
                baseType: BaseType.OBJECT,
                name: "Light",
                properties: {
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3
                    },
                    COLOR: {
                        name: "color",
                        type: BaseType.COLOR3,
                        defaultValue: [1, 1, 1]
                    },
                    INTENSITY: {
                        name: "intensity",
                        type: POSITIVE_NUMBER,
                        newValue: 10
                    },
                    SPOT_DIRECTION: {
                        name: "spotDirection",
                        type: BaseType.VECTOR3,
                        optional: true,
                        newValue: [0, 1, 0],
                        defaultText: "point light"
                    },
                    SPOT_CUTOFF_ANGLE: {
                        name: "spotCutoffAngle",
                        type: NON_NEGATIVE_DEGREES,
                        isValid: _isSpotLight,
                        newValue: 25
                    },
                    SPOT_FULL_INTENSITY_ANGLE: {
                        name: "spotFullIntensityAngle",
                        type: NON_NEGATIVE_DEGREES,
                        isValid: _isSpotLight,
                        newValue: 5
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            BLINKER = {
                baseType: BaseType.OBJECT,
                name: "Blinker",
                properties: {
                    PARTICLE: {
                        name: "particle",
                        type: PARTICLE_DESCRIPTOR
                    },
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3
                    },
                    PERIOD: {
                        name: "period",
                        type: POSITIVE_MILLISECONDS,
                        newValue: 1000
                    },
                    BLINKS: {
                        name: "blinks",
                        type: NON_NEGATIVE_MILLISECONDS_ARRAY
                    },
                    INTENSITY: {
                        name: "intensity",
                        type: POSITIVE_NUMBER,
                        newValue: 10
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            LOADOUT_REFERENCE = {
                baseType: BaseType.ENUM,
                getValues: function (parent) {
                    if (parent.loadouts) {
                        return parent.loadouts.map(function (loadout) {
                            return loadout.name;
                        });
                    }
                    return [];
                }
            },
            _shownInDatabase = function (data) {
                return data.showInDatabase !== false;
            },
            _isShip = function (data) {
                return !!data.type && !classes.getSpacecraftType(data.type).isFighterType();
            },
            _hasLoadouts = function (data) {
                return !!data.loadouts && (data.loadouts.length > 0);
            },
            /**
             * The descriptor object for spacecraft classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            SPACECRAFT_CLASS = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                BASED_ON: {
                    name: "basedOn",
                    type: SPACECRAFT_CLASS_REFERENCE,
                    optional: true,
                    defaultText: "none"
                },
                TYPE: {
                    name: "type",
                    type: SPACECRAFT_TYPE_REFERENCE
                },
                FULL_NAME: {
                    name: "fullName",
                    type: BaseType.STRING,
                    optional: true,
                    getDerivedDefault: _getName,
                    updateOnValidate: true
                },
                SHOW_IN_DATABASE: {
                    name: "showInDatabase",
                    type: BaseType.BOOLEAN,
                    defaultValue: true
                },
                DESCRIPTION: {
                    name: "description",
                    type: LONG_STRING,
                    isValid: _shownInDatabase,
                    newValue: "-"
                },
                HITPOINTS: {
                    name: "hitpoints",
                    type: POSITIVE_INTEGER
                },
                ARMOR: {
                    name: "armor",
                    type: NON_NEGATIVE_NUMBER,
                    defaultValue: 0
                },
                TURN_STYLE: {
                    name: "turnStyle",
                    type: SPACECRAFT_TURN_STYLE,
                    isValid: _isShip,
                    defaultValue: classes.SpacecraftTurnStyle.YAW_PITCH
                },
                ATTACK_VECTOR: {
                    name: "attackVector",
                    type: BaseType.VECTOR3,
                    isValid: _isShip,
                    defaultValue: [0, 1, 0]
                },
                ATTACK_THRESHOLD_ANGLE: {
                    name: "attackThresholdAngle",
                    type: NON_NEGATIVE_DEGREES_180,
                    isValid: _isShip,
                    defaultValue: 0
                },
                MODEL: {
                    name: "model",
                    type: MODEL_REFERENCE
                },
                SHADER: {
                    name: "shader",
                    type: SHADER_REFERENCE
                },
                TEXTURE: {
                    name: "texture",
                    type: TEXTURE_REFERENCE
                },
                FACTION_COLOR: {
                    name: "factionColor",
                    type: BaseType.COLOR4,
                    optional: true,
                    defaultText: "none"
                },
                DEFAULT_LUMINOSITY_FACTORS: {
                    name: "defaultLuminosityFactors",
                    type: LUMINOSITY_FACTOR_PAIRS,
                    optional: true,
                    defaultText: "all zeros"
                },
                MASS: {
                    name: "mass",
                    type: KILOGRAMS,
                    newValue: 10000
                },
                DRAG_FACTOR: {
                    name: "dragFactor",
                    type: NON_NEGATIVE_SCALE,
                    defaultValue: 1
                },
                LOCKING_TIME_FACTOR: {
                    name: "lockingTimeFactor",
                    type: NON_NEGATIVE_SCALE,
                    defaultValue: 1
                },
                BODIES: {
                    name: "bodies",
                    type: _createTypedArrayType(BODY, {min: 1})
                },
                WEAPON_SLOTS: {
                    name: "weaponSlots",
                    type: _createTypedArrayType(WEAPON_SLOT, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                MISSILE_LAUNCHERS: {
                    name: "missileLaunchers",
                    type: _createTypedArrayType(MISSILE_LAUNCHER, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                THRUSTER_SLOTS: {
                    name: "thrusterSlots",
                    type: _createTypedArrayType(THRUSTER_SLOT, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                VIEWS: {
                    name: "views",
                    type: _createTypedArrayType(VIEW, {min: 1})
                },
                LOADOUTS: {
                    name: "loadouts",
                    type: _createTypedArrayType(LOADOUT, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                DEFAULT_LOADOUT: {
                    name: "defaultLoadout",
                    type: LOADOUT_REFERENCE,
                    isValid: _hasLoadouts,
                    optional: true,
                    defaultText: "none",
                    updateOnValidate: true
                },
                HUM_SOUND: {
                    name: "humSound",
                    type: SOUND_DESCRIPTOR,
                    optional: true,
                    defaultText: "none"
                },
                EXPLOSION: {
                    name: "explosion",
                    type: EXPLOSION_CLASS_REFERENCE
                },
                SHOW_TIME_RATIO_DURING_EXPLOSION: {
                    name: "showTimeRatioDuringExplosion",
                    type: RATIO,
                    newValue: 0.5
                },
                DAMAGE_INDICATORS: {
                    name: "damageIndicators",
                    type: _createTypedArrayType(DAMAGE_INDICATOR, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                LIGHTS: {
                    name: "lights",
                    type: _createTypedArrayType(SPACECRAFT_LIGHT, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                BLINKERS: {
                    name: "blinkers",
                    type: _createTypedArrayType(BLINKER, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                SCORE_VALUE: {
                    name: "scoreValue",
                    type: NON_NEGATIVE_INTEGER,
                    defaultValue: 0
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SKYBOX = {
                baseType: BaseType.OBJECT,
                name: "Skybox",
                getName: function (data) {
                    return data.class;
                },
                properties: {
                    CLASS: {
                        name: "class",
                        type: SKYBOX_CLASS_REFERENCE
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            BACKGROUND_OBJECT_POSITION = {
                baseType: BaseType.OBJECT,
                name: "BackgroundObjectPosition",
                getPreviewText: function (data) {
                    return (data.angleAlpha || 0) + "°, " + (data.angleBeta || 0) + "°" + ((data.angleGamma !== undefined) ? ", " + data.angleGamma + "°" : "");
                },
                properties: {
                    ANGLE_ALPHA: {
                        name: "angleAlpha",
                        type: DEGREES,
                        defaultValue: 0
                    },
                    ANGLE_BETA: {
                        name: "angleBeta",
                        type: DEGREES,
                        defaultValue: 0
                    },
                    ANGLE_GAMMA: {
                        name: "angleGamma",
                        type: DEGREES,
                        defaultValue: 0
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            BACKGROUND_OBJECT = {
                baseType: BaseType.OBJECT,
                name: "BackgroundObject",
                getName: function (data) {
                    return data.class + " (" + data.size + ")";
                },
                properties: {
                    CLASS: {
                        name: "class",
                        type: BACKGROUND_OBJECT_CLASS_REFERENCE
                    },
                    SIZE: {
                        name: "size",
                        type: POSITIVE_SCALE,
                        newValue: 100
                    },
                    POSITION: {
                        name: "position",
                        type: BACKGROUND_OBJECT_POSITION
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            DUST_CLOUD = {
                baseType: BaseType.OBJECT,
                name: "DustCloud",
                getName: function (data) {
                    return data.class;
                },
                properties: {
                    CLASS: {
                        name: "class",
                        type: DUST_CLOUD_CLASS_REFERENCE
                    }
                }
            },
            _effectIsRelative = function (data) {
                return data.relativeToCamera !== false;
            },
            PARTICLE_EFFECT = {
                baseType: BaseType.OBJECT,
                name: "ParticleEffect",
                getName: function (data) {
                    return data.class;
                },
                properties: {
                    CLASS: {
                        name: "class",
                        type: EXPLOSION_CLASS_REFERENCE,
                        newValue: "blueNebula"
                    },
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3,
                        defaultValue: [0, 0, 0]
                    },
                    RELATIVE_TO_CAMERA: {
                        name: "relativeToCamera",
                        type: BaseType.BOOLEAN,
                        defaultValue: true
                    },
                    DIRECTION: {
                        name: "direction",
                        type: BaseType.VECTOR3,
                        defaultValue: [0, 0, 1]
                    },
                    RELATIVE_DIRECTION: {
                        name: "relativeDirection",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _effectIsRelative
                    }
                }
            },
            /**
             * The descriptor object for spacecraft classes, describing their properties
             * @type Editor~ItemDescriptor
             */
            ENVIRONMENT = {
                NAME: {
                    name: "name",
                    type: BaseType.STRING
                },
                LOCATION: {
                    name: "location",
                    type: BaseType.STRING
                },
                COLOR: {
                    name: "color",
                    type: BaseType.COLOR4,
                    defaultValue: [0, 0, 0, 0]
                },
                SKYBOXES: {
                    name: "skyboxes",
                    type: _createTypedArrayType(SKYBOX, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                BACKGROUND_OBJECTS: {
                    name: "backgroundObjects",
                    type: _createTypedArrayType(BACKGROUND_OBJECT, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                DUST_CLOUDS: {
                    name: "dustClouds",
                    type: _createTypedArrayType(DUST_CLOUD, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                PARTICLE_EFFECTS: {
                    name: "particleEffects",
                    type: _createTypedArrayType(PARTICLE_EFFECT, {min: 1}),
                    optional: true,
                    defaultText: "none"
                },
                SHADOWS: {
                    name: "shadows",
                    type: BaseType.BOOLEAN,
                    defaultValue: true
                },
                AMBIENT_COLOR: {
                    name: "ambientColor",
                    type: BaseType.COLOR3,
                    defaultValue: [0, 0, 0]
                },
                DRAG: {
                    name: "drag",
                    type: NON_NEGATIVE_NUMBER,
                    defaultValue: 0
                },
                ANGULAR_DRAG: {
                    name: "angularDrag",
                    type: NON_NEGATIVE_NUMBER,
                    defaultValue: 0
                },
                LOCKING_TIME_FACTOR: {
                    name: "lockingTimeFactor",
                    type: NON_NEGATIVE_SCALE,
                    defaultValue: 1
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TEAM_FACTION = {
                baseType: BaseType.ENUM,
                getValues: function () {
                    var prefix = strings.FACTION.PREFIX.name, prefixLength = prefix.length;
                    return strings.getKeys(prefix).map(function (key) {
                        return key.substring(prefixLength);
                    });
                }
            },
            _teamHasNoName = function (data) {
                return !data.name;
            },
            _teamHasNoFaction = function (data) {
                return !data.faction;
            },
            _getDefaultTeamName = function (data) {
                return data.faction;
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TEAM = {
                baseType: BaseType.OBJECT,
                name: "Team",
                unpack: function (stringValue) {
                    return {
                        name: stringValue,
                        faction: stringValue
                    };
                },
                getName: function (instance) {
                    return instance.name || instance.faction;
                },
                properties: {
                    NAME: {
                        name: "name",
                        type: BaseType.STRING,
                        isRequired: _teamHasNoFaction,
                        getDerivedDefault: _getDefaultTeamName,
                        updateOnValidate: true
                    },
                    FACTION: {
                        name: "faction",
                        type: TEAM_FACTION,
                        isRequired: _teamHasNoName,
                        updateOnValidate: true
                    },
                    COLOR: {
                        name: "color",
                        type: BaseType.COLOR4,
                        optional: true
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            CONDITION_TYPE = {
                baseType: BaseType.ENUM,
                values: missions.ConditionType
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT_REFERENCE = {
                baseType: BaseType.ENUM,
                name: "Spacecraft",
                getValues: function (parent, topParent) {
                    var result = [], i, j, spacecraft;
                    if (topParent.spacecrafts) {
                        for (i = 0; i < topParent.spacecrafts.length; i++) {
                            spacecraft = topParent.spacecrafts[i];
                            if (spacecraft.name) {
                                result.push(spacecraft.name);
                            } else if (spacecraft.squad) {
                                if (spacecraft.count) {
                                    for (j = 0; j < spacecraft.count; j++) {
                                        result.push(spacecraft.squad + " " + (j + 1));
                                    }
                                } else {
                                    result.push(spacecraft.squad);
                                }
                            } else if (spacecraft.count && spacecraft.names) {
                                for (j = 0; j < Math.min(spacecraft.count, spacecraft.names.length); j++) {
                                    result.push(spacecraft.names[j]);
                                }
                            }
                        }
                    }
                    return result;
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SQUAD_REFERENCE = {
                baseType: BaseType.ENUM,
                name: "Squad",
                getValues: function (parent, topParent) {
                    var result = [], i, spacecraft, squad;
                    if (topParent.spacecrafts) {
                        for (i = 0; i < topParent.spacecrafts.length; i++) {
                            spacecraft = topParent.spacecrafts[i];
                            if (spacecraft.squad) {
                                if (spacecraft.squad.indexOf(" ") < 0) {
                                    result.push(spacecraft.squad);
                                } else {
                                    squad = spacecraft.squad.split(" ")[0];
                                    if (result.indexOf(squad) < 0) {
                                        result.push(squad);
                                    }
                                }
                            }
                        }
                    }
                    return result;
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TEAM_REFERENCE = {
                baseType: BaseType.ENUM,
                name: "Team",
                getValues: function (parent, topParent) {
                    if (topParent.teams) {
                        return topParent.teams.filter(function (team) {
                            return !!team.name || !!team.faction;
                        }).map(function (team) {
                            return team.name || team.faction;
                        });
                    }
                    return [];
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SUBJECT_GROUP = {
                baseType: BaseType.OBJECT,
                name: "SubjectGroup",
                getPreviewText: function (instance) {
                    var subjects = [];
                    if (instance.spacecrafts) {
                        subjects = subjects.concat(instance.spacecrafts);
                    }
                    if (instance.squads) {
                        subjects = subjects.concat(instance.squads);
                    }
                    if (instance.teams) {
                        subjects = subjects.concat(instance.teams);
                    }
                    if (subjects.length === 0) {
                        return "none";
                    }
                    if (subjects.length === 1) {
                        return subjects[0];
                    }
                    if (subjects.length === 2) {
                        return subjects[0] + ", " + subjects[1];
                    }
                    return subjects[0] + ", " + subjects[1] + "...";
                },
                properties: {
                    SPACECRAFTS: {
                        name: "spacecrafts",
                        type: _createTypedArrayType(SPACECRAFT_REFERENCE),
                        optional: true
                    },
                    SQUADS: {
                        name: "squads",
                        type: _createTypedArrayType(SQUAD_REFERENCE),
                        optional: true
                    },
                    TEAMS: {
                        name: "teams",
                        type: _createTypedArrayType(TEAM_REFERENCE),
                        optional: true
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            DESTROYED_CONDITION_WHICH = {
                baseType: BaseType.ENUM,
                values: missions.DestroyedConditionWhich
            },
            /**
             * @type Editor~TypeDescriptor
             */
            COUNT_CONDITION_RELATION = {
                baseType: BaseType.ENUM,
                values: missions.CountConditionRelation
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TIME_CONDITION_WHEN = {
                baseType: BaseType.ENUM,
                values: missions.TimeConditionWhen
            },
            /**
             * @type Editor~TypeDescriptor
             */
            EVENT_REFERENCE = {
                baseType: BaseType.ENUM,
                getValues: function (parent, topParent) {
                    if (topParent.events) {
                        return topParent.events.filter(function (event) {
                            return !!event.name;
                        }).map(function (event) {
                            return event.name;
                        });
                    }
                    return [];
                }
            },
            _parentIsDestroyedCondition = function (data, parent) {
                return !!parent && (parent.type === missions.ConditionType.DESTROYED);
            },
            _parentIsCountCondition = function (data, parent) {
                return !!parent && (parent.type === missions.ConditionType.COUNT);
            },
            _parentIsTimeCondition = function (data, parent) {
                return !!parent && (parent.type === missions.ConditionType.TIME);
            },
            _isRepeatTime = function (data, parent) {
                return _parentIsTimeCondition(data, parent) && (data.when === missions.TimeConditionWhen.REPEAT);
            },
            /**
             * A merge of all the different possible condition parameters
             * @type Editor~TypeDescriptor
             */
            CONDITION_PARAMS = {
                baseType: BaseType.OBJECT,
                name: "ConditionParams",
                getPreviewText: function (instance) {
                    // DestroyedCondition params:
                    if (instance.which) {
                        return instance.which;
                    }
                    // CountCondition params:
                    if (instance.relation !== undefined) {
                        return instance.relation + " " + instance.count;
                    }
                    // TimeCondition params:
                    if (instance.when !== undefined) {
                        return instance.when + (instance.maxCount ? " (" + instance.maxCount + "x)" : "") + ": " + utils.getTimeString(instance.time) + (instance.start ? " after " + instance.start : "");
                    }
                    return "none";
                },
                properties: {
                    // DestroyedCondition params:
                    WHICH: {
                        name: "which",
                        type: DESTROYED_CONDITION_WHICH,
                        isRequired: _parentIsDestroyedCondition,
                        isValid: _parentIsDestroyedCondition
                    },
                    // CountCondition params:
                    COUNT: {
                        name: "count",
                        type: NON_NEGATIVE_INTEGER,
                        isRequired: _parentIsCountCondition,
                        isValid: _parentIsCountCondition
                    },
                    RELATION: {
                        name: "relation",
                        type: COUNT_CONDITION_RELATION,
                        isRequired: _parentIsCountCondition,
                        isValid: _parentIsCountCondition
                    },
                    // TimeCondition params:
                    TIME: {
                        name: "time",
                        type: NON_NEGATIVE_MILLISECONDS,
                        isRequired: _parentIsTimeCondition,
                        isValid: _parentIsTimeCondition
                    },
                    WHEN: {
                        name: "when",
                        type: TIME_CONDITION_WHEN,
                        isRequired: _parentIsTimeCondition,
                        isValid: _parentIsTimeCondition
                    },
                    START: {
                        name: "start",
                        type: EVENT_REFERENCE,
                        optional: true,
                        isValid: _parentIsTimeCondition,
                        defaultText: "mission start"
                    },
                    MAX_COUNT: {
                        name: "maxCount",
                        type: POSITIVE_INTEGER,
                        optional: true,
                        isValid: _isRepeatTime,
                        defaultText: "infinite"
                    },
                    START_VALUE: {
                        name: "startValue",
                        type: MILLISECONDS,
                        optional: true,
                        isValid: _isRepeatTime,
                        defaultValue: 0
                    }
                }
            },
            _conditionCanHaveSubjects = function (data) {
                return (data.type === missions.ConditionType.DESTROYED) || (data.type === missions.ConditionType.COUNT);
            },
            _conditionCanHaveParams = function (data) {
                return ((data.type === missions.ConditionType.DESTROYED) && data.subjects && new missions.SubjectGroup(data.subjects).isMulti()) || 
                        (data.type === missions.ConditionType.COUNT) || (data.type === missions.ConditionType.TIME);
            },
            _conditionMustHaveParams = function (data) {
                return (data.type === missions.ConditionType.COUNT) || (data.type === missions.ConditionType.TIME);
            },
            _getConditionParamDefault = function (data) {
                return (data.type === missions.ConditionType.DESTROYED) ? "all" : "none";
            },
            /**
             * @type Editor~TypeDescriptor
             */
            CONDITION = {
                baseType: BaseType.OBJECT,
                name: "Condition",
                getName: function (instance) {
                    if (instance.type) {
                        return instance.type;
                    }
                    return "condition";
                },
                getPreviewText: function (instance) {
                    if (instance.type) {
                        switch (instance.type) {
                            case missions.ConditionType.COUNT:
                                return "count of " + SUBJECT_GROUP.getPreviewText(instance.subjects || utils.EMPTY_OBJECT) + " " + CONDITION_PARAMS.getPreviewText(instance.params || utils.EMPTY_OBJECT);
                            case missions.ConditionType.DESTROYED:
                                return ((instance.params && instance.params.which === missions.DestroyedConditionWhich.ANY) ? "any of " : "") + SUBJECT_GROUP.getPreviewText(instance.subjects || utils.EMPTY_OBJECT) + " destroyed";
                            case missions.ConditionType.TIME:
                                return instance.params ? CONDITION_PARAMS.getPreviewText(instance.params) : "time";
                        }
                        return instance.type;
                    }
                    return "condition";
                },
                properties: {
                    TYPE: {
                        name: "type",
                        type: CONDITION_TYPE
                    },
                    SUBJECTS: {
                        name: "subjects",
                        type: SUBJECT_GROUP,
                        isRequired: _conditionCanHaveSubjects,
                        isValid: _conditionCanHaveSubjects
                    },
                    PARAMS: {
                        name: "params",
                        type: CONDITION_PARAMS,
                        isRequired: _conditionMustHaveParams,
                        isValid: _conditionCanHaveParams,
                        updateOnValidate: true,
                        getDerivedDefault: _getConditionParamDefault
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TRIGGER_WHICH = {
                baseType: BaseType.ENUM,
                values: missions.TriggerWhich
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TRIGGER_WHEN = {
                baseType: BaseType.ENUM,
                values: missions.TriggerWhen
            },
            _triggerHasConditions = function (data) {
                return data.conditions && (data.conditions.length > 0);
            },
            _triggerHasMultipleConditions = function (data) {
                return data.conditions && (data.conditions.length > 1);
            },
            _getTriggerWhenString = function (when, plural) {
                switch (when) {
                    case missions.TriggerWhen.BECOMES_TRUE:
                        return "";
                    case missions.TriggerWhen.BECOMES_FALSE:
                        return (plural ? "become" : "becomes") + " false";
                }
            },
            _getTriggerDefaultOnce = function (data) {
                var i;
                if (data.conditions) {
                    for (i = 0; i < data.conditions.length; i++) {
                        if (missions.createCondition(data.conditions[i]).canChangeMultipleTimes()) {
                            return false;
                        }
                    }
                }
                return true;
            },
            _isTriggerOnceValid = function (data) {
                return !_getTriggerDefaultOnce(data);
            },
            _triggerIsOneShot = function (data) {
                return (data.once === true) ||
                        ((data.once === undefined) && _getTriggerDefaultOnce(data));
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TRIGGER = {
                baseType: BaseType.OBJECT,
                name: "Trigger",
                getPreviewText: function (instance) {
                    var result = (instance.delay ? utils.getTimeString(instance.delay) + " after " : "");
                    if (instance.conditions && (instance.conditions.length > 0)) {
                        if (instance.conditions.length > 1) {
                            result = result + ((instance.which === missions.TriggerWhich.ANY) ? "any of " : "") + instance.conditions.length + " conditions";
                        } else {
                            result = result + CONDITION.getPreviewText(instance.conditions[0]);
                        }
                        return result + (instance.when ? " " + _getTriggerWhenString(instance.when, instance.conditions.length > 1) : "");
                    }
                    return result + "mission start";
                },
                properties: {
                    CONDITIONS: {
                        name: "conditions",
                        type: _createTypedArrayType(CONDITION, {min: 1}),
                        optional: true
                    },
                    WHICH: {
                        name: "which",
                        type: TRIGGER_WHICH,
                        defaultValue: missions.TriggerWhich.ALL,
                        isValid: _triggerHasMultipleConditions
                    },
                    WHEN: {
                        name: "when",
                        type: TRIGGER_WHEN,
                        defaultValue: missions.TriggerWhen.BECOMES_TRUE,
                        isValid: _triggerHasConditions
                    },
                    ONCE: {
                        name: "once",
                        type: BaseType.BOOLEAN,
                        getDerivedDefault: _getTriggerDefaultOnce,
                        isValid: _isTriggerOnceValid,
                        optional: true
                    },
                    DELAY: {
                        name: "delay",
                        type: NON_NEGATIVE_MILLISECONDS,
                        defaultValue: 0,
                        isValid: _triggerIsOneShot
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            ACTION_TYPE = {
                baseType: BaseType.ENUM,
                values: missions.ActionType
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT_COMMAND = {
                baseType: BaseType.ENUM,
                values: ai.SpacecraftCommand
            },
            /**
             * @type Editor~TypeDescriptor
             */
            JUMP_COMMAND_WAY = {
                baseType: BaseType.ENUM,
                values: ai.JumpCommandWay
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT_FORMATION = {
                baseType: BaseType.ENUM,
                values: spacecraft.SpacecraftFormation
            },
            /**
             * @type Editor~TypeDescriptor
             */
            FORMATION = {
                baseType: BaseType.OBJECT,
                name: "SpacecraftFormation",
                getPreviewText: function (instance) {
                    return instance.type + (instance.spacing ? " (" + instance.spacing.join(", ") + ")" : "");
                },
                properties: {
                    TYPE: {
                        name: "type",
                        type: SPACECRAFT_FORMATION
                    },
                    SPACING: {
                        name: "spacing",
                        type: BaseType.VECTOR3
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            JUMP_COMMAND_PARAMS = {
                baseType: BaseType.OBJECT,
                name: "JumpCommandParams",
                getPreviewText: function (instance) {
                    return (instance.way || "") + (instance.anchor ? " (" + instance.anchor + ")" : "");
                },
                properties: {
                    WAY: {
                        name: "way",
                        type: JUMP_COMMAND_WAY,
                        optional: true
                    },
                    FORMATION: {
                        name: "formation",
                        type: FORMATION,
                        optional: true
                    },
                    ANCHOR: {
                        name: "anchor",
                        type: SPACECRAFT_REFERENCE,
                        optional: true
                    },
                    DISTANCE: {
                        name: "distance",
                        type: DISTANCE,
                        optional: true
                    },
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3,
                        optional: true
                    },
                    ROTATIONS: {
                        name: "rotations",
                        type: BaseType.ROTATIONS,
                        optional: true
                    },
                    RELATIVE: {
                        name: "relative",
                        type: BaseType.BOOLEAN,
                        optional: true
                    },
                    FALLBACK_POSITION: {
                        name: "fallbackPosition",
                        type: BaseType.VECTOR3,
                        optional: true
                    },
                    FALLBACK_ROTATIONS: {
                        name: "fallbackRotations",
                        type: BaseType.ROTATIONS,
                        optional: true
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TARGET_COMMAND_PARAMS = {
                baseType: BaseType.OBJECT,
                name: "TargetCommandParams",
                getPreviewText: function (instance) {
                    var result;
                    if (instance.single) {
                        result = instance.single;
                    } else if (instance.list) {
                        result = "list (" + instance.list.length + ")";
                    } else if (instance.squads) {
                        result = "squads (" + instance.squads.length + ")";
                    } else if (instance.none) {
                        result = "none";
                    }
                    if (instance.priority) {
                        result += "!";
                    }
                    return result;
                },
                properties: {
                    SINGLE: {
                        name: "single",
                        type: SPACECRAFT_REFERENCE,
                        optional: true
                    },
                    LIST: {
                        name: "list",
                        type: _createTypedArrayType(SPACECRAFT_REFERENCE),
                        optional: true
                    },
                    SQUADS: {
                        name: "squads",
                        type: _createTypedArrayType(SQUAD_REFERENCE),
                        optional: true
                    },
                    NONE: {
                        name: "none",
                        type: BaseType.BOOLEAN,
                        optional: true
                    },
                    PRIORITY: {
                        name: "priority",
                        type: BaseType.BOOLEAN,
                        optional: true
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            HUD_SECTION = {
                baseType: BaseType.ENUM,
                values: battle.HUDSection
            },
            /**
             * @type Editor~TypeDescriptor
             */
            HUD_SECTION_STATE = {
                baseType: BaseType.ENUM,
                values: battle.HUDSectionState
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MESSAGE_REFERENCE = {
                baseType: BaseType.ENUM,
                getValues: function (parent, topParent, itemName) {
                    var prefix = strings.MISSION.PREFIX.name + utils.getFilenameWithoutExtension(itemName) + strings.MISSION.MESSAGES_SUFFIX.name, prefixLength = prefix.length;
                    return strings.getKeys(prefix).map(function (key) {
                        return key.substring(prefixLength);
                    });
                }
            },
            _parentIsMessageAction = function (data, parent) {
                return !!parent && (parent.type === missions.ActionType.MESSAGE);
            },
            _parentIsCommandAction = function (data, parent) {
                return !!parent && (parent.type === missions.ActionType.COMMAND);
            },
            _isJumpCommandActionParams = function (data, parent) {
                return _parentIsCommandAction(data, parent) && (data.command === ai.SpacecraftCommand.JUMP);
            },
            _isTargetCommandActionParams = function (data, parent) {
                return _parentIsCommandAction(data, parent) && (data.command === ai.SpacecraftCommand.TARGET);
            },
            _parentIsHUDAction = function (data, parent) {
                return !!parent && (parent.type === missions.ActionType.HUD);
            },
            _missionHasMessages = function (data, parent, itemName) {
                var prefix = strings.MISSION.PREFIX.name + utils.getFilenameWithoutExtension(itemName) + strings.MISSION.MESSAGES_SUFFIX.name;
                return !!parent && (parent.type === missions.ActionType.MESSAGE) && (strings.getKeys(prefix).length > 0);
            },
            _requiresMessage = function (data, parent, itemName) {
                return _parentIsMessageAction(data, parent) && !_missionHasMessages(data, parent, itemName);
            },
            _getStringPreview = function (string) {
                return (string.length > 0) ? (string.substr(0, LONG_TEXT_PREVIEW_LENGTH) + ((string.length > LONG_TEXT_PREVIEW_LENGTH) ? "..." : "")) : "...";
            },
            /**
             * A merge of all the different possible action parameters
             * @type Editor~TypeDescriptor
             */
            ACTION_PARAMS = {
                baseType: BaseType.OBJECT,
                name: "ActionParams",
                getPreviewText: function (instance) {
                    // MessageAction params:
                    if ((instance.text !== undefined) || (instance.textID !== undefined)) {
                        return "message" + (instance.text ? " (" + _getStringPreview(instance.text) + ")" : (instance.textID ? " (" + instance.textID + ")" : ""));
                    }
                    // CommandAction params:
                    if (instance.command !== undefined) {
                        if (instance.jump && instance.jump.way) {
                            return instance.command + " " + instance.jump.way;
                        }
                        if (instance.target) {
                            return instance.command + " " + TARGET_COMMAND_PARAMS.getPreviewText(instance.target);
                        }
                        return instance.command;
                    }
                    // HUDAction params:
                    if (instance.state !== undefined) {
                        return "HUD: " + (instance.section ? instance.section + " " : "") + instance.state;
                    }
                    return "none";
                },
                properties: {
                    // MessageAction params:
                    TEXT: {
                        name: "text",
                        type: LONG_STRING,
                        newValue: "Test",
                        isRequired: _requiresMessage,
                        isValid: _parentIsMessageAction
                    },
                    TEXT_ID: {
                        name: "textID",
                        type: MESSAGE_REFERENCE,
                        optional: true,
                        isValid: _missionHasMessages
                    },
                    SOURCE: {
                        name: "source",
                        type: SPACECRAFT_REFERENCE,
                        optional: true,
                        isValid: _parentIsMessageAction
                    },
                    DURATION: {
                        name: "duration",
                        type: NON_NEGATIVE_MILLISECONDS,
                        optional: true,
                        isValid: _parentIsMessageAction
                    },
                    PERMANENT: {
                        name: "permanent",
                        type: BaseType.BOOLEAN,
                        optional: true,
                        isValid: _parentIsMessageAction
                    },
                    URGENT: {
                        name: "urgent",
                        type: BaseType.BOOLEAN,
                        optional: true,
                        isValid: _parentIsMessageAction
                    },
                    COLOR: {
                        name: "color",
                        type: BaseType.COLOR4,
                        optional: true,
                        isValid: _parentIsMessageAction
                    },
                    // CommandAction params:
                    COMMAND: {
                        name: "command",
                        type: SPACECRAFT_COMMAND,
                        isRequired: _parentIsCommandAction,
                        isValid: _parentIsCommandAction
                    },
                    JUMP: {
                        name: "jump",
                        type: JUMP_COMMAND_PARAMS,
                        optional: true,
                        isValid: _isJumpCommandActionParams
                    },
                    TARGET: {
                        name: "target",
                        type: TARGET_COMMAND_PARAMS,
                        optional: true,
                        isValid: _isTargetCommandActionParams
                    },
                    // HUDAction params:
                    SECTION: {
                        name: "section",
                        type: HUD_SECTION,
                        optional: true,
                        isValid: _parentIsHUDAction
                    },
                    STATE: {
                        name: "state",
                        type: HUD_SECTION_STATE,
                        isRequired: _parentIsHUDAction,
                        isValid: _parentIsHUDAction
                    }
                }
            },
            _actionCanHaveSubjects = function (data) {
                return data.type === missions.ActionType.COMMAND;
            },
            _actionCanHaveParams = function (data) {
                return [missions.ActionType.MESSAGE, missions.ActionType.COMMAND, missions.ActionType.HUD].indexOf(data.type) >= 0;
            },
            /**
             * @type Editor~TypeDescriptor
             */
            ACTION = {
                baseType: BaseType.OBJECT,
                name: "Action",
                getName: function (instance) {
                    if (instance.type) {
                        if (instance.type === missions.ActionType.COMMAND) {
                            return instance.type + ((instance.params && instance.params.command) ? ": " + instance.params.command : "");
                        }
                        return instance.type;
                    }
                    return "action";
                },
                properties: {
                    TYPE: {
                        name: "type",
                        type: ACTION_TYPE
                    },
                    DELAY: {
                        name: "delay",
                        type: NON_NEGATIVE_MILLISECONDS,
                        defaultValue: 0
                    },
                    SUBJECTS: {
                        name: "subjects",
                        type: SUBJECT_GROUP,
                        isRequired: _actionCanHaveSubjects,
                        isValid: _actionCanHaveSubjects
                    },
                    PARAMS: {
                        name: "params",
                        type: ACTION_PARAMS,
                        isRequired: _actionCanHaveParams,
                        isValid: _actionCanHaveParams,
                        updateOnValidate: true
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            MISSION_EVENT = {
                baseType: BaseType.OBJECT,
                name: "MissionEvent",
                getName: function (instance) {
                    if (instance.name) {
                        return instance.name;
                    }
                    if (instance.actions && (instance.actions.length > 0) && (instance.actions[0].type === missions.ActionType.WIN)) {
                        return "win";
                    }
                    if (instance.actions && (instance.actions.length > 0) && (instance.actions[0].type === missions.ActionType.LOSE)) {
                        return "lose";
                    }
                    if (instance.trigger && (!instance.trigger.conditions || instance.trigger.conditions.length === 0)) {
                        return "start";
                    }
                    if (instance.actions && (instance.actions.length === 1)) {
                        return ACTION.getName(instance.actions[0]);
                    }
                    return "event";
                },
                properties: {
                    NAME: {
                        name: "name",
                        type: BaseType.STRING,
                        optional: true
                    },
                    TRIGGER: {
                        name: "trigger",
                        type: TRIGGER
                    },
                    ACTIONS: {
                        name: "actions",
                        type: _createTypedArrayType(ACTION)
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SCENE_VIEW_LOOK_AT_MODE = {
                baseType: BaseType.ENUM,
                values: classes.SceneViewLookAtMode
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SCENE_VIEW = {
                baseType: BaseType.OBJECT,
                name: "SceneView",
                properties: {
                    NAME: {
                        name: "name",
                        type: BaseType.STRING
                    },
                    FOV: {
                        name: "fov",
                        type: DEGREES,
                        globalDefault: true,
                        settingName: config.CAMERA_SETTINGS.DEFAULT_FOV
                    },
                    FOV_RANGE: {
                        name: "fovRange",
                        type: BaseType.RANGE,
                        globalDefault: true,
                        settingName: config.CAMERA_SETTINGS.DEFAULT_FOV_RANGE
                    },
                    SPAN: {
                        name: "span",
                        type: DISTANCE,
                        globalDefault: true,
                        settingName: config.CAMERA_SETTINGS.DEFAULT_SPAN
                    },
                    FPS: {
                        name: "fps",
                        type: BaseType.BOOLEAN,
                        defaultValue: false
                    },
                    BASE_ORIENTATION: {
                        name: "baseOrientation",
                        type: BASE_ORIENTATION,
                        globalDefault: true,
                        settingName: config.CAMERA_SETTINGS.DEFAULT_BASE_ORIENTATION,
                        isValid: _isFPS
                    },
                    POINT_TO_FALLBACK: {
                        name: "pointToFallback",
                        type: POINT_TO_FALLBACK,
                        optional: true
                    },
                    MOVABLE: {
                        name: "movable",
                        type: BaseType.BOOLEAN
                    },
                    TURNABLE: {
                        name: "turnable",
                        type: BaseType.BOOLEAN
                    },
                    ALPHA_RANGE: {
                        name: "alphaRange",
                        type: _createRangeType(true, true, DEGREES),
                        optional: true,
                        defaultText: "unlimited",
                        isValid: _turnableFPS
                    },
                    BETA_RANGE: {
                        name: "betaRange",
                        type: _createRangeType(true, true, DEGREES_BETA),
                        defaultValue: [-90, 90],
                        isValid: _turnableFPS
                    },
                    CONFINES: {
                        name: "confines",
                        type: BaseType.CONFINES,
                        optional: true
                    },
                    RESETS_WHEN_LEAVING_CONFINES: {
                        name: "resetsWhenLeavingConfines",
                        type: BaseType.BOOLEAN,
                        optional: true
                    },
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3
                    },
                    ROTATIONS: {
                        name: "rotations",
                        type: BaseType.ROTATIONS,
                        optional: true
                    },
                    EXCLUDE_FROM_CYCLE: {
                        name: "excludeFromCycle",
                        type: BaseType.BOOLEAN,
                        optional: true
                    },
                    TURN_AROUND_ALL: {
                        name: "turnAroundAll",
                        type: BaseType.BOOLEAN,
                        defaultValue: false
                    },
                    LOOK_AT: {
                        name: "lookAt",
                        type: SCENE_VIEW_LOOK_AT_MODE
                    },
                    DISTANCE_RANGE: {
                        name: "distanceRange",
                        type: BaseType.RANGE,
                        optional: true
                    },
                    STARTS_WITH_RELATIVE_POSITION: {
                        name: "startsWithRelativePosition",
                        type: BaseType.BOOLEAN,
                        optional: true
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            AI_TYPE = {
                baseType: BaseType.ENUM,
                values: utils.getEnumObject(ai.getAITypes())
            },
            /**
             * @type Editor~TypeDescriptor
             */
            CLASS_LOADOUT_REFERENCE = {
                name: "loadout",
                baseType: BaseType.ENUM,
                getValues: function (parent) {
                    var spacecraftClass;
                    if (parent.class) {
                        spacecraftClass = classes.getSpacecraftClass(parent.class);
                        return spacecraftClass.getLoadoutNames();
                    }
                    return [];
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT_COUNT = {
                baseType: BaseType.NUMBER,
                integer: true,
                min: 1,
                max: 9
            },
            _craftIsSingle = function (data) {
                return !data.count || (data.count === 1);
            },
            _craftIsMulti = function (data) {
                return data.count && (data.count > 1);
            },
            _craftCanBePiloted = function (data) {
                return _craftIsSingle(data) && !data.away;
            },
            _multiCraftCanBePiloted = function (data) {
                return _craftIsMulti(data) && !data.away;
            },
            _craftCanHaveLoadouts = function (data) {
                return _craftIsMulti(data) && !data.loadout && !data.equipment;
            },
            _craftHasNoLoadouts = function (data) {
                return !data.loadouts || (data.loadouts.length === 0);
            },
            _craftCanHaveLoadout = function (data) {
                return _craftHasNoLoadouts(data) && !data.equipment;
            },
            _craftCanHaveEquipment = function (data) {
                return _craftHasNoLoadouts(data) && !data.loadout;
            },
            _getDefaultLoadout = function (data) {
                var spacecraftClass;
                if (data.class) {
                    spacecraftClass = classes.getSpacecraftClass(data.class);
                    return spacecraftClass.getDefaultLoadout() || "none";
                }
            },
            _craftIsNotPiloted = function (data) {
                return !data.piloted && !data.pilotedIndex;
            },
            _craftIsNotPilotedSingle = function (data) {
                return !data.piloted;
            },
            _craftCanHavePositions = function (data) {
                return _craftIsMulti(data) && !data.position && !data.formation;
            },
            _craftHasNoPositions = function (data) {
                return !data.positions;
            },
            _craftCanHaveFormation = function (data) {
                return _craftIsMulti(data) && _craftHasNoPositions(data);
            },
            /**
             * @type Editor~TypeDescriptor
             */
            SPACECRAFT = {
                baseType: BaseType.OBJECT,
                name: "Spacecraft",
                getName: function (instance) {
                    return instance.name || (instance.squad || instance.class) + (instance.count ? (" (" + instance.count + ")") : "");
                },
                properties: {
                    NAME: {
                        name: "name",
                        type: BaseType.STRING,
                        optional: true,
                        isValid: _craftIsSingle
                    },
                    SQUAD: {
                        name: "squad",
                        type: BaseType.STRING, // should be an enum with the squad names from strings, with an optional index
                        optional: true,
                        defaultText: "none"
                    },
                    TEAM: {
                        name: "team",
                        type: TEAM_REFERENCE,
                        optional: true
                    },
                    CLASS: {
                        name: "class",
                        type: SPACECRAFT_CLASS_REFERENCE
                    },
                    AI: {
                        name: "ai",
                        type: AI_TYPE,
                        optional: true,
                        defaultText: "none",
                        isValid: _craftIsNotPilotedSingle
                    },
                    POSITION: {
                        name: "position",
                        type: BaseType.VECTOR3,
                        optional: true,
                        isValid: _craftHasNoPositions,
                        defaultValue: [0, 0, 0]
                    },
                    ROTATIONS: {
                        name: "rotations",
                        type: BaseType.ROTATIONS,
                        optional: true
                    },
                    LOADOUT: {
                        name: "loadout",
                        type: CLASS_LOADOUT_REFERENCE,
                        optional: true,
                        isValid: _craftCanHaveLoadout,
                        getDerivedDefault: _getDefaultLoadout,
                        updateOnValidate: true
                    },
                    EQUIPMENT: {
                        name: "equipment",
                        type: LOADOUT,
                        optional: true,
                        isValid: _craftCanHaveEquipment,
                        defaultText: "from loadout",
                        updateOnValidate: true
                    },
                    AWAY: {
                        name: "away",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _craftIsNotPiloted
                    },
                    PILOTED: {
                        name: "piloted",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _craftCanBePiloted
                    },
                    INITIAL_TARGET: {
                        name: "initialTarget",
                        type: SPACECRAFT_REFERENCE,
                        optional: true
                    },
                    EXCLUDE_FROM_REFERENCE_SCORE: {
                        name: "excludeFromReferenceScore",
                        type: BaseType.BOOLEAN,
                        defaultValue: false,
                        isValid: _craftIsNotPiloted
                    },
                    COUNT: {
                        name: "count",
                        type: SPACECRAFT_COUNT,
                        optional: true,
                        defaultText: "single ship"
                    },
                    NAMES: {
                        name: "names",
                        type: STRING_ARRAY,
                        optional: true,
                        isValid: _craftIsMulti
                    },
                    LOADOUTS: {
                        name: "loadouts",
                        type: _createTypedArrayType(CLASS_LOADOUT_REFERENCE),
                        optional: true,
                        isValid: _craftCanHaveLoadouts,
                        updateOnValidate: true
                    },
                    PILOTED_INDEX: {
                        name: "pilotedIndex",
                        type: SPACECRAFT_COUNT,
                        optional: true,
                        isValid: _multiCraftCanBePiloted
                    },
                    POSITIONS: {
                        name: "positions",
                        type: _createTypedArrayType(BaseType.VECTOR3),
                        optional: true,
                        isValid: _craftCanHavePositions
                    },
                    FORMATION: {
                        name: "formation",
                        type: FORMATION,
                        optional: true,
                        isValid: _craftCanHaveFormation
                    }
                }
            },
            /**
             * @type Editor~TypeDescriptor
             */
            TIPS_SET = {
                baseType: BaseType.SET,
                values: []
            },
            /**
             * @type Editor~ItemDescriptor
             */
            MISSION = {
                TITLE: {
                    name: "title",
                    type: BaseType.STRING,
                    optional: true
                },
                DESCRIPTION: {
                    name: "description",
                    type: LONG_STRING
                },
                NEXT_MISSION: {
                    name: "nextMission",
                    type: MISSION_REFERENCE,
                    optional: true
                },
                TIPS: {
                    name: "tips",
                    type: TIPS_SET,
                    optional: true
                },
                ENVIRONMENT: {//TODO: can be an object as well
                    name: "environment",
                    type: ENVIRONMENT_REFERENCE
                },
                ANTICIPATION_THEME: {
                    name: "anticipationTheme",
                    type: MUSIC_REFERENCE,
                    optional: true
                },
                COMBAT_THEME: {
                    name: "combatTheme",
                    type: MUSIC_REFERENCE,
                    optional: true
                },
                TEAMS: {
                    name: "teams",
                    type: _createTypedArrayType(TEAM),
                    optional: true
                },
                EVENTS: {
                    name: "events",
                    type: _createTypedArrayType(MISSION_EVENT),
                    optional: true
                },
                VIEWS: {
                    name: "views",
                    type: _createTypedArrayType(SCENE_VIEW),
                    optional: true
                },
                SPACECRAFTS: {
                    name: "spacecrafts",
                    type: _createTypedArrayType(SPACECRAFT)
                }
            };
    /**
     * @class
     * Represents a basic or complex type.
     * @param {String|Editor~TypeDescriptor|Editor~ItemDescriptor} type Either string, for basic types (from enum BaseType), or an object 
     * with a baseType property containing the base type string and other properties containing the additional parameters of the type.
     * Item descriptors are also accepted, taking them as an unnamed object type with the given properties
     */
    function Type(type) {
        /**
         * @type Editor~TypeDescriptor
         */
        this._descriptor = (typeof type === "string") ? {baseType: type} : type;
        // interpret descriptors without a baseType as item descriptors
        if (!this._descriptor.baseType) {
            this._descriptor = {
                baseType: BaseType.OBJECT,
                properties: this._descriptor
            };
        }
    }
    /**
     * Returns whether there is a property named "name" among the properties this (object based) type
     * @returns {Boolean}
     */
    Type.prototype.hasNameProperty = function () {
        var props, i;
        if (!this._descriptor.properties) {
            return false;
        }
        if (this._descriptor.getName) {
            return true;
        }
        props = Object.keys(this._descriptor.properties);
        for (i = 0; i < props.length; i++) {
            if (this._descriptor.properties[props[i]].name === NAME_PROPERTY_NAME) {
                return true;
            }
        }
        return false;
    };
    /**
     * Returns the value of the name property for the passed instance (either obtained from the 
     * corresponding field of the instance data or the getter function defined for the type)
     * @param {Object} instance
     * @returns {String}
     */
    Type.prototype.getInstanceName = function (instance) {
        if (this._descriptor.getName) {
            return this._descriptor.getName(instance);
        }
        return instance[NAME_PROPERTY_NAME];
    };
    /**
     * Returns the name of the type 
     * @returns {String}
     */
    Type.prototype.getName = function () {
        return this._descriptor.name;
    };
    /**
     * 
     * @returns {Editor~TypeDescriptor}
     */
    Type.prototype.getDescriptor = function () {
        return this._descriptor;
    };
    /**
     * Returns a displayable name for the type 
     * @returns {String}
     */
    Type.prototype.getDisplayName = function () {
        if (this._descriptor.name) {
            return this._descriptor.name;
        }
        if (this._descriptor.resourceReference) {
            return this._descriptor.resourceReference;
        }
        if (this._descriptor.classReference) {
            return this._descriptor.classReference;
        }
        if (this._descriptor.environmentReference) {
            return this._descriptor.environmentReference;
        }
        if (this._descriptor.missionReference) {
            return this._descriptor.missionReference;
        }
        return this._descriptor.baseType;
    };
    /**
     * Returns the base type of this type
     * @returns {String} (enum BaseType)
     */
    Type.prototype.getBaseType = function () {
        return this._descriptor.baseType;
    };
    /**
     * For number types, returns the unit of measurement
     * @returns {String}
     */
    Type.prototype.getUnit = function () {
        return this._descriptor.unit;
    };
    /**
     * For number types, returns the minimum allowed value
     * @returns {Number}
     */
    Type.prototype.getMin = function () {
        return this._descriptor.min;
    };
    /**
     * For number types, returns the maximum allowed value
     * @returns {Number}
     */
    Type.prototype.getMax = function () {
        return this._descriptor.max;
    };
    /**
     * For number types, returns whether only integers are allowed
     * @returns {Boolean}
     */
    Type.prototype.isInteger = function () {
        return !!this._descriptor.integer;
    };
    /**
     * For array types, returns their fixed length if set (undefined if not)
     * @returns {Number}
     */
    Type.prototype.getFixedLength = function () {
        return this._descriptor.fixedLength;
    };
    /**
     * For array types, returns their min length if set (undefined if not)
     * @returns {Number}
     */
    Type.prototype.getMinLength = function () {
        return this._descriptor.minLength;
    };
    /**
     * For array types, returns their max length if set (undefined if not)
     * @returns {Number}
     */
    Type.prototype.getMaxLength = function () {
        return this._descriptor.maxLength;
    };
    /**
     * Returns whether this type is a reference string (e.g. resource or class reference) type
     * @returns {Boolean}
     */
    Type.prototype.isItemReference = function () {
        return !!this._descriptor.resourceReference || !!this._descriptor.classReference || !!this._descriptor.environmentReference || !!this._descriptor.missionReference;
    };
    /**
     * For resource reference string types, returns the category of resources the type refers to
     * @returns {String}
     */
    Type.prototype.getResourceReference = function () {
        return this._descriptor.resourceReference;
    };
    /**
     * For class reference string types, returns the category of classes the type refers to
     * @returns {String}
     */
    Type.prototype.getClassReference = function () {
        return this._descriptor.classReference;
    };
    /**
     * For environment reference string types, returns the category of environments the type refers to
     * @returns {String}
     */
    Type.prototype.getEnvironmentReference = function () {
        return this._descriptor.environmentReference;
    };
    /**
     * For mission reference string types, returns the category of missions the type refers to
     * @returns {String}
     */
    Type.prototype.getMissionReference = function () {
        return this._descriptor.missionReference;
    };
    /**
     * For reference string types, returns the ItemType corresponding to the type of reference
     * @returns {ItemType}
     */
    Type.prototype.getReferenceItemType = function () {
        if (this.getResourceReference()) {
            return common.ItemType.RESOURCE;
        }
        if (this.getClassReference()) {
            return common.ItemType.CLASS;
        }
        if (this.getEnvironmentReference()) {
            return common.ItemType.ENVIRONMENT;
        }
        if (this.getMissionReference()) {
            return common.ItemType.MISSION;
        }
        return common.ItemType.NONE;
    };
    /**
     * For reference string types, returns the name of the category of items it references
     * @returns {String}
     */
    Type.prototype.getReferenceItemCategory = function () {
        return this._descriptor.resourceReference || this._descriptor.classReference || this._descriptor.environmentReference || this._descriptor.missionReference;
    };
    /**
     * For string types, returns whether the type is flagged as long
     * @returns {Boolean}
     */
    Type.prototype.isLong = function () {
        return this._descriptor.long;
    };
    /**
     * For enum and set types, returns the list of possible values
     * @param {Boolean} [allowNull=false] 
     * @param {Object} [dataParent] The parent object of the property with this type 
     * @param {Object} [dataTopParent] The top level parent object of the property with this type 
     * @param {String} [itemName] The name of the editor item this property belongs to
     * @returns {String[]}
     */
    Type.prototype.getValues = function (allowNull, dataParent, dataTopParent, itemName) {
        var values;
        if (this._descriptor.values) {
            values = utils.getEnumValues(this._descriptor.values);
            return (typeof values[0] === "number") ? utils.getEnumKeys(this._descriptor.values) : values;
        }
        if (this._descriptor.getValues) {
            return this._descriptor.getValues(dataParent, dataTopParent, itemName);
        }
        if (this._descriptor.resourceReference) {
            return resources.getResourceNames(this._descriptor.resourceReference);
        }
        if (this._descriptor.classReference) {
            return classes.getClassNames(this._descriptor.classReference);
        }
        if (this._descriptor.environmentReference) {
            return environments.getEnvironmentNames();
        }
        if (this._descriptor.missionReference) {
            return missions.getMissionNames();
        }
        if (allowNull) {
            return null;
        }
        document.crash();
    };
    /**
     * For object types, returns the object storing the property descriptors
     * @returns {Object}
     */
    Type.prototype.getProperties = function () {
        return this._descriptor.properties;
    };
    /**
     * For associative arrays, returns the list of valid keys. If there is no restriction on valid keys, no array is returned.
     * @returns {String[]}
     */
    Type.prototype.getValidKeys = function () {
        return this._descriptor.validKeys;
    };
    /**
     * Returns the type of elements for arrays and associative arrays.
     * @returns {Type}
     */
    Type.prototype.getElementType = function () {
        return new Type(this._descriptor.elementType);
    };
    /**
     * Returns the type of the first members of pairs (for pairs type)
     * @returns {Type}
     */
    Type.prototype.getFirstType = function () {
        return new Type(this._descriptor.first.type);
    };
    /**
     * Returns the type of the second members of pairs (for pairs type)
     * @returns {Type}
     */
    Type.prototype.getSecondType = function () {
        return new Type(this._descriptor.second.type);
    };
    // ------------------------------------------------------------------------------
    // Public functions
    /**
     * 
     * @param {Editor~PropertyDescriptor} propertyDescriptor
     * @param {Object} parent
     * @param {Object} topParent
     * @param {String} itemName
     * @returns {String[]}
     */
    function getPropertyValues(propertyDescriptor, parent, topParent, itemName) {
        var values = new Type(propertyDescriptor.type).getValues(false, parent, topParent, itemName);
        // an object cannot reference itself (e.g. a fighter class cannot be based on itself)
        if (parent && (propertyDescriptor.name === BASED_ON_PROPERTY_NAME)) {
            utils.removeFromArray(values, parent[NAME_PROPERTY_NAME]);
        }
        return values;
    }
    // ------------------------------------------------------------------------------
    // Initialization
    graphics.executeWhenReady(function () {
        // shader variants can be set for graphics quality levels (which will be used instead of the original shader in case the corresponding
        // graphics quality is set)
        SHADER_VARIANTS.validKeys = graphics.getShaderComplexities().concat(SHADER_VARIANTS.validKeys);
    });
    missions.executeWhenReady(function () {
        TIPS_SET.values = missions.getTipIDs();
    });
    // ------------------------------------------------------------------------------
    // The public interface of the module
    return {
        BaseType: BaseType,
        Unit: Unit,
        ThrusterUse: ThrusterUse,
        NAME_PROPERTY_NAME: NAME_PROPERTY_NAME,
        BASED_ON_PROPERTY_NAME: BASED_ON_PROPERTY_NAME,
        AXIS: AXIS,
        /**
         * @type Object.<String, Editor~ItemDescriptor>
         */
        itemDescriptors: {
            "textures": TEXTURE,
            "cubemaps": CUBEMAP,
            "shaders": SHADER,
            "models": MODEL,
            "soundEffects": SOUND_EFFECT,
            "music": MUSIC,
            "skyboxClasses": SKYBOX_CLASS,
            "backgroundObjectClasses": BACKGROUND_OBJECT_CLASS,
            "dustCloudClasses": DUST_CLOUD_CLASS,
            "explosionClasses": EXPLOSION_CLASS,
            "projectileClasses": PROJECTILE_CLASS,
            "missileClasses": MISSILE_CLASS,
            "weaponClasses": WEAPON_CLASS,
            "propulsionClasses": PROPULSION_CLASS,
            "jumpEngineClasses": JUMP_ENGINE_CLASS,
            "shieldClasses": SHIELD_CLASS,
            "spacecraftTypes": SPACECRAFT_TYPE,
            "spacecraftClasses": SPACECRAFT_CLASS,
            "environments": ENVIRONMENT,
            "missions": MISSION
        },
        Type: Type,
        getPropertyValues: getPropertyValues
    };
});
/**
 * Copyright 2016-2017, 2019-2020 Krisztián Nagy
 * @file Provides the content and event handlers for the Properties window of the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param utils Used for enum handling
 * @param config Used to obtain configuration settings
 * @param descriptors Used to obtain the appropriate properties description object
 * @param common Used to create selectors
 */
define('editor/properties',[
    "utils/utils",
    "armada/configuration",
    "editor/descriptors",
    "editor/common"
], function (utils, config, descriptors, common) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // Constants
            PROPERTIES_CLASS = "propertiesTable",
            PROPERTY_ROW_CLASS = "property",
            UNSET_PROPERTY_ROW_CLASS = "unset",
            PROPERTY_CLASS = "propertyName",
            CONTROL_CLASS = "propertyControl",
            PROPERTY_EDITOR_HEADER_CLASS = "propertyEditorHeader",
            PROPERTY_EDITOR_HEADER_BUTTON_CLASS = "propertyEditorHeaderButton",
            SET_PROPERTY_BUTTON_CLASS = "setProperty",
            UNSET_PROPERTY_BUTTON_CLASS = "unsetProperty",
            JUMP_TO_REFERENCE_BUTTON_CLASS = "jumpReference",
            TEXT_AREA_ROWS = 5,
            TEXT_AREA_COLS = 100,
            LONG_TEXT_PREVIEW_LENGTH = 16,
            EMPTY_LIST_TEXT = "empty list",
            INHERITED_PROPERTY_TEXT = "inherited",
            DEFAULT_PROPERTY_TEXT = "default",
            UNSET_PROPERTY_TEXT = "not set",
            NONE_PROPERTY_TEXT = "none",
            UNKNOWN_PROPERTY_TEXT = "unknown",
            SET_PROPERTY_BUTTON_CAPTION = "set",
            UNSET_PROPERTY_BUTTON_CAPTION = "x",
            UNSET_PROPERTY_BUTTON_TOOLTIP = "Unset property",
            WITH_SET_PROPERTY_BUTTON_CLASS = "withSetButton",
            WITH_UNSET_PROPERTY_BUTTON_CLASS = "withUnsetButton",
            JUMP_TO_REFERENCE_BUTTON_CAPTION = "↷",
            JUMP_TO_REFERENCE_BUTTON_TOOLTIP = "Jump to referenced item",
            WITH_JUMP_TO_REFERENCE_BUTTON_CLASS = "withJumpButton",
            ADD_BUTTON_CAPTION = "+",
            ADD_BUTTON_TOOLTIP = "Add a new element with default values",
            DUPLICATE_BUTTON_CAPTION = "#",
            DUPLICATE_BUTTON_TOOLTIP = "Duplicate this element",
            MOVE_UP_BUTTON_CAPTION = "↑",
            MOVE_UP_BUTTON_TOOLTIP = "Move this element up in the list",
            MOVE_DOWN_BUTTON_CAPTION = "↓",
            MOVE_DOWN_BUTTON_TOOLTIP = "Move this element down in the list",
            REMOVE_BUTTON_CAPTION = "x",
            REMOVE_BUTTON_TOOLTIP = "Remove this element",
            NEW_OBJECT_NAME_PREFIX = "new",
            DUPLICATE_ELEMENT_SUFFIX = "_copy",
            // ------------------------------------------------------------------------------
            // Private variables
            /**
             * A reference to the element within which the property editor controls are created
             * @type Element
             */
            _element,
            /**
             * A reference to the selected item the properties of which are displayed
             * @type Editor~Item
             */
            _item,
            /**
             * A reference to the resource / class that the selected item is based on (references)
             * @type GenericResource|GenericClass
             */
            _basedOn,
            /**
             * The module providing the Preview for the item the properties of which are displayed
             * @type Editor~Preview
             */
            _preview,
            /**
             * A reference to the function to execute whenever the name property of the selected item is changed
             * @type Function
             */
            _nameChangeHandler,
            /**
             * A reference to the function to execute to select another item (for jumping to referenced items) in the editor
             * @type Function
             */
            _selectItemFunction,
            // ------------------------------------------------------------------------------
            // Private functions
            _createControl, _createProperties, createProperties;
    /**
     * Updates the reference to the base of the displayed item 
     * @returns {Boolean} Whether the reference has been changed
     */
    function _updateBasedOn() {
        var newBasedOn = _item.data[descriptors.BASED_ON_PROPERTY_NAME] ?
                common.getItemReference({type: _item.type, category: _item.category, name: _item.data[descriptors.BASED_ON_PROPERTY_NAME]}) :
                null;
        if (newBasedOn !== _basedOn) {
            _basedOn = newBasedOn;
            return true;
        }
        return false;
    }
    /**
     * Reinitializes the item the properties of which are edited, and notifies the preview module of the change
     * @param {String} name The name of the property that changed
     */
    function _updateData(name) {
        var references, i;
        _item.reference.reloadData();
        // we need to reload the items that are based on the modified item
        references = common.getItemReferencesOfSameCategory(_item);
        for (i = 0; i < references.length; i++) {
            if (references[i].getData()[descriptors.BASED_ON_PROPERTY_NAME] === _item.data[descriptors.NAME_PROPERTY_NAME]) {
                references[i].reloadData();
            }
        }
        // if we changed the basedon property, refresh the property editors, as all inherited properties might change
        if (_updateBasedOn()) {
            _element.innerHTML = "";
            createProperties(_element, _item, _preview, _nameChangeHandler);
        }
        // signal the preview about the change
        if (_preview) {
            _preview.handleDataChanged(name);
        }
    }
    /**
     * Changes the property with the given name (key) in the data object, and notifies the preview module of the change
     * @param {String} topName The name (key) of the property of the edited item which changed / under which the change happened 
     * @param {} value The new value the property is to be changed to
     * @param {Object|Array} [parent] If the changed property belongs to an object or array below the main item, a reference to that object 
     * or array needs to be  given here
     * @param {String|Number} [name] If the changed property belongs to an object or array below the main item, the name of the property or
     * in case of array the index of the element needs to be given
     * here (topName refers to the name of the property under which the change happened. In case of changing 
     * selectedSpacecraftClass.loadouts[1].weapons[0].class, topName would be "loadouts" and name would be "class"
     * (and parent should refer to weapons[0]))
     * @param {Function} callback Function to execute after the data object has been changed but before the game objects have been reloaded from the new data
     */
    function _changeData(topName, value, parent, name, callback) {
        if (parent) {
            parent[name] = value;
        } else {
            _item.data[topName] = value;
        }
        if (callback) {
            callback(value);
        }
        _updateData(topName);
    }
    /**
     * Creates and returns a control that can be used to edit boolean properties.
     * @param {String} topName Name of the top property being edited
     * @param {Boolean} data The starting value
     * @param {Object} [parent] See _changeData
     * @param {String} [name] See _changeData
     * @param {Function} [onChange] A function to execute every time after the value of the boolean was changed using this control
     * @returns {Element}
     */
    function _createBooleanControl(topName, data, parent, name, onChange) {
        var result = common.createBooleanInput(data, function (value) {
            _changeData(topName, value, parent, name, onChange);
        });
        return result;
    }
    /**
     * Creates and returns a control that can be used to edit string properties.
     * @param {String} topName Name of the top property being edited
     * @param {String} data The starting value
     * @param {Object} [parent] See _changeData
     * @param {String} [name] See _changeData
     * @param {Function} [onChange] A function to execute every time after the value of the string was changed using this control
     * @returns {Element}
     */
    function _createStringControl(topName, data, parent, name, onChange) {
        var result = document.createElement("input");
        result.type = "text";
        result.value = data;
        result.onchange = function () {
            _changeData(topName, result.value, parent, name, onChange);
        };
        return result;
    }
    /**
     * Creates and returns a popup preconfigured to notify the preview window about the editing of the top level property it belongs to,
     * in case it is top level
     * @param {Element} invoker The invoker of the popup (see Popup)
     * @param {Popup} [parentPopup] If this popup is to be a child of another one, give the parent here
     * @param {String} topName The name of the top level property this popup belongs to
     * @param {Function} [showHandler] A function to be executed next to to notifying the preview whenever the popup is shown
     * @param {Function} [hideHandler] A function to be executed next to to notifying the preview whenever the popup is hidden
     * @returns {Popup}
     */
    function _createPopup(invoker, parentPopup, topName, showHandler, hideHandler) {
        return new common.Popup(invoker, parentPopup, {
            show: function () {
                if (_preview && !parentPopup) {
                    _preview.handleStartEdit(topName, 0);
                }
                if (showHandler) {
                    showHandler();
                }
            },
            hide: function () {
                if (_preview && !parentPopup) {
                    _preview.handleStopEdit(topName);
                }
                if (hideHandler) {
                    hideHandler();
                }
            }
        });
    }
    /**
     * Returns a short, preview excerpt from a longer text to show
     * @param {String} string The original (potentially) long text
     * @returns {String}
     */
    function _getStringPreview(string) {
        return (string.length > 0) ? (string.substr(0, LONG_TEXT_PREVIEW_LENGTH) + ((string.length > LONG_TEXT_PREVIEW_LENGTH) ? "..." : "")) : "...";
    }
    /**
     * Creates and returns a control that can be used to edit long string properties.
     * @param {String} topName Name of the top property being edited
     * @param {String} data The starting value
     * @param {Object} [parent] See _changeData
     * @param {String} [name] See _changeData
     * @param {Popup} [parentPopup] If this object property editor is displayed within a popup, give a reference to that popup here
     * @param {Function} [onChange] A function to execute every time after the value of the string was changed using this control
     * @returns {Element}
     */
    function _createLongStringControl(topName, data, parent, name, parentPopup, onChange) {
        var
                textarea = document.createElement("textarea"),
                button, popup;
        button = common.createButton(_getStringPreview(data), function () {
            popup.toggle();
        });
        popup = _createPopup(button, parentPopup, topName, null, function () {
            _changeData(topName, textarea.value, parent, name, onChange);
            button.textContent = _getStringPreview(textarea.value);
            if (parentPopup) {
                parentPopup.alignPosition();
            }
        });
        textarea.value = data;
        textarea.cols = TEXT_AREA_COLS;
        textarea.rows = TEXT_AREA_ROWS;
        textarea.spellcheck = false;
        textarea.autocomplete = "off";
        textarea.autocorrect = "off";
        textarea.autocapitalize = "off";
        popup.getElement().appendChild(textarea);
        popup.addToPage();
        button.popup = popup; // custom property referencing the popup
        return button;
    }
    /**
     * @callback NumberControl~changeHandler
     * @param {Element} element The HTML element representing the control the value of which was changed
     */
    /**
     * Creates and returns a control that can be used to edit numeric properties.
     * @param {String} topName Name of the top property being edited
     * @param {Number} data The starting value
     * @param {Boolean} integer If true, only integer values are allowed (otherwise floats as well)
     * @param {NumberControl~changeHandler} [changeHandler] The function that should be run on the change event of the control, after 
     * checking the value to be a number
     * @param {Object} [parent] See _changeData
     * @param {String} [name] See _changeData
     * @param {String} [unit] The unit of measurement using which the number is to be interpreted 
     * @param {Number} [min] The minimum allowed value for this number
     * @param {Number} [max] The minimum allowed value for this number
     * @returns {Element}
     */
    function _createNumberControl(topName, data, integer, changeHandler, parent, name, unit, min, max) {
        var result = document.createElement("div"),
                input = common.createNumericInput(data, {integer, min, max}, function (value) {
                    _changeData(topName, value, parent, name, changeHandler);
                });
        result.appendChild(input);
        if (unit) {
            result.appendChild(common.createLabel(unit));
        }
        return result;
    }
    /**
     * Creates and returns a control that can be used to edit enum properties.
     * @param {String} topName Name of the top property being edited
     * @param {String[]} values The list of possible values
     * @param {String} data The starting value
     * @param {Object} [parent] See _changeData
     * @param {String} [name] See _changeData
     * @param {Function} [onchange]
     * @returns {Element}
     */
    function _createEnumControl(topName, values, data, parent, name, onchange) {
        var result = common.createSelector(values, data, false, function (value) {
            _changeData(topName, result ? result.value : value, parent, name, onchange);
        });
        return result;
    }
    /**
     * Creates and returns a control that can be used to edit color properties.
     * @param {String} name Name of the property to edit
     * @param {Number[4]} data The reference to the property to edit
     * @returns {Element}
     */
    function _createColorControl(name, data) {
        return common.createColorPicker(data, function () {
            _updateData(name);
        });
    }
    /**
     * Creates and returns a control that can be used to edit numeric vector properties.
     * @param {String} name Name of the property to edit
     * @param {Number[]} data The reference to the property to edit
     * @returns {Element}
     */
    function _createVectorControl(name, data) {
        return common.createVectorEditor(data, function () {
            _updateData(name);
        });
    }
    /**
     * Creates and returns a control that can be used to edit numeric range properties.
     * @param {String} name Name of the property to edit
     * @param {Editor~TypeDescriptor} typeDescriptor
     * @param {Number[2]} data The reference to the property to edit
     * @returns {Element}
     */
    function _createRangeControl(name, typeDescriptor, data) {
        if ((typeof typeDescriptor) !== "object") {
            typeDescriptor = {};
        }
        return common.createRangeEditor(data, typeDescriptor, function () {
            _updateData(name);
        });
    }
    /**
     * Returns the appropriate default value for the property described by the passed descriptor object
     * @param {Editor~PropertyDescriptor} propertyDescriptor
     * @param {GenericResource|GenericClass} basedOn If the resource / class the property of which is considered has a reference to
     * another object as a base (inheriting undefined properties from it), that base resource / class needs to be given here
     * @param {Object} parent The object itself the data of which is considered (see _changeData)
     * @param {Object} grandParent The parent of the object the data of which is considered
     * @param {Object} topParent The top level object we are editing
     * @param {Boolean} [undefinedIfOptionalWithNoDefault=false] If true, the function will return undefined for properties marked as optional which do
     * not have a default value set
     * @param {Boolean} [undefinedIfOptionalOrHasDefault=false] If true, the function will return undefined for properties marked as optional OR has a default value
     * @param {String} [typeName] The name of the type of the object this property is part of
     * @param {Number} [arrayIndex] If this value is created for an element an array, this should be the index of the element
     * @param {Number} [propertyOfArrayElement=false] If this value is created for a property of an object that is an element in the array, this should be true
     * @returns {}
     */
    function _getDefaultValue(propertyDescriptor, basedOn, parent, grandParent, topParent, undefinedIfOptionalWithNoDefault, undefinedIfOptionalOrHasDefault, typeName, arrayIndex, propertyOfArrayElement) {
        var result, type, propertyDescriptors, propertyDescriptorNames, i, optional, count;
        type = new descriptors.Type(propertyDescriptor.type);
        optional = propertyDescriptor.optional || (propertyDescriptor.isRequired && !propertyDescriptor.isRequired(parent, grandParent, _item.name));
        // automatic naming - only for string type name properties (can be enum as well)
        if ((propertyDescriptor.name === descriptors.NAME_PROPERTY_NAME) && typeName && (type.getBaseType() === descriptors.BaseType.STRING)) {
            if (arrayIndex !== undefined) {
                return typeName + " " + (arrayIndex + 1).toString();
            }
            return NEW_OBJECT_NAME_PREFIX + typeName;
        }
        if ((undefinedIfOptionalWithNoDefault && optional && (propertyDescriptor.defaultValue === undefined)) ||
                (undefinedIfOptionalOrHasDefault && (optional || (propertyDescriptor.defaultValue !== undefined)))) {
            return undefined;
        }
        if (basedOn) {
            result = utils.deepCopy(basedOn.getData()[propertyDescriptor.name]);
            if (result === undefined) {
                return _getDefaultValue(
                        propertyDescriptor,
                        (basedOn.getData()[descriptors.BASED_ON_PROPERTY_NAME] ?
                                common.getItemReference({type: _item.type, category: _item.category, name: basedOn.getData()[descriptors.BASED_ON_PROPERTY_NAME]}) :
                                null),
                        null, null, topParent, undefinedIfOptionalWithNoDefault, undefinedIfOptionalOrHasDefault);
            }
            return result;
        }
        if (propertyDescriptor.newValue) {
            return utils.deepCopy(propertyDescriptor.newValue);
        }
        if (propertyDescriptor.defaultValue) {
            return utils.deepCopy(propertyDescriptor.defaultValue);
        }
        if (propertyDescriptor.globalDefault && propertyDescriptor.settingName) {
            return utils.deepCopy(config.getSetting(propertyDescriptor.settingName));
        }
        switch (type.getBaseType()) {
            case descriptors.BaseType.BOOLEAN:
                return false;
            case descriptors.BaseType.NUMBER:
                return (type.getMin() !== undefined) ? Math.max(type.getMin(), 0) : 0;
            case descriptors.BaseType.STRING:
                return "";
            case descriptors.BaseType.ARRAY:
                result = [];
                count = 0;
                if (type.getFixedLength()) {
                    count = type.getFixedLength();
                } else if (type.getMinLength()) {
                    count = type.getMinLength();
                }
                while (count > 0) {
                    result.push(_getDefaultValue(
                            {type: propertyDescriptor.type.elementType},
                            null,
                            result,
                            parent,
                            topParent,
                            true));
                    count--;
                }
                return result;
            case descriptors.BaseType.PAIRS:
            case descriptors.BaseType.ROTATIONS:
            case descriptors.BaseType.SET:
                return [];
            case descriptors.BaseType.OBJECT:
                result = {};
                propertyDescriptors = type.getProperties();
                propertyDescriptorNames = Object.keys(propertyDescriptors);
                for (i = 0; i < propertyDescriptorNames.length; i++) {
                    result[propertyDescriptors[propertyDescriptorNames[i]].name] = _getDefaultValue(
                            propertyDescriptors[propertyDescriptorNames[i]],
                            null,
                            result,
                            parent,
                            topParent,
                            true,
                            true,
                            type.getName(),
                            propertyOfArrayElement ? undefined : arrayIndex,
                            (arrayIndex !== undefined));
                }
                return result;
            case descriptors.BaseType.ENUM:
                return descriptors.getPropertyValues(propertyDescriptor, parent, topParent, _item ? _item.name : null)[0];
            case descriptors.BaseType.COLOR3:
            case descriptors.BaseType.VECTOR3:
                return [0, 0, 0];
            case descriptors.BaseType.COLOR4:
                return [0, 0, 0, 1];
            case descriptors.BaseType.RANGE:
                return [0, 0];
            case descriptors.BaseType.CONFINES:
                return [[0, 0], [0, 0], [0, 0]];
            case descriptors.BaseType.ASSOCIATIVE_ARRAY:
                return {};
        }
        document.crash();
    }
    /**
     * Creates a JSON object for items described by the passed item descriptor, with all properties (except for the name property) will
     * be set to default values
     * @param {Editor~ItemDescriptor} itemDescriptor
     * @param {String} name The value to set for the name property in the created object
     * @returns {Object}
     */
    function getDefaultItemData(itemDescriptor, name) {
        var result = {}, i, propertyDescriptor, propertyDescriptorNames = Object.keys(itemDescriptor);
        for (i = 0; i < propertyDescriptorNames.length; i++) {
            propertyDescriptor = itemDescriptor[propertyDescriptorNames[i]];
            if (propertyDescriptor.name === descriptors.NAME_PROPERTY_NAME) {
                result[propertyDescriptor.name] = name;
            } else {
                result[propertyDescriptor.name] = _getDefaultValue(propertyDescriptor, null, result, null, null, true, true);
            }
        }
        return result;
    }
    /**
     * Adds a header (div element) to the element representing the passed Popup with the appropriate CSS class,
     * containing the element and buttons passed. The buttons also get the appropriate CSS class.
     * @param {Popup} popup
     * @param {Element[]} elements
     * @param {Element[]} buttons
     */
    function _addPropertyEditorHeader(popup, elements, buttons) {
        var i, result = document.createElement("div");
        result.classList.add(PROPERTY_EDITOR_HEADER_CLASS);
        for (i = 0; i < elements.length; i++) {
            result.appendChild(elements[i]);
        }
        for (i = 0; i < buttons.length; i++) {
            buttons[i].classList.add(PROPERTY_EDITOR_HEADER_BUTTON_CLASS);
            result.appendChild(buttons[i]);
        }
        popup.getElement().appendChild(result);
    }
    /**
     * Creates and returns a control that can be used to edit object properties. (by opening a popup to edit the properties of that object)
     * Can create editors for arrays of objects (of the same type)
     * @param {String} topName Name of the top property being edited (under which this object resides)
     * @param {Editor~TypeDescriptor} typeDescriptor The descriptor object, with BaseType.OBJECT basetype, that describes the properties
     * @param {Object|Array} data The data itself to be modified (an instance of the object the type of which is described, or an array of
     * such objects)
     * @param {Object} parent The parent of data
     * @param {Object} topParent The top level object we are editing
     * @param {Popup} [parentPopup] If this object property editor is displayed within a popup, give a reference to that popup here
     * @param {Function} changeHandler 
     * @param {Type} [arrayType] For object arrays: The type object created from the type descriptor of the array
     * @returns {Element}
     */
    function _createObjectControl(topName, typeDescriptor, data, parent, topParent, parentPopup, changeHandler, arrayType) {
        var
                i, button = document.createElement("button"),
                popup = _createPopup(button, parentPopup, topName),
                isArray = (data instanceof Array),
                type = new descriptors.Type(typeDescriptor),
                indices, indexLabel, indexSelector,
                addElementButton, removeElementButton, moveUpElementButton, moveDownElementButton, duplicateElementButton,
                propertiesTable, getIndexText, addPropertiesTable, indexChangeHandler, updateButtonText, refreshIndices, update,
                minCount = (arrayType ? arrayType.getMinLength() || 0 : 0),
                maxCount = (arrayType ? arrayType.getMaxLength() || 0 : 0);
        getIndexText = function (index) {
            var instanceName = ((index >= 0) && data[index]) ? type.getInstanceName(data[index]) : "";
            return (index + 1).toString() + (instanceName ? ": " + instanceName : "");
        };
        refreshIndices = function () {
            return common.setSelectorOptions(indexSelector, data.map(function (entry, index) {
                return getIndexText(index);
            }));
        };
        addPropertiesTable = function (index) {
            propertiesTable = _createProperties(popup.getElement(), (index === undefined) ? data : data[index], typeDescriptor.properties, topName, parent, topParent, popup, update);
        };
        indexChangeHandler = function () {
            var index = indexSelector.selectedIndex;
            popup.hideChildren();
            if (propertiesTable) {
                popup.getElement().removeChild(propertiesTable);
                propertiesTable = null;
            }
            if (index >= 0) {
                if (_preview && !parentPopup) {
                    _preview.handleStartEdit(topName, index);
                }
                addPropertiesTable(index);
                indexLabel.textContent = typeDescriptor.name;
                indexSelector.hidden = false;
                addElementButton.hidden = !!maxCount && (data.length >= maxCount);
                removeElementButton.hidden = (data.length <= minCount);
                duplicateElementButton.hidden = false;
                moveUpElementButton.hidden = (data.length < 2) || (index === 0);
                moveDownElementButton.hidden = (data.length < 2) || (index === (data.length - 1));
            } else {
                indexLabel.textContent = EMPTY_LIST_TEXT;
                indexSelector.hidden = true;
                addElementButton.hidden = false;
                removeElementButton.hidden = true;
                duplicateElementButton.hidden = true;
                moveUpElementButton.hidden = true;
                moveDownElementButton.hidden = true;
            }
            popup.alignPosition();
        };
        updateButtonText = function () {
            button.textContent = isArray ?
                    (((data.length === 1) && typeDescriptor.getName) ? "[" + typeDescriptor.getName(data[0]) + "]" : typeDescriptor.name + " [" + data.length + "]") :
                    (typeDescriptor.getPreviewText ? typeDescriptor.getPreviewText(data) : typeDescriptor.name);
            if (parentPopup) {
                parentPopup.alignPosition();
            }
        };
        update = function () {
            updateButtonText();
            if (indexSelector && (indexSelector.selectedIndex >= 0)) {
                indexSelector.options[indexSelector.selectedIndex].text = getIndexText(indexSelector.selectedIndex);
            }
            if (changeHandler) {
                changeHandler();
            }
        };
        // for arrays: adding a selector at the top of the popup, using which the instance to modify within the array can be selected
        if (isArray) {
            // some objecs have a string shorthand: if the data contains the shorthand, extract it to the full object so it can be edited as usual
            // (only supported for arrays for now)
            if (typeDescriptor.unpack) {
                for (i = 0; i < data.length; i++) {
                    if ((typeof data[i]) === "string") {
                        data[i] = typeDescriptor.unpack(data[i]);
                    }
                }
            }
            // if the array elements have a "name" property, use the values of that instead of indices for selection
            indices = [];
            while (indices.length < data.length) {
                indices.push(getIndexText(indices.length));
            }
            indexLabel = common.createLabel((data.length > 0) ? typeDescriptor.name : EMPTY_LIST_TEXT);
            indexSelector = common.createSelector(indices, indices[0], false, indexChangeHandler);
            addElementButton = common.createButton(ADD_BUTTON_CAPTION, function () {
                var newIndex;
                data.push(_getDefaultValue({type: typeDescriptor}, null, null, null, topParent, true, undefined, undefined, data.length));
                newIndex = document.createElement("option");
                newIndex.value = getIndexText(data.length - 1);
                newIndex.text = newIndex.value;
                indexSelector.add(newIndex);
                _updateData(topName);
                indexSelector.selectedIndex = data.length - 1;
                update();
                indexChangeHandler();
            }, ADD_BUTTON_TOOLTIP);
            removeElementButton = common.createButton(REMOVE_BUTTON_CAPTION, function () {
                data.splice(indexSelector.selectedIndex, 1);
                _updateData(topName);
                refreshIndices();
                update();
                indexChangeHandler();
            }, REMOVE_BUTTON_TOOLTIP);
            duplicateElementButton = common.createButton(DUPLICATE_BUTTON_CAPTION, function () {
                var newIndex;
                data.push(utils.deepCopy(data[indexSelector.selectedIndex]));
                if (type.hasNameProperty() && data[data.length - 1][descriptors.NAME_PROPERTY_NAME]) {
                    data[data.length - 1][descriptors.NAME_PROPERTY_NAME] += DUPLICATE_ELEMENT_SUFFIX;
                }
                newIndex = document.createElement("option");
                newIndex.value = getIndexText(data.length - 1);
                newIndex.text = newIndex.value;
                indexSelector.add(newIndex);
                _updateData(topName);
                indexSelector.selectedIndex = data.length - 1;
                update();
                indexChangeHandler();
            }, DUPLICATE_BUTTON_TOOLTIP);
            moveUpElementButton = common.createButton(MOVE_UP_BUTTON_CAPTION, function () {
                data.splice(indexSelector.selectedIndex - 1, 2, data[indexSelector.selectedIndex], data[indexSelector.selectedIndex - 1]);
                updateButtonText();
                _updateData(topName);
                indexSelector.options[indexSelector.selectedIndex].text = getIndexText(indexSelector.selectedIndex);
                indexSelector.options[indexSelector.selectedIndex - 1].text = getIndexText(indexSelector.selectedIndex - 1);
                indexSelector.selectedIndex -= 1;
                indexChangeHandler();
            }, MOVE_UP_BUTTON_TOOLTIP);
            moveDownElementButton = common.createButton(MOVE_DOWN_BUTTON_CAPTION, function () {
                data.splice(indexSelector.selectedIndex, 2, data[indexSelector.selectedIndex + 1], data[indexSelector.selectedIndex]);
                updateButtonText();
                _updateData(topName);
                indexSelector.options[indexSelector.selectedIndex].text = getIndexText(indexSelector.selectedIndex);
                indexSelector.options[indexSelector.selectedIndex + 1].text = getIndexText(indexSelector.selectedIndex + 1);
                indexSelector.selectedIndex += 1;
                indexChangeHandler();
            }, MOVE_DOWN_BUTTON_TOOLTIP);
            _addPropertyEditorHeader(popup, [indexLabel, indexSelector], (arrayType && arrayType.getFixedLength()) ?
                    [moveUpElementButton, moveDownElementButton] :
                    [addElementButton, duplicateElementButton, moveUpElementButton, moveDownElementButton, removeElementButton]);
            if (data.length > 0) {
                addPropertiesTable(0);
            } else {
                indexSelector.hidden = true;
                moveUpElementButton.hidden = true;
                moveDownElementButton.hidden = true;
                removeElementButton.hidden = true;
            }
        } else {
            addPropertiesTable();
        }
        popup.addToPage();
        // create a button using which the popup can be opened
        button.type = "button";
        updateButtonText();
        button.onclick = function () {
            if (isArray) {
                indexSelector.selectedIndex = 0;
                indexChangeHandler();
            }
            popup.toggle();
            updateButtonText();
        };
        button.popup = popup; // custom property referencing the popup
        button.title = "Click to toggle property editor";
        return button;
    }
    /**
     * Adds a new row at the bottom of the passed table that has one cell for each of the elements in the passed
     * array, housing the element itself
     * @param {Element} table A HTML table element
     * @param {Element[]} elements The list of elements for the row contain. Can contain null / undefined (falsy) 
     * elements, which will be simply skipped
     */
    function _addRow(table, elements) {
        var row, cell, i;
        row = document.createElement("tr");
        for (i = 0; i < elements.length; i++) {
            if (elements[i]) {
                cell = document.createElement("td");
                cell.appendChild(elements[i]);
                row.appendChild(cell);
            }
        }
        table.appendChild(row);
    }
    /**
     * Sets up the passed button element to toggle the passed popup on click.
     * @param {Element} button A HTML button element
     * @param {String} caption The caption to show on the button (innerHTML)
     * @param {Popup} popup The popup the button should toggle
     */
    function _setPopupTogglerButton(button, caption, popup) {
        button.type = "button";
        button.innerHTML = caption;
        button.onclick = function () {
            popup.toggle();
        };
    }
    /**
     * Creates and returns a control that can be used to edit array properties. (by opening a popup to edit the elements of that array)
     * @param {String} topName Name of the top property being edited (under which this array resides)
     * @param {Editor~TypeDescriptor} elementTypeDescriptor The descriptor object describing the type of the elements of the array
     * @param {Array} array The array itself that the control should edit
     * @param {Array} parent The parent object that houses the array
     * @param {Object} topParent The top level object we are editing
     * @param {Popup} [parentPopup] If this array property editor is displayed within a popup, give a reference to that popup here
     * @param {Function} [changeHandler]
     * @param {Type} [arrayType] The type object created from the type descriptor of the array
     * @returns {Element}
     */
    function _createArrayControl(topName, elementTypeDescriptor, array, parent, topParent, parentPopup, changeHandler, arrayType) {
        var
                type = new descriptors.Type(elementTypeDescriptor),
                minCount = arrayType.getMinLength() || 0,
                maxCount = arrayType.getMaxLength() || 0,
                button = document.createElement("button"),
                popup = _createPopup(button, parentPopup, topName),
                label, table, addElementButton, i,
                updateLabel = function () {
                    label.textContent = (array.length > 0) ? type.getDisplayName() + " list" : EMPTY_LIST_TEXT;
                },
                updateButtonText = function () {
                    button.innerHTML = ((array.length === 1) && (typeof array[0] === "string")) ? "[" + array[0] + "]" : new descriptors.Type(elementTypeDescriptor).getDisplayName() + " [" + array.length + "]";
                    if (parentPopup) {
                        parentPopup.alignPosition();
                    }
                },
                elementChangeHandler = function () {
                    updateButtonText();
                    if (changeHandler) {
                        changeHandler();
                    }
                },
                refreshTable,
                addElementEditor = function (index) {
                    var elements = [
                        common.createLabel((index + 1).toString()),
                        _createControl({name: index, type: elementTypeDescriptor}, array[index], topName, array, parent, null, topParent, parentPopup, elementChangeHandler)
                    ];
                    if ((minCount === 0) || (array.length > minCount)) {
                        elements.push(common.createButton(REMOVE_BUTTON_CAPTION, function () {
                            array.splice(index, 1);
                            updateLabel();
                            refreshTable();
                            popup.alignPosition();
                            _updateData(topName);
                            elementChangeHandler();
                        }));
                    }
                    _addRow(table, elements);
                };
        refreshTable = function () {
            table.innerHTML = "";
            for (i = 0; i < array.length; i++) {
                addElementEditor(i);
            }
            addElementButton.hidden = (maxCount > 0) && (array.length >= maxCount);
        };
        addElementButton = common.createButton(ADD_BUTTON_CAPTION, function () {
            array.push(_getDefaultValue({type: elementTypeDescriptor}, null, parent, null, topParent, true));
            updateLabel();
            refreshTable();
            popup.alignPosition();
            _updateData(topName);
            elementChangeHandler();
        });
        label = common.createLabel();
        updateLabel();
        _addPropertyEditorHeader(popup, [label], [addElementButton]);
        table = document.createElement("table");
        refreshTable();
        popup.getElement().appendChild(table);
        popup.addToPage();
        // create a button using which the popup can be opened
        _setPopupTogglerButton(button, "", popup);
        updateButtonText();
        button.popup = popup; // custom property referencing the popup
        return button;
    }
    /**
     * Creates and returns a control that can be used to edit set properties. (by opening a popup to toggle the elements of that set)
     * @param {String} topName Name of the top property being edited (under which this array resides)
     * @param {Editor~TypeDescriptor} typeDescriptor The descriptor object describing the set type
     * @param {Array} data The set itself that the control should edit
     * @param {type} [parentPopup] If this array property editor is displayed within a popup, give a reference to that popup here
     * @returns {Element}
     */
    function _createSetControl(topName, typeDescriptor, data, parentPopup) {
        var
                button = document.createElement("button"),
                popup = _createPopup(button, parentPopup, topName),
                values = new descriptors.Type(typeDescriptor).getValues(true) || [],
                table, i,
                typeName = new descriptors.Type(typeDescriptor).getDisplayName(),
                updateButtonText = function () {
                    button.innerHTML = typeName + " (" + data.length + "/" + values.length + ")";
                    if (parentPopup) {
                        parentPopup.alignPosition();
                    }
                },
                elementChangeHandler = function (index, value) {
                    var elementIndex = data.indexOf(values[index]);
                    if (value) {
                        if (elementIndex === -1) {
                            data.push(values[index]);
                        }
                    } else {
                        if (elementIndex >= 0) {
                            data.splice(elementIndex, 1);
                        }
                    }
                    _updateData(topName);
                    updateButtonText();
                };
        table = document.createElement("table");
        for (i = 0; i < values.length; i++) {
            _addRow(table, [
                common.createLabel(values[i].toString()),
                common.createBooleanInput(data.indexOf(values[i]) >= 0, elementChangeHandler.bind(this, i))
            ]);
        }
        popup.getElement().appendChild(table);
        popup.addToPage();
        // create a button using which the popup can be opened
        _setPopupTogglerButton(button, "", popup);
        updateButtonText();
        button.popup = popup; // custom property referencing the popup
        return button;
    }
    /**
     * Adds a new row at the bottom of the passed table element containing the passed two element in separate cells,
     * with a third cell in between them displaying a colon.
     * @param {Element} table
     * @param {Element} firstElement
     * @param {Element} secondElement
     * @param {Element} [removeButton] The button to put next to the pair that should remove this pair from an array of pairs
     */
    function _addPairRow(table, firstElement, secondElement, removeButton) {
        _addRow(table, [
            firstElement,
            common.createLabel(":"),
            secondElement,
            removeButton
        ]);
    }
    /**
     * Creates and returns a control that can be used to array of pairs type properties. (by opening a popup to edit the pairs in the
     * array)
     * @param {String} topName Name of the top property being edited (under which this array resides)
     * @param {Editor~TypeDescriptor} typeDescriptor The descriptor object describing the pair array type
     * @param {Array} data The array itself that the control should edit
     * @param {Object} topParent The top level object we are editing
     * @param {type} [parentPopup] If this array property editor is displayed within a popup, give a reference to that popup here
     * @returns {Element}
     */
    function _createPairsControl(topName, typeDescriptor, data, topParent, parentPopup) {
        var
                button = document.createElement("button"),
                popup = _createPopup(button, parentPopup, topName),
                label, table, i, addPairButton,
                refreshTable,
                updateLabel = function () {
                    label.textContent = (data.length > 0) ? "list of pairs" : EMPTY_LIST_TEXT;
                },
                updateButtonText = function () {
                    button.innerHTML = new descriptors.Type(typeDescriptor).getDisplayName() + " (" + data.length + ")";
                    if (parentPopup) {
                        parentPopup.alignPosition();
                    }
                },
                addPairEditor = function (index) {
                    _addPairRow(table,
                            _createControl({name: 0, type: typeDescriptor.first.type}, data[index][0], topName, data[index], null, null, topParent, parentPopup),
                            _createControl({name: 1, type: typeDescriptor.second.type}, data[index][1], topName, data[index], null, null, topParent, parentPopup),
                            common.createButton(REMOVE_BUTTON_CAPTION, function () {
                                data.splice(index, 1);
                                updateLabel();
                                updateButtonText();
                                refreshTable();
                                popup.alignPosition();
                                _updateData(topName);
                            }));
                };
        refreshTable = function () {
            table.innerHTML = "";
            _addPairRow(table, common.createLabel(typeDescriptor.first.name), common.createLabel(typeDescriptor.second.name));
            for (i = 0; i < data.length; i++) {
                addPairEditor(i);
            }
        };
        addPairButton = common.createButton(ADD_BUTTON_CAPTION, function () {
            data.push([
                _getDefaultValue({type: typeDescriptor.first.type}, null, null, null, topParent),
                _getDefaultValue({type: typeDescriptor.second.type}, null, null, null, topParent)]);
            updateLabel();
            updateButtonText();
            addPairEditor(data.length - 1);
            popup.alignPosition();
            _updateData(topName);
        });
        label = common.createLabel();
        updateLabel();
        _addPropertyEditorHeader(popup, [label], [addPairButton]);
        table = document.createElement("table");
        refreshTable();
        popup.getElement().appendChild(table);
        popup.addToPage();
        // create a button using which the popup can be opened
        _setPopupTogglerButton(button, "", popup);
        updateButtonText();
        button.popup = popup; // custom property referencing the popup
        return button;
    }
    /**
     * Creates and returns a control that can be used to array of rotations type properties. (by opening a popup to edit the rotations in 
     * the array)
     * @param {String} topName Name of the top property being edited (under which this array resides)
     * @param {Array} data The array itself that the control should edit
     * @param {type} [parentPopup] If this array property editor is displayed within a popup, give a reference to that popup here
     * @returns {Element}
     */
    function _createRotationsControl(topName, data, parentPopup) {
        var
                button = document.createElement("button"),
                popup = _createPopup(button, parentPopup, topName),
                table, i, addRotationButton,
                refreshTable,
                updateButtonText = function () {
                    if (data.length > 1) {
                        button.textContent = data.length + " rotations";
                    } else if (data.length === 1) {
                        button.textContent = data[0].axis + ((data[0].degrees < 0) ? " - " : " + ") + Math.abs(data[0].degrees) + "°";
                    } else {
                        button.textContent = "none";
                    }
                    if (parentPopup) {
                        parentPopup.alignPosition();
                    }
                },
                addRotationEditor = function (index) {
                    _addPairRow(table,
                            _createControl({name: "axis", type: descriptors.AXIS}, data[index].axis, topName, data[index], null, null, null, parentPopup, updateButtonText),
                            _createControl({name: "degrees", type: {baseType: descriptors.BaseType.NUMBER, min: -360, max: 360}}, data[index].degrees, topName, data[index], null, null, null, parentPopup, updateButtonText),
                            common.createButton(REMOVE_BUTTON_CAPTION, function () {
                                data.splice(index, 1);
                                updateButtonText();
                                refreshTable();
                                popup.alignPosition();
                                _updateData(topName);
                            }));
                };
        refreshTable = function () {
            table.innerHTML = "";
            _addPairRow(table, common.createLabel("axis"), common.createLabel("degrees"));
            for (i = 0; i < data.length; i++) {
                addRotationEditor(i);
            }
        };
        addRotationButton = common.createButton(ADD_BUTTON_CAPTION, function () {
            data.push({
                axis: _getDefaultValue({type: descriptors.AXIS}),
                degrees: _getDefaultValue({type: descriptors.BaseType.NUMBER})
            });
            updateButtonText();
            addRotationEditor(data.length - 1);
            popup.alignPosition();
            _updateData(topName);
        });
        // expand string shorthands to proper objects
        for (i = 0; i < data.length; i++) {
            if (typeof data[i] === "string") {
                data[i] = {
                    axis: data[i][0].toUpperCase(),
                    degrees: parseFloat(data[i].substring(1))
                };
            }
        }
        _addPropertyEditorHeader(popup, [common.createLabel("rotations")], [addRotationButton]);
        table = document.createElement("table");
        refreshTable();
        popup.getElement().appendChild(table);
        popup.addToPage();
        // create a button using which the popup can be opened
        _setPopupTogglerButton(button, "", popup);
        updateButtonText();
        button.popup = popup; // custom property referencing the popup
        return button;
    }
    /**
     * Creates and returns a control that can be used to edit confines type properties. (by opening a popup to edit the ranges)
     * @param {String} topName Name of the top property being edited (under which this array resides)
     * @param {Array} data The array itself that the control should edit
     * @param {type} [parentPopup] If this array property editor is displayed within a popup, give a reference to that popup here
     * @returns {Element}
     */
    function _createConfinesControl(topName, data, parentPopup) {
        var
                button = document.createElement("button"),
                popup = _createPopup(button, parentPopup, topName),
                table, i, axis;
        table = document.createElement("table");
        for (i = 0; i < data.length; i++) {
            switch (i) {
                case 0:
                    axis = "X";
                    break;
                case 1:
                    axis = "Y";
                    break;
                case 2:
                    axis = "Z";
                    break;
                default:
                    axis = i.toString();
            }
            _addRow(table, [common.createLabel(axis), _createRangeControl(topName, {elementType: {unit: descriptors.Unit.METERS}}, data[i])]);
        }
        popup.getElement().appendChild(table);
        popup.addToPage();
        // create a button using which the popup can be opened
        _setPopupTogglerButton(button, "Confines", popup);
        button.popup = popup; // custom property referencing the popup
        return button;
    }
    /**
     * Creates and returns a control that can be used to edit associative array properties. (by opening a popup to edit the elements of that 
     * array)
     * @param {String} topName Name of the top property being edited (under which this array resides)
     * @param {String[]} [validKeys] If only a set of values are accepted as valid keys in the array, pass them here (if not given, arbitrary string keys can be used)
     * @param {Editor~TypeDescriptor} elementTypeDescriptor The descriptor object describing the type of the elements of the array
     * @param {Object} data The array itself that the control should edit
     * @param {Object} topParent The top level object we are editing
     * @param {type} [parentPopup] If this array property editor is displayed within a popup, give a reference to that popup here
     * @returns {Element}
     */
    function _createAssocArrayControl(topName, validKeys, elementTypeDescriptor, data, topParent, parentPopup) {
        var
                button = document.createElement("button"),
                popup = _createPopup(button, parentPopup, topName),
                table, addEntryButton,
                newEntryKeyEditor, newEntryKeySelector,
                refreshTable,
                /**
                 * Returns the list of valid keys that can still be used (so are not in the array already)
                 * @returns {Array}
                 */
                getValidKeys = function () {
                    var i, result = [];
                    for (i = 0; i < validKeys.length; i++) {
                        if (!data.hasOwnProperty(validKeys[i])) {
                            result.push(validKeys[i]);
                        }
                    }
                    return result;
                },
                updateButtonText = function () {
                    button.innerHTML = new descriptors.Type(elementTypeDescriptor).getDisplayName() + " (" + Object.keys(data).length + ")";
                    if (parentPopup) {
                        parentPopup.alignPosition();
                    }
                },
                /**
                 * Displays the currently available valid keys in the key selector
                 */
                updateEntryKeySelector = function () {
                    var i, option, keys;
                    if (newEntryKeySelector) {
                        while (newEntryKeySelector.options.length > 0) {
                            newEntryKeySelector.remove(0);
                        }
                        keys = getValidKeys();
                        for (i = 0; i < keys.length; i++) {
                            option = document.createElement("option");
                            option.text = keys[i];
                            newEntryKeySelector.add(option);
                        }
                        if (keys.length === 0) {
                            newEntryKeySelector.hidden = true;
                            addEntryButton.disabled = true;
                        } else {
                            newEntryKeySelector.hidden = false;
                            addEntryButton.disabled = false;
                        }
                    }
                },
                addEntryEditor = function (index) {
                    var key = Object.keys(data)[index];
                    _addPairRow(table,
                            common.createLabel(key),
                            _createControl({name: key, type: elementTypeDescriptor}, data[key], topName, data, null, null, topParent, parentPopup),
                            common.createButton(REMOVE_BUTTON_CAPTION, function () {
                                delete data[key];
                                updateButtonText();
                                updateEntryKeySelector();
                                refreshTable();
                                popup.alignPosition();
                                _updateData(topName);
                            }));
                },
                getKeyEditor = function () {
                    return validKeys ? newEntryKeySelector : newEntryKeyEditor;
                };
        refreshTable = function () {
            var i, keys = Object.keys(data);
            table.innerHTML = "";
            for (i = 0; i < keys.length; i++) {
                addEntryEditor(i);
            }
        };
        if (!validKeys) {
            newEntryKeyEditor = document.createElement("input");
            newEntryKeyEditor.type = "text";
            newEntryKeyEditor.onchange = function () {
                addEntryButton.disabled = (newEntryKeyEditor.value.length === 0);
            };
        } else {
            newEntryKeySelector = common.createSelector(getValidKeys(), undefined, false, function () {
                addEntryButton.disabled = (newEntryKeySelector.value.length === 0);
            });
        }
        addEntryButton = common.createButton(ADD_BUTTON_CAPTION, function () {
            data[getKeyEditor().value] = _getDefaultValue({type: elementTypeDescriptor}, null, null, null, topParent);
            updateButtonText();
            updateEntryKeySelector();
            refreshTable();
            popup.alignPosition();
            _updateData(topName);
        });
        addEntryButton.disabled = (getKeyEditor().value.length === 0);
        _addPropertyEditorHeader(popup, [getKeyEditor()], [addEntryButton]);
        table = document.createElement("table");
        refreshTable();
        popup.getElement().appendChild(table);
        popup.addToPage();
        // create a button using which the popup can be opened
        _setPopupTogglerButton(button, "", popup);
        updateButtonText();
        button.popup = popup; // custom property referencing the popup
        return button;
    }
    /**
     * Creates and returns an element that can be used to display the value of properties the type of which is not identified.
     * @param {} data The value of the property to display
     * @returns {Element}
     */
    function _createDefaultControl(data) {
        var result = document.createElement("span");
        result.innerHTML = data.toString();
        result.classList.add(CONTROL_CLASS);
        return result;
    }
    /**
     * Creates and returns a control that can be used to initialize unset properties
     * @param {Editor~PropertyDescriptor} propertyDescriptor
     * @param {String} topName See _changeData
     * @param {Object} parent See _changeData
     * @param {Object} topParent The top level object we are editing
     * @param {Popup} [parentPopup] If this property editor is displayed within a popup, give a reference to that popup here
     * @param {Function} [changeHandler] Operations need to be executed in case this property changes
     * @param {Element} [row] The <tr> element within which this control sits
     * @returns {Element}
     */
    function _createUnsetControl(propertyDescriptor, topName, parent, topParent, parentPopup, changeHandler, row) {
        var result = document.createElement("div"),
                labelText, defaultValue, label, button, type = new descriptors.Type(propertyDescriptor.type), optional, setProperty, limit = false;
        optional = propertyDescriptor.optional || (propertyDescriptor.isRequired && !propertyDescriptor.isRequired(parent, null, _item.name));
        if ((!parent || (parent === _item.data)) && _basedOn) {
            label = _createDefaultControl(INHERITED_PROPERTY_TEXT);
        } else if ((propertyDescriptor.defaultValue !== undefined) || propertyDescriptor.globalDefault || propertyDescriptor.defaultText) {
            labelText = DEFAULT_PROPERTY_TEXT;
            if (propertyDescriptor.defaultText) {
                labelText = propertyDescriptor.defaultText;
            } else {
                defaultValue = propertyDescriptor.defaultValue;
                if ((defaultValue === undefined) && propertyDescriptor.globalDefault && propertyDescriptor.settingName) {
                    defaultValue = config.getSetting(propertyDescriptor.settingName);
                }
                if (typeof defaultValue === "number") {
                    labelText = defaultValue.toString();
                    if (type.getUnit()) {
                        labelText += " " + type.getUnit();
                    }
                } else if (typeof defaultValue === "boolean") {
                    labelText = defaultValue ? "yes" : "no";
                } else if (typeof defaultValue === "string") {
                    labelText = defaultValue;
                    limit = true;
                } else if (Array.isArray(defaultValue)) {
                    if (defaultValue.length === 0) {
                        labelText = "empty list";
                    } else {
                        if ((typeof defaultValue[0] === "number") || (typeof defaultValue[0] === "string")) {
                            if (type.getBaseType() === descriptors.BaseType.RANGE) {
                                labelText = defaultValue.map(function (element) {
                                    var elementType = type.getElementType();
                                    return element + ((elementType && elementType.getUnit()) ? " " + elementType.getUnit() : "");
                                }).join(" - ");
                            } else {
                                labelText = defaultValue.join(", ");
                            }
                            if ((propertyDescriptor.type === descriptors.BaseType.COLOR3) || (propertyDescriptor.type === descriptors.BaseType.COLOR4)) {
                                labelText = common.createColorPreview(defaultValue).outerHTML + labelText;
                                limit = false;
                            } else {
                                limit = true;
                            }
                        } else if (typeof defaultValue[0] === "boolean") {
                            labelText = defaultValue.map((boolean) => (boolean ? "yes" : "no")).join(", ");
                            limit = true;
                        }
                    }
                }
            }
            if (limit && (labelText.length > 20)) {
                labelText = labelText.substring(0, 17) + "...";
            }
            label = _createDefaultControl(labelText);
        } else if (propertyDescriptor.getDerivedDefault) {
            label = _createDefaultControl(propertyDescriptor.getDerivedDefault(parent, null, _item.name));
        } else if (optional) {
            if (type.getBaseType() === descriptors.BaseType.ROTATIONS) {
                label = _createDefaultControl(NONE_PROPERTY_TEXT);
            } else {
                label = _createDefaultControl(UNSET_PROPERTY_TEXT);
            }
        } else {
            label = _createDefaultControl(UNKNOWN_PROPERTY_TEXT);
        }
        label.classList.add(WITH_SET_PROPERTY_BUTTON_CLASS);
        result.appendChild(label);
        setProperty = function () {
            var value, parentNode = result.parentNode, control;
            if (!parentNode) {
                return;
            }
            value = _getDefaultValue(propertyDescriptor, _basedOn, parent, null, topParent);
            parentNode.removeChild(result);
            if (row) {
                row.classList.remove(UNSET_PROPERTY_ROW_CLASS);
            }
            control = _createControl(propertyDescriptor, value, topName, parent, null, null, topParent, parentPopup, changeHandler, row);
            parentNode.appendChild(control);
            parentNode.control = control;
            _changeData(topName, value, parent, propertyDescriptor.name, changeHandler);
        };
        button = document.createElement("button");
        button.type = "button";
        button.innerHTML = SET_PROPERTY_BUTTON_CAPTION;
        button.className = SET_PROPERTY_BUTTON_CLASS;
        button.onclick = setProperty;
        result.appendChild(button);
        result.title = "Click to set property";
        result.onclick = setProperty;
        if (row) {
            row.classList.add(UNSET_PROPERTY_ROW_CLASS);
        }
        return result;
    }
    /**
     * Creates and returns a control that can be used to edit the value of the property described by the passed property description object.
     * Creates the appripriate type of control depending on the type of the property.
     * @param {Editor~PropertyDescriptor} propertyDescriptor Should contain the name and type of the property
     * @param {} data The starting value of the property
     * @param {String} [topName] If the property to edit resides below another property of the main edited item, the name of the property 
     * directly under the main item must be given here (so that the preview can be notified about under which property did the change happen)
     * @param {Object} [parent] If the property to edit resides below another property of the main edited item, the parent object of the
     * edited property must be given here
     * @param {Object} [arrayParent] If the property is the element of an array, the parent parameter will refer to the array, and this one
     * will refer to the parent of the array
     * @param {Object} [objectParent] If the property is the property of an object, this refers to the parent of the object
     * @param {Object} topParent The top level object we are editing
     * @param {Popup} [parentPopup] If this property editor is displayed within a popup, give a reference to that popup here
     * @param {Function} [changeHandler] Operations to be executed in case this property changes
     * @param {Element} [row] The <tr> element within which this control sits
     * @returns {Element}
     */
    _createControl = function (propertyDescriptor, data, topName, parent, arrayParent, objectParent, topParent, parentPopup, changeHandler, row) {
        var
                result, control, button,
                /**
                 * @type Type
                 */
                type = new descriptors.Type(propertyDescriptor.type), elementType, required, optional;
        topName = topName || propertyDescriptor.name;
        required = !!propertyDescriptor.isRequired && propertyDescriptor.isRequired(parent, objectParent, _item.name);
        optional = propertyDescriptor.optional || (propertyDescriptor.isRequired && !propertyDescriptor.isRequired(parent, objectParent, _item.name));
        if (data === undefined) {
            result = _createUnsetControl(propertyDescriptor, topName, parent, topParent, parentPopup, changeHandler, row);
        } else {
            switch (type.getBaseType()) {
                case descriptors.BaseType.BOOLEAN:
                    result = _createBooleanControl(topName, data, parent, propertyDescriptor.name, changeHandler);
                    break;
                case descriptors.BaseType.NUMBER:
                    result = _createNumberControl(topName, data, type.isInteger(), changeHandler, parent, propertyDescriptor.name, type.getUnit(), type.getMin(), type.getMax());
                    break;
                case descriptors.BaseType.STRING:
                    if (type.isLong()) {
                        result = _createLongStringControl(topName, data, parent, propertyDescriptor.name, parentPopup, changeHandler);
                    } else {
                        result = _createStringControl(topName, data, parent, propertyDescriptor.name, changeHandler);
                    }
                    break;
                case descriptors.BaseType.ENUM:
                    control = _createEnumControl(topName, descriptors.getPropertyValues(propertyDescriptor, arrayParent || parent, topParent, _item.name), data, parent, propertyDescriptor.name, changeHandler);
                    control.classList.add(CONTROL_CLASS);
                    result = document.createElement("div");
                    result.appendChild(control);
                    if (type.isItemReference()) {
                        control.classList.add(WITH_JUMP_TO_REFERENCE_BUTTON_CLASS);
                        button = common.createButton(JUMP_TO_REFERENCE_BUTTON_CAPTION, function () {
                            _selectItemFunction(type.getReferenceItemType(), control.value, type.getReferenceItemCategory());
                        }, JUMP_TO_REFERENCE_BUTTON_TOOLTIP);
                        button.classList.add(JUMP_TO_REFERENCE_BUTTON_CLASS);
                        result.appendChild(button);
                    }
                    break;
                case descriptors.BaseType.COLOR3:
                case descriptors.BaseType.COLOR4:
                    result = _createColorControl(topName, data);
                    break;
                case descriptors.BaseType.VECTOR3:
                    result = _createVectorControl(topName, data);
                    break;
                case descriptors.BaseType.RANGE:
                    result = _createRangeControl(topName, propertyDescriptor.type, data);
                    break;
                case descriptors.BaseType.PAIRS:
                    result = _createPairsControl(topName, propertyDescriptor.type, data, topParent, parentPopup);
                    break;
                case descriptors.BaseType.ROTATIONS:
                    result = _createRotationsControl(topName, data, parentPopup);
                    break;
                case descriptors.BaseType.SET:
                    result = _createSetControl(topName, propertyDescriptor.type, data, parentPopup);
                    break;
                case descriptors.BaseType.CONFINES:
                    result = _createConfinesControl(topName, data, parentPopup);
                    break;
                case descriptors.BaseType.ARRAY:
                    elementType = type.getElementType();
                    if (elementType.getBaseType() === descriptors.BaseType.OBJECT) {
                        result = _createObjectControl(topName, elementType.getDescriptor(), data, parent, topParent, parentPopup, changeHandler, type);
                    } else {
                        result = _createArrayControl(topName, elementType.getDescriptor(), data, parent, topParent, parentPopup, changeHandler, type);
                    }
                    break;
                case descriptors.BaseType.ASSOCIATIVE_ARRAY:
                    result = _createAssocArrayControl(topName, type.getValidKeys(), type.getElementType().getDescriptor(), data, topParent, parentPopup);
                    break;
                case descriptors.BaseType.OBJECT:
                    result = _createObjectControl(topName, propertyDescriptor.type, data, parent, topParent, parentPopup, changeHandler);
                    break;
                default:
                    result = _createDefaultControl(data);
            }
            if (row) {
                row.classList.remove(UNSET_PROPERTY_ROW_CLASS);
            }
            // add unset button for optional values
            if (!required && (optional || (propertyDescriptor.defaultValue !== undefined) || propertyDescriptor.globalDefault || propertyDescriptor.getDerivedDefault ||
                    ((!parent || (parent === _item.data)) && _basedOn && (propertyDescriptor.name !== descriptors.NAME_PROPERTY_NAME))) && (propertyDescriptor.name !== descriptors.BASED_ON_PROPERTY_NAME)) {
                if (!control) {
                    control = result;
                    control.classList.add(CONTROL_CLASS);
                    result = document.createElement("div");
                    result.appendChild(control);
                    result.popup = control.popup;
                }
                result.classList.add(WITH_UNSET_PROPERTY_BUTTON_CLASS);
                button = common.createButton(UNSET_PROPERTY_BUTTON_CAPTION, function () {
                    var parentNode = result.parentNode, newControl;
                    if (control.popup) {
                        control.popup.remove();
                    }
                    parentNode.removeChild(result);
                    newControl = _createUnsetControl(propertyDescriptor, topName, parent, topParent, parentPopup, changeHandler, row);
                    newControl.classList.add(CONTROL_CLASS);
                    parentNode.appendChild(newControl);
                    parentNode.control = newControl;
                    _changeData(topName, undefined, parent, propertyDescriptor.name, changeHandler);
                }, UNSET_PROPERTY_BUTTON_TOOLTIP);
                button.classList.add(UNSET_PROPERTY_BUTTON_CLASS);
                result.appendChild(button);
            }
        }
        result.classList.add(CONTROL_CLASS);
        return result;
    };
    /**
     * Creates labels and controls to show and edit the properties of an object
     * @param {Element} element The parent HTML element to add the created content to
     * @param {Object} data The object itself that is to be edited
     * @param {Editor~ItemDescriptor} itemDescriptor An object that should contain the property descriptors based on which to create the 
     * controls
     * @param {String} [topName] See _changeData or _createControl
     * @param {Object} parent The parent object of data
     * @param {Object} topParent The top level object we are editing
     * @param {Popup} [parentPopup] If this object property editor is displayed within a popup, give a reference to that popup here
     * @param {Function} changeHandler Operations need to be executed when one of the created controls changes a property 
     * @returns {Element} The element that houses the properties and was added to the parent element
     */
    _createProperties = function (element, data, itemDescriptor, topName, parent, topParent, parentPopup, changeHandler) {
        var
                table, rows, properties, validate, generateRow, generateTable;
        generateRow = function (row, index) {
            var valid, required, nameCell, valueCell, control, propertyDescriptor = itemDescriptor[properties[index]];
            nameCell = document.createElement("td");
            nameCell.classList.add(PROPERTY_CLASS);
            nameCell.innerHTML = propertyDescriptor.name;
            nameCell.title = propertyDescriptor.name;
            row.appendChild(nameCell);
            valueCell = document.createElement("td");
            valid = !propertyDescriptor.isValid || propertyDescriptor.isValid(data, parent, _item.name);
            required = !propertyDescriptor.optional && !propertyDescriptor.globalDefault && !propertyDescriptor.getDerivedDefault && (propertyDescriptor.defaultValue === undefined) && (!propertyDescriptor.isRequired || propertyDescriptor.isRequired(data, parent, _item.name));
            if (!valid || (row.required && !required)) {
                delete data[propertyDescriptor.name];
            } else if (required && (data[propertyDescriptor.name] === undefined) && (!_basedOn || (data !== _item.data))) {
                data[propertyDescriptor.name] = _getDefaultValue(propertyDescriptor, null, data, parent, topParent, true, true);
            }
            control = _createControl(propertyDescriptor, data[propertyDescriptor.name], topName, data, null, parent, topParent, parentPopup, validate.bind(this, row), row);
            valueCell.appendChild(control);
            valueCell.control = control;
            row.appendChild(valueCell);
            row.valueCell = valueCell;
            row.hidden = !valid;
            row.required = required;
        };
        generateTable = function () {
            var i, row;
            rows = [];
            for (i = 0; i < properties.length; i++) {
                row = document.createElement("tr");
                row.className = PROPERTY_ROW_CLASS;
                generateRow(row, i);
                table.appendChild(row);
                rows.push(row);
            }
        };
        validate = function (sourceRow) {
            var i, valid;
            for (i = 0; i < rows.length; i++) {
                valid = !itemDescriptor[properties[i]].isValid || itemDescriptor[properties[i]].isValid(data, parent, _item.name);
                if ((rows[i].hidden !== !valid) || (valid && itemDescriptor[properties[i]].updateOnValidate && (sourceRow !== rows[i]))) {
                    if (rows[i].valueCell.control.popup) {
                        rows[i].valueCell.control.popup.remove();
                    }
                    rows[i].innerHTML = "";
                    generateRow(rows[i], i);
                }
            }
            if (changeHandler) {
                changeHandler();
            }
            if (parentPopup) {
                parentPopup.alignPosition(true);
            }
        };
        table = document.createElement("table");
        table.classList.add(PROPERTIES_CLASS);
        properties = Object.keys(itemDescriptor);
        generateTable();
        element.appendChild(table);
        return table;
    };
    /**
     * Creates the content for the Properties window - the list of available properties and controls to edit their values.
     * @param {Element} element The parent HTML element to add the created content to
     * @param {Editor~Item} item The item for which to display the property values
     * @param {Editor~Preview} preview The module providing the Preview window for the item
     * @param {Function} changeHandler Operations need to be executed one of the created controls changes a property
     * @param {Function} selectItemFunction The function to execute for selecting a new item  in the editor
     */
    createProperties = function (element, item, preview, changeHandler, selectItemFunction) {
        _element = element;
        _item = item;
        _preview = preview;
        _nameChangeHandler = changeHandler;
        _selectItemFunction = selectItemFunction;
        _updateBasedOn();
        _createProperties(element, item.data, descriptors.itemDescriptors[item.category], null, null, item.data, null, changeHandler);
    };
    // ------------------------------------------------------------------------------
    // The public interface of the module
    return {
        createProperties: createProperties,
        getDefaultItemData: getDefaultItemData
    };
});
/**
 * Copyright 2017, 2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for shader resources within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param resources Used to request the loading of the shader
 */
define('editor/preview/shader-preview',[
    "modules/media-resources"
], function (resources) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            /**
             * The names of properties the change of which should trigger an update of the preview div
             * @type String[]
             */
            DIV_UPDATE_PROPERTIES = [
                "vertexShaderSource", "fragmentShaderSource"
            ],
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * A reference to the object storing the HTML elements to be used for the preview
             * @type Object
             */
            _elements,
            /**
             * 
             * @type Element
             */
            _codeDiv,
            /**
             * A reference to the displayed skybox class
             * @type ShaderResource
             */
            _shaderResource;
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * Put all the occurrences of the past expressions within the passed code inside
     * an HTML <span> tag with the passed class
     * @param {String} code
     * @param {String[]} expressions
     * @param {String} markupClass
     * @returns {String}
     */
    function _markupCode(code, expressions, markupClass) {
        for (var i = 0; i < expressions.length; i++) {
            code = code.replace(new RegExp(expressions[i], "g"), '<span class="' + markupClass + '">$&</span>');
        }
        return code;
    }
    /**
     * Process and return raw GLSL shader source code to be displayed as syntax highlighted HTML text
     * @param {String} code
     * @returns {String}
     */
    function _processCode(code) {
        code = code.replace(/\/\/(.*?)\n/g, '<span class="glsl-comment">$&</span>');
        code = code.replace(/\n/g, "<br/>");
        code = code.replace(/ {2}/g, "&nbsp;&nbsp;");
        code = _markupCode(code, ["#version", "#define", "#elseif", "#ifdef", "#ifndef", "#endif", "#if", "#else"], "glsl-directive");
        code = _markupCode(code, ["uniform ", "attribute ", "varying ", "precision ", "lowp ", "mediump ", "highp ", "struct", "return", "discard", "\\bif\\b", "\\belse\\b", "\\bswitch\\b", "\\bcase\\b", "\\bfor\\b", "\\bbreak\\b", "\\bcontinue\\b"], "glsl-keyword");
        code = _markupCode(code, ["void", "bool", "\\bint\\b", "float", "vec2", "vec3", "vec4", "mat2", "mat3", "mat4", "sampler2D", "samplerCube"], "glsl-type");
        code = _markupCode(code, ["gl_Position", "gl_FragColor"], "glsl-variable");
        code = _markupCode(code, ["dot\\(", "cross\\(", "length\\(", "normalize\\(", "reflect\\(", "abs\\(", "sign\\(", "fract\\(", "min\\(", "max\\(", "pow\\(", "sin\\(", "cos\\(", "mix\\(", "step\\(", "clamp\\(", "texture2D\\(", "textureCube\\("], "glsl-function");
        code = _markupCode(code, ["\\(", "\\)", "\\[", "\\]"], "glsl-operator");
        return code;
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window for the editor to show the selected 
     * shader recource.
     * @param {Editor~RefreshElements} [elements] References to the HTML elements that can be used for the preview.
     * @param {SpacecraftClass} [shaderResource] The shader resource to preview
     */
    function refresh(elements, shaderResource) {
        _shaderResource = shaderResource || _shaderResource;
        _elements = elements || _elements;
        resources.executeWhenReady(function () {
            var vertexShaderTitle, vertexShaderCode, code, fragmentShaderTitle, fragmentShaderCode;
            _elements.options.hidden = true;
            _elements.div.hidden = false;
            _elements.canvas.hidden = true;
            _elements.info.hidden = true;
            
            _codeDiv = document.createElement("div");
            _codeDiv.classList.add("previewContent");
            vertexShaderTitle = document.createElement("h1");
            vertexShaderTitle.textContent = "Vertex shader";
            vertexShaderTitle.classList.add("glsl-header");
            _codeDiv.appendChild(vertexShaderTitle);
            vertexShaderCode = document.createElement("p");
            vertexShaderCode.classList.add("glsl-code");
            code = _shaderResource.getVertexShaderSource();
            vertexShaderCode.innerHTML = _processCode(code);
            _codeDiv.appendChild(vertexShaderCode);
            fragmentShaderTitle = document.createElement("h1");
            fragmentShaderTitle.textContent = "Fragment shader";
            fragmentShaderTitle.classList.add("glsl-header");
            _codeDiv.appendChild(fragmentShaderTitle);
            fragmentShaderCode = document.createElement("p");
            fragmentShaderCode.classList.add("glsl-code");
            code = _shaderResource.getFragmentShaderSource();
            fragmentShaderCode.innerHTML = _processCode(code);
            _codeDiv.appendChild(fragmentShaderCode);
            _elements.div.appendChild(_codeDiv);
            
            _elements.div.style.height = (_elements.div.parentNode.clientHeight - (_elements.options.clientHeight + _elements.info.clientHeight)) + "px";
        });
        resources.requestResourceLoad();
    }
    /**
     * Clears the preview 
     */
    function clear() {
        if (_codeDiv) {
            _codeDiv.parentNode.removeChild(_codeDiv);
            _codeDiv = null;
        }
    }
    /**
     * Updates the preview (refreshes if needed) in case the property with the given name changed
     * @param {String} name
     */
    function handleDataChanged(name) {
        if (DIV_UPDATE_PROPERTIES.indexOf(name) >= 0) {
            clear();
            refresh();
        }
    }
    /**
     * Called from outside
     */
    function handleStartEdit() {
        return true;
    }
    /**
     * Called from outside
     */
    function handleStopEdit() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Initialization
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: clear,
        handleDataChanged: handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2016-2020 Krisztián Nagy
 * @file Provides the general structure to preview windows of the Interstellar Armada editor that use a WebGL scene 
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param utils Used for enum value listing, async execution.
 * @param vec Used for vector operations related to camera control.
 * @param mat Used for matrix operatinos related to camera control.
 * @param pools Used to clean up the particle pool during animations and refresh
 * @param managedGL Used to create a managed context for the WebGL preview canvas.
 * @param renderableObjects Used for accessing uniform name constants
 * @param sceneGraph Used for creating the preview scene
 * @param resources Used to request media resources and wait for their loading.
 * @param audio Used to set audio volume
 * @param graphics Used to access the graphics settings of the game (same are used for the preview)
 * @param config Used to access default camera configuration settings.
 * @param constants Used to get pool names
 * @param classes Used to create an object view for the preview model.
 * @param explosion Used to manage the explosion pool.
 * @param common Used to create selectors.
 */
define('editor/preview/webgl-preview',[
    "utils/utils",
    "utils/vectors",
    "utils/matrices",
    "modules/pools",
    "modules/managed-gl",
    "modules/media-resources",
    "modules/audio",
    "modules/scene/renderable-objects",
    "modules/scene/scene-graph",
    "armada/graphics",
    "armada/configuration",
    "armada/logic/constants",
    "armada/logic/classes",
    "armada/logic/explosion",
    "editor/common"
], function (
        utils, vec, mat,
        pools, managedGL, resources, audio,
        renderableObjects, sceneGraph,
        graphics, config, constants, classes, explosion,
        common) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Enums
            /**
             * The available render modes for the preview.
             * @enum {String}
             * @type Object
             */
            RenderMode = {
                WIREFRAME: "wireframe",
                SOLID: "solid",
                BOTH: "both"
            },
            // ----------------------------------------------------------------------
            // Constants
            INITIAL_CAMERA_FOV = 40,
            INITIAL_CAMERA_SPAN = 0.2,
            ROTATION_MOUSE_SENSITIVITY = 1.0,
            CAMERA_ROTATION_MOUSE_SENSITIVITY = 0.25,
            CAMERA_PAN_MOUSE_SENSITIVITY = 0.25,
            CAMERA_SCROLL_MOVE_FACTOR = 1000,
            FREE_CAMERA_INITIAL_HEIGHT = 500,
            FREE_CAMERA_VIEW_DISTANCE = 15000,
            MODEL_ROTATE_BUTTON = utils.MouseButton.LEFT,
            CAMERA_ROTATE_BUTTON = utils.MouseButton.MIDDLE,
            ENLARGE_FACTOR = 1.05,
            SHRINK_FACTOR = 0.95,
            SETTING_CLASS = "setting",
            SETTING_LABEL_CLASS = "settingLabel",
            CANVAS_BACKGROUND_COLOR = [0, 0, 0, 1],
            AMBIENT_COLOR = [0, 0, 0],
            MANAGED_CONTEXT_NAME = "context",
            DEFAULT_DISTANCE_FACTOR = 1.5,
            DEFAULT_CAMERA_DIRECTION = [0, -1, 0],
            MAX_DISTANCE_FACTOR = 100,
            OBJECT_VIEW_NAME = "standard",
            FOV = 45,
            WIREFRAME_SHADER_NAME = "oneColor",
            WIREFRAME_COLOR = [1, 1, 1, 1],
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * @type Pool
             */
            _particlePool,
            /**
             * @type Pool
             */
            _explosionPool,
            /**
             * @type ManagedGLContext
             */
            _context,
            /**
             * @type Scene
             */
            _scene,
            /**
             * @type RenderableObject3D
             */
            _model, _wireframeModel,
            /**
             * @type Number[2]
             */
            _mousePos,
            /**
             * @type Boolean
             */
            _turningModel, _turningCamera,
            /**
             * A reference to the object storing the HTML elements to be used for the preview
             * @type Object
             */
            _elements,
            /**
             * (enum RenderMode)
             * @type String
             */
            _renderMode,
            /**
             * @type String
             */
            _lod,
            /**
             * 
             * @type WebGLPreviewContext
             */
            _currentContext,
            /**
             * Whether the scne is currently animating (a requestAnimFrame loop is active)
             * @type Boolean
             */
            _animating,
            /**
             * Whether the animation should be stopped next time a frame is about to be rendered by requestAnimFrame
             * @type Boolean
             */
            _animationStopScheduled,
            /**
             * Whether the sound should be muted
             * @type Boolean
             */
            _muted,
            /**
             * The timestamp of the last render frame to calculate elapsed time
             * @type DOMHighResTimeStamp
             */
            _lastRenderTimestamp,
            /**
             * The current frames per seconds value
             * @type Number
             */
            _fps,
            /**
             * 
             * @type Object
             */
            _optionElements = {
                renderModeSelector: null,
                lodSelector: null,
                animateButton: null,
                muteCheckbox: null
            };
    /**
     * @typedef {Object} Editor~WebGLPreviewParams
     * @property {Boolean} renderModeSetting
     * @property {Boolean} lodSetting
     * @property {Boolean} animateButton
     * @property {Boolean} [animateOnRefresh] If not set, preserving previously set animation state
     * @property {Boolean} muteCheckbox
     * @property {String[]} canvasUpdateProperties
     * @property {String[]} optionRefreshProperties
     * @property {String[]} infoUpdateProperties
     * @property {Number} [defaultDistanceFactor]
     * @property {Number[3]} [cameraDirection] 
     */
    /**
     * @typedef {Object} Editor~WebGLPreviewFunctions
     * @property {Function} clear
     * @property {Function} load
     * @property {Function} updateForRefresh
     * @property {Function} clearSettingsForNewItem
     * @property {Function} createOptions
     * @property {Function} animate
     * @property {Function} onModelRotate
     * @property {Function} getInfo
     */
    /**
     * @class
     * @param {Editor~WebGLPreviewParams} params
     * @param {Editor~WebGLPreviewFunctions} functions
     */
    function WebGLPreviewContext(params, functions) {
        /**
         * @type Editor~WebGLPreviewParams
         */
        this.params = params;
        /**
         * @type Editor~WebGLPreviewFunctions
         */
        this.functions = functions;
        /**
         * @type Float32Array
         */
        this.modelOrientationMatrix = mat.identity4();
        /**
         * @type Float32Array
         */
        this.cameraOrientationMatrix = mat.identity4();
        /**
         * @type Number
         */
        this.cameraDistance = 0;
    }
    function setContext(value) {
        if (_currentContext) {
            _currentContext.functions.clear();
        }
        _currentContext = value;
    }
    function getScene() {
        return _scene;
    }
    function getWireframeShaderName() {
        return WIREFRAME_SHADER_NAME;
    }
    function setModel(value) {
        _model = value;
    }
    function setupWireframeModel(model) {
        model.setUniformValueFunction(renderableObjects.UNIFORM_COLOR_NAME, function () {
            return WIREFRAME_COLOR;
        });
    }
    function setWireframeModel(value) {
        _wireframeModel = value;
        setupWireframeModel(value);
    }
    /**
     * Creates the content for the preview information panel and adds it to the page.
     */
    function _updateInfo() {
        var infoSections = [], info;
        _elements.info.innerHTML = "";
        if (_currentContext) {
            if (_model && _model.getModel) {
                infoSections.push(
                        "Model: " +
                        "triangles: " + _model.getModel().getNumTriangles(_model.getCurrentLOD()) +
                        ", lines: " + _model.getModel().getNumLines(_model.getCurrentLOD()) +
                        ", dimensions: " + _model.getModel().getWidth(_model.getCurrentLOD()).toFixed(3) + " × " +
                        _model.getModel().getHeight(_model.getCurrentLOD()).toFixed(3) + " × " +
                        _model.getModel().getDepth(_model.getCurrentLOD()).toFixed(3));
            }
            if (_currentContext.functions.getInfo) {
                info = _currentContext.functions.getInfo();
                if (info) {
                    infoSections.push(info);
                }
            }
            if (_fps) {
                infoSections.push("FPS: " + _fps);
            }
            _elements.info.appendChild(common.createLabel(infoSections.join("<br/>")));
        }
        _elements.info.hidden = (_elements.info.innerHTML === "");
    }
    /**
     * Function to execute on (active, used) particles in the particle pool every animation step
     * @param {Particle} particle
     * @param {Number} indexInPool
     */
    function _handleParticle(particle, indexInPool) {
        if (particle.canBeReused()) {
            _particlePool.markAsFree(indexInPool);
        }
    }
    /**
     * Function to execute on (active, used) explosions in the explosion pool every animation step
     * @param {Explosion} exp
     * @param {Number} indexInPool
     */
    function _handleExplosion(exp, indexInPool) {
        if (exp.canBeReused()) {
            _explosionPool.markAsFree(indexInPool);
        }
    }
    /**
     * Updates both the calculated CSS size for the canvas as well as sets the size attributes according to the rendered (client) size.
     */
    function _updateCanvasSize() {
        _elements.div.style.height = (_elements.div.parentNode.clientHeight - (_elements.options.clientHeight + _elements.info.clientHeight)) + "px";
        _elements.canvas.style.height = _elements.div.style.height;
        _elements.canvas.width = _elements.canvas.clientWidth;
        _elements.canvas.height = _elements.canvas.clientHeight;
    }
    /**
     * Called when a change happens as the result of which the preview scene should rendered again (if it is not rendered continuously)
     * @param {Boolean} [force=false] If false, the render is only executed if there is no requestAnimFrame render loop active
     * @param {Number} [dt=0] The time elapsed since the last render (to advance animation, in milliseconds)
     */
    function requestRender(force, dt) {
        if (!_animating || force) {
            dt = dt || 0;
            if (_particlePool.hasLockedObjects()) {
                _particlePool.executeForLockedObjects(_handleParticle);
            }
            if (_explosionPool.hasLockedObjects()) {
                _explosionPool.executeForLockedObjects(_handleExplosion);
            }
            _updateInfo();
            _updateCanvasSize();
            _scene.render(_context, dt);
            if (_currentContext && _currentContext.functions.animate) {
                _currentContext.functions.animate(dt);
            }
            _fps = dt ? Math.round(1000 / dt) : 0;
        }
    }
    /**
     * Updates the caption of the "Animate" button according to the current animation state
     */
    function _updateAnimateButton() {
        if (_optionElements.animateButton) {
            _optionElements.animateButton.innerHTML = _animating ? "Stop" : "Animate";
        }
    }
    /**
     * Renders one animation frame (to be used with requestAnimFrame)
     * @param {DOMHighResTimeStamp} timestamp From requestAnimFrame
     */
    function _renderFrame(timestamp) {
        var dt;
        if (_animating) {
            if (!_lastRenderTimestamp) {
                _lastRenderTimestamp = timestamp;
            }
            dt = timestamp - _lastRenderTimestamp;
            if (!_animationStopScheduled) {
                requestRender(true, dt);
                _lastRenderTimestamp = timestamp;
                window.requestAnimationFrame(_renderFrame);
            } else {
                _fps = 0;
                _animating = false;
                _updateAnimateButton();
                _updateInfo();
                _updateCanvasSize();
            }
        }
    }
    /**
     * Starts the animation loop using requestAnimFrame (if it is not active)
     */
    function startAnimating() {
        if (!_animating) {
            _animating = true;
            _animationStopScheduled = false;
            _lastRenderTimestamp = 0;
            _updateAnimateButton();
            window.requestAnimationFrame(_renderFrame);
        } else if (_animationStopScheduled) {
            _animationStopScheduled = false;
        }
    }
    /**
     * Sets the animation loop to be stopped next time the frame render is invoked
     */
    function stopAnimating() {
        _animationStopScheduled = true;
    }
    /**
     * Turns the model or the camera (or both), depending on which turn mode is active. Attached to the mouse move after a mouse down 
     * on the preview canvas.
     * @param {MouseEvent} event
     */
    function _handleMouseMove(event) {
        var camera = _scene.getCamera(), cameraOri,
                rotA = -(event.screenX - _mousePos[0]) * Math.radians(ROTATION_MOUSE_SENSITIVITY),
                rotB = -(event.screenY - _mousePos[1]) * Math.radians(ROTATION_MOUSE_SENSITIVITY),
                axisA, axisB;
        if (_model) {
            if (_turningModel) {
                cameraOri = camera.getCameraOrientationMatrix();
                axisA = mat.getRowA43(cameraOri);
                axisB = mat.getRowB43(cameraOri);
                _model.rotate(axisB, rotA);
                _model.rotate(axisA, rotB);
                if (_wireframeModel) {
                    _wireframeModel.setOrientationMatrix(_model.getOrientationMatrix());
                }
                mat.setMatrix4(_currentContext.modelOrientationMatrix, _model.getOrientationMatrix());
                if (_currentContext.functions.onModelRotate) {
                    _currentContext.functions.onModelRotate();
                }
            }
        } else {
            if (_turningModel) {
                camera.setAngularVelocityVector([
                    CAMERA_ROTATION_MOUSE_SENSITIVITY * rotB,
                    CAMERA_ROTATION_MOUSE_SENSITIVITY * rotA,
                    0]);
                camera.update(10000);
                camera.setAngularVelocityVector([0, 0, 0]);
                mat.setMatrix4(_currentContext.cameraOrientationMatrix, camera.getCameraOrientationMatrix());
            }
        }
        if (_turningCamera) {
            if (_model) {
                camera.setAngularVelocityVector([-rotB, -rotA, 0]);
                camera.update(10000);
                camera.setAngularVelocityVector([0, 0, 0]);
                mat.setMatrix4(_currentContext.cameraOrientationMatrix, camera.getCameraOrientationMatrix());
            } else {
                _scene.getCamera().setControlledVelocityVector([
                    -(event.screenX - _mousePos[0]) * CAMERA_PAN_MOUSE_SENSITIVITY,
                    (event.screenY - _mousePos[1]) * CAMERA_PAN_MOUSE_SENSITIVITY,
                    0]);
                _scene.getCamera().update(1000);
                _scene.getCamera().setControlledVelocityVector([0, 0, 0]);
            }
        }
        requestRender();
        _mousePos = [event.screenX, event.screenY];
    }
    /**
     * A handler for the mouse up event that cancels the rotation (of the model or the camera, depending on the button) by the mouse
     * @param {MouseEvent} event
     * @returns {Boolean}
     */
    function _handleMouseUp(event) {
        switch (event.which) {
            case MODEL_ROTATE_BUTTON:
                _turningModel = false;
                break;
            case CAMERA_ROTATE_BUTTON:
                _turningCamera = false;
                break;
        }
        if (!_turningModel && !_turningCamera) {
            document.body.onmousemove = null;
            document.body.onmouseup = null;
        }
        event.preventDefault();
        event.stopPropagation();
        return false;
    }
    /**
     * A handler for the mouse down event that sets the other handlers to start mouse model /camera rotation (depending on the button)
     * @param {MouseEvent} event
     * @returns {Boolean}
     */
    function _handleMouseDown(event) {
        switch (event.which) {
            case MODEL_ROTATE_BUTTON:
                _turningModel = true;
                break;
            case CAMERA_ROTATE_BUTTON:
                _turningCamera = true;
                break;
        }
        if (_turningModel || _turningCamera) {
            _mousePos = [event.screenX, event.screenY];
            document.body.onmousemove = _handleMouseMove;
            // once the user releases the mouse button, the event handlers should be cancelled
            document.body.onmouseup = _handleMouseUp;
        }
        event.preventDefault();
        event.stopPropagation();
        return false;
    }
    /**
     * A handler for the wheel event that fires when the user scrolls with the mouse, that approaches / moves away from the model,
     * depending on the scroll direction
     * @param {WheelEvent} event
     * @returns {Boolean}
     */
    function _handleWheel(event) {
        var originalDistance, originalPos, scaleFactor = 0;
        if (event.deltaY > 0) {
            scaleFactor = ENLARGE_FACTOR;
        }
        if (event.deltaY < 1) {
            scaleFactor = SHRINK_FACTOR;
        }
        if (scaleFactor) {
            originalPos = mat.translationVector3(_scene.getCamera().getCameraPositionMatrix());
            originalDistance = vec.length3(originalPos);
            _scene.getCamera().setControlledVelocityVector([0, 0, (_model ? originalDistance : CAMERA_SCROLL_MOVE_FACTOR) * (scaleFactor - 1)]);
            _scene.getCamera().update(1000);
            _scene.getCamera().setControlledVelocityVector([0, 0, 0]);
            _currentContext.cameraDistance = vec.length3(mat.translationVector3(_scene.getCamera().getCameraPositionMatrix()));
            requestRender();
        }
        return false;
    }
    /**
     * Return whether according to the currently set render mode, the wireframe model should be rendered.
     * @returns {Boolean}
     */
    function _shouldRenderWireframe() {
        return (_renderMode === RenderMode.WIREFRAME) || (_renderMode === RenderMode.BOTH);
    }
    /**
     * Return whether according to the currently set render mode, the solid model should be rendered.
     * @returns {Boolean}
     */
    function _shouldRenderSolid() {
        return (_renderMode === RenderMode.SOLID) || (_renderMode === RenderMode.BOTH) || (!_wireframeModel);
    }
    /**
     * Shows or hides the wireframe and solid models according to the currently set render mode. Does not call for render.
     */
    function _updateForRenderMode() {
        if (_wireframeModel) {
            if (_shouldRenderWireframe()) {
                _wireframeModel.getNode().show();
            } else {
                _wireframeModel.getNode().hide();
            }
        }
        if (_model) {
            if (_shouldRenderSolid()) {
                _model.getNode().show();
            } else {
                _model.getNode().hide();
            }
        }
    }
    /**
     * Sets the currently active numeric LOD for the passed model
     * @param {ShadedLODMesh} model
     */
    function _updateLOD(model) {
        if (model.setStaticLOD) {
            model.setStaticLOD(graphics.getLOD(_lod));
        }
    }
    /**
     * Sets the currently active numeric LOD for the wireframe and solid models. Does not call for render.
     */
    function _updateForLOD() {
        if (_model) {
            _model.getNode().execute(_updateLOD);
        }
        if (_wireframeModel) {
            _wireframeModel.getNode().execute(_updateLOD);
        }
    }
    /**
     * Creates and returns a <span> HTML element storing the passed text, having the class associated with setting labels.
     * @param {String} text
     * @returns {Element}
     */
    function _createSettingLabel(text) {
        var result = document.createElement("span");
        result.classList.add(SETTING_LABEL_CLASS);
        result.innerHTML = text;
        return result;
    }
    /**
     * Creates a setting element for the preview options panel, with a label and a control
     * @param {Element} control The control to edit the value of the setting
     * @param {String} [labelText] The text that should show on the label (if any)
     * @returns {Element}
     */
    function createSetting(control, labelText) {
        var result = document.createElement("div");
        result.classList.add(SETTING_CLASS);
        if (labelText) {
            result.appendChild(_createSettingLabel(labelText));
        }
        result.appendChild(control);
        return result;
    }
    /**
     * Call this whenever a resize event occurs on the window to update the canvas
     */
    function _handleResize() {
        if (_scene) {
            _updateCanvasSize();
            requestRender();
        }
    }
    /**
     * @typedef {Object} Editor~RefreshElements
     * @property {Element} div The div that houses the canvas
     * @property {HTMLCanvasElement} canvas The canvas that can be used to display a preview image of the selected object
     * @property {Element} options The div that houses the preview options
     * @property {Element} info The div that houses the bottom info bar
     */
    /**
     * @typedef {Object} Editor~RefreshParams
     * @property {Boolean} preserve Whether to preserve the existing settings (e.g. model and camera orientation)
     * @property {Boolean} reload Whether to force-reload the model (even if the settings are set to be preserved)
     * @property {Boolean} clearScene Whether to clear the scene (nodes, light sources)
     */
    /**
     * Updates the content of the preview canvas according to the current preview settings
     * @param {Editor~RefreshParams} params
     */
    function updateCanvas(params) {
        var shadowMappingSettings, shouldReload, wasAnimating;
        params = params || {};
        shouldReload = !params.preserve || params.reload;
        wasAnimating = _animating;
        stopAnimating();
        if (graphics.shouldUseShadowMapping()) {
            graphics.getShadowMappingShader();
        }
        if (shouldReload) {
            _currentContext.functions.clear();
            _model = null;
            _wireframeModel = null;
            _particlePool.clear();
            _explosionPool.clear();
        }
        if (!_scene) {
            _scene = new sceneGraph.Scene(
                    0, 0, 1, 1, // full canvas
                    true, [true, true, true, true], // background is erased on render
                    CANVAS_BACKGROUND_COLOR, true,
                    graphics.getLODContext(),
                    graphics.getMaxDirLights(),
                    graphics.getMaxPointLights(),
                    graphics.getMaxSpotLights(),
                    {
                        useVerticalValues: config.getSetting(config.GENERAL_SETTINGS.USE_VERTICAL_CAMERA_VALUES),
                        viewDistance: config.getSetting(config.BATTLE_SETTINGS.VIEW_DISTANCE),
                        fov: INITIAL_CAMERA_FOV,
                        span: INITIAL_CAMERA_SPAN,
                        transitionDuration: config.getSetting(config.BATTLE_SETTINGS.CAMERA_DEFAULT_TRANSITION_DURATION),
                        transitionStyle: config.getSetting(config.BATTLE_SETTINGS.CAMERA_DEFAULT_TRANSITION_STYLE)
                    });
            resources.executeWhenReady(function () {
                shadowMappingSettings = graphics.getShadowMappingSettings();
                if (shadowMappingSettings) {
                    shadowMappingSettings.deferSetup = true;
                }
                _scene.setShadowMapping(shadowMappingSettings);
            });
        } else {
            if (params.clearScene || shouldReload) {
                _scene.clear(true);
                _scene.setClearColor(CANVAS_BACKGROUND_COLOR);
                _scene.setAmbientColor(AMBIENT_COLOR);
            }
        }
        // clear the previous render
        if (_context && !params.preserve) {
            requestRender();
        }
        if (_currentContext.functions.load(params, _currentContext.modelOrientationMatrix)) {
            shouldReload = true;
        }
        _context = _context || new managedGL.ManagedGLContext(MANAGED_CONTEXT_NAME, _elements.canvas, graphics.getAntialiasing(), true, graphics.getFiltering());
        resources.executeWhenReady(function () {
            var view;
            _elements.div.hidden = false;
            _elements.canvas.hidden = false;
            _updateForLOD();
            _updateInfo();
            _updateCanvasSize();
            _context.clear();
            resources.executeWhenReady(function () {
                _scene.addToContext(_context);
                _context.setup();
                if (shouldReload) {
                    if (_model) {
                        if (!params.preserve) {
                            _currentContext.cameraDistance = (_currentContext.params.defaultDistanceFactor || DEFAULT_DISTANCE_FACTOR) * _model.getScaledSize();
                        }
                        view = new classes.ObjectView({
                            name: OBJECT_VIEW_NAME,
                            isAimingView: false,
                            fps: false,
                            fov: FOV,
                            fovRange: [FOV, FOV],
                            followsPosition: true,
                            followsOrientation: false,
                            movable: true,
                            turnable: true,
                            rotationCenterIsObject: true,
                            distanceRange: [0, MAX_DISTANCE_FACTOR * _model.getScaledSize()],
                            position: vec.scaled3(_currentContext.params.cameraDirection || DEFAULT_CAMERA_DIRECTION, _currentContext.cameraDistance)
                        });
                        _scene.getCamera().setViewDistance(config.getSetting(config.BATTLE_SETTINGS.VIEW_DISTANCE));
                        _scene.getCamera().setConfiguration(view.createCameraConfiguration(_model,
                                config.getDefaultCameraBaseOrientation(),
                                config.getDefaultCameraPointToFallback(),
                                config.getDefaultCameraFOV(),
                                config.getDefaultCameraSpan()));
                    } else {
                        if (!params.preserve) {
                            _scene.getCamera().moveToPosition([0, 0, FREE_CAMERA_INITIAL_HEIGHT], 0);
                            _scene.getCamera().getConfiguration().setRelativeOrientationMatrix(mat.identity4(), true);
                        }
                        _scene.getCamera().setViewDistance(FREE_CAMERA_VIEW_DISTANCE);
                    }
                    if (params.preserve) {
                        _scene.getCamera().getConfiguration().setRelativeOrientationMatrix(mat.matrix4(_currentContext.cameraOrientationMatrix), true);
                    }
                }
                _elements.canvas.onmousedown = _handleMouseDown;
                _elements.canvas.onwheel = _handleWheel;
                _context.executeWhenReady(function () {
                    _updateForRenderMode();
                    _updateForLOD();
                    _currentContext.functions.updateForRefresh();
                    if (_currentContext.params.animateOnRefresh || (wasAnimating && (_currentContext.params.animateOnRefresh !== false))) {
                        startAnimating();
                    } else {
                        requestRender();
                    }
                });
            });
            // cannot directly call a new load request inside executeWhenReady() as it would change the ready state
            // back to not ready and commence an infinite loop, with the setTimeout() it is executed after all 
            // onReady handlers are cleared
            setTimeout(function () {
                resources.requestResourceLoad();
            }, 0);
        });
        resources.requestResourceLoad();
    }
    /**
     * Resets the preview settings (those handled through the options, not the ones connected to the canvas) to their default values.
     * The settings that persist across different items are not reset.
     */
    function clearSettingsForNewItem() {
        _renderMode = _renderMode || RenderMode.SOLID;
        _lod = (_lod !== undefined) ? _lod : graphics.getLODLevel();
        _currentContext.modelOrientationMatrix = mat.identity4();
        _currentContext.cameraOrientationMatrix = mat.identity4();
        _currentContext.functions.clearSettingsForNewItem();
    }
    /**
     * Creates the controls that form the content of the preview options and adds them to the page.
     */
    function createOptions() {
        _elements.options.innerHTML = "";
        // render mode selector
        if (_currentContext.params.renderModeSetting) {
            _optionElements.renderModeSelector = common.createSelector(utils.getEnumValues(RenderMode), _renderMode, false, function () {
                _renderMode = _optionElements.renderModeSelector.value;
                _updateForRenderMode();
                requestRender();
            });
            _elements.options.appendChild(createSetting(_optionElements.renderModeSelector, "Render mode:"));
        }
        if (_currentContext.params.lodSetting) {
            // LOD selector
            _optionElements.lodSelector = common.createSelector(graphics.getLODLevels(), _lod, false, function () {
                _lod = _optionElements.lodSelector.value;
                _updateForLOD();
                requestRender();
                _updateInfo();
            });
            _elements.options.appendChild(createSetting(_optionElements.lodSelector, "LOD:"));
        }
        if (_currentContext.params.animateButton) {
            // animate button
            _optionElements.animateButton = common.createButton(_animating ? "Stop" : "Animate", function () {
                if (!_animating) {
                    startAnimating();
                } else {
                    stopAnimating();
                }
            });
            _elements.options.appendChild(createSetting(_optionElements.animateButton));
        }
        if (_currentContext.params.muteCheckbox) {
            // mute checkbox
            _optionElements.muteCheckbox = common.createBooleanInput(_muted, function () {
                _muted = _optionElements.muteCheckbox.checked;
                audio.setMasterVolume(_muted ? 0 : 1);
            });
            _elements.options.appendChild(createSetting(_optionElements.muteCheckbox, "Mute:"));
        }
        _currentContext.functions.createOptions();
        _elements.options.hidden = (_elements.options.innerHTML === "");
    }
    /**
     * @typedef {Object} refreshElements
     * @property {HTMLCanvasElement} canvas The canvas that can be used to display a preview image of the selected object
     * @property {Element} options The div that houses the preview options
     */
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor 
     * @param {refreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {Editor~RefreshParams} params Additional parameters 
     */
    function refresh(elements, params) {
        _elements = elements;
        createOptions();
        updateCanvas(params);
        window.addEventListener("resize", _handleResize);
    }
    /**
     * Clears the preview and its current context so that a new preview (or the same with a different context) can be opened
     */
    function clear() {
        stopAnimating();
        setContext(null);
    }
    /**
     * Updates the preview (refreshes if needed) in case the property with the given name changed
     * @param {String} name
     */
    function handleDataChanged(name) {
        if (_currentContext.params.optionRefreshProperties.indexOf(name) >= 0) {
            createOptions();
        }
        if (_currentContext.params.canvasUpdateProperties.indexOf(name) >= 0) {
            updateCanvas({
                preserve: true,
                reload: true
            });
        } else if (_currentContext.params.infoUpdateProperties.indexOf(name) >= 0) {
            _updateInfo();
            _updateCanvasSize();
            requestRender();
        }
    }
    // initializazion
    // obtaining pool references
    _particlePool = pools.getPool(constants.PARTICLE_POOL_NAME, renderableObjects.Particle);
    _explosionPool = pools.getPool(constants.EXPLOSION_POOL_NAME, explosion.Explosion);
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        WebGLPreviewContext: WebGLPreviewContext,
        setContext: setContext,
        getScene: getScene,
        getWireframeShaderName: getWireframeShaderName,
        setModel: setModel,
        setWireframeModel: setWireframeModel,
        setupWireframeModel: setupWireframeModel,
        requestRender: requestRender,
        startAnimating: startAnimating,
        stopAnimating: stopAnimating,
        createSetting: createSetting,
        clearSettingsForNewItem: clearSettingsForNewItem,
        updateCanvas: updateCanvas,
        refresh: refresh,
        clear: clear,
        handleDataChanged: handleDataChanged
    };
});

/**
 * Copyright 2016, 2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for skybox classes within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param environments Used to create the skybox
 * @param preview Used for common WebGL preview functionality
 */
define('editor/preview/skybox-preview',[
    "armada/logic/environments",
    "editor/preview/webgl-preview"
], function (environments, preview) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            /**
             * The names of properties the change of which should trigger an update of the preview canvas
             * @type String[]
             */
            CANVAS_UPDATE_PROPERTIES = [
                "shader",
                "cubemap"],
            /**
             * The names of the properties the change of which should trigger a refresh of the preview options
             * @type String[]
             */
            OPTION_REFRESH_PROPERIES = [
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the info text
             * @type String[]
             */
            INFO_UPDATE_PROPERTIES = [
            ],
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * An instance to preview the currently selected skybox class
             * @type Skybox
             */
            _skybox,
            /**
             * A reference to the displayed skybox class
             * @type SkyboxClass
             */
            _skyboxClass,
            /**
             * Stores the WebGL preview context information for skybox class previews
             * @type WebGLPreviewContext
             */
            _previewContext;
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * For the functions.clear property of the preview context
     */
    function _clear() {
        if (_skybox) {
            _skybox.destroy();
            _skybox = null;
        }
    }
    /**
     * For the functions.load property of the preview context
     * @param {Editor~RefreshParams} params
     */
    function _load(params) {
        var
                shouldReload;
        params = params || {};
        shouldReload = !params.preserve || params.reload;
        if (shouldReload) {
            _skybox = new environments.Skybox(_skyboxClass);
        }
        _skybox.addToScene(preview.getScene());
    }
    /**
     * For the functions.clearSettingsForNewItem property of the preview context
     */
    function _clearSettingsForNewItem() {
        return true;
    }
    /**
     * For the functions.createOptions property of the preview context
     */
    function _createOptions() {
        return true;
    }
    /**
     * For the functions.updateForRefresh property of the preview context
     */
    function _updateForRefresh() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor to show the selected 
     * skybox class.
     * @param {Editor~RefreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {SkyboxClass} skyboxClass The skybox class to preview
     * @param {Editor~RefreshParams} params Additional parameters 
     */
    function refresh(elements, skyboxClass, params) {
        var sameClass = (_skyboxClass === skyboxClass);
        preview.setContext(_previewContext);
        _skyboxClass = skyboxClass;
        if (sameClass) {
            if (!params) {
                params = {
                    preserve: true,
                    reload: true
                };
            }
        } else {
            preview.clearSettingsForNewItem();
        }
        preview.refresh(elements, params);
    }
    /**
     * Called from outside
     */
    function handleStartEdit() {
        return true;
    }
    /**
     * Called from outside
     */
    function handleStopEdit() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Initialization
    _previewContext = new preview.WebGLPreviewContext({
        renderModeSetting: false,
        lodSetting: false,
        canvasUpdateProperties: CANVAS_UPDATE_PROPERTIES,
        optionRefreshProperties: OPTION_REFRESH_PROPERIES,
        infoUpdateProperties: INFO_UPDATE_PROPERTIES
    }, {
        clear: _clear,
        load: _load,
        updateForRefresh: _updateForRefresh,
        clearSettingsForNewItem: _clearSettingsForNewItem,
        createOptions: _createOptions
    });
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: preview.clear,
        handleDataChanged: preview.handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2016, 2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for background object classes within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param environments Used to create the background object
 * @param preview Used for common WebGL preview functionality
 */
define('editor/preview/backgroundObject-preview',[
    "armada/logic/environments",
    "editor/preview/webgl-preview"
], function (environments, preview) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            /**
             * The names of properties the change of which should trigger an update of the preview canvas
             * @type String[]
             */
            CANVAS_UPDATE_PROPERTIES = [
                "layers"
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the preview options
             * @type String[]
             */
            OPTION_REFRESH_PROPERIES = [
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the info text
             * @type String[]
             */
            INFO_UPDATE_PROPERTIES = [
            ],
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * An instance to preview the currently selected background object class
             * @type BackgroundObject
             */
            _backgroundObject,
            /**
             * A reference to the displayed background object class
             * @type BackgroundObjectClass
             */
            _backgroundObjectClass,
            /**
             * Stores the WebGL preview context information for background object class previews
             * @type WebGLPreviewContext
             */
            _previewContext;
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * For the functions.clear property of the preview context
     */
    function _clear() {
        if (_backgroundObject) {
            _backgroundObject.destroy();
            _backgroundObject = null;
        }
    }
    /**
     * For the functions.load property of the preview context
     * @param {Editor~RefreshParams} params
     */
    function _load(params) {
        var
                shouldReload;
        params = params || {};
        shouldReload = !params.preserve || params.reload;
        if (shouldReload) {
            _backgroundObject = new environments.BackgroundObject(_backgroundObjectClass, 600, 0, -90, 180);
        }
        _backgroundObject.addToScene(preview.getScene(), true);
    }
    /**
     * For the functions.clearSettingsForNewItem property of the preview context
     */
    function _clearSettingsForNewItem() {
        return true;
    }
    /**
     * For the functions.createOptions property of the preview context
     */
    function _createOptions() {
        return true;
    }
    /**
     * For the functions.updateForRefresh property of the preview context
     */
    function _updateForRefresh() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor to show the selected 
     * background object class.
     * @param {Editor~RefreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {SpacecraftClass} backgroundObjectClass The background object class to preview
     * @param {Editor~RefreshParams} params Additional parameters 
     */
    function refresh(elements, backgroundObjectClass, params) {
        var sameClass = (_backgroundObjectClass === backgroundObjectClass);
        preview.setContext(_previewContext);
        _backgroundObjectClass = backgroundObjectClass;
        if (sameClass) {
            if (!params) {
                params = {
                    preserve: true,
                    reload: true
                };
            }
        } else {
            preview.clearSettingsForNewItem();
        }
        preview.refresh(elements, params);
    }
    /**
     * Called from outside
     */
    function handleStartEdit() {
        return true;
    }
    /**
     * Called from outside
     */
    function handleStopEdit() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Initialization
    _previewContext = new preview.WebGLPreviewContext({
        renderModeSetting: false,
        lodSetting: false,
        canvasUpdateProperties: CANVAS_UPDATE_PROPERTIES,
        optionRefreshProperties: OPTION_REFRESH_PROPERIES,
        infoUpdateProperties: INFO_UPDATE_PROPERTIES
    }, {
        clear: _clear,
        load: _load,
        updateForRefresh: _updateForRefresh,
        clearSettingsForNewItem: _clearSettingsForNewItem,
        createOptions: _createOptions
    });
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: preview.clear,
        handleDataChanged: preview.handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2016, 2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for explosion classes within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param mat Used for creating identity matrices
 * @param pools Used for displaying info about the particle pool state
 * @param renderableObjects Used to access the pool for particles
 * @param lights Used for creating the light sources for the preview scene
 * @param constants Used to get pool names
 * @param explosion Used to create the preview explosions
 * @param common Used for creating option elements
 * @param preview This module is based on the common WebGL preview module
 */
define('editor/preview/explosion-preview',[
    "utils/matrices",
    "modules/pools",
    "modules/scene/renderable-objects",
    "modules/scene/lights",
    "armada/logic/constants",
    "armada/logic/explosion",
    "editor/common",
    "editor/preview/webgl-preview"
], function (mat, pools, renderableObjects, lights, constants, explosion, common, preview) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            LIGHT_SOURCES = [
                {
                    color: [1, 1, 1],
                    direction: [1, 0, 1]
                }
            ],
            /**
             * The names of properties the change of which should trigger an update of the preview canvas
             * @type String[]
             */
            CANVAS_UPDATE_PROPERTIES = [
                "particleEmitters",
                "lightStates",
                "soundEffect"
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the preview options
             * @type String[]
             */
            OPTION_REFRESH_PROPERIES = [
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the info text
             * @type String[]
             */
            INFO_UPDATE_PROPERTIES = [
            ],
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * @type Pool
             */
            _particlePool,
            /**
             * A reference to the object storing the HTML elements to be used for the preview
             * @type Object
             */
            _elements,
            /**
             * @type Explosion
             */
            _explosion,
            /**
             * A reference to the displayed explosion class
             * @type ExplosionClass
             */
            _explosionClass,
            /**
             * Stores the WebGL preview context information for explosion class previews
             * @type WebGLPreviewContext
             */
            _previewContext,
            /**
             * 
             * @type Object
             */
            _optionElements = {
                restartButton: null
            };
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * For the WebGL preview context.
     * Clears the object references of the currently stored explosion (if any)
     */
    function _clear() {
        if (_explosion) {
            _explosion.destroy();
            _explosion = null;
        }
    }
    /**
     * For the WebGL preview context.
     * Updates the content of the preview canvas according to the current preview settings
     * @param {Editor~RefreshParams} params
     * @param {Float32Array} orientationMatrix
     */
    function _load(params, orientationMatrix) {
        var
                shouldReload,
                i;
        params = params || {};
        shouldReload = !params.preserve || params.reload;
        if (params.clearScene || shouldReload) {
            for (i = 0; i < LIGHT_SOURCES.length; i++) {
                preview.getScene().addDirectionalLightSource(new lights.DirectionalLightSource(LIGHT_SOURCES[i].color, LIGHT_SOURCES[i].direction));
            }
            if (shouldReload) {
                _explosion = new explosion.Explosion(_explosionClass, mat.identity4(), orientationMatrix, [0, 1, 0], true, true, mat.identity4());
            }
            _explosion.addResourcesToScene(preview.getScene(), false);
            _explosion.addToScene(preview.getScene().getRootNode(), null, false, function (model) {
                preview.setModel(model);
            });
        }
    }
    /**
     * For the WebGL preview context.
     * Resets the preview settings (those handled through the options, not the ones connected to the canvas) to their default values.
     * The settings that persist across different items are not reset.
     */
    function _clearSettingsForNewItem() {
        return true;
    }
    /**
     * For the WebGL preview context.
     * Creates the controls that form the content of the preview options and adds them to the page.
     */
    function _createOptions() {
        // explode button
        _optionElements.restartButton = common.createButton("Restart", function () {
            _explosion.getVisualModel().getNode().markAsReusable(true);
            _explosion.addToScene(preview.getScene().getRootNode(), null, false, function (model) {
                preview.setModel(model);
            });
            preview.startAnimating();
        });
        _elements.options.appendChild(preview.createSetting(_optionElements.restartButton));
        return true;
    }
    /**
     * For the WebGL preview context.
     * Currently does nothing, the model does not need to be changed when refreshed.
     */
    function _updateForRefresh() {
        return true;
    }
    /**
     * For the WebGL preview context.
     * Returns the info (particle count and particle pool state) to be added to the info panel
     */
    function _getInfo() {
        var explosionNode = _explosion && _explosion.getVisualModel() && _explosion.getVisualModel().getNode();
        return (explosionNode ? ("Particles: " + (!explosionNode.canBeReused() ? explosionNode.getSubnodes().getLength() : "0") + ", ") : "") +
                "Pool: " + _particlePool.getLockedObjectCount() + "/" + _particlePool.getObjects().length;
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor to show the selected 
     * explosion class.
     * @param {Editor~RefreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {ExplosionClass} explosionClass The explosion class to preview
     * @param {Editor~RefreshParams} params Additional parameters 
     */
    function refresh(elements, explosionClass, params) {
        var sameClass = (_explosionClass === explosionClass);

        preview.setContext(_previewContext);

        _elements = elements;
        _explosionClass = explosionClass;
        if (sameClass) {
            if (!params) {
                params = {
                    preserve: true,
                    reload: true
                };
            }
        } else {
            preview.clearSettingsForNewItem();
        }
        preview.refresh(elements, params);
    }
    /**
     * Updates the preview for the case when a property of the previewed item is being edited
     */
    function handleStartEdit() {
        return true;
    }
    /**
     * Updates the preview for the case when a property of the previewed item is no longer being edited
     */
    function handleStopEdit() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Initialization
    _previewContext = new preview.WebGLPreviewContext({
        renderModeSetting: false,
        lodSetting: false,
        animateButton: true,
        animateOnRefresh: true,
        muteCheckbox: true,
        canvasUpdateProperties: CANVAS_UPDATE_PROPERTIES,
        optionRefreshProperties: OPTION_REFRESH_PROPERIES,
        infoUpdateProperties: INFO_UPDATE_PROPERTIES,
        defaultDistanceFactor: 2
    }, {
        clear: _clear,
        load: _load,
        updateForRefresh: _updateForRefresh,
        clearSettingsForNewItem: _clearSettingsForNewItem,
        createOptions: _createOptions,
        getInfo: _getInfo
    });
    // initializazion
    // obtaining pool references
    _particlePool = pools.getPool(constants.PARTICLE_POOL_NAME, renderableObjects.Particle);
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: preview.clear,
        handleDataChanged: preview.handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2016, 2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for projectile classes within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param lights Used for creating the light sources for the preview scene
 * @param equipment Used to create the preview projectiles
 * @param preview
 */
define('editor/preview/projectile-preview',[
    "modules/scene/lights",
    "armada/logic/equipment",
    "editor/preview/webgl-preview"
], function (lights, equipment, preview) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            LIGHT_SOURCES = [
                {
                    color: [1, 1, 1],
                    direction: [1, 0, 1]
                }
            ],
            /**
             * The names of properties the change of which should trigger an update of the preview canvas
             * @type String[]
             */
            CANVAS_UPDATE_PROPERTIES = [
                "shader", "texture",
                "size", "intersectionPositions", "width"
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the preview options
             * @type String[]
             */
            OPTION_REFRESH_PROPERIES = [
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the info text
             * @type String[]
             */
            INFO_UPDATE_PROPERTIES = [
            ],
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * @type Projectile
             */
            _projectile,
            /**
             * A reference to the displayed projectile class
             * @type ProjectileClass
             */
            _projectileClass,
            /**
             * Stores the WebGL preview context information for projectile class previews
             * @type WebGLPreviewContext
             */
            _previewContext;
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * For the WebGL preview context.
     * Clears the object references of the currently stored projectile (if any)
     */
    function _clear() {
        if (_projectile) {
            _projectile.destroy();
            _projectile = null;
        }
    }
    /**
     * For the WebGL preview context.
     * Updates the content of the preview canvas according to the current preview settings
     * @param {Editor~RefreshParams} params
     * @param {Float32Array} orientationMatrix
     */
    function _load(params, orientationMatrix) {
        var
                shouldReload,
                i;
        params = params || {};
        shouldReload = !params.preserve || params.reload;
        if (params.clearScene || shouldReload) {
            for (i = 0; i < LIGHT_SOURCES.length; i++) {
                preview.getScene().addDirectionalLightSource(new lights.DirectionalLightSource(LIGHT_SOURCES[i].color, LIGHT_SOURCES[i].direction));
            }
            if (shouldReload) {
                _projectile = new equipment.Projectile(_projectileClass, undefined, orientationMatrix);
            }
            _projectile.addResourcesToScene(preview.getScene(), false);
            _projectile.addToScene(preview.getScene(), false, function (model) {
                preview.setModel(model);
            });
        }
    }
    /**
     * For the WebGL preview context.
     * Resets the preview settings (those handled through the options, not the ones connected to the canvas) to their default values.
     * The settings that persist across different items are not reset.
     */
    function _clearSettingsForNewItem() {
        return true;
    }
    /**
     * For the WebGL preview context.
     * Creates the controls that form the content of the preview options and adds them to the page.
     * Currently does nothing, no preview options are yet implemented for projectile previews.
     */
    function _createOptions() {
        return true;
    }
    /**
     * For the WebGL preview context.
     * Currently does nothing, the model does not need to be changed when refreshed.
     */
    function _updateForRefresh() {
        return true;
    }
    /**
     * The handler for when the model is rotated by the user
     */
    function _onModelRotate() {
        _projectile.getVisualModel().updateDirection();
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor to show the selected 
     * projectile class.
     * @param {Editor~RefreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {ProjectileClass} projectileClass The projectile class to preview
     * @param {Editor~SpacecraftClassRefreshParams} params Additional parameters 
     */
    function refresh(elements, projectileClass, params) {
        var sameClass = (_projectileClass === projectileClass);

        preview.setContext(_previewContext);

        _projectileClass = projectileClass;
        if (sameClass) {
            if (!params) {
                params = {
                    preserve: true,
                    reload: true
                };
            }
        } else {
            preview.clearSettingsForNewItem();
        }
        preview.refresh(elements, params);
    }
    /**
     * Updates the preview for the case when a property of the previewed item is being edited
     */
    function handleStartEdit() {
        return true;
    }
    /**
     * Updates the preview for the case when a property of the previewed item is no longer being edited
     */
    function handleStopEdit() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Initialization
    _previewContext = new preview.WebGLPreviewContext({
        renderModeSetting: false,
        lodSetting: false,
        canvasUpdateProperties: CANVAS_UPDATE_PROPERTIES,
        optionRefreshProperties: OPTION_REFRESH_PROPERIES,
        infoUpdateProperties: INFO_UPDATE_PROPERTIES,
        defaultDistanceFactor: 3
    }, {
        clear: _clear,
        load: _load,
        updateForRefresh: _updateForRefresh,
        clearSettingsForNewItem: _clearSettingsForNewItem,
        createOptions: _createOptions,
        onModelRotate: _onModelRotate
    });
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: preview.clear,
        handleDataChanged: preview.handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2016-2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for weapon classes within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param lights Used for creating the light sources for the preview scene
 * @param graphics Used to set graphics settings
 * @param equipment Used to create the preview weapons
 * @param preview
 */
define('editor/preview/weapon-preview',[
    "modules/scene/lights",
    "armada/graphics",
    "armada/logic/equipment",
    "editor/preview/webgl-preview"
], function (lights, graphics, equipment, preview) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            LIGHT_SOURCES = [
                {
                    color: [1, 1, 1],
                    direction: [1, 0, 1]
                }
            ],
            /**
             * The names of properties the change of which should trigger an update of the preview canvas
             * @type String[]
             */
            CANVAS_UPDATE_PROPERTIES = [
                "model", "shader", "texture",
                "defaultLuminosityFactors"
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the preview options
             * @type String[]
             */
            OPTION_REFRESH_PROPERIES = [
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the info text
             * @type String[]
             */
            INFO_UPDATE_PROPERTIES = [
                "cooldown", "barrels"
            ],
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * @type Weapon
             */
            _weapon, _wireframeWeapon,
            /**
             * A reference to the displayed weapon class
             * @type WeaponClass
             */
            _weaponClass,
            /**
             * Stores the WebGL preview context information for weapon class previews
             * @type WebGLPreviewContext
             */
            _previewContext;
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * For the WebGL preview context.
     * Clears the object references of the currently stored weapon (if any)
     */
    function _clear() {
        if (_weapon) {
            _weapon.destroy();
            _weapon = null;
            _wireframeWeapon.destroy();
            _wireframeWeapon = null;
        }
    }
    /**
     * For the WebGL preview context.
     * Updates the content of the preview canvas according to the current preview settings
     * @param {Editor~RefreshParams} params
     * @param {Float32Array} orientationMatrix
     */
    function _load(params, orientationMatrix) {
        var
                shouldReload,
                shadows,
                i;
        params = params || {};
        shouldReload = !params.preserve || params.reload;
        if (params.clearScene || shouldReload) {
            shadows = graphics.isShadowMappingEnabled();
            preview.getScene().setClearColor([0, 0, 0, 1]);
            preview.getScene().setAmbientColor([0, 0, 0]);
            for (i = 0; i < LIGHT_SOURCES.length; i++) {
                preview.getScene().addDirectionalLightSource(new lights.DirectionalLightSource(LIGHT_SOURCES[i].color, LIGHT_SOURCES[i].direction));
            }
            graphics.setShadowMapping();
            if (shadows !== graphics.isShadowMappingEnabled()) {
                graphics.handleSettingsChanged();
                shouldReload = true;
            }
            if (shouldReload) {
                _weapon = new equipment.Weapon(_weaponClass);
                _wireframeWeapon = new equipment.Weapon(_weaponClass);
            }
            _weapon.addToScene(preview.getScene().getRootNode(), undefined, false,
                    {
                        projectileResources: false,
                        sound: false,
                        orientationMatrix: orientationMatrix
                    },
                    shouldReload ?
                    function (model) {
                        preview.setModel(model);
                    } :
                    null);
            _wireframeWeapon.addToScene(preview.getScene().getRootNode(), undefined, true,
                    {
                        shaderName: preview.getWireframeShaderName(),
                        projectileResources: false,
                        sound: false,
                        orientationMatrix: orientationMatrix
                    },
                    shouldReload ?
                    function (model) {
                        preview.setWireframeModel(model);
                    } :
                    null);
        }
    }
    /**
     * For the WebGL preview context.
     * Resets the preview settings (those handled through the options, not the ones connected to the canvas) to their default values.
     * The settings that persist across different items are not reset.
     */
    function _clearSettingsForNewItem() {
        return true;
    }
    /**
     * For the WebGL preview context.
     * Creates the controls that form the content of the preview options and adds them to the page.
     * Currently does nothing, no preview options are yet implemented for weapon previews.
     */
    function _createOptions() {
        return true;
    }
    /**
     * For the WebGL preview context.
     * Currently does nothing, the model does not need to be changed when refreshed.
     */
    function _updateForRefresh() {
        return true;
    }
    /**
     * Returns additional information to be displayed in the info section of the preview
     * @returns {String}
     */
    function _getInfo() {
        var result, value, valueDrop;
        result = "";
        if (_weapon) {
            value = _weapon.getDamage();
            if (value > 0) {
                result = "Weapon: ";
                valueDrop = value - _weapon.getDamage(1);
                result += "damage: " + (Math.round(value * 100) / 100) + " (-" + (Math.round(valueDrop * 100) / 100) + " / arm.), ";
                value = _weapon.getFirepower();
                valueDrop = value - _weapon.getFirepower(1);
                result += "firepower: " + (Math.round(value * 100) / 100) + " (-" + (Math.round(valueDrop * 100) / 100) + " / arm.), ";
                result += "fire rate: " + (Math.round(_weapon.getFireRate() * 100) / 100) + " / s, ";
                result += "range: " + _weapon.getRange() + " m";
            }
        }
        return result;
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor to show the selected 
     * weapon class.
     * @param {Editor~RefreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {WeaponClass} weaponClass The weapon class to preview
     * @param {Editor~SpacecraftClassRefreshParams} params Additional parameters 
     */
    function refresh(elements, weaponClass, params) {
        var sameClass = (_weaponClass === weaponClass);

        preview.setContext(_previewContext);

        _weaponClass = weaponClass;
        if (sameClass) {
            if (!params) {
                params = {
                    preserve: true,
                    reload: true
                };
            }
        } else {
            preview.clearSettingsForNewItem();
        }
        preview.refresh(elements, params);
    }
    /**
     * Updates the preview for the case when a property of the previewed item is being edited
     */
    function handleStartEdit() {
        return true;
    }
    /**
     * Updates the preview for the case when a property of the previewed item is no longer being edited
     */
    function handleStopEdit() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Initialization
    _previewContext = new preview.WebGLPreviewContext({
        renderModeSetting: true,
        lodSetting: true,
        canvasUpdateProperties: CANVAS_UPDATE_PROPERTIES,
        optionRefreshProperties: OPTION_REFRESH_PROPERIES,
        infoUpdateProperties: INFO_UPDATE_PROPERTIES
    }, {
        clear: _clear,
        load: _load,
        updateForRefresh: _updateForRefresh,
        getInfo: _getInfo,
        clearSettingsForNewItem: _clearSettingsForNewItem,
        createOptions: _createOptions
    });
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: preview.clear,
        handleDataChanged: preview.handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2019-2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for missile classes within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param vec Used for vector operations
 * @param mat Used for matrix operations
 * @param resources Used for waiting for resource load
 * @param lights Used for creating the light sources for the preview scene
 * @param graphics Used to acquire wireframe shader and update settings based on the environment
 * @param environments Used to access the environments
 * @param equipment Used to create the preview missiles
 * @param common Used to create selectors
 * @param descriptors Used to access enums
 * @param preview This module is based on the common WebGL preview module
 */
define('editor/preview/missile-preview',[
    "utils/vectors",
    "utils/matrices",
    "modules/media-resources",
    "modules/scene/lights",
    "armada/graphics",
    "armada/logic/environments",
    "armada/logic/equipment",
    "editor/common",
    "editor/descriptors",
    "editor/preview/webgl-preview"
], function (vec, mat, resources, lights, graphics, environments, equipment, common, descriptors, preview) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            LIGHT_SOURCES = [
                {
                    color: [1, 1, 1],
                    direction: [1, 0, 1]
                }
            ],
            ENGINE_STATE_OFF = "off",
            /**
             * The names of properties the change of which should trigger an update of the preview canvas
             * @type String[]
             */
            CANVAS_UPDATE_PROPERTIES = [
                "model", "modelScale", "shader", "texture",
                "trail", "thrusterSlots"
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the preview options
             * @type String[]
             */
            OPTION_REFRESH_PROPERIES = [
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the info text
             * @type String[]
             */
            INFO_UPDATE_PROPERTIES = [
                "launchVelocity", "ignitionTime", "acceleration", "duration"
            ],
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * @type Missile
             */
            _missile, _wireframeMissile,
            /**
             * @type Environment
             */
            _environment,
            /**
             * A reference to the object storing the HTML elements to be used for the preview
             * @type Object
             */
            _elements,
            /**
             * A reference to the displayed missile class
             * @type MissileClass
             */
            _missileClass,
            /**
             * @type String
             */
            _environmentName,
            /**
             * The uses of the engine that are currently set to be turned on
             * @type String[]
             */
            _activeEngineUses = [],
            /**
             * Stores the WebGL preview context information for missile class previews
             * @type WebGLPreviewContext
             */
            _previewContext,
            /**
             * 
             * @type Object
             */
            _optionElements = {
                addTrailButton: null,
                environmentSelector: null,
                engineStateEditor: null,
                engineStatePopup: null
            };
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * Updates the visual models of the thrusters according to the currently set engine state.
     */
    function _updateThrusters() {
        var i;
        _missile.resetThrusterBurn();
        for (i = 0; i < _activeEngineUses.length; i++) {
            switch (_activeEngineUses[i]) {
                case descriptors.ThrusterUse.FORWARD:
                    _missile.addThrusterBurnForward(1);
                    break;
                case descriptors.ThrusterUse.YAW_LEFT:
                    _missile.addThrusterBurnYawLeft(1);
                    break;
                case descriptors.ThrusterUse.YAW_RIGHT:
                    _missile.addThrusterBurnYawRight(1);
                    break;
                case descriptors.ThrusterUse.PITCH_UP:
                    _missile.addThrusterBurnPitchUp(1);
                    break;
                case descriptors.ThrusterUse.PITCH_DOWN:
                    _missile.addThrusterBurnPitchDown(1);
                    break;
            }
        }
        _missile.updateThrusterVisuals();
    }
    /**
     * Updates the engine state editor control in the preview options panel according to the current possibilities and settings.
     */
    function _updateEngineStateEditor() {
        _optionElements.engineStateEditor.innerHTML = _activeEngineUses.length > 0 ?
                (_activeEngineUses[0] + ((_activeEngineUses.length > 1) ? "..." : "")) :
                ENGINE_STATE_OFF;
    }
    /**
     * Adds a trail based on the current orientation of the missile to show how it would look
     */
    function _addTrail() {
        var
                trailEmitter = _missile._trailEmitter,
                growthRate = trailEmitter._descriptor.getGrowthRate(),
                duration = trailEmitter._descriptor.getDuration(),
                model = _missile.getVisualModel(),
                enginePosition, direction, length, count, segmentLength, dt, i;
        enginePosition = model.getPositionVector();
        vec.add3(enginePosition, vec.prodVec3Mat3Aux(_missileClass.getEnginePosition(), mat.prodScalingRotation3Aux(model.getScalingMatrix(), model.getOrientationMatrix())));
        direction = (vec.length3Squared(enginePosition) > 0) ? vec.normal3(enginePosition) : mat.getRowB43Neg(model.getOrientationMatrix());
        length = _missileClass.getLength() * 5;
        count = 3;
        segmentLength = length / count;
        dt = duration / (count * growthRate);
        trailEmitter.startNew(preview.getScene(), vec.sum3(enginePosition, vec.scaled3(direction, count * segmentLength)));
        for (i = 1; i <= count; i++) {
            trailEmitter.addPoint(vec.sum3(enginePosition, vec.scaled3(direction, (count - i) * segmentLength)), dt);
        }
        preview.requestRender();
    }
    /**
     * For the WebGL preview context.
     * Clears the object references of the currently stored missile (if any)
     */
    function _clear() {
        if (_missile) {
            _missile.destroy();
            _missile = null;
            _wireframeMissile.destroy();
            _wireframeMissile = null;
        }
    }
    /**
     * For the WebGL preview context.
     * Updates the content of the preview canvas according to the current preview settings
     * @param {Editor~RefreshParams} params
     * @param {Float32Array} orientationMatrix
     * @returns {Boolean}
     */
    function _load(params, orientationMatrix) {
        var
                environmentChanged,
                shouldReload,
                shadows,
                i;
        params = params || {};
        if (params.preserve) {
            if (params.environmentName === undefined) {
                params.environmentName = _environmentName;
            }
        }
        environmentChanged = params.environmentName !== _environmentName;
        shouldReload = !params.preserve || params.reload;
        if (environmentChanged || shouldReload) {
            shadows = graphics.isShadowMappingEnabled();
            if (params.environmentName) {
                _environment = environments.getEnvironment(params.environmentName);
                if (_environment.hasShadows()) {
                    graphics.setShadowMapping();
                } else {
                    graphics.setShadowMapping(false, false);
                }
            } else {
                _environment = null;
                preview.getScene().setClearColor([0, 0, 0, 1]);
                preview.getScene().setAmbientColor([0, 0, 0]);
                for (i = 0; i < LIGHT_SOURCES.length; i++) {
                    preview.getScene().addDirectionalLightSource(new lights.DirectionalLightSource(LIGHT_SOURCES[i].color, LIGHT_SOURCES[i].direction));
                }
                graphics.setShadowMapping();
            }
            if (shadows !== graphics.isShadowMappingEnabled()) {
                graphics.handleSettingsChanged();
                shouldReload = true;
            }
        }
        if (shouldReload) {
            _clear();
            _missile = new equipment.Missile(_missileClass);
            _wireframeMissile = new equipment.Missile(_missileClass);
        }
        if (orientationMatrix) {
            _missile.getPhysicalModel().setOrientationMatrix(mat.matrix4(orientationMatrix));
            _wireframeMissile.getPhysicalModel().setOrientationMatrix(_missile.getPhysicalModel().getOrientationMatrix());
        }
        if (params.clearScene || shouldReload) {
            _missileClass.acquireResources({missileOnly: false, sound: true, trail: true});
            graphics.getShader(preview.getWireframeShaderName());
            _missile.addToScene(preview.getScene(), false, undefined,
                    undefined,
                    true,
                    shouldReload ?
                    function (model) {
                        preview.setModel(model);
                        _missile._trailEmitter.addResourcesToScene(preview.getScene());
                    } :
                    null);
            _wireframeMissile.addToScene(preview.getScene(), true, undefined,
                    preview.getWireframeShaderName(),
                    false,
                    shouldReload ?
                    function (model) {
                        preview.setWireframeModel(model);
                    } :
                    null);
        } else {
            preview.setModel(_missile.getVisualModel());
            preview.setWireframeModel(_wireframeMissile.getVisualModel());
        }
        if (params.environmentName && (environmentChanged || shouldReload)) {
            _environment.addToScene(preview.getScene());
            if (_environment.addParticleEffectsToScene(preview.getScene())) {
                resources.executeWhenReady(preview.startAnimating);
            }
        }
        _environmentName = params.environmentName;
        _updateEngineStateEditor();
        return shouldReload;
    }
    /**
     * For the WebGL preview context.
     * Resets the preview settings (those handled through the options, not the ones connected to the canvas) to their default values.
     * The settings that persist across different items are not reset.
     */
    function _clearSettingsForNewItem() {
        _environmentName = null;
        _activeEngineUses = [];
    }
    /**
     * Creates and returns the control that can be used to set the engine state for the preview. Also sets the reference for the 
     * corresponding popup.
     * @returns {Element}
     */
    function _createEngineEditor() {
        var
                button = document.createElement("button"),
                popup = new common.Popup(button, null, {}),
                values = [
                    descriptors.ThrusterUse.FORWARD,
                    descriptors.ThrusterUse.YAW_LEFT,
                    descriptors.ThrusterUse.YAW_RIGHT,
                    descriptors.ThrusterUse.PITCH_UP,
                    descriptors.ThrusterUse.PITCH_DOWN
                ],
                table, row, cell, propertyEditor, i,
                elementChangeHandler = function (index, value) {
                    var elementIndex = _activeEngineUses.indexOf(values[index]);
                    if (value) {
                        if (elementIndex === -1) {
                            _activeEngineUses.push(values[index]);
                        }
                    } else {
                        if (elementIndex >= 0) {
                            _activeEngineUses.splice(elementIndex, 1);
                        }
                    }
                    _updateEngineStateEditor();
                    _updateThrusters();
                    preview.requestRender();
                };
        table = document.createElement("table");
        for (i = 0; i < values.length; i++) {
            propertyEditor = common.createBooleanInput(_activeEngineUses.indexOf(values[i]) >= 0, elementChangeHandler.bind(_createEngineEditor, i));
            row = document.createElement("tr");
            cell = document.createElement("td");
            cell.appendChild(common.createLabel(values[i].toString()));
            row.appendChild(cell);
            cell = document.createElement("td");
            cell.appendChild(propertyEditor);
            row.appendChild(cell);
            table.appendChild(row);
        }
        popup.getElement().appendChild(table);
        popup.addToPage();
        _optionElements.engineStatePopup = popup;
        // create a button using which the popup can be opened
        button.type = "button";
        button.onclick = function () {
            popup.toggle();
        };
        return button;
    }
    /**
     * For the WebGL preview context.
     * Creates the controls that form the content of the preview options and adds them to the page.
     */
    function _createOptions() {
        // add trail button
        _optionElements.addTrailButton = common.createButton("Add trail", function () {
            _addTrail();
        });
        _elements.options.appendChild(preview.createSetting(_optionElements.addTrailButton));
        // environment selector
        _optionElements.environmentSelector = common.createSelector(environments.getEnvironmentNames(), _environmentName, true, function () {
            preview.updateCanvas({
                preserve: true,
                clearScene: true,
                environmentName: (_optionElements.environmentSelector.value !== "none") ? _optionElements.environmentSelector.value : null
            });

        });
        _elements.options.appendChild(preview.createSetting(_optionElements.environmentSelector, "Environment:"));
        // engine state editor
        _optionElements.engineStateEditor = _createEngineEditor();
        _elements.options.appendChild(preview.createSetting(_optionElements.engineStateEditor, "Thrusters:"));
    }
    /**
     * The animation step
     */
    function _animate() {
        if (_environment) {
            _environment.simulate();
        }
    }
    /**
     * For the WebGL preview context.
     */
    function _updateForRefresh() {
        _updateThrusters();
    }
    /**
     * Returns additional information to be displayed in the info section of the preview
     * @returns {String}
     */
    function _getInfo() {
        var result, value;
        result = "";
        if (_missile) {
            value = _missileClass.getNominalRange();
            if (value > 0) {
                result = "Missile: ";
                result += "nominal range: " + (Math.round(value * 100) / 100) + " m";
            }
        }
        return result;
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor to show the selected 
     * missile class.
     * @param {Editor~RefreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {MissileClass} missileClass The missile class to preview
     * @param {Editor~SpacecraftClassRefreshParams} params Additional parameters 
     */
    function refresh(elements, missileClass, params) {
        var sameClass = (_missileClass === missileClass);

        preview.setContext(_previewContext);

        _elements = elements;
        _missileClass = missileClass;
        if (sameClass) {
            if (!params) {
                params = {
                    preserve: true,
                    reload: true
                };
            }
        } else {
            preview.clearSettingsForNewItem();
        }
        preview.refresh(elements, params);
    }
    /**
     * Updates the preview for the case when a property of the previewed item is being edited
     */
    function handleStartEdit() {
        return true;
    }
    /**
     * Updates the preview for the case when a property of the previewed item is no longer being edited
     */
    function handleStopEdit() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Initialization
    _previewContext = new preview.WebGLPreviewContext({
        renderModeSetting: true,
        lodSetting: true,
        animateButton: true,
        canvasUpdateProperties: CANVAS_UPDATE_PROPERTIES,
        optionRefreshProperties: OPTION_REFRESH_PROPERIES,
        infoUpdateProperties: INFO_UPDATE_PROPERTIES
    }, {
        clear: _clear,
        load: _load,
        animate: _animate,
        updateForRefresh: _updateForRefresh,
        getInfo: _getInfo,
        clearSettingsForNewItem: _clearSettingsForNewItem,
        createOptions: _createOptions
    });
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: preview.clear,
        handleDataChanged: preview.handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2016-2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for spacecraft classes within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param utils Used for enum value listing, async execution.
 * @param mat Used for copying matrices
 * @param resources Used for waiting for resource load
 * @param renderableObjects Used for accessing uniform name constants
 * @param lights Used for creating the light sources for the preview scene
 * @param config Used to access default camera configuration settings
 * @param graphics Used to set graphics settings according to the environment
 * @param environments Used to access the environments
 * @param SpacecraftEvents Used to set spacecraft event handlers
 * @param spacecraft Used to create the spacecraft for preview
 * @param common Used to create selectors
 * @param descriptors Used to access enums
 * @param preview This module is based on the common WebGL preview module
 */
define('editor/preview/spacecraft-preview',[
    "utils/utils",
    "utils/matrices",
    "modules/media-resources",
    "modules/scene/renderable-objects",
    "modules/scene/lights",
    "armada/configuration",
    "armada/graphics",
    "armada/logic/environments",
    "armada/logic/SpacecraftEvents",
    "armada/logic/spacecraft",
    "editor/common",
    "editor/descriptors",
    "editor/preview/webgl-preview"
], function (
        utils, mat,
        resources, renderableObjects, lights,
        config, graphics, environments, SpacecraftEvents, spacecraft,
        common, descriptors, preview) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            LIGHT_SOURCES = [
                {
                    color: [1, 1, 1],
                    direction: [1, 0, 1]
                }
            ],
            HITBOX_HIGHLIGHT_COLOR = [0.8, 0.4, 0.3, 0.5],
            ENGINE_STATE_NO_PROPULSION = "no propulsion",
            ENGINE_STATE_OFF = "off",
            /**
             * The names of properties the change of which should trigger an update of the preview canvas
             * @type String[]
             */
            CANVAS_UPDATE_PROPERTIES = [
                "basedOn",
                "model", "shader", "texture",
                "factionColor", "defaultLuminosityFactors",
                "bodies",
                "weaponSlots", "missileLaunchers", "thrusterSlots",
                "loadouts",
                "humSound",
                "explosion",
                "lights", "blinkers"],
            /**
             * The names of the properties the change of which should trigger a refresh of the preview options
             * @type String[]
             */
            OPTION_REFRESH_PROPERIES = [
                "basedOn",
                "loadouts"
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the info text
             * @type String[]
             */
            INFO_UPDATE_PROPERTIES = [
            ],
            /**
             * The params to pass to spacecraft.simulate()
             * @type Spacecraft~SimulateParams
             */
            SPACECRAFT_SIMULATE_PARAMS = {
                controlThrusters: false,
                applyThrusterForces: false
            },
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * @type Spacecraft
             */
            _spacecraft, _wireframeSpacecraft,
            /**
             * @type Environment
             */
            _environment,
            /**
             * A reference to the object storing the HTML elements to be used for the preview
             * @type Object
             */
            _elements,
            /**
             * A reference to the displayed spacecraft class
             * @type SpacecraftClass
             */
            _spacecraftClass,
            /**
             * @type String
             */
            _environmentName, _loadoutName,
            /**
             * The faction color to use on the previewed spacecraft model
             * @type Number[4]
             */
            _factionColor,
            /**
             * Whether the user has changed the original faction color to a custom one
             * @type Boolean
             */
            _factionColorChanged,
            /**
             * The uses of the engine that are currently set to be turned on
             * @type String[]
             */
            _activeEngineUses = [],
            /**
             * Whether the hitbox is currently visible
             * @type Boolean
             */
            _showHitbox,
            /**
             * Used to highlight the hitbox that is currently being edited
             * @type Number
             */
            _highlightedHitboxIndex,
            /**
             * Stores the WebGL preview context information for spacecraft class previews
             * @type WebGLPreviewContext
             */
            _previewContext,
            /**
             * 
             * @type Object
             */
            _optionElements = {
                environmentSelector: null,
                loadoutSelector: null,
                factionColorPicker: null,
                engineStateEditor: null,
                engineStatePopup: null,
                explodeButton: null,
                shieldRechargeButton: null
            };
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * Returns the regular hitbox color (detemined by game configuration, the same that is shown if hitboxes are turned on in the game)
     * @returns {Number[4]}
     */
    function _hitboxColorFunction() {
        return config.getSetting(config.BATTLE_SETTINGS.HITBOX_COLOR);
    }
    /**
     * Returns the color to be used on the currently edited hitbox
     * @returns {Number[4]}
     */
    function _highlighterHitboxColorFunction() {
        return HITBOX_HIGHLIGHT_COLOR;
    }
    /**
     * Sets the appropriate hitbox visibility and colors for the current settingsF
     */
    function _updateForHitboxState() {
        var i, node, nodes = _spacecraft.getHitbox().getSubnodes();
        if (_showHitbox) {
            i = 0;
            for (node = nodes.getFirst(); node; node = node.next, i++) {
                node.getRenderableObject().setUniformValueFunction(renderableObjects.UNIFORM_COLOR_NAME, (i === _highlightedHitboxIndex) ?
                        _highlighterHitboxColorFunction :
                        _hitboxColorFunction);
            }
            _spacecraft.showHitbox();
        } else {
            _spacecraft.hideHitbox();
        }
    }
    /**
     * Updates the visual models of the thrusters according to the currently set engine state.
     */
    function _updateThrusters() {
        var i;
        if (_spacecraft.getPropulsion()) {
            _spacecraft.resetThrusterBurn();
            for (i = 0; i < _activeEngineUses.length; i++) {
                _spacecraft.addThrusterBurn(_activeEngineUses[i], (
                        (_activeEngineUses[i] === descriptors.ThrusterUse.FORWARD) ||
                        (_activeEngineUses[i] === descriptors.ThrusterUse.REVERSE) ||
                        (_activeEngineUses[i] === descriptors.ThrusterUse.STRAFE_LEFT) ||
                        (_activeEngineUses[i] === descriptors.ThrusterUse.STRAFE_RIGHT) ||
                        (_activeEngineUses[i] === descriptors.ThrusterUse.RAISE) ||
                        (_activeEngineUses[i] === descriptors.ThrusterUse.LOWER)) ?
                        _spacecraft.getMaxThrusterMoveBurnLevel() :
                        _spacecraft.getMaxThrusterTurnBurnLevel());
            }
            _spacecraft.updatePropulsionVisuals();
        }
    }
    /**
     * Updates the engine state editor control in the preview options panel according to the current possibilities and settings.
     */
    function _updateEngineStateEditor() {
        var i, checkboxes;
        _optionElements.engineStateEditor.disabled = !_spacecraft.getPropulsion();
        if (_optionElements.engineStateEditor.disabled) {
            _activeEngineUses = [];
            checkboxes = _optionElements.engineStatePopup.getElement().querySelectorAll('input[type="checkbox"]');
            for (i = 0; i < checkboxes.length; i++) {
                checkboxes[i].checked = false;
            }
            _optionElements.engineStatePopup.hide();
        }
        _optionElements.engineStateEditor.innerHTML = _activeEngineUses.length > 0 ?
                (_activeEngineUses[0] + ((_activeEngineUses.length > 1) ? "..." : "")) :
                (_spacecraft.getPropulsion() ? ENGINE_STATE_OFF : ENGINE_STATE_NO_PROPULSION);
    }
    /**
     * Updates the caption and enabled state of the "Explode" button to reflect the current state of the spacecraft
     */
    function _updateExplodeButton() {
        _optionElements.explodeButton.innerHTML = (_spacecraft && _spacecraft.getHitpoints() > 0) ? "Explode" : "Respawn";
        _optionElements.explodeButton.disabled = !_spacecraft || ((_spacecraft.getHitpoints() === 0) && (_spacecraft.isAlive()));
    }
    /**
     * Updates the caption and enabled state of the "Shield recharge" button to reflect the current state of the spacecraft
     */
    function _updateShieldRechargeButton() {
        _optionElements.shieldRechargeButton.disabled = !_spacecraft || (_spacecraft.getHitpoints() <= 0) || !_spacecraft.hasShield();
    }
    /**
     * @typedef {Editor~RefreshParams} Editor~SpacecraftClassRefreshParams
     * @property {String} environmentName The name of the environment to put the previewed spacecraft in
     * @property {String} loadoutName The name of the loadout to be equipped on the previewed spacecraft
     */
    /**
     * 
     */
    function _clear() {
        if (_spacecraft) {
            _spacecraft.destroy();
            _spacecraft = null;
            _wireframeSpacecraft.destroy();
            _wireframeSpacecraft = null;
        }
    }
    /**
     * Updates the content of the preview canvas according to the current preview settings
     * @param {Editor~SpacecraftClassRefreshParams} params
     * @param {Float32Array} orientationMatrix
     * @returns {Boolean}
     */
    function _load(params, orientationMatrix) {
        var
                environmentChanged,
                loadoutChanged,
                shouldReload,
                shadows,
                i;
        params = params || {};
        if (params.preserve) {
            if (params.environmentName === undefined) {
                params.environmentName = _environmentName;
            }
            if (params.loadoutName === undefined) {
                params.loadoutName = _loadoutName;
            }
        }
        environmentChanged = params.environmentName !== _environmentName;
        loadoutChanged = params.loadoutName !== _loadoutName;
        shouldReload = !params.preserve || params.reload;
        if (environmentChanged || shouldReload) {
            shadows = graphics.isShadowMappingEnabled();
            if (params.environmentName) {
                _environment = environments.getEnvironment(params.environmentName);
                if (_environment.hasShadows()) {
                    graphics.setShadowMapping();
                } else {
                    graphics.setShadowMapping(false, false);
                }
            } else {
                _environment = null;
                preview.getScene().setClearColor([0, 0, 0, 1]);
                preview.getScene().setAmbientColor([0, 0, 0]);
                for (i = 0; i < LIGHT_SOURCES.length; i++) {
                    preview.getScene().addDirectionalLightSource(new lights.DirectionalLightSource(LIGHT_SOURCES[i].color, LIGHT_SOURCES[i].direction));
                }
                graphics.setShadowMapping();
            }
            if (shadows !== graphics.isShadowMappingEnabled()) {
                graphics.handleSettingsChanged();
                shouldReload = true;
            }
        }
        if (shouldReload) {
            _clear();
            _spacecraft = new spacecraft.Spacecraft(_spacecraftClass);
            _wireframeSpacecraft = new spacecraft.Spacecraft(_spacecraftClass);
        }
        if (orientationMatrix) {
            _spacecraft.setPhysicalOrientationMatrix(mat.matrix4(orientationMatrix));
            _wireframeSpacecraft.setPhysicalOrientationMatrix(_spacecraft.getPhysicalOrientationMatrix());
        }
        if (loadoutChanged || environmentChanged || shouldReload) {
            if (_loadoutName) {
                _spacecraft.unequip();
                _wireframeSpacecraft.unequip();
                _loadoutName = null;
            }
            if (params.loadoutName) {
                _spacecraft.equipLoadout(_spacecraftClass.getLoadout(params.loadoutName));
                _wireframeSpacecraft.equipLoadout(_spacecraftClass.getLoadout(params.loadoutName));
                _loadoutName = params.loadoutName;
            }
        }
        _spacecraft.addToScene(preview.getScene(), undefined, false,
                (environmentChanged || shouldReload) ?
                {weapons: true, missilesInLaunchers: true, allMissilesInLaunchers: true, lightSources: true, blinkers: true, hitboxes: true, thrusterParticles: true, explosion: true, shield: true, sound: true} :
                {self: false, weapons: true},
                {
                    replaceVisualModel: true,
                    factionColor: _factionColor
                },
                (environmentChanged || shouldReload) ?
                function (model) {
                    preview.setModel(model);
                } :
                null);
        _wireframeSpacecraft.addToScene(preview.getScene(), undefined, true,
                (environmentChanged || shouldReload) ?
                {weapons: true, missilesInLaunchers: true, allMissilesInLaunchers: true} :
                {self: false, weapons: true},
                {
                    replaceVisualModel: true,
                    shaderName: preview.getWireframeShaderName()
                },
                (environmentChanged || shouldReload) ?
                function (model) {
                    preview.setWireframeModel(model);
                } :
                null,
                function (model) {
                    preview.setupWireframeModel(model);
                });
        if (params.environmentName && (environmentChanged || shouldReload)) {
            _environment.addToScene(preview.getScene());
            if (_environment.addParticleEffectsToScene(preview.getScene())) {
                resources.executeWhenReady(preview.startAnimating);
            }
        }
        _environmentName = params.environmentName;
        _updateEngineStateEditor();
        return shouldReload;
    }
    /**
     * Resets the preview settings (those handled through the options, not the ones connected to the canvas) to their default values.
     * The settings that persist across different items are not reset.
     */
    function _clearSettingsForNewItem() {
        _environmentName = null;
        _loadoutName = null;
        if (!_factionColor) {
            _factionColorChanged = false;
        }
        if (!_factionColorChanged) {
            _factionColor = _spacecraftClass.getFactionColor() ? _spacecraftClass.getFactionColor().slice() : [0, 0, 0, 0];
        }
        _activeEngineUses = [];
        _showHitbox = false;
    }
    /**
     * Creates and returns the control that can be used to set the engine state for the preview. Also sets the reference for the 
     * corresponding popup.
     * @returns {Element}
     */
    function _createEngineEditor() {
        var
                button = document.createElement("button"),
                popup = new common.Popup(button, null, {}),
                values = utils.getEnumValues(descriptors.ThrusterUse),
                table, row, cell, propertyEditor, i,
                elementChangeHandler = function (index, value) {
                    var elementIndex = _activeEngineUses.indexOf(values[index]);
                    if (value) {
                        if (elementIndex === -1) {
                            _activeEngineUses.push(values[index]);
                        }
                    } else {
                        if (elementIndex >= 0) {
                            _activeEngineUses.splice(elementIndex, 1);
                        }
                    }
                    _updateEngineStateEditor();
                    _updateThrusters();
                    preview.requestRender();
                };
        table = document.createElement("table");
        for (i = 0; i < values.length; i++) {
            propertyEditor = common.createBooleanInput(_activeEngineUses.indexOf(values[i]) >= 0, elementChangeHandler.bind(_createEngineEditor, i));
            row = document.createElement("tr");
            cell = document.createElement("td");
            cell.appendChild(common.createLabel(values[i].toString()));
            row.appendChild(cell);
            cell = document.createElement("td");
            cell.appendChild(propertyEditor);
            row.appendChild(cell);
            table.appendChild(row);
        }
        popup.getElement().appendChild(table);
        popup.addToPage();
        _optionElements.engineStatePopup = popup;
        // create a button using which the popup can be opened
        button.type = "button";
        button.disabled = true;
        button.onclick = function () {
            popup.toggle();
        };
        return button;
    }
    /**
     * Creates the controls that form the content of the preview options and adds them to the page.
     */
    function _createOptions() {
        // environment selector
        _optionElements.environmentSelector = common.createSelector(environments.getEnvironmentNames(), _environmentName, true, function () {
            preview.updateCanvas({
                preserve: true,
                clearScene: true,
                environmentName: (_optionElements.environmentSelector.value !== "none") ? _optionElements.environmentSelector.value : null
            });
            _updateExplodeButton();
            _updateShieldRechargeButton();
        });
        _elements.options.appendChild(preview.createSetting(_optionElements.environmentSelector, "Environment:"));
        // loadout selector
        _optionElements.loadoutSelector = common.createSelector(_spacecraftClass.getLoadoutNames(), _loadoutName, true, function () {
            preview.updateCanvas({
                preserve: true,
                reload: true,
                loadoutName: (_optionElements.loadoutSelector.value !== "none") ? _optionElements.loadoutSelector.value : null
            });
            _updateEngineStateEditor();
            _updateExplodeButton();
            _updateShieldRechargeButton();
        });
        _elements.options.appendChild(preview.createSetting(_optionElements.loadoutSelector, "Loadout:"));
        // faction color picker
        _optionElements.factionColorPicker = common.createColorPicker(_factionColor, function () {
            _factionColorChanged = true;
            preview.updateCanvas({
                preserve: true,
                reload: true
            });
            _updateExplodeButton();
            _updateShieldRechargeButton();
        });
        _elements.options.appendChild(preview.createSetting(_optionElements.factionColorPicker, "Faction color:"));
        // engine state editor
        _optionElements.engineStateEditor = _createEngineEditor();
        _elements.options.appendChild(preview.createSetting(_optionElements.engineStateEditor, "Engine:"));
        // explode button
        _optionElements.explodeButton = common.createButton("Explode", function () {
            if (_spacecraft.getHitpoints() > 0) {
                _spacecraft.setHitpointsToZero();
                _spacecraft.addEventHandler(SpacecraftEvents.DESTRUCTED, function () {
                    _spacecraft.getVisualModel().getNode().hide();
                    _updateExplodeButton();
                    _updateShieldRechargeButton();
                    return false;
                });
                preview.startAnimating();
            } else {
                if (_spacecraft.getExplosion()) {
                    _spacecraft.getExplosion().finish();
                }
                _spacecraft.getVisualModel().getNode().show();
                _spacecraft.respawn();
                _updateThrusters();
                preview.requestRender();
            }
            _updateExplodeButton();
            _updateShieldRechargeButton();
        });
        _elements.options.appendChild(preview.createSetting(_optionElements.explodeButton));
        // shield recharge button
        _optionElements.shieldRechargeButton = common.createButton("Recharge shield", function () {
            _spacecraft.rechargeShield();
            preview.startAnimating();
        });
        _elements.options.appendChild(preview.createSetting(_optionElements.shieldRechargeButton));
    }
    /**
     * The animation step (i.e. spacecraft.simulate())
     * @param {Number} dt The time elapsed since the last animation step
     */
    function _animate(dt) {
        if (_spacecraft) {
            _spacecraft.simulate(dt, SPACECRAFT_SIMULATE_PARAMS);
        }
        if (_environment) {
            _environment.simulate();
        }
    }
    /**
     * 
     */
    function _updateForRefresh() {
        _updateForHitboxState();
        if (_spacecraft && (_spacecraft.getHitpoints() <= 0)) {
            _spacecraft.getVisualModel().getNode().show();
            _spacecraft.respawn();
        }
        _updateThrusters();
        _updateExplodeButton();
        _updateShieldRechargeButton();
    }
    /**
     * The handler for when the model is rotated by the user
     */
    function _onModelRotate() {
        var explosion = _spacecraft && _spacecraft.getExplosion();
        if (explosion) {
            explosion.getVisualModel().setOrientationMatrix(mat.matrix4(_spacecraft.getVisualModel().getOrientationMatrix()));
        }
    }
    /**
     * Returns additional information to be displayed in the info section of the preview
     * @returns {String}
     */
    function _getInfo() {
        var result, firepower, firepowerDecrease;
        result = "";
        if (_spacecraft) {
            if (_spacecraft.getPropulsion()) {
                result += "accel.: " + Math.round(_spacecraft.getMaxAcceleration()) + " m/s², speed: " + Math.round(_spacecraft.getMaxCombatSpeed()) + " m/s, ";
                result += "ang.accel.: " + Math.round(_spacecraft.getMaxAngularAcceleration() * utils.DEG) + " °/s², turn rate: " + Math.round(_spacecraft.getMaxCombatTurnRate()) + " °/s";
            }
            firepower = _spacecraft.getFirepower();
            if (firepower > 0) {
                firepowerDecrease = firepower - _spacecraft.getFirepower(1);
                result += (result ? ", " : "") + " firepower: " + (Math.round(firepower * 100) / 100) + " (-" + (Math.round(firepowerDecrease * 100) / 100) + " / arm.), ";
                result += "range: " + _spacecraft.getWeaponRangesDisplayText() + " m";
            }
            if (_spacecraft.hasShield()) {
                result += (result ? ", " : "") + " shield: " + _spacecraft.getShieldCapacity();
            }
            result += (result ? ", " : "") + "score value: " + _spacecraft.getScoreValue();
            result = "Spacecraft: " + result;
        }
        return result;
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor to show the selected 
     * spacecraft class.
     * @param {Editor~RefreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {SpacecraftClass} spacecraftClass The spacecraft class to preview
     * @param {Editor~SpacecraftClassRefreshParams} params Additional parameters 
     */
    function refresh(elements, spacecraftClass, params) {
        var sameClass = (_spacecraftClass === spacecraftClass);

        preview.setContext(_previewContext);

        _elements = elements;
        _spacecraftClass = spacecraftClass;
        if (sameClass) {
            if (!params) {
                params = {
                    preserve: true,
                    reload: true
                };
            }
        } else {
            preview.clearSettingsForNewItem();
        }
        preview.refresh(elements, params);
    }
    /**
     * Updates the preview for the case when a property of the previewed item is being edited
     * @param {String} name The name of the property that is edited (under which the editing is happening)
     * @param {Number} [index] If the property is an array, this is the index of the element in the array being edited
     */
    function handleStartEdit(name, index) {
        if (name === "bodies") {
            _showHitbox = true;
            _highlightedHitboxIndex = index;
            _updateForHitboxState();
            preview.requestRender();
        }
    }
    /**
     * Updates the preview for the case when a property of the previewed item is no longer being edited
     * @param {String} name The name of the property that is no longer edited 
     */
    function handleStopEdit(name) {
        if (name === "bodies") {
            _showHitbox = false;
            _updateForHitboxState();
            preview.requestRender();
        }
    }
    // ----------------------------------------------------------------------
    // Initialization
    _previewContext = new preview.WebGLPreviewContext({
        renderModeSetting: true,
        lodSetting: true,
        animateButton: true,
        muteCheckbox: true,
        canvasUpdateProperties: CANVAS_UPDATE_PROPERTIES,
        optionRefreshProperties: OPTION_REFRESH_PROPERIES,
        infoUpdateProperties: INFO_UPDATE_PROPERTIES
    }, {
        clear: _clear,
        load: _load,
        updateForRefresh: _updateForRefresh,
        clearSettingsForNewItem: _clearSettingsForNewItem,
        createOptions: _createOptions,
        animate: _animate,
        onModelRotate: _onModelRotate,
        getInfo: _getInfo
    });
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: preview.clear,
        handleDataChanged: preview.handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2017, 2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for environments within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param resources Used for waiting for resource load
 * @param control Used for accessing the camer controller
 * @param graphics Used to set graphics settings according to the environment
 * @param common Used to create the option elements
 * @param preview This module is based on the common WebGL preview module
 */
define('editor/preview/environment-preview',[
    "modules/media-resources",
    "armada/control",
    "armada/graphics",
    "editor/common",
    "editor/preview/webgl-preview"
], function (
        resources,
        control, graphics,
        common, preview) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            /**
             * The names of properties the change of which should trigger an update of the preview canvas
             * @type String[]
             */
            CANVAS_UPDATE_PROPERTIES = [
                "color", "skyboxes", "backgroundObjects", "dustClouds", "particleEffects"
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the preview options
             * @type String[]
             */
            OPTION_REFRESH_PROPERIES = [
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the info text
             * @type String[]
             */
            INFO_UPDATE_PROPERTIES = [
            ],
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * @type Environment
             */
            _environment,
            /**
             * A reference to the object storing the HTML elements to be used for the preview
             * @type Object
             */
            _elements,
            /**
             * 
             * @type CameraController
             */
            _cameraController,
            /**
             * 
             * @type Number
             */
            _cameraSpeed,
            /**
             * Stores the WebGL preview context information for spacecraft class previews
             * @type WebGLPreviewContext
             */
            _previewContext,
            /**
             * 
             * @type Object
             */
            _optionElements = {
                cameraSpeedEditor: null
            };
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * @typedef {Editor~RefreshParams} Editor~EnvironmentRefreshParams
     * @property {Number} cameraSpeed
     */
    /**
     * 
     */
    function _clear() {
        if (_environment) {
            _environment.removeFromScene();
        }
        if (_cameraController) {
            _cameraController.stop();
        }
    }
    /**
     * Updates the content of the preview canvas according to the current preview settings
     * @param {Editor~EnvironmentRefreshParams} params
     */
    function _load(params) {
        var shadows;
        params = params || {};
        if (params.preserve) {
            if (params.cameraSpeed === undefined) {
                params.cameraSpeed = _cameraSpeed;
            }
        }
        shadows = graphics.isShadowMappingEnabled();
        if (_environment.hasShadows()) {
            graphics.setShadowMapping();
        } else {
            graphics.setShadowMapping(false, false);
        }
        if (shadows !== graphics.isShadowMappingEnabled()) {
            graphics.handleSettingsChanged();
        }
        _environment.addToScene(preview.getScene());
        if (_environment.addParticleEffectsToScene(preview.getScene())) {
            resources.executeWhenReady(preview.startAnimating);
        }
        _cameraSpeed = params.cameraSpeed;
    }
    /**
     * Resets the preview settings (those handled through the optionns, not the ones connected to the canvas) to their default values.
     * The settings that persist across different items are not reset.
     */
    function _clearSettingsForNewItem() {
        _cameraSpeed = 0;
    }
    /**
     * Creates the controls that form the content of the preview options and adds them to the page.
     */
    function _createOptions() {
        // environment selector
        _optionElements.cameraSpeedEditor = common.createNumericInput(_cameraSpeed, {}, function (value) {
            preview.updateCanvas({
                preserve: true,
                clearScene: true,
                cameraSpeed: value
            });
        });
        _elements.options.appendChild(preview.createSetting(_optionElements.cameraSpeedEditor, "Camera speed:"));
    }
    /**
     * The animation step (i.e. environment.simulate())
     * @param {Number} dt The time elapsed since the last animation step
     */
    function _animate(dt) {
        if (_environment) {
            _cameraController.executeActions((_cameraSpeed > 0) ? [[{
                        name: "cameraMoveForward",
                        intensity: _cameraSpeed / _cameraController.getMaxSpeed()
                    }]] : [], dt);
            _environment.simulate();
        }
    }
    /**
     * 
     */
    function _updateForRefresh() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor to show the selected 
     * spacecraft class.
     * @param {Editor~RefreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {SpacecraftClass} environment The spacecraft class to preview
     * @param {Editor~SpacecraftClassRefreshParams} params Additional parameters 
     */
    function refresh(elements, environment, params) {
        var sameClass = (_environment === environment);

        preview.setContext(_previewContext);

        _elements = elements;
        _environment = environment;
        _cameraController = control.getController("camera");
        if (sameClass) {
            if (!params) {
                params = {
                    preserve: true,
                    reload: true
                };
            }
        } else {
            preview.clearSettingsForNewItem();
        }
        preview.refresh(elements, params);
        _cameraController.setControlledCamera(preview.getScene().getCamera());
    }
    /**
     * Updates the preview for the case when a property of the previewed item is being edited
     */
    function handleStartEdit() {
        return true;
    }
    /**
     * Updates the preview for the case when a property of the previewed item is no longer being edited
     */
    function handleStopEdit() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Initialization
    _previewContext = new preview.WebGLPreviewContext({
        renderModeSetting: false,
        lodSetting: false,
        animateButton: true,
        muteCheckbox: false,
        canvasUpdateProperties: CANVAS_UPDATE_PROPERTIES,
        optionRefreshProperties: OPTION_REFRESH_PROPERIES,
        infoUpdateProperties: INFO_UPDATE_PROPERTIES
    }, {
        clear: _clear,
        load: _load,
        updateForRefresh: _updateForRefresh,
        clearSettingsForNewItem: _clearSettingsForNewItem,
        createOptions: _createOptions,
        animate: _animate
    });
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: preview.clear,
        handleDataChanged: preview.handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2020 Krisztián Nagy
 * @file Provides the setup and event-handling for the preview window used for missions within the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, window */

/**
 * @param preview
 */
define('editor/preview/mission-preview',[
    "editor/preview/webgl-preview"
], function (preview) {
    "use strict";
    var
            // ----------------------------------------------------------------------
            // Constants
            /**
             * The names of properties the change of which should trigger an update of the preview canvas
             * @type String[]
             */
            CANVAS_UPDATE_PROPERTIES = [
                "environment",
                "spacecrafts"
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the preview options
             * @type String[]
             */
            OPTION_REFRESH_PROPERIES = [
            ],
            /**
             * The names of the properties the change of which should trigger a refresh of the info text
             * @type String[]
             */
            INFO_UPDATE_PROPERTIES = [
                "events"
            ],
            /** 
             * The mission is loaded on this difficulty for the preview
             * @type String 
             * */
            DIFFICULTY = "hard",
            /**
             * The spacecrafts in the mission preview are rendered with this shader
             * @type String
             */
            SPACECRAFT_SHADER_NAME = "oneColor",
            /**
             * The grids in the mission preview are rendered with this shader
             * @type String
             */
            GRID_SHADER_NAME = "oneColor",
            /**
             * The position markers in the mission preview are rendered with this shader
             * @type String
             */
            MARKER_SHADER_NAME = "oneColor",
            /**
             * The number of grids (increasing in size) to add to the mission preview scene
             * @type Number
             */
            GRID_COUNT = 4,
            /**
             * The size of the smallest grid to add, in meters
             * @type Number
             */
            SMALLEST_GRID_SIZE = 10,
            /**
             * The size (radius) of the circle part of the position markers
             * @type Number
             */
            MARKER_SIZE = 10,
            /**
             * The RGB color components of spacecrafts that are away will be multiplied by this factor
             * @type String
             */
            AWAY_COLOR_FACTOR = 0.5,
            /**
             * The alpha color component of spacecrafts that are away will be multiplied by this factor
             * @type String
             */
            AWAY_ALPHA_FACTOR = 0.1,
            /** 
             * Grids are rendered with this color in the mission preview
             * @type Number[4]
             */
            GRID_COLOR = [1, 1, 1, 0.1],
            /** 
             * Position markers for spacecrafts are rendered with this color in the mission preview
             * @type Number[4]
             */
            MARKER_COLOR = [1, 1, 0, 0.25],
            /** 
             * Friendly spacecrafts are rendered with this color in the mission preview
             * @type Number[4]
             */
            FRIENDLY_COLOR = [0, 1, 0, 1],
            /** 
             * Hostile spacecrafts are rendered with this color in the mission preview
             * @type Number[4]
             */
            HOSTILE_COLOR = [1, 0, 0, 1],
            /** 
             * Spacecrafts are rendered when their visible size reaches minimum this number
             * @type Number 
             */
            SMALLEST_SIZE_WHEN_DRAWN = 0.1,
            // ----------------------------------------------------------------------
            // Private variables
            /**
             * @type MissionDescriptor
             */
            _missionDescriptor,
            /**
             * @type Mission
             */
            _mission,
            /**
             * Stores the WebGL preview context information for mission previews
             * @type WebGLPreviewContext
             */
            _previewContext;
    // ----------------------------------------------------------------------
    // Private Functions
    /**
     * For the WebGL preview context.
     * Clears the object references of the currently stored mission (if any)
     */
    function _clear() {
        if (_mission) {
            _mission.destroy();
            _mission = null;
        }
    }
    /**
     * For the WebGL preview context.
     * Updates the content of the preview canvas according to the current preview settings
     * @param {Editor~RefreshParams} params
     */
    function _load(params) {
        var shouldReload;
        params = params || {};
        shouldReload = !params.preserve || params.reload;
        if (params.clearScene || shouldReload) {
            if (shouldReload) {
                _mission = _missionDescriptor.createMission(DIFFICULTY);
            }
            _mission.addToScene(preview.getScene(), null, {
                spacecraftShaderName: SPACECRAFT_SHADER_NAME,
                gridShaderName: GRID_SHADER_NAME,
                markerShaderName: MARKER_SHADER_NAME,
                gridColor: GRID_COLOR,
                gridCount: GRID_COUNT,
                smallestGridSize: SMALLEST_GRID_SIZE,
                markerColor: MARKER_COLOR,
                markerSize: MARKER_SIZE,
                friendlyColor: FRIENDLY_COLOR,
                hostileColor: HOSTILE_COLOR,
                smallestSizeWhenDrawn: SMALLEST_SIZE_WHEN_DRAWN,
                awayColorFactor: AWAY_COLOR_FACTOR,
                awayAlphaFactor: AWAY_ALPHA_FACTOR
            });
        }
    }
    /**
     * For the WebGL preview context.
     * Resets the preview settings (those handled through the options, not the ones connected to the canvas) to their default values.
     * The settings that persist across different items are not reset.
     */
    function _clearSettingsForNewItem() {
        return true;
    }
    /**
     * For the WebGL preview context.
     * Creates the controls that form the content of the preview options and adds them to the page.
     * Currently does nothing, no preview options are yet implemented for mission previews.
     */
    function _createOptions() {
        return true;
    }
    /**
     * For the WebGL preview context.
     * Currently does nothing, the model does not need to be changed when refreshed.
     */
    function _updateForRefresh() {
        return true;
    }
    /**
     * Returns additional information to be displayed in the info section of the preview
     * @returns {String}
     */
    function _getInfo() {
        var result, performanceLevelScores, performanceLevels, spacecrafts, pilotedCraft, i, friendlyPresent = 0, friendlyTotal = 0, hostilePresent = 0, hostileTotal = 0;
        result = "";
        if (_mission) {
            result = '<span class="objectives">[show objectives]<div class="objectives popup">' + _missionDescriptor.getMissionObjectives().join('<br>') + '</div></span>';
            performanceLevelScores = _mission.getPerformanceLevelScores();
            performanceLevels = Object.keys(performanceLevelScores);
            result += "  Score requirements:";
            for (i = 0; i < performanceLevels.length; i++) {
                if (performanceLevelScores[performanceLevels[i]] > 0) {
                    result += " " + performanceLevels[i] + ": " + performanceLevelScores[performanceLevels[i]];
                }
            }
            spacecrafts = _mission.getSpacecrafts();
            pilotedCraft = _mission.getPilotedSpacecraft();
            if (pilotedCraft) {
                result += ", Player ship: " + (pilotedCraft.getDisplayName() || ("unnamed " + pilotedCraft.getClass().getDisplayName()));
            }
            for (i = 0; i < spacecrafts.length; i++) {
                if (pilotedCraft && spacecrafts[i].isHostile(pilotedCraft)) {
                    if (!spacecrafts[i].isAway()) {
                        hostilePresent++;
                    }
                    hostileTotal++;
                } else {
                    if (!spacecrafts[i].isAway()) {
                        friendlyPresent++;
                    }
                    friendlyTotal++;
                }
            }
            if (pilotedCraft) {
                result += ", friendlies: " + friendlyPresent + " / " + friendlyTotal + ", hostiles: " + hostilePresent + " / " + hostileTotal;
            } else {
                result += ", spacecrafts: " + friendlyPresent + " / " + friendlyTotal;
            }
        }
        return result;
    }
    // ----------------------------------------------------------------------
    // Public Functions
    /**
     * The main function that sets up the preview window (both options and the preview canvas) for the editor to show the selected 
     * mission.
     * @param {Editor~RefreshElements} elements References to the HTML elements that can be used for the preview.
     * @param {MissionDescriptor} missionDescriptor The descriptor of the mission to preview
     * @param {Editor~RefreshParams} params Additional parameters 
     */
    function refresh(elements, missionDescriptor, params) {
        var sameClass = (_missionDescriptor === missionDescriptor);

        preview.setContext(_previewContext);

        _missionDescriptor = missionDescriptor;
        if (sameClass) {
            if (!params) {
                params = {
                    preserve: true,
                    reload: true
                };
            }
        } else {
            preview.clearSettingsForNewItem();
        }
        preview.refresh(elements, params);
    }
    /**
     * Updates the preview for the case when a property of the previewed item is being edited
     */
    function handleStartEdit() {
        return true;
    }
    /**
     * Updates the preview for the case when a property of the previewed item is no longer being edited
     */
    function handleStopEdit() {
        return true;
    }
    // ----------------------------------------------------------------------
    // Initialization
    _previewContext = new preview.WebGLPreviewContext({
        canvasUpdateProperties: CANVAS_UPDATE_PROPERTIES,
        optionRefreshProperties: OPTION_REFRESH_PROPERIES,
        infoUpdateProperties: INFO_UPDATE_PROPERTIES
    }, {
        clear: _clear,
        load: _load,
        updateForRefresh: _updateForRefresh,
        getInfo: _getInfo,
        clearSettingsForNewItem: _clearSettingsForNewItem,
        createOptions: _createOptions
    });
    // ----------------------------------------------------------------------
    // The public interface of the module
    return {
        refresh: refresh,
        clear: preview.clear,
        handleDataChanged: preview.handleDataChanged,
        handleStartEdit: handleStartEdit,
        handleStopEdit: handleStopEdit
    };
});

/**
 * Copyright 2016-2020 Krisztián Nagy
 * @file The main module for the Interstellar Armada editor.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global define, document, localStorage, requirejs, Blob, window */

/**
 * @param utils Used for deep copying 
 * @param application Used for logging, configuration setup and downloading files
 * @param resources Used for loading the resource configuration and displaying it in the Resources window
 * @param lights Used to set up light space perspective shadow mapping
 * @param constants Used for accessing the previously run version number in the local storage
 * @param config Used to load game configuration and settings from file
 * @param graphics Used to load the graphics settings from file
 * @param classes Used to display the class structure in the Items window and access the selected class for preview and properties
 * @param environments Used to load the environments 
 * @param missions Used to load the missions 
 * @param control Used to load game controllers so they can be used in previews
 * @param strings Used to load translations
 * @param common Used for clearing open popups
 * @param descriptors Used to determine whether the descriptor for a specific resource / class category is available
 * @param properties Used to generate the content of the Properties window
 * @param shaderPreview Used to create previews for shader resources
 * @param skyboxPreview Used to create previews for skybox classes
 * @param backgroundObjectPreview Used to create previews for background object classes
 * @param explosionPreview Used to create previews for explosion classes
 * @param projectilePreview Used to create previews for projectile classes
 * @param weaponPreview Used to create previews for weapon classes
 * @param missilePreview Used to create previews for missile classes
 * @param spacecraftPreview Used to create previews for spacecraft classes
 * @param environmentPreview Used to create previews for environments
 * @param missionPreview Used to create previews for missions
 */
define('editor/editor',[
    "utils/utils",
    "modules/application",
    "modules/media-resources",
    "modules/scene/lights",
    "armada/constants",
    "armada/configuration",
    "armada/graphics",
    "armada/logic/classes",
    "armada/logic/environments",
    "armada/logic/missions",
    "armada/control",
    "armada/strings",
    "editor/common",
    "editor/descriptors",
    "editor/properties",
    "editor/preview/shader-preview",
    "editor/preview/skybox-preview",
    "editor/preview/backgroundObject-preview",
    "editor/preview/explosion-preview",
    "editor/preview/projectile-preview",
    "editor/preview/weapon-preview",
    "editor/preview/missile-preview",
    "editor/preview/spacecraft-preview",
    "editor/preview/environment-preview",
    "editor/preview/mission-preview"
], function (
        utils,
        application, resources, lights,
        constants, config, graphics, classes,
        environments, missions,
        control, strings,
        common, descriptors, properties,
        shaderPreview,
        skyboxPreview, backgroundObjectPreview, explosionPreview, projectilePreview, weaponPreview, missilePreview, spacecraftPreview, environmentPreview, missionPreview) {
    "use strict";
    var
            // ------------------------------------------------------------------------------
            // Constants
            ITEMS_WINDOW_ID = "items",
            PREVIEW_WINDOW_ID = "preview",
            PROPERTIES_WINDOW_ID = "properties",
            // history
            BACK_BUTTON_ID = "backButton",
            FORWARD_BUTTON_ID = "forwardButton",
            // new item
            NEW_ITEM_BUTTON_ID = "newItemButton",
            NEW_ITEM_DIALOG_ID = "newItemDialog",
            NEW_ITEM_TYPE_ID = "newItemType",
            NEW_ITEM_CATEGORY_ID = "newItemCategory",
            NEW_ITEM_BASE_ID = "newItemBase",
            NEW_ITEM_NAME_ID = "newItemName",
            NEW_ITEM_CREATE_BUTTON_ID = "newItemCreate",
            NEW_ITEM_CANCEL_BUTTON_ID = "newItemCancel",
            // export items
            EXPORT_BUTTON_ID = "exportButton",
            EXPORT_DIALOG_ID = "exportDialog",
            EXPORT_TYPE_ID = "exportType",
            EXPORT_NAME_ID = "exportName",
            EXPORT_NAME_CONTAINER_ID = "exportNameContainer",
            EXPORT_ITEM_ID = "exportItem",
            EXPORT_ITEM_CONTAINER_ID = "exportItemContainer",
            EXPORT_AUTHOR_ID = "exportAuthor",
            EXPORT_EXPORT_BUTTON_ID = "exportExport",
            EXPORT_CANCEL_BUTTON_ID = "exportCancel",
            // import items
            IMPORT_BUTTON_ID = "importButton",
            IMPORT_DIALOG_ID = "importDialog",
            IMPORT_TYPE_ID = "importType",
            IMPORT_FILE_ID = "importFile",
            IMPORT_IMPORT_BUTTON_ID = "importImport",
            IMPORT_CANCEL_BUTTON_ID = "importCancel",
            // classes
            WINDOW_LABEL_CLASS = "windowLabel",
            WINDOW_CONTENT_CLASS = "windowContent",
            SELECTED_CLASS = "selected",
            ITEM_TYPE_LABEL_CLASS = "itemType",
            CATEGORY_CLASS = "category",
            ELEMENT_LIST_CLASS = "elementList",
            ELEMENT_CLASS = "element",
            ELEMENT_INSERTING_CLASS = "inserting",
            ELEMENT_DRAGOVER_CLASS = "dragover",
            ENVIRONMENTS_CATEGORY = "environments",
            MISSIONS_CATEGORY = "missions",
            ID_SEPARATOR = "_",
            ELEMENT_LI_ID_PREFIX = "element_",
            PREVIEW_OPTIONS_ID = "previewOptions",
            PREVIEW_DIV_ID = "previewDiv",
            PREVIEW_CANVAS_ID = "previewCanvas",
            PREVIEW_INFO_ID = "previewInfo",
            NO_ITEM_SELECTED_TEXT = "select an item from the left",
            NO_PREVIEW_TEXT = "preview not available for this type of item",
            NO_PROPERTIES_TEXT = "properties not available for this type of item",
            // ------------------------------------------------------------------------------
            // Private variables
            /**
             * The content of the Preview window for an item belonging to a specific category is generated based on the module stored within this
             * object, at the key that is the same as the category name
             * @type Object
             */
            _previews = {
                "shaders": shaderPreview,
                "skyboxClasses": skyboxPreview,
                "backgroundObjectClasses": backgroundObjectPreview,
                "explosionClasses": explosionPreview,
                "projectileClasses": projectilePreview,
                "weaponClasses": weaponPreview,
                "missileClasses": missilePreview,
                "spacecraftClasses": spacecraftPreview,
                "environments": environmentPreview,
                "missions": missionPreview
            },
            /**
             * The HTML elements (<span>) that corresponds to the various items, by type, category and string id
             * Also stores references to the lists containing the items on the category level: _itemElements[type][category]._list
             * @type Object.<String, Object.<String, Object.<String,Element>>>
             */
            _itemElements,
            /**
             * The HTML element (<span>) that corresponds to the currently selected item
             * @type Element
             */
            _selectedItemElement,
            /**
             * The data of the currently selected item
             * @type Editor~Item
             */
            _selectedItem = {
                type: common.ItemType.NONE,
                name: "",
                category: "",
                reference: null,
                data: null
            },
            /**
             * The history of selected items, in chronological order, so the user can go back (/forward)
             * @type Editor~Item[]
             */
            _itemHistory = [],
            /**
             * The index of the currently selected item within the _itemHistory list
             * @type Number
             */
            _historyIndex = -1,
            _backButton,
            _forwardButton,
            _resourceList,
            _classList,
            _environmentList,
            _missionList,
            _selectItem,
            _newItemDialog,
            _exportDialog,
            _importDialog,
            _initNewItemDialog,
            _initExportDialog;
    // ------------------------------------------------------------------------------
    // Private functions
    /**
     * Expands a (sub)list, optionally scrolling to make sure the specified item is visible
     * @param {Element} listElement The HTML element representing the list. (e.g. <ul>)
     * @param {Element} [itemElement] The HTML element representing the item to scroll to
     */
    function _expandList(listElement, itemElement) {
        var parent;
        listElement.hidden = false;
        if (itemElement) {
            parent = document.getElementById(ITEMS_WINDOW_ID).querySelector("." + WINDOW_CONTENT_CLASS);
            if (itemElement.offsetTop < parent.scrollTop) {
                parent.scrollTop = itemElement.offsetTop;
            } else if (itemElement.offsetTop + itemElement.offsetHeight > parent.scrollTop + parent.clientHeight) {
                parent.scrollTop = itemElement.offsetTop + itemElement.offsetHeight - parent.clientHeight;
            }
        }
    }
    /**
     * Toggles a (sub)list between expanded / collapsed state.
     * @param {Element} listElement The HTML element representing the list. (e.g. <ul>)
     */
    function _toggleList(listElement) {
        listElement.hidden = !listElement.hidden;
    }
    /**
     * Creates and returns a <div> element with the CSS class associated with (window) labels and the passed text.
     * @param {String} text
     * @returns {Element}
     */
    function _createLabel(text) {
        var label = document.createElement("div");
        label.classList.add(WINDOW_LABEL_CLASS);
        label.innerHTML = text;
        return label;
    }
    /**
     * Hides the window label that is below the passed element in the DOM.
     * @param {Element} parent
     */
    function _hideLabel(parent) {
        var label = parent.querySelector("div." + WINDOW_LABEL_CLASS);
        label.hidden = true;
    }
    /**
     * Sets a new text for the window label that is below the passed element in the DOM.
     * @param {Element} parent
     * @param {String} text
     */
    function _setLabel(parent, text) {
        var label = parent.querySelector("div." + WINDOW_LABEL_CLASS);
        label.hidden = false;
        label.innerHTML = text;
    }
    /**
     * Clears the currently open preview (if any), so that a new one can be opened (or the missing preview text shown)
     */
    function _clearPreview() {
        if ((_selectedItem.type !== common.ItemType.NONE) && (_previews[_selectedItem.category])) {
            _previews[_selectedItem.category].clear();
        }
    }
    /**
     * Loads the content of the Preview window for the currently selected element.
     */
    function _loadPreview() {
        var
                previewWindowContent = document.getElementById(PREVIEW_WINDOW_ID).querySelector("." + WINDOW_CONTENT_CLASS),
                previewOptions = previewWindowContent.querySelector("div#" + PREVIEW_OPTIONS_ID),
                previewDiv = document.getElementById(PREVIEW_DIV_ID),
                previewCanvas = document.getElementById(PREVIEW_CANVAS_ID),
                previewInfo = document.getElementById(PREVIEW_INFO_ID);
        if (_selectedItem.type === common.ItemType.NONE) {
            previewDiv.hidden = true;
            previewCanvas.hidden = true;
            previewOptions.hidden = true;
            previewInfo.hidden = true;
            _setLabel(previewWindowContent, NO_ITEM_SELECTED_TEXT);
        } else if (!_previews[_selectedItem.category]) {
            previewDiv.hidden = true;
            previewCanvas.hidden = true;
            previewOptions.hidden = true;
            previewInfo.hidden = true;
            _setLabel(previewWindowContent, NO_PREVIEW_TEXT);
        } else {
            _hideLabel(previewWindowContent);
            _previews[_selectedItem.category].refresh({
                options: previewOptions,
                div: previewDiv,
                canvas: previewCanvas,
                info: previewInfo
            }, _selectedItem.reference);
        }
    }
    /**
     * In case the property accessed within the passed data is a reference to an item with the passed old name and in the same category 
     * as currently selected, changes the reference to the passed new name
     * @param {Object|Array} data The data within to access the property to check
     * @param {String|Number} accessor The key of the property (for objects) or the index of the element (for arrays) to access the property to check
     * @param {Type} type The type describing the accessed property
     * @param {String} oldName 
     * @param {String} newName
     * @param {Function} categoryGetter A function that should return the category of reference (e.g. "textures" or "projectileClasses") for a passed type
     * @returns {Boolean}
     */
    function _changeReference(data, accessor, type, oldName, newName, categoryGetter) {
        var index;
        // if the property is a reference type in the same category as currently selected (e.g. we have a texture selected and the property is a texture reference)
        if ((categoryGetter(type) === _selectedItem.category)) {
            // references are either enums (a simple string reference) or sets (an array of string references)
            switch (type.getBaseType()) {
                case descriptors.BaseType.ENUM:
                    if (data[accessor] === oldName) {
                        data[accessor] = newName;
                        return true;
                    }
                    break;
                case descriptors.BaseType.SET:
                    index = data[accessor].indexOf(oldName);
                    if (index >= 0) {
                        data[accessor][index] = newName;
                        return true;
                    }
                    break;
            }
        }
        return false;
    }
    /**
     * Checks for all references within the passed data using the passed type information, and replaces all references having the passed
     * old name in the same category as currently selected to the passed new name. 
     * E.g. we want to replace texture references to the "explosion" texture to references to the "shard" texture in an explosion class,
     * because we have just renamed the corresponding texture (so we have it selected)
     * See the parameter examples on how to do that.
     * @param {} data The data in which to look for references. Will be interpreted based on the type info to recursively check for references
     * within arrays / objects. E.g. the initialization JSON object for an explosion class
     * @param {Type} type The information describing the type of the passed data. E.g. the EXPLOSION_CLASS item descriptor
     * @param {String} oldName The old name which to replace e.g. "explosion"
     * @param {String} newName The new name which to replace e.g. "shard"
     * @param {Function} categoryGetter Should return the category of reference if a type is passed to it. E.g. passing a texture reference
     * type descriptor to it, should return "textures" if we are looking for resource references (but not if we are looking for class references)
     */
    function _changeReferences(data, type, oldName, newName, categoryGetter) {
        var propertyDescriptors, propertyDescriptorNames, i, childType, keys;
        if (data) {
            switch (type.getBaseType()) {
                case descriptors.BaseType.OBJECT:
                    propertyDescriptors = type.getProperties();
                    propertyDescriptorNames = Object.keys(propertyDescriptors);
                    for (i = 0; i < propertyDescriptorNames.length; i++) {
                        childType = new descriptors.Type(propertyDescriptors[propertyDescriptorNames[i]].type);
                        if (!_changeReference(data, propertyDescriptors[propertyDescriptorNames[i]].name, childType, oldName, newName, categoryGetter)) {
                            _changeReferences(data[propertyDescriptors[propertyDescriptorNames[i]].name], childType, oldName, newName, categoryGetter);
                        }
                    }
                    break;
                case descriptors.BaseType.ARRAY:
                    childType = type.getElementType();
                    for (i = 0; i < data.length; i++) {
                        if (!_changeReference(data, i, childType, oldName, newName, categoryGetter)) {
                            _changeReferences(data[i], childType, oldName, newName, categoryGetter);
                        }
                    }
                    break;
                case descriptors.BaseType.ASSOCIATIVE_ARRAY:
                    childType = type.getElementType();
                    keys = Object.keys(data);
                    for (i = 0; i < keys.length; i++) {
                        if (!_changeReference(data, keys[i], childType, oldName, newName, categoryGetter)) {
                            _changeReferences(data[keys[i]], childType, oldName, newName, categoryGetter);
                        }
                    }
                    break;
                case descriptors.BaseType.PAIRS:
                    for (i = 0; i < data.length; i++) {
                        childType = type.getFirstType();
                        if (!_changeReference(data[i], 0, childType, oldName, newName, categoryGetter)) {
                            _changeReferences(data[i][0], childType, oldName, newName, categoryGetter);
                        }
                        childType = type.getSecondType();
                        if (!_changeReference(data[i], 1, childType, oldName, newName, categoryGetter)) {
                            _changeReferences(data[i][1], childType, oldName, newName, categoryGetter);
                        }
                    }
                    break;
            }
        }
    }
    /**
     * Updates the URL hash to describe the currently selected item
     */
    function _updateHash() {
        location.hash = _selectedItem.type + "/" + _selectedItem.category + "/" + _selectedItem.name;
    }
    /**
     * Creates and returns a function that can be used when the name of an item is changed
     * @param {String} oldName
     * @param {String} newName
     * @param {Function} categoryGetter Should return the reference category of a property if the type info of the property is passed to it,
     * of the same item type as the item that has been changed (resource / class / etc)
     * @returns {Function}
     */
    function _createItemNameChangeHandler(oldName, newName, categoryGetter) {
        return function (itemInstance, categoryName) {
            var descriptor = descriptors.itemDescriptors[categoryName];
            if (descriptor) {
                _changeReferences(itemInstance.getData(), new descriptors.Type(descriptor), oldName, newName, categoryGetter, true);
            }
            itemInstance.reloadData();
        };
    }
    /**
     * A function to execute whenever the name property of the selected item is changed
     */
    function _handleNameChange() {
        var newName = _selectedItem.data.name, oldName = _selectedItemElement.innerHTML, nameChangeHandler;
        if (newName && (newName !== oldName)) {
            _selectedItemElement.innerHTML = newName;
            switch (_selectedItem.type) {
                case common.ItemType.RESOURCE:
                    resources.renameResource(_selectedItem.category, oldName, newName);
                    nameChangeHandler = _createItemNameChangeHandler(oldName, newName, function (type) {
                        return type.getResourceReference();
                    });
                    break;
                case common.ItemType.CLASS:
                    classes.renameClass(_selectedItem.category, oldName, newName);
                    nameChangeHandler = _createItemNameChangeHandler(oldName, newName, function (type) {
                        return type.getClassReference();
                    });
                    break;
                default:
                    application.showError("Name change not supported for this type of item!");
                    return;
            }
            _selectedItem.name = newName;
            _itemElements[_selectedItem.type][_selectedItem.category][newName] = _itemElements[_selectedItem.type][_selectedItem.category][oldName];
            delete _itemElements[_selectedItem.type][_selectedItem.category][oldName];
            resources.executeForAllResources(nameChangeHandler);
            classes.executeForAllClasses(nameChangeHandler);
            environments.executeForAllEnvironments(nameChangeHandler);
            _updateHash();
        }
    }
    /**
     * Updates the enabled / disabled states of history back / forward buttons, to be called every time
     * we move within history
     */
    function _updateHistoryButtons() {
        _backButton.disabled = _historyIndex <= 0;
        _forwardButton.disabled = _historyIndex >= (_itemHistory.length - 1);
    }
    /**
     * Loads the content of the Properties window for the currently selected element.
     */
    function _loadProperties() {
        var windowContent = document.getElementById(PROPERTIES_WINDOW_ID).querySelector("." + WINDOW_CONTENT_CLASS);
        windowContent.innerHTML = "";
        if (_selectedItem.type === common.ItemType.NONE) {
            windowContent.appendChild(_createLabel(NO_ITEM_SELECTED_TEXT));
        } else if (!descriptors.itemDescriptors[_selectedItem.category]) {
            windowContent.appendChild(_createLabel(NO_PROPERTIES_TEXT));
        } else {
            properties.createProperties(windowContent, _selectedItem, _previews[_selectedItem.category], _handleNameChange, _selectItem);
        }
    }
    /**
     * Sets the data the passed item and loads the appropriate Preview and Properties windows for it, if available
     * Only to be used by _selectItem and history operations - outside of these, use _selectItem
     * @param {String} type (enum ItemType) The type of the selected item
     * @param {String} name The name (id) of the selected item
     * @param {String} category The category the selected item belongs to (this will determine the format of the Preview and Properties windows)
     * @param {Element} [element] The HTML element (<span>) that references the item in the category list (if not given, will be looked up from the _itemElements object)
     */
    function _loadItem(type, name, category, element) {
        var reference;
        _newItemDialog.hidden = true;
        _exportDialog.hidden = true;
        reference = common.getItemReference({type, name, category}, true);
        if (reference) {
            if (_selectedItemElement) {
                _selectedItemElement.classList.remove(SELECTED_CLASS);
            }
            _clearPreview();
            _selectedItem.type = type;
            _selectedItem.name = name;
            _selectedItem.category = category;
            _selectedItem.reference = reference;
            _selectedItem.data = reference.getData();
            common.removePopups();
            _loadProperties();
            _loadPreview();
            if (!element) {
                element = _itemElements[_selectedItem.type][_selectedItem.category][_selectedItem.name];
            }
            _expandList(_itemElements[_selectedItem.type][_selectedItem.category]._list, element);
            _selectedItemElement = element;
            _selectedItemElement.classList.add(SELECTED_CLASS);
            _updateHash();
        }
    }
    /**
     * Sets up the variables and handlers for the history back / forward buttons (to be called at startup)
     */
    function _loadHistoryButtons() {
        _backButton = document.getElementById(BACK_BUTTON_ID);
        _forwardButton = document.getElementById(FORWARD_BUTTON_ID);
        _backButton.onclick = function () {
            var item;
            _historyIndex--;
            item = _itemHistory[_historyIndex];
            _loadItem(item.type, item.name, item.category);
            _updateHistoryButtons();
        };
        _forwardButton.onclick = function () {
            var item;
            _historyIndex++;
            item = _itemHistory[_historyIndex];
            _loadItem(item.type, item.name, item.category);
            _updateHistoryButtons();
        };
    }
    /**
     * Sets the data for a new selected item and loads the appropriate Preview and Properties windows for it, if available
     * Also updates selection history
     * @param {String} type (enum ItemType) The type of the selected item
     * @param {String} name The name (id) of the selected item
     * @param {String} category The category the selected item belongs to (this will determine the format of the Preview and Properties windows)
     * @param {Element} [element] The HTML element (<span>) that references the item in the category list (if not given, will be looked up from the _itemElements object)
     */
    _selectItem = function (type, name, category, element) {
        if ((_selectedItem.type !== type) || (_selectedItem.name !== name) || (_selectedItem.category !== category)) {
            _loadItem(type, name, category, element);
            if ((_itemHistory.length > 0) && (_historyIndex < (_itemHistory.length - 1))) {
                _itemHistory.splice(_historyIndex + 1);
            }
            _itemHistory.push({type: type, name: name, category: category, element: element});
            _historyIndex = _itemHistory.length - 1;
            _updateHistoryButtons();
        }
    };
    /**
     * Creates and returns a function that can be used as the onclick event handler on an element representing a selectable item (such as
     * a resource or game class)
     * @param {Element} element The element that represents the item (typically <span>, showing the name of the item)
     * @param {String} type (enum ItemType) The type this item belongs to
     * @param {String} category The category the item belongs to (e.g. "spacecraftClasses")
     * @param {String} name The name (string ID) of the item (e.g. "falcon")
     * @returns {Function}
     */
    function _createElementClickHandler(element, type, category, name) {
        return function () {
            _selectItem(type, name, category, element);
        };
    }
    /**
     * Returns a string that can be used as a drag and drop dataTransfer type for items of the passed type and category
     * @param {String} type
     * @param {String} category
     * @returns {String}
     */
    function _getItemDataTransferType(type, category) {
        return (type + "/" + category).toLowerCase();
    }
    /**
     * Creates and returns a handler for the dragstart event for item elements (<li> tags)
     * @param {Element} element
     * @param {String} type
     * @param {String} category
     * @returns {Function}
     */
    function _createElementDragStartHandler(element, type, category) {
        var dataTransferType = _getItemDataTransferType(type, category);
        return function (event) {
            event.dataTransfer.setData(dataTransferType, element.id);
            element.classList.add(ELEMENT_INSERTING_CLASS);
        };
    }
    /**
     * Creates and returns a handler for the dragend event for item elements (<li> tags)
     * @param {Element} element
     * @returns {Function}
     */
    function _createElementDragEndHandler(element) {
        return function () {
            element.classList.remove(ELEMENT_INSERTING_CLASS);
        };
    }
    /**
     * Creates and returns a handler for the dragenter event for item elements (<li> tags)
     * @param {Element} element
     * @param {String} type
     * @param {String} category
     * @returns {Function}
     */
    function _createElementDragEnterHandler(element, type, category) {
        var dataTransferType = _getItemDataTransferType(type, category);
        return function (event) {
            var hasCorrectType = event.dataTransfer.types.indexOf(dataTransferType) >= 0;
            if (hasCorrectType && (event.dataTransfer.getData(dataTransferType) !== element.id)) {
                element.classList.add(ELEMENT_DRAGOVER_CLASS);
                event.preventDefault();
            }
        };
    }
    /**
     * Creates and returns a handler for the dragover event for item elements (<li> tags)
     * @param {Element} element
     * @param {String} type
     * @param {String} category
     * @returns {Function}
     */
    function _createElementDragOverHandler(element, type, category) {
        var dataTransferType = _getItemDataTransferType(type, category);
        return function (event) {
            var hasCorrectType = event.dataTransfer.types.indexOf(dataTransferType) >= 0;
            if (hasCorrectType && (event.dataTransfer.getData(dataTransferType) !== element.id)) {
                event.preventDefault();
            }
        };
    }
    /**
     * Creates and returns a handler for the dragleave event for item elements (<li> tags)
     * @param {Element} element
     * @param {String} type
     * @param {String} category
     * @returns {Function}
     */
    function _createElementDragLeaveHandler(element, type, category) {
        var dataTransferType = _getItemDataTransferType(type, category);
        return function (event) {
            var hasCorrectType = event.dataTransfer.types.indexOf(dataTransferType) >= 0;
            if (hasCorrectType) {
                element.classList.remove(ELEMENT_DRAGOVER_CLASS);
            }
        };
    }
    /**
     * Creates and returns a handler for the drop event for item elements (<li> tags)
     * @param {Element} element
     * @param {String} type
     * @param {String} category
     * @returns {Function}
     */
    function _createElementDropHandler(element, type, category) {
        var dataTransferType = _getItemDataTransferType(type, category);
        return function (event) {
            var otherElement = document.getElementById(event.dataTransfer.getData(dataTransferType));
            element.classList.remove(ELEMENT_DRAGOVER_CLASS);
            element.parentNode.insertBefore(otherElement, element.nextSibling);
            switch (type) {
                case common.ItemType.RESOURCE:
                    resources.moveResourceAfter(category, otherElement.firstChild.textContent, element.firstChild.textContent);
                    break;
                case common.ItemType.CLASS:
                    classes.moveClassAfter(category, otherElement.firstChild.textContent, element.firstChild.textContent);
                    break;
                default:
                    application.showError("Cannot move element of type '" + type + "'!");
            }
        };
    }
    /**
     * Returns the info object that can be embedded at the beginning of exported files (e.g. classes)
     * @param {String} name The name to be included in the info
     * @param {String} author The author to be included in the info
     * @returns {Object}
     */
    function _getInfoObject(name, author) {
        return {
            name: name,
            author: author,
            comment: "Created by Interstellar Armada editor",
            version: application.getVersion(),
            creationTime: new Date().toString()
        };
    }
    /**
     * Returns the stringified info object that can be embedded at the beginning of exported files (e.g. classes)
     * @param {String} name The name to be included in the info
     * @param {String} author The author to be included in the info
     * @returns {String}
     */
    function _getInfoString(name, author) {
        return JSON.stringify(_getInfoObject(name, author));
    }
    /**
     * Returns the string that can be used as the content of an exported file 
     * @param {String} name The name to be included in the info section of the file
     * @param {String} author The author to be included in the info section of the file
     * @param {String[]} categories The list of the categories to include in the file
     * @param {Function} getNamesFunction The function that returns the names of the items to be included for a given category
     * @param {Function} getItemFunction  The function that returns the data of items to be included, given the category and name of the item
     * @returns {String}
     */
    function _getItemsString(name, author, categories, getNamesFunction, getItemFunction) {
        var i, j, itemNames, result, itemData;
        result = '{"info":' + _getInfoString(name, author);
        for (i = 0; i < categories.length; i++) {
            result += ',"' + categories[i] + '":[';
            itemNames = getNamesFunction(categories[i]);
            for (j = 0; j < itemNames.length; j++) {
                itemData = getItemFunction(categories[i], itemNames[j]).getData();
                if (itemData) {
                    result += ((j > 0) ? ',' : '') + JSON.stringify(itemData);
                }
            }
            result += ']';
        }
        result += "}";
        return result;
    }
    /**
     * Exports the passed string into a JSON file the download of which is then triggered
     * @param {String} name The name of the file (without extension)
     * @param {String} string The string to use as the contents of the file
     */
    function _exportString(name, string) {
        var
                blob = new Blob([string], {type: "text/json"}),
                e = document.createEvent("MouseEvents"),
                a = document.createElement("a");
        a.download = name + ".json";
        a.href = window.URL.createObjectURL(blob);
        a.dataset.downloadurl = ["text/json", a.download, a.href].join(":");
        e.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
        a.dispatchEvent(e);
    }
    /**
     * Sets up the event handlers for the elements in the export dialog
     */
    function _loadExportDialog() {
        var
                exportType = document.getElementById(EXPORT_TYPE_ID),
                exportName = document.getElementById(EXPORT_NAME_ID),
                exportNameContainer = document.getElementById(EXPORT_NAME_CONTAINER_ID),
                exportItem = document.getElementById(EXPORT_ITEM_ID),
                exportItemContainer = document.getElementById(EXPORT_ITEM_CONTAINER_ID),
                exportAuthor = document.getElementById(EXPORT_AUTHOR_ID),
                exportExport = document.getElementById(EXPORT_EXPORT_BUTTON_ID),
                exportCancel = document.getElementById(EXPORT_CANCEL_BUTTON_ID),
                typeOptions = [common.ItemType.RESOURCE, common.ItemType.CLASS, common.ItemType.ENVIRONMENT, common.ItemType.MISSION],
                getMissions = function () {
                    return missions.getMissionNames().map(function (missionName) {
                        return utils.getFilenameWithoutExtension(missionName);
                    });
                };
        common.setSelectorOptions(exportType, typeOptions);
        exportType.onchange = function () {
            if (exportType.value === common.ItemType.MISSION) {
                common.setSelectorOptions(exportItem, getMissions());
                exportNameContainer.hidden = true;
                exportItemContainer.hidden = false;
            } else {
                exportName.value = exportType.value;
                exportNameContainer.hidden = false;
                exportItemContainer.hidden = true;
            }
        };
        exportType.onchange();
        exportExport.onclick = function () {
            switch (exportType.value) {
                case common.ItemType.RESOURCE:
                    _exportString(
                            exportName.value,
                            _getItemsString(
                                    exportName.value,
                                    exportAuthor.value,
                                    resources.getResourceTypes(),
                                    resources.getResourceNames,
                                    resources.getResource));
                    break;
                case common.ItemType.CLASS:
                    _exportString(
                            exportName.value,
                            _getItemsString(
                                    exportName.value,
                                    exportAuthor.value,
                                    classes.getClassCategories(),
                                    classes.getClassNames,
                                    classes.getClass));
                    break;
                case common.ItemType.ENVIRONMENT:
                    _exportString(
                            exportName.value,
                            _getItemsString(
                                    exportName.value,
                                    exportAuthor.value,
                                    [ENVIRONMENTS_CATEGORY],
                                    environments.getEnvironmentNames,
                                    function (categoryName, itemName) {
                                        return (categoryName === ENVIRONMENTS_CATEGORY) ? environments.getEnvironment(itemName) : null;
                                    }));
                    break;
                case common.ItemType.MISSION:
                    missions.requestMissionDescriptor(missions.getMissionNames()[exportItem.selectedIndex], function (missionDescriptor) {
                        var data = Object.assign({info: _getInfoObject(missionDescriptor.getName(), exportAuthor.value)}, missionDescriptor.getData());
                        delete data.name;
                        _exportString(
                                exportItem.value,
                                JSON.stringify(data));
                    });
                    break;
                default:
                    application.showError("Exporting " + exportType.value + " is not yet implemented!");
            }
            _exportDialog.hidden = true;
        };
        exportCancel.onclick = function () {
            _exportDialog.hidden = true;
        };
        _initExportDialog = function () {
            var index;
            if (_selectedItem) {
                index = typeOptions.indexOf(_selectedItem.type);
                if (index >= 0) {
                    exportType.selectedIndex = index;
                    exportType.onchange();
                    if (exportType.value === common.ItemType.MISSION) {
                        index = getMissions().indexOf(utils.getFilenameWithoutExtension(_selectedItem.name));
                        if (index >= 0) {
                            exportItem.selectedIndex = index;
                        }
                    }
                }
            }
        };
    }
    /**
     * Sets up the event handlers for the elements in the import dialog
     */
    function _loadImportDialog() {
        var
                importType = document.getElementById(IMPORT_TYPE_ID),
                importFile = document.getElementById(IMPORT_FILE_ID),
                importImport = document.getElementById(IMPORT_IMPORT_BUTTON_ID),
                importCancel = document.getElementById(IMPORT_CANCEL_BUTTON_ID),
                typeOptions = [common.ItemType.MISSION];
        common.setSelectorOptions(importType, typeOptions);
        importImport.onclick = function () {
            switch (importType.value) {
                case common.ItemType.MISSION:
                    var file = importFile.files[0];
                    if (file) {
                        file.text().then(function (text) {
                            var data = JSON.parse(text);
                            if (data) {
                                data.name = file.name;
                                if (missions.getMissionNames().indexOf(data.name) >= 0) {
                                    application.showError("A mission with this filename already exists!", application.ErrorSeverity.MINOR);
                                } else {
                                    missions.createMissionDescriptor(data);
                                    _loadItems();
                                    _selectItem(importType.value, data.name, common.ItemType.MISSION);
                                }
                            }
                        }.bind(this)).catch(function () {
                            application.showError("The selected file doesn't seem to be a valid mission file!", application.ErrorSeverity.MINOR);
                        });
                    }
                    break;
                default:
                    application.showError("Importing " + importType.value + " is not yet implemented!");
            }
            _importDialog.hidden = true;
        };
        importCancel.onclick = function () {
            _importDialog.hidden = true;
        };
    }
    /**
     * Creates and returns a collapsable list (<ul> tag) containing the categories of the game items belonging to the passed type.
     * @param {String} itemType (enum ItemType)
     * @returns {Element}
     */
    function _createCategoryList(itemType) {
        var result = document.createElement("div"),
                itemTypeLabel,
                categories, categoryList, categoryElement, categorySpan,
                items, itemList, itemElement, itemSpan,
                i, j, getItems;
        switch (itemType) {
            case common.ItemType.RESOURCE:
                categories = resources.getResourceTypes();
                getItems = resources.getResourceNames;
                break;
            case common.ItemType.CLASS:
                categories = classes.getClassCategories();
                getItems = classes.getClassNames;
                break;
            case common.ItemType.ENVIRONMENT:
                categories = [ENVIRONMENTS_CATEGORY];
                getItems = environments.getEnvironmentNames;
                break;
            case common.ItemType.MISSION:
                categories = [MISSIONS_CATEGORY];
                getItems = missions.getMissionNames;
                break;
            default:
                application.crash();
        }
        _itemElements[itemType] = {};
        itemTypeLabel = document.createElement("div");
        itemTypeLabel.classList.add(ITEM_TYPE_LABEL_CLASS);
        itemTypeLabel.textContent = itemType;
        result.appendChild(itemTypeLabel);
        categoryList = document.createElement("ul");
        for (i = 0; i < categories.length; i++) {
            categoryElement = document.createElement("li");
            categoryElement.classList.add(CATEGORY_CLASS);
            categorySpan = document.createElement("span");
            categorySpan.classList.add(CATEGORY_CLASS);
            categorySpan.innerHTML = categories[i];
            categoryElement.appendChild(categorySpan);
            _itemElements[itemType][categories[i]] = {};
            itemList = document.createElement("ul");
            itemList.classList.add(ELEMENT_LIST_CLASS);
            items = getItems(categories[i]);
            for (j = 0; j < items.length; j++) {
                itemElement = document.createElement("li");
                itemElement.setAttribute("id", ELEMENT_LI_ID_PREFIX + itemType + ID_SEPARATOR + categories[i] + ID_SEPARATOR + items[j]);
                itemElement.classList.add(ELEMENT_CLASS);
                itemElement.draggable = (itemType === common.ItemType.RESOURCE) || (itemType === common.ItemType.CLASS);
                itemSpan = document.createElement("span");
                itemSpan.classList.add(ELEMENT_CLASS);
                itemSpan.textContent = items[j];
                if (itemType === common.ItemType.MISSION) {
                    itemSpan.textContent = utils.getFilenameWithoutExtension(itemSpan.textContent);
                }
                itemElement.appendChild(itemSpan);
                _itemElements[itemType][categories[i]][items[j]] = itemSpan;
                itemSpan.onclick = _createElementClickHandler(itemSpan, itemType, categories[i], items[j]);
                if (itemElement.draggable) {
                    itemElement.ondragstart = _createElementDragStartHandler(itemElement, itemType, categories[i], itemElement.id);
                    itemElement.ondragend = _createElementDragEndHandler(itemElement);
                    itemElement.ondragenter = _createElementDragEnterHandler(itemElement, itemType, categories[i]);
                    itemElement.ondragover = _createElementDragOverHandler(itemElement, itemType, categories[i]);
                    itemElement.ondragleave = _createElementDragLeaveHandler(itemElement, itemType, categories[i]);
                    itemElement.ondrop = _createElementDropHandler(itemElement, itemType, categories[i]);
                }
                itemList.appendChild(itemElement);
            }
            itemList.hidden = true;
            categoryElement.appendChild(itemList);
            categorySpan.onclick = _toggleList.bind(this, itemList);
            _itemElements[itemType][categories[i]]._list = itemList;
            categoryList.appendChild(categoryElement);
        }
        result.appendChild(categoryList);
        return result;
    }
    /**
     * Loads the content of the Items window - collapsable lists of game items of each category. Call after the configuration has been 
     * loaded.
     */
    function _loadItems() {
        var windowContent = document.getElementById(ITEMS_WINDOW_ID).querySelector("." + WINDOW_CONTENT_CLASS);
        _hideLabel(windowContent);
        _itemElements = {};
        if (_resourceList) {
            windowContent.removeChild(_resourceList);
        }
        _resourceList = _createCategoryList(common.ItemType.RESOURCE);
        windowContent.appendChild(_resourceList);
        if (_classList) {
            windowContent.removeChild(_classList);
        }
        _classList = _createCategoryList(common.ItemType.CLASS);
        windowContent.appendChild(_classList);
        if (_environmentList) {
            windowContent.removeChild(_environmentList);
        }
        _environmentList = _createCategoryList(common.ItemType.ENVIRONMENT);
        windowContent.appendChild(_environmentList);
        if (_missionList) {
            windowContent.removeChild(_missionList);
        }
        _missionList = _createCategoryList(common.ItemType.MISSION);
        windowContent.appendChild(_missionList);
    }
    /**
     * Loads the default values and sets the change handlers for the contents of the New item dialog
     */
    function _loadNewItemDialog() {
        var
                newItemType = document.getElementById(NEW_ITEM_TYPE_ID),
                newItemCategory = document.getElementById(NEW_ITEM_CATEGORY_ID),
                newItemBase = document.getElementById(NEW_ITEM_BASE_ID),
                newItemName = document.getElementById(NEW_ITEM_NAME_ID),
                createButton = document.getElementById(NEW_ITEM_CREATE_BUTTON_ID),
                cancelButton = document.getElementById(NEW_ITEM_CANCEL_BUTTON_ID),
                typeOptions = [common.ItemType.RESOURCE, common.ItemType.CLASS, common.ItemType.ENVIRONMENT, common.ItemType.MISSION],
                getItems, create, createAsync;
        common.setSelectorOptions(newItemType, typeOptions);
        newItemType.onchange = function () {
            switch (newItemType.value) {
                case common.ItemType.RESOURCE:
                    common.setSelectorOptions(newItemCategory, resources.getResourceTypes());
                    getItems = resources.getResourceNames;
                    create = function () {
                        var newItemData = ((newItemBase.selectedIndex > 0) ?
                                utils.deepCopy(resources.getResource(newItemCategory.value, newItemBase.value).getData()) :
                                properties.getDefaultItemData(
                                        descriptors.itemDescriptors[newItemCategory.value],
                                        newItemName.value));
                        newItemData.name = newItemName.value;
                        resources.createResource(newItemCategory.value, newItemData);
                    };
                    break;
                case common.ItemType.CLASS:
                    common.setSelectorOptions(newItemCategory, classes.getClassCategories());
                    getItems = classes.getClassNames;
                    create = function () {
                        var newItemData = ((newItemBase.selectedIndex > 0) ?
                                utils.deepCopy(classes.getClass(newItemCategory.value, newItemBase.value).getData()) :
                                properties.getDefaultItemData(
                                        descriptors.itemDescriptors[newItemCategory.value],
                                        newItemName.value));
                        newItemData.name = newItemName.value;
                        classes.createClass(newItemCategory.value, newItemData);
                    };
                    break;
                case common.ItemType.ENVIRONMENT:
                    common.setSelectorOptions(newItemCategory, [ENVIRONMENTS_CATEGORY]);
                    getItems = environments.getEnvironmentNames;
                    create = function () {
                        var newItemData = ((newItemBase.selectedIndex > 0) ?
                                utils.deepCopy(environments.getEnvironment(newItemBase.value).getData()) :
                                properties.getDefaultItemData(
                                        descriptors.itemDescriptors[newItemCategory.value],
                                        newItemName.value));
                        newItemData.name = newItemName.value;
                        environments.createEnvironment(newItemData);
                    };
                    break;
                case common.ItemType.MISSION:
                    common.setSelectorOptions(newItemCategory, [MISSIONS_CATEGORY]);
                    getItems = missions.getMissionNames;
                    create = null;
                    createAsync = function (callback) {
                        var newItemData;
                        if (newItemBase.selectedIndex > 0) {
                            missions.requestMissionDescriptor(newItemBase.value, function (missionDescriptor) {
                                newItemData = utils.deepCopy(missionDescriptor.getData());
                                newItemData.name = newItemName.value;
                                missions.createMissionDescriptor(newItemData);
                                callback();
                            });
                        } else {
                            newItemData = utils.deepCopy(properties.getDefaultItemData(
                                    descriptors.itemDescriptors[newItemCategory.value],
                                    newItemName.value));
                            newItemData.name = newItemName.value;
                            missions.createMissionDescriptor(newItemData);
                            callback();
                        }
                    };
                    break;
                default:
                    getItems = null;
                    create = null;
                    createAsync = null;
                    application.showError("Creating " + newItemType.value + " is not yet implemented!");
            }
            newItemCategory.onchange();
        };
        newItemCategory.onchange = function () {
            if (getItems) {
                common.setSelectorOptions(newItemBase, ["none"].concat(getItems(newItemCategory.value)));
                if (newItemType.value === common.ItemType.MISSION) {
                    newItemName.value = "mission";
                } else {
                    newItemName.value = newItemCategory.value;
                    if (newItemName.value.indexOf("Classes") >= 0) {
                        newItemName.value = newItemName.value.substring(0, newItemName.value.indexOf("Classes"));
                    } else if (newItemName.value[newItemName.value.length - 1] === "s") {
                        newItemName.value = newItemName.value.substring(0, newItemName.value.length - 1);
                    }
                }
            }
        };
        newItemBase.onchange = function () {
            if (newItemBase.selectedIndex > 0) {
                if (newItemType.value === common.ItemType.MISSION) {
                    newItemName.value = newItemBase.value;
                    if (newItemName.value.indexOf(".json") === newItemName.value.length - 5) {
                        newItemName.value = newItemName.value.substring(0, newItemName.value.length - 5);
                    }
                    newItemName.value = newItemName.value + "_copy";
                } else {
                    newItemName.value = newItemBase.value + "_copy";
                }
            } else {
                if (newItemType.value === common.ItemType.MISSION) {
                    newItemName.value = "newMission";
                } else {
                    newItemName.value = newItemCategory.value;
                }
            }
        };
        newItemType.onchange();
        createButton.onclick = function () {
            var itemNames;
            if (getItems) {
                itemNames = getItems(newItemCategory.value);
                if (itemNames.indexOf(newItemName.value) >= 0) {
                    application.showError("Cannot create item: '" + newItemName.value + "' already exists!", application.ErrorSeverity.MINOR);
                    return;
                }
                if (create) {
                    create();
                    _loadItems();
                    _newItemDialog.hidden = true;
                    _selectItem(newItemType.value, newItemName.value, newItemCategory.value);
                } else if (createAsync) {
                    createAsync(function () {
                        _loadItems();
                        _newItemDialog.hidden = true;
                        _selectItem(newItemType.value, newItemName.value, newItemCategory.value);
                    });
                }
            }
        };
        cancelButton.onclick = function () {
            _newItemDialog.hidden = true;
        };
        _initNewItemDialog = function () {
            var index;
            if (_selectedItem) {
                index = typeOptions.indexOf(_selectedItem.type);
                if (index >= 0) {
                    newItemType.selectedIndex = index;
                    newItemType.onchange();
                    index = common.getSelectorOptions(newItemCategory).indexOf(_selectedItem.category);
                    if (index >= 0) {
                        newItemCategory.selectedIndex = index;
                        newItemCategory.onchange();
                    }
                }
            }
        };
    }
    /**
     * Sets up the content for all dialogs
     */
    function _loadDialogs() {
        _newItemDialog = document.getElementById(NEW_ITEM_DIALOG_ID);
        _exportDialog = document.getElementById(EXPORT_DIALOG_ID);
        _importDialog = document.getElementById(IMPORT_DIALOG_ID);
        document.getElementById(NEW_ITEM_BUTTON_ID).onclick = function () {
            _newItemDialog.hidden = !_newItemDialog.hidden;
            if (!_newItemDialog.hidden) {
                _initNewItemDialog();
                _exportDialog.hidden = true;
                _importDialog.hidden = true;
            }
        };
        _loadNewItemDialog();

        document.getElementById(EXPORT_BUTTON_ID).onclick = function () {
            _exportDialog.hidden = !_exportDialog.hidden;
            if (!_exportDialog.hidden) {
                _initExportDialog();
                _newItemDialog.hidden = true;
                _importDialog.hidden = true;
            }
        };
        _loadExportDialog();

        document.getElementById(IMPORT_BUTTON_ID).onclick = function () {
            _importDialog.hidden = !_importDialog.hidden;
            if (!_importDialog.hidden) {
                _newItemDialog.hidden = true;
                _exportDialog.hidden = true;
            }
        };
        _loadImportDialog();
    }
    /**
     * Sends an asynchronous request to get the JSON file describing the game settings and sets the callback function to set them and
     * load the content of the Items window
     * @param {{folder: String, filename: String}} settingsFileDescriptor
     */
    function _requestSettingsLoad(settingsFileDescriptor) {
        application.requestTextFile(settingsFileDescriptor.folder, settingsFileDescriptor.filename, function (settingsText) {
            var settingsJSON = JSON.parse(settingsText);
            application.log("Loading game settings...", 1);
            graphics.loadSettingsFromJSON(settingsJSON.graphics);
            graphics.loadSettingsFromLocalStorage();
            config.loadSettingsFromJSON(settingsJSON.logic);
            graphics.executeWhenReady(function () {
                lights.setupLiSPSM(graphics.getLispsmMinimumNear(), graphics.getLispsmNearFactor());
            });
            config.executeWhenReady(function () {
                environments.requestLoad();
                environments.executeWhenReady(function () {
                    missions.requestLoad(true);
                    missions.executeWhenReady(function () {
                        var hash;
                        application.log("Game settings loaded.", 1);
                        localStorage[constants.VERSION_LOCAL_STORAGE_ID] = application.getVersion();
                        application.log("Initialization completed.");
                        _setLabel(document.getElementById(PREVIEW_WINDOW_ID), NO_ITEM_SELECTED_TEXT);
                        _setLabel(document.getElementById(PROPERTIES_WINDOW_ID), NO_ITEM_SELECTED_TEXT);
                        _loadItems();
                        _loadHistoryButtons();
                        _loadDialogs();
                        if (location.hash) {
                            hash = location.hash.substring(1).split("/");
                            if (hash.length > 3) {
                                _selectItem(hash[0], location.hash.substring(3 + hash[0].length + hash[1].length), hash[1]);
                            } else if (hash.length === 3) {
                                _selectItem(hash[0], hash[2], hash[1]);
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Starts the whole initialization / setup process by sending an asynchronous request to get the JSON file describing the game 
     * configuration and setting the callback to continue when it is loaded.
     */
    function _requestConfigLoad() {
        application.requestTextFile("config", "config.json", function (configText) {
            var configJSON = JSON.parse(configText);
            application.log("Loading configuration...");
            application.setFolders(configJSON.folders);
            application.setLogVerbosity(configJSON.logVerbosity);
            application.setVersion(configJSON.version);
            application.setDebugVersion(configJSON.debugVersion);
            application.log("Game version is: " + application.getVersion(), 1);
            requirejs([
                "modules/media-resources"
            ], function (resources) {
                var language = "English";
                config.loadConfigurationFromJSON(configJSON.dataFiles.logic);
                graphics.loadConfigurationFromJSON(configJSON.graphics);
                missions.loadConfigurationFromJSON(configJSON.logic);
                control.loadConfigurationFromJSON(configJSON.control);
                resources.requestConfigLoad(configJSON.dataFiles.media.resources, function () {
                    application.log("Configuration loaded.");
                });
                application.requestTextFile(
                        configJSON.configFiles.strings[language].folder,
                        configJSON.configFiles.strings[language].filename,
                        function (responseText) {
                            strings.loadStrings(language, JSON.parse(responseText), strings);
                            strings.setLanguage(language);
                            _requestSettingsLoad(configJSON.configFiles.settings);
                        });
            });
        });
    }
    /**
     * The function to handle the window resize event
     * @returns {}
     */
    function _handleResize() {
        common.alignPopups();
    }
    // ------------------------------------------------------------------------------
    // The public interface of the module
    return {
        initialize: function (data) {
            application.log("Initializing the Interstellar Armada Editor...");
            application.useElectron(data.electron);
            application.setPreviouslyRunVersion(localStorage[constants.VERSION_LOCAL_STORAGE_ID]);
            _requestConfigLoad();
            window.addEventListener("resize", _handleResize);
        }
    };
});

/**
 * Copyright 2016-2017 Krisztián Nagy
 * @file The entry point for the Interstellar Armada editor, to be invoked by RequireJS.
 * @author Krisztián Nagy [nkrisztian89@gmail.com]
 * @licence GNU GPLv3 <http://www.gnu.org/licenses/>
 * @version 1.0
 */

/*global requirejs */
/**
 * @param editor
 */
requirejs(["editor/editor"], function (editor) {
    "use strict";
    editor.initialize({electron: false});
});

define("editor-main", function(){});

